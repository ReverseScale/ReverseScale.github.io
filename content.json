{"meta":{"title":"Technology","subtitle":"","description":"","author":"Steven's Blog","url":"https://reversescale.github.io"},"pages":[{"title":"Not found","date":"2018-11-15T12:15:47.151Z","updated":"2018-11-15T02:35:05.000Z","comments":true,"path":"404.html","permalink":"https://reversescale.github.io/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#fff;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#000;margin-top:260px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=5; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"About","date":"2015-08-16T06:58:08.000Z","updated":"2018-11-15T12:29:41.694Z","comments":false,"path":"about/index.html","permalink":"https://reversescale.github.io/about/index.html","excerpt":"","text":"Excellence is a continuous process and not an accident. Thanks for reading! ~ 👨🏻‍💻 职业：程序员劝退师📟 WeChat：WhatsXie🤪 不只生产 bug 更是 bug 的搬运工📮 邮件：ReverseScale@iCloud.com🤖 Github：https://github.com/ReverseScale 博客新装修，历史文章正在路上…"},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2018-01-25T14:41:06.000Z","comments":true,"path":"archives/index.html","permalink":"https://reversescale.github.io/archives/index.html","excerpt":"","text":""},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2018-01-25T14:41:06.000Z","comments":false,"path":"categories/index.html","permalink":"https://reversescale.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2018-01-25T14:41:06.000Z","comments":true,"path":"tags/index.html","permalink":"https://reversescale.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用 ngrok 快速实现内网穿透","slug":"Ngrok through","date":"2018-08-13T03:56:27.000Z","updated":"2018-11-15T13:18:46.822Z","comments":true,"path":"2018/08/13/Ngrok through/","link":"","permalink":"https://reversescale.github.io/2018/08/13/Ngrok through/","excerpt":"实现内网穿透的工具很多，之所以介绍 ngrok，主要还是因为它使用便捷，不用搭建服务器等等麻烦的工序，适合前段开发过程中，快速评估检测项目~","text":"实现内网穿透的工具很多，之所以介绍 ngrok，主要还是因为它使用便捷，不用搭建服务器等等麻烦的工序，适合前段开发过程中，快速评估检测项目~ Ngrok是什么ngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放。 而我用来在家里快速访问 Jenkins，偷个懒🤪 搭建方法由于要完成一个网页优化的作业找了很久ngrok的使用方法，都不够简便易行最后终于发现了一个好方法。 下载 MAC 版的 ngrok：https://ngrok.com/download 解压到指定目录：Safari 浏览器下载 Mac OS X 环境一般直接解压（反正我是自动解压的），将 ngrok 放进项目目录。 进入到 ngrok 所在路径：1cd /tmp 开启服务1./ngrok http localhost:8080 会出现如下 ngrok 控制台 等待 Session Status 状态为 online（变绿），就可以在外网通过 Forwarding 的地址进行连接了。 注意：Forwarding地址中的 c33faf1b 不是固定的，在每次开始 ngrok 服务的时候都会变更，想固定？ ngrok:😛要钱。 测试一下例如： ngrok 穿透前在局域网中访问地址：http://localhost:8080 ngrok 穿透后局域网 + 公网访问地址：https://c33faf1b.ngrok.io","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/tags/Tips/"}]},{"title":"如何用 Swift 打造你的第一个区块链 App","slug":"How to build DApp","date":"2018-07-06T14:51:21.000Z","updated":"2018-11-15T13:19:04.032Z","comments":true,"path":"2018/07/06/How to build DApp/","link":"","permalink":"https://reversescale.github.io/2018/07/06/How to build DApp/","excerpt":"区块链(Blockchain) 是一种突破性技术(Disruptive Technologies)，近年渐获关注，号称将互联网从信息共享，推向价值传递，让我们一步一步的来探索它设计上的奇思妙想~","text":"区块链(Blockchain) 是一种突破性技术(Disruptive Technologies)，近年渐获关注，号称将互联网从信息共享，推向价值传递，让我们一步一步的来探索它设计上的奇思妙想~ 因为区块链是许多加密货币(Cryptocurrencies) 如比特币(Bitcoin)、以太坊(Ethereum)、莱特币(Litecoin) 的创始技术。那区块链是如何运作的呢？在本次的教学里，我将会谈到所有关于区块链技术的知识，以及如何用Swift 来制作自己的「区块链」。那么，让我们开始吧！ 区块链的运作顾名思义，区块链就是一个由不同的区块串连在一起的「链」，每个区块包含三则资讯：资料(Data)、杂凑值(Hash)、和前一个区块的杂凑值。 资料 ──依据使用情境，储存在区块的资料会因区块链的类型而不同。例如，在比特币区块链中，储存资料就是与交易有关的资讯，即是转帐的金额、以及参与交易二人的资讯。 杂凑值 ──你可以把杂凑想成是一种数位指纹，它是用来识别一个区块及其资料。杂凑最重要的地方，就是它是一个独一无二的字母数字(Alphanumeric)程式码，通常会由64个字元组成。当一个区块被创造时，杂凑值也同时产生。当一个区块被更动时，杂凑值也会同时被更动。透过这种方式，当你想要查看区块上的任何变动时，杂凑值就非常重要。 前一个区块的杂凑值 ──每个区块就是藉由储存前个区块的杂凑来链结在一起，组成一个区块链！这就是让区块链如此安全的原因。看看这张图片： 如你所见，每个区块由资料（未显示）、杂凑值、和前一个区块杂凑值所组成。举个例子，黄色区块包含了自己的杂凑值H7S6、和红色区块的杂凑值8SD9。以这种方式，它们组成了一个链结，并以此连结在一起。现在，假设有个骇客入侵并尝试更动红色区块。请记住，每次一个区块以任何方式被更动时，区块的杂值凑也会被更动！因此，当下一个区块执行确认、并看到前一个区块的杂凑值并不吻合时，它会有效地将自己从「链」中分离出来，而不会被骇客读取。 这就是区块练会如此安全的原因，你几乎不可能尝试回溯并更改任何资料。杂凑值提供了不错的保密及隐私，但还有两个安全机制来让区块链更加安全：验证(Proof-of-work)及智慧合约(Smart Contract)。虽然我不会详述，但你可以在这里了解更多。区块链最后一个保全方式就是基于它的位置。与大多储存在伺服器或是资料库内的资料不同，区块链使用点对点网路(Peer-To-Peer, P2P)，它是一种网路型态，允许任何人加入并将该网路上的资料分发给每位接收者。每当有人加入这个网路时，他们就会得到区块链的完整拷贝；每当有人建立一个新区块时，就会传送到网路内的所有人。然后，透过一些复杂的程式，让节点(Node)在加入这个区块到区块链之前，先确认该区块有否被窜改。就这样，任何地方的任何人都可以取得这些资讯。如果你是HBO矽谷群瞎传(Silicon Valley)的忠实粉丝，这听起来可能有点熟悉，因为在这出美剧里，主角就是用了类似的技术来建立一个全新网路。 因为每个人或节点都有一份区块链的拷贝，他们可以有共识并确认哪些区块是合法的。因此，如果你想要骇入一个区块，你必须骇入网路上超过50% 的区块来通过你的资讯。这就是为什么区块链或许是过去十年以来最安全的技术之一。 关于范例应用现在你了解区块链是如何运作了，那么开始来制作我们的范例App吧！请先下载初始项目。（https://raw.githubusercontent.com/appcoda/BlockchainDemo/master/BlockchainStarter.zip） 如你所见，我们有两个比特币钱包。第一个帐号Account 1065 拥有500 BTC，而第二个帐号0217 则什么都没有。我们利用传送按钮来传送比特币到其他帐号。为了赚取BTC，我们按下Mine 按钮就可以获得50 BTC 为奖励。基本来说，我们做的是当App 执行时，利用控制台来观察两个比特币帐号间的交易情况。 你会注意到，侧边栏里有两个重要的类别：Block及Blockchain。打开这些档案，你会看到档案是空的，那是因为我将会引导你写出这些类别的逻辑。那我们开始吧！ 在Swift 定义Block前往Block.swift并添加程式码以定义一个区块。首先，让我们了解一下区块是什么。我们先前定义了一个区块由三个部分组成：杂凑值、记录的实际资料、以及前一个区块的杂凑值。当我们想建立自己的区块链时，必须要知道区块的排序，这一点可以很容易地在Swift中定义。添加以下程式码到类别里： 1234var hash: String!var data: String!var previousHash: String!var index: Int! 现在，我们需要添加最后一个重要的程式码。我之前提到每次一个区块被更动，杂凑就会改变；这就是区块链如此安全的特色之一。所以我们必须建立一个函式来产生一个随机字母数字的杂凑。这个函式只需要几行程式码： 123func generateHash() -&gt; String &#123; return NSUUID().uuidString.replacingOccurrences(of: \"-\", with: \"\")&#125; NSUUID是一个物件，代表桥接UUID的通用唯一值。它内置于Swift中，而且非常适合用来产生32字元的字串。这个函式产生一个UUID，消除所有连字符(-)，然后回传String，即区块的杂凑。Block.swift现在应该看起来像这样： 我们已经定义了Block类别，接着让我们定义Blockchain类别吧。切换到Blockchain.swift。 在Swift 定义Blockchain如前文所说，让我们尝试从基本面来了解区块链。在基本的术语里，区块链只是区块串在一起组成的链；换句话说，它是一个包含所有项目的列表。听起来是不是有点熟悉呢？因为这就是阵列的定义，而这个阵列就是由区块所组成！让我们把下列的程式码加进去吧： 1var chain = [Block]() 小提示：这几乎可以应用在电脑科学世界的所有事上。如果你曾遇过大问题，试着将它拆解成小组件，然后以自己的方法来解决问题；就像我们弄清楚如何在Swift中加入区块及区块链一样！ 你会注意到在阵列里面包含了先前定义的Block类别，那是我们在区块链中需要的所有变数。加入两个函式到类别里，我们就完成了。试着用我前文所教的来回答这个问题： 在一个区块链中，两个主要的函式是什么？ 希望你能够回答这个问题！这两个区块链拥有的主要函式，是用来建立初始区块，以及在后面新增新的区块。当然，现在我不会下放这个链并加入智慧合约，但是这些是基本函式！加入以下程式码到Blockchain.swift： 1234567891011121314151617func createGenesisBlock(data:String) &#123; let genesisBlock = Block() genesisBlock.hash = genesisBlock.generateHash() genesisBlock.data = data genesisBlock.previousHash = \"0000\" genesisBlock.index = 0 chain.append(genesisBlock)&#125; func createBlock(data:String) &#123; let newBlock = Block() newBlock.hash = newBlock.generateHash() newBlock.data = data newBlock.previousHash = chain[chain.count-1].hash newBlock.index = chain.count chain.append(newBlock)&#125; 我们加入的第一个函式是用来建立初始区块。为此，我们建立了一个函式来把区块的资料作为Input。然后，我们定义一个名为genesisBlock的变数，并将它设为Block型别。因为它是Block型别，所以它有我们之前在Block.swift定义的所有变数及函式。我们设定generateHash()为杂凑、 Input data为资料。因为这是第一个区块，所以我们将前一个区块的杂凑设定为000，好让我们知道这是初始区块。我们将它的索引值设为0 ，然后放到区块链chain。 我们建立的下一个函式则适用于所有genesisBlock后的区块，而它会建立剩下的所有区块。你会注意到它跟之前的函式非常相似，唯一的不同的是我们将previousHash设定为前一个区块的杂凑，并将index设为它在区块练的位置。完成了！我们已经成功定义自己的Blockchain！你的程式码应该如下图所示！ 接着，我们将所有的部分连接到ViewController.swift档案，并看看执行成果吧！ 钱包后台(Wallet Backend)切换到ViewController.swift，我们可以看到所有的UI元件都已经连结完毕。我们所需要做的就是处理交易，并将交易列印到控制台上。然而在开始之前，我们应该稍微探讨一下比特币区块链。比特币来自一个总帐号，假设这个帐号的编号是000。当你挖掘一颗比特币时，就表示你解答了数学问题，并获得一定数量的比特币作为奖励。这是发行货币一个很聪明的方法，同时也创造了让更多人去挖掘的动机。在我们的App 里，我们将100 BTC 作为奖励。首先，让我们在ViewController 添加需要的变数： 123456let firstAccount = 1065let secondAccount = 0217let bitcoinChain = Blockchain()let reward = 100var accounts: [String: Int] = [\"0000\": 10000000]let invalidAlert = UIAlertController(title: \"Invalid Transaction\", message: \"Please check the details of your transaction as we were unable to process this.\", preferredStyle: .alert) 我们定义两个帐号：一个编号为1065，另一个编号为0217。我们同时新增一个bitcoinChain变数来作为我们的区块链，并将reward设定为100。我们需要一个作为比特币来源的主帐号：这是我们的初始帐号，编号为0000，它拥有一千万个比特币。你可以把这个帐号当成银行，在每一次的奖励中，就会从中取出100个比特币，并转至合法的帐号里。我们也定义一个警告，在每次交易无法完成时显示。 现在，让我们来写些将会执行的泛用函式。你可以猜到这些函式是什么吗？ 第一个函式是用来处理交易的。我们要确认传送者及接收者的帐号中，接收或扣除的金额是正确的，而且这个资讯会被记录在我们的区块链上。 下一个函式是要在控制台里印出完整的纪录，它会显示每个区块及每个区块内的资料。 最后一个函式是用来验证区块链是否合法，方法为确认前个区块的杂凑是否符合下一个区块的资讯。因为我们不会示范任何骇客方法，所以范例中的链永远都是合法的。 Transaction 函式以下是我们的泛用交易函式。在定义变数之下输入以下程式码： 1234567891011121314151617181920212223242526func transaction(from: String, to: String, amount: Int, type: String) &#123; // 1 if accounts[from] == nil &#123; self.present(invalidAlert, animated: true, completion: nil) return &#125; else if accounts[from]!-amount &lt; 0 &#123; self.present(invalidAlert, animated: true, completion: nil) return &#125; else &#123; accounts.updateValue(accounts[from]!-amount, forKey: from) &#125; // 2 if accounts[to] == nil &#123; accounts.updateValue(amount, forKey: to) &#125; else &#123; accounts.updateValue(accounts[to]!+amount, forKey: to) &#125; // 3 if type == \"genesis\" &#123; bitcoinChain.createGenesisBlock(data: \"From: \\(from); To: \\(to); Amount: \\(amount)BTC\") &#125; else if type == \"normal\" &#123; bitcoinChain.createBlock(data: \"From: \\(from); To: \\(to); Amount: \\(amount)BTC\") &#125;&#125; 看起来程式码很多，但是它的核心只是为每次的交易定义一些规则。在开头的地方，我们有四个参数：to、from、amount以及type。To、From、及Amount的含义一目了然，而Type基本上就是定义交易的类型。这里有两种Type：Normal和Genesis。一个Normal的交易类型会是在帐号1065与0217之间进行，而Genesis交易类型则会涉及到帐号0000。 第一个if-else条件式是关于来源帐号。如果来源帐号不存在或金额不足，我们会显示交易无效的警告，然后结束函式。而如果通过的话，我们会更新数值。 第二个if-else条件式是关于接收帐号。如果接收帐号不存在，那么我们随它而去，然后结束函式。要不然，我们就会传送正确的比特币数量到帐号。 第三个if-else条件式处理交易的类型。如果一个交易涉及初始区块，我们就建立一个新的初始区块；反之我们建立一个新区块来储存资料。 Printing 函式在每次交易的最后，我们想要看到一个清单列出所有交易，来确保我们知道所有发生的事情。以下是我们在transaction函式下输入的程式码： 123456789func chainState() &#123; for i in 0...bitcoinChain.chain.count-1 &#123; print(\"\\tBlock: \\(bitcoinChain.chain[i].index!)\\n\\tHash: \\(bitcoinChain.chain[i].hash!)\\n\\tPreviousHash: \\(bitcoinChain.chain[i].previousHash!)\\n\\tData: \\(bitcoinChain.chain[i].data!)\") &#125; redLabel.text = \"Balance: \\(accounts[String(describing: firstAccount)]!) BTC\" blueLabel.text = \"Balance: \\(accounts[String(describing: secondAccount)]!) BTC\" print(accounts) print(chainValidity())&#125; 这是一个简单的for回圈，包含bitcoinChain的每个区块。我们印出区块的编号、杂凑值、前个区块的杂凑、以及储存的资料，再更新UILabel来显示每个帐号内正确的BTC数目。最后，印出一个列出每个帐号的清单（应该会有三个），并验证链的合法性。现在，你应该会在函式最后一行中发生错误。这是因为我们还没定义chainValidity()函式，那么就来开始吧！ Validity 函式记住，如果前一个区块的杂凑值符合目前区块所描述的内容，那么这一个链就是合法的。我们可以轻易地用另一个for 回圈来重复验证每个区块。 123456789func chainValidity() -&gt; String &#123; var isChainValid = true for i in 1...bitcoinChain.chain.count-1 &#123; if bitcoinChain.chain[i].previousHash != bitcoinChain.chain[i-1].hash &#123; isChainValid = false &#125; &#125; return \"Chain is valid: \\(isChainValid)\\n\"&#125; 跟之前有点相似，我们在bitcoinChain中重复验证每个区块，来确认前一个区块的杂凑值是否与目前区块所描述的内容符合。这样就完成了！我们已经定义了函式，并将会每次都用到它们！你的ViewController.swift现在应该看起来像这样： 现在我们只需要将按钮连接到函式就完成了，来开始最后的篇章吧！ 将所有东西连结在一起当我们的App首次启动时，我们想让初始帐号0000传送50 BTC到我们的第一个帐号。然后，我们将让第一个帐号传送10 BTC到第二个帐号。这个步骤仅需三行程式码就可以完成。如此更改你的viewDidLoad函式： 1234567override func viewDidLoad() &#123; super.viewDidLoad() transaction(from: \"0000\", to: \"\\(firstAccount)\", amount: 50, type: \"genesis\") transaction(from: \"\\(firstAccount)\", to: \"\\(secondAccount)\", amount: 10, type: \"normal\") chainState() self.invalidAlert.addAction(UIAlertAction(title: \"OK\", style: .default, handler: nil))&#125; 我们使用先前定义好的函式，并在最后呼叫chainState()。同时，我们新增一个OK按钮到交易无效的警告中。现在让我们来看看剩下的四个函式里要加入什么：redMine()、blueMine()、redSend()及blueSend()。 挖矿函式挖矿函式非常地简单，只要三行程式码就行了。这就是我们要添加的程式码： 1234567891011@IBAction func redMine(_ sender: Any) &#123; transaction(from: \"0000\", to: \"\\(firstAccount)\", amount: 100, type: \"normal\") print(\"New block mined by: \\(firstAccount)\") chainState()&#125; @IBAction func blueMine(_ sender: Any) &#123; transaction(from: \"0000\", to: \"\\(secondAccount)\", amount: 100, type: \"normal\") print(\"New block mined by: \\(secondAccount)\") chainState()&#125; 在第一个挖矿函式中，我们使用transaction函式从初始帐号传送100 BTC到第一个帐号，先印出一个区块被挖出，再印出chainState。同样地，我们在blueMine函式里将100 BTC传送到第二个帐号。 传送函式传送函式与先前的函式也稍微相似。 123456789101112131415161718192021@IBAction func redSend(_ sender: Any) &#123; if redAmount.text == \"\" &#123; present(invalidAlert, animated: true, completion: nil) &#125; else &#123; transaction(from: \"\\(firstAccount)\", to: \"\\(secondAccount)\", amount: Int(redAmount.text!)!, type: \"normal\") print(\"\\(redAmount.text!) BTC sent from \\(firstAccount) to \\(secondAccount)\") chainState() redAmount.text = \"\" &#125;&#125; @IBAction func blueSend(_ sender: Any) &#123; if blueAmount.text == \"\" &#123; present(invalidAlert, animated: true, completion: nil) &#125; else &#123; transaction(from: \"\\(secondAccount)\", to: \"\\(firstAccount)\", amount: Int(blueAmount.text!)!, type: \"normal\") print(\"\\(blueAmount.text!) BTC sent from \\(secondAccount) to \\(firstAccount)\") chainState() blueAmount.text = \"\" &#125;&#125; 首先，我们确认redAmount或blueAmount中的文字栏位是否为空值。如果是，我们会显示一个交易无效的警告。如果不是，我们就可以继续。我们使用transaction函式输入金额，并把交易设为normal型态，以将第一个帐号的金额传送到第二个帐号（或相反）。我们印出被传送的金额，然后呼叫chainState()函式。最后，把文字栏位清空。这样我们就完成啰！确认一下你的程式码是否符合下图所示。 执行App 试试看！从前端来说，它看起来就如一个普通的交易App，但你会知道它后台的运作。试试使用App 将BTC 从一个帐号交易给另一个帐号、并试着欺骗App 吧！ 结论在这次的教学中，你学到了如何使用Swift 来建立一个区块链，并建立自己的比特币交易。请注意在真实的加密货币后台里，实作部分是跟上文是完全不一样的东西，因为它需要藉由智慧合约来分散，但是上面的示范内容用来学习的。在这个范例中，我们运用了比特币来当加密货币，但你能想到区块链还的其他用途吗？欢迎在下面留言分享你的看法！希望你在此学到新的东西！你可以在Github下载完整项目作参考。 完整项目：https://github.com/appcoda/BlockchainDemo原文链接：https://www.appcoda.com/blockchain-introduction/","categories":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://reversescale.github.io/categories/Blockchain/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://reversescale.github.io/tags/Blockchain/"}]},{"title":"ReactNative 学习成果总结","slug":"ReactNative APP","date":"2018-03-29T11:56:27.000Z","updated":"2018-11-15T13:45:53.356Z","comments":true,"path":"2018/03/29/ReactNative APP/","link":"","permalink":"https://reversescale.github.io/2018/03/29/ReactNative APP/","excerpt":"ReactNative 这几年风生水起，当然除了 React 社区生态圈的加持和 Facebook 的大力推广以外，另外一个最主要的原因就是其在开发效率和应用性能方面取得了一个比较好的平衡~","text":"ReactNative 这几年风生水起，当然除了 React 社区生态圈的加持和 Facebook 的大力推广以外，另外一个最主要的原因就是其在开发效率和应用性能方面取得了一个比较好的平衡~ 学习课程：《双平台真实开发GitHub App React Native技术全面掌握》399 大洋，含着泪吃了一个月泡面.. Github 代码库：https://github.com/ReverseScale/RNAPPGithub.git 知识点： 1.整理 ReactNative 网络封装及常用的三方模块 2.ReactNative 的 AsyncStorage数据库技术、离线缓存 3.ReactNative 的数据 DAO 层设计技巧，数据状态实时更新 4.ReactNative 的代码提取技巧，组合模式应用技巧，数据异步刷新与动态添加 5.ReactNative 的版本升级、数据统计、社会化分享、第三方登录，热更新等 6.ReactNative 项目发布前的优化、打包与上线 目录结构： 生命周期及使用场景 项目介绍 组件化 集成与管理 布局约束 组件封装 本地持久化 网络请求封装 功能调试 双平台适配 开源组件库的使用 热更新 生命周期及使用场景常用方法： constructor: componentWillMount: render: componentDidMount: componentWillReceiveProps: shouldComponentUpdate: componentWillUpdate: componentDidUpdate componentWillUnmount: constructor:在组件创建的时候调用一次,这个方法进行this.state初始化状态机。123456constructor(props) &#123; super(props); // 初始状态 this.state = &#123; isShow:true &#125;;&#125; componentWillMount:在组件生命周期中只会被执行一次,在初始渲染(render函数)前被执行。注意: 如果这个函数通过setState函数修改状态机变量,RN框架不会额外执行渲染(界面刷新) 如果子组件也有componentWillMount函数使用,会在父组件之后调用 需要从本地存储中读取数据用于显示,常用这个函数 render:该函数组件必有的，通过返回JSX或其他组件来构成DOM，换言之，就是组件的核心渲染过程。 componentDidMount:在React Native组件的生命周期中,这个函数只会被执行一次，它在初始渲染完成后会马上被调用。在这之后开发者可以通过子组件的引用来访问，操作任何子组件。如果RN组件的子组件也有componentDidMount函数，并会在父组件的componentDidMount函数之前被调用。 常用来网络请求数据 componentWillReceiveProps:在React Native组件的初始渲染完成后，props改变时，这个函数被调用，参数是个新的props。 shouldComponentUpdate:React Native组件的初始渲染执行完成后, RN组件接收到新的state或者props时这个函数会调用。 通过这个函数阻止无必要的重新渲染，是提高React Native应用程序性能的一大技巧。 componentWillUpdate:初始渲染完成后,重新渲染前会调用这个函数。 这个函数不能通过this.setState再次改变状态机变量的值。 组件更新时调用。 componentDidUpdateRN组件初始渲染完成后，RN框架在重新渲染RN组件完成后调用。参数是渲染前的props和state。 组件更新完毕时调用。 componentWillUnmount:ReactNative 组件被卸载前会调用，通常做一些清理内容。 项目介绍双平台效果预览： React Native是React在移动端的跨平台方案。如果想更快地理解和掌握React Native开发，就必须先了解React。 React是FaceBook开源的一个前端框架，它起源于 Facebook 的内部项目，并于 2013 年 5 月开源。因为React 拥有较高的性能，代码逻辑非常简单，所以越来越多的人已开始关注和使用它，目前该框架在Github上已经有7万+star。 ReactNative 技术导图： 组件化React采用组件化的方式开发，通过将view构建成组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。有一句话说的很形象：在React中，构建应用就像搭积木一样。 组件化特征React认为一个组件应该具有如下特征： 可组合（Composeable）：一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部。如果一个组件内部创建了另一个组件，那么说父组件拥有它创建的子组件，通过这个特性，一个复杂的UI可以拆分成多个简单的UI组件； 可重用（Reusable）：每个组件都是具有独立功能的，它可以被使用在多个UI场景； 可维护（Maintainable）：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护； 封装好的导航栏就可以被称之为一个组件，它符合上述三个特点： 可组合：可以将导航栏组件放在页面组件中作为页面组件的子组件。而且在导航栏组件的内部，也有按钮组件等子组件。 可重用：如果封装好了该组件，就可以放在任意需要导航栏的页面（组件）使用，也可以放在其他项目中使用。 可维护：因为具有独立的功能和展示逻辑，所以便于定位和修改。 组件的属性与状态在React Native（React.js）里，组件所持有的数据分为两种： 属性（props）：组件的props是不可变的，它只能从其他的组件（例如父组件）传递过来。 状态（state）：组件的state是可变的，它负责处理与用户的交互。在通过用户点击事件等操作以后，如果使得当前组件的某个state发生了改变，那么当前组件就会触发render()方法刷新自己。 我们可以看到这个页面有两个子页面，一个是‘最热’页面（组件），另一个是‘趋势‘页面（组件）。那么这两个组件都有什么props和state呢？ 1.props：由于props是从其父组件传递过来的，那么可想而知，props的声明应该是在当前组件的父组件里来做。在React Native中，通常props的声明是和当前组件的声明放在一起的： 1234//最热子页面&lt;FavoriteTabPage &#123;...this.props&#125; tabLabel='最热' flag=&#123;FlAG_STORAGE.flag_popular&#125;/&gt;//趋势子页面&lt;FavoriteTabPage &#123;...this.props&#125; tabLabel='趋势' flag=&#123;FlAG_STORAGE.flag_trending&#125;/&gt; 在这里，收藏页面是父组件，而最热页面和趋势页面是其子组件。在收藏页面组件里声明了最热页面和趋势页面的组件。 而且我们也可以看到，最热页面和趋势页面组件都用的是同一个组件：FavoriteTabPage，而这两个页面的不同点只在于传入的两个props的不同：tabLabel和flag。 而在FavoriteTabPage组件内部，如果想调用flag这个props，可以使用this.props.flag来调用。 2.state: 下面是最热和趋势页面的组件： 12345678class FavoriteTabPage extends Component&#123;//组件的构造方法constructor(props)&#123; super(props); this.state=&#123; dataSource:new ListView.DataSource(&#123;rowHasChanged:(r1,r2)=&gt;r1!==r2&#125;),isLoading:false, &#125;&#125; 这里面定义了两个state: dataSource:列表的数据源 isLoading:是否正在刷新 这两个state都是将来可能经常变化的。比如在网络请求以后，列表的数据源会被替换掉，这个时候就要调用: 1234this.setState(&#123; //把新的值newDataArr对象传给dataSource dataSource:newDataArr&#125;) 3.DOMDOM 是前端的一个概念，暂时可以粗略理解为一个页面的树形结构。React 生命周期的三大阶段 Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM 在每个阶段都有相应的状态和与之对应的回调函数，具体可以看下图： 上图来自：贾鹏辉的技术博客：React Native之React速学教程(中) 集成与管理1.指定版本初始化在终端输入react-native demo –version 0.40.0命令以后，就会初始化一个React Native版本为0.40.0的项目。这个最初项目里面直接就包含了iOS和Android的工程文件夹，可以用对应的IDE打开后编译运行。 在新建一个React Native项目之后的根目录结构是这样的： 2.使用 Cocoapods 管理 ReactNativePodfile 文件格式：1234567891011pod &apos;React&apos;, :path =&gt; &apos;./node_modules/react-native&apos;, :subspecs =&gt; [ &apos;Core&apos;, &apos;RCTText&apos;, &apos;RCTImage&apos;, &apos;RCTActionSheet&apos;, &apos;RCTGeolocation&apos;, &apos;RCTNetwork&apos;, &apos;RCTSettings&apos;, &apos;RCTVibration&apos;, &apos;RCTWebSocket&apos;, ] ReactNative 0.42.0 以上版本需在 Podfile 配置 yoga：12# 如果你的RN版本 &gt;= 0.42.0，请加入下面这行pod &quot;yoga&quot;, :path =&gt; &quot;./node_modules/react-native/ReactCommon/yoga&quot; 输入react-native run-ios或者react-native run-android指令， 就会自动打开模拟器运行项目(前提是安装了相应的开发环境)。 但是一个比较完整的项目仅仅有这些类别的文件是不够的，还需要一些工具类，模型类，资源等文件。为了很好地区分它们，使项目结构一目了然，需要组织好项目文件夹以及类的命名，下面是我将教程里的文件夹命名和结构稍加修改后的一个方案，可供大家参考： 布局约束采用Flex布局的元素，被称为Flex container，其所有子元素被称为Flex item；容器默认存在两个轴，分别是主轴（main axis）和垂直的交叉轴（cross axis）,主轴开始的位置叫做main start，结束的位置叫main end；交叉轴的开始位置叫做cross start，结束的位置叫做cross end；单个item占据的主轴空间叫做main size，占据的交叉轴控件叫做cross size。 如下图所示： 组件化驱动下，搜索结果页中展示的 Cell 与之前的列表页 Cell 可以重用： 我们把该组件定名为：RespositoryCell，结合代码来看一下具体的实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960export default class RepositoryCell extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; isFavorite: this.props.projectModel.isFavorite, favoriteIcon: this.props.projectModel.isFavorite ? require('../../res/images/ic_star.png') : require('../../res/images/ic_unstar_transparent.png'), &#125;; &#125; componentWillReceiveProps(nextProps) &#123; this.setFavoriteState(nextProps.projectModel.isFavorite) &#125; setFavoriteState(isFavorite) &#123; this.props.projectModel.isFavorite = isFavorite; this.setState(&#123; isFavorite: isFavorite, favoriteIcon: isFavorite ? require('../../res/images/ic_star.png') : require('../../res/images/ic_unstar_transparent.png') &#125;) &#125; onPressFavorite() &#123; this.setFavoriteState(!this.state.isFavorite) this.props.onFavorite(this.props.projectModel.item, !this.state.isFavorite) &#125; render() &#123; let item = this.props.projectModel.item? this.props.projectModel.item:this.props.projectModel; let favoriteButton=this.props.projectModel.item? &lt;TouchableOpacity style=&#123;&#123;padding:6&#125;&#125; onPress=&#123;()=&gt;this.onPressFavorite()&#125; underlayColor='transparent'&gt; &lt;Image ref='favoriteIcon' style=&#123;[&#123;width: 22, height: 22,&#125;,this.props.theme.styles.tabBarSelectedIcon]&#125; source=&#123;this.state.favoriteIcon&#125;/&gt; &lt;/TouchableOpacity&gt;:null; return ( &lt;TouchableOpacity onPress=&#123;this.props.onSelect&#125; style=&#123;styles.container&#125; &gt; &lt;View style=&#123;styles.cell_container&#125;&gt; &lt;Text style=&#123;styles.title&#125;&gt;&#123;item.full_name&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.description&#125;&gt;&#123;item.description&#125;&lt;/Text&gt; &lt;View style=&#123;styles.row&#125;&gt; &lt;View style=&#123;styles.row&#125;&gt; &lt;Text&gt;Author:&lt;/Text&gt; &lt;Image style=&#123;&#123;height: 22, width: 22&#125;&#125; source=&#123;&#123;uri: item.owner.avatar_url&#125;&#125; /&gt; &lt;/View&gt; &lt;View style=&#123;&#123;justifyContent: 'space-between', flexDirection: 'row'&#125;&#125;&gt; &lt;Text&gt;Star:&lt;/Text&gt; &lt;Text&gt;&#123;item.stargazers_count&#125;&lt;/Text&gt; &lt;/View&gt; &#123;favoriteButton&#125; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) &#125;&#125; 这里声明了RespositoryCell组件，它继承于Component，也就是组件类，即是说，声明组件的时候必须都要继承与这个类。 集中看一下该组件的render方法，它返回的是该组件的实际布局：在语法上使用JSX，类似于HTML的标签式语法，很清楚地将cell的层级展现了出来： 最外层被一个View组件包裹着，里面第一层有三个子组件：两个Text组件和一个作为底部背景的View组件。 底部背景的View组件又有三个子组件：View组件（显示作者信息），View组件（显示star信息）,收藏按钮。 结构分解图： 组件封装 我的页面 个人中心 对于“我的页面”和“个人中心”这类结构相似的页面，建议进行组件封装，封装后的 AboutPage 实现代码简洁如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768export default class AboutPage extends Component&#123; constructor(props) &#123; super(props); this.aboutCommon=new AboutCommon(props,(dic)=&gt;this.updateState(dic),FLAG_ABOUT.flag_about,config); this.state = &#123; projectModels: [], author:config.author &#125; &#125; componentDidMount() &#123; this.aboutCommon.componentDidMount(); &#125; componentWillUnmount() &#123; this.aboutCommon.componentWillUnmount(); &#125; updateState(dic)&#123; this.setState(dic); &#125; onClick(tab) &#123; let TargetComponent, params = &#123;...this.props,menuType:tab&#125;; switch (tab) &#123; case MORE_MENU.About_Author: TargetComponent = AboutMePage; break; case MORE_MENU.Website: TargetComponent = WebViewPage; params.title='GitHubPopular'; var url='https://reversescale.github.io'; params.url=url; break; case MORE_MENU.Feedback: var url='mailto://reversescale@icloud.com'; Linking.canOpenURL(url).then(supported =&gt; &#123; if (!supported) &#123; console.log('Can\\'t handle url: ' + url); &#125; else &#123; return Linking.openURL(url); &#125; &#125;).catch(err =&gt; console.error('An error occurred', err)); break; case MORE_MENU.Share: break; &#125; if (TargetComponent) &#123; this.props.navigator.push(&#123; component: TargetComponent, params: params, &#125;); &#125; &#125; render() &#123; let content=&lt;View&gt; &#123;this.aboutCommon.renderRepository(this.state.projectModels)&#125; &#123;ViewUtils.getSettingItem(()=&gt;this.onClick(MORE_MENU.Website), require('../../../res/images/ic_computer.png'), MORE_MENU.Website, this.props.theme.styles.tabBarSelectedIcon)&#125; &lt;View style=&#123;GlobalStyles.line&#125;/&gt; &#123;ViewUtils.getSettingItem(()=&gt;this.onClick(MORE_MENU.About_Author), require('../my/img/ic_insert_emoticon.png'), MORE_MENU.About_Author, this.props.theme.styles.tabBarSelectedIcon)&#125; &lt;View style=&#123;GlobalStyles.line&#125;/&gt; &#123;ViewUtils.getSettingItem(()=&gt;this.onClick(MORE_MENU.Feedback), require('../../../res/images/ic_feedback.png'), MORE_MENU.Feedback, this.props.theme.styles.tabBarSelectedIcon)&#125; &lt;/View&gt; return this.aboutCommon.render(content, &#123; 'name': 'GitHub Popular', 'description': '这是一个用来查看GitHub最受欢迎与最热项目的App,它基于React Native支持Android和iOS双平台。', \"avatar\": \"http://og1yl0w9z.bkt.clouddn.com/18-3-28/61685877.jpg\", \"backgroundImg\": \"http://og1yl0w9z.bkt.clouddn.com/18-3-28/37407402.jpg\", &#125;); &#125;&#125; 本地持久化 主题选择界面 切换主题后界面 在涉及如主题变更等操作时，需要将状态信息保存，这时就需要用到类似于iOS 中的NSUserDefault， AsyncStorage 是React Native中的 Key-Value 存储系统，可以做本地持久化。 首先看它主要的几个接口： 根据键来获取值，获取的结果会放在回调函数中：1static getItem(key: string, callback:(error, result)) 根据键来设置值：1static setItem(key: string, value: string, callback:(error)) 根据键来移除项：1static removeItem(key: string, callback:(error)) 获取所有的键：1static getAllKeys(callback:(error, keys)) 设置多项，其中 keyValuePairs 是字符串的二维数组，比如：[[‘k1’, ‘val1’], [‘k2’, ‘val2’]]：1static multiSet(keyValuePairs, callback:(errors)) 获取多项，其中 keys 是字符串数组，比如：[‘k1’, ‘k2’]：1static multiGet(keys, callback:(errors, result)) 删除多项，其中 keys 是字符串数组，比如：[‘k1’, ‘k2’]：1static multiRemove(keys, callback:(errors)) 清除所有的项目：1static clear(callback:(error)) 网络请求封装在React Native中，经常使用Fetch函数来实现网络请求，它支持GET和POST请求并返回一个Promise对象，这个对象包含一个正确的结果和一个错误的结果。 来看一下用Fetch发起的POST请求封装： 12345678910111213141516171819static post(url,data)&#123; return new Promise((resolve,reject)=&gt;&#123; fetch(url,&#123; method:'POST', header:&#123; 'Accept':'application/json', 'Content-Type':'application/json' &#125;, body:JSON.stringify(data) &#125;) .then(response=&gt;response.json()) .then(result=&gt;&#123; resolve(result); &#125;) .catch(error=&gt;&#123; reject(error); &#125;) &#125;) &#125; 从上面的代码中，我们可以大致看到：Fetch函数中，第一个参数是请求url，第二个参数是一个字典，包括方法，请求头，请求体等信息。 随后的then和catch分别捕捉了fetch函数的返回值：一个Promise对象的正确结果和错误结果。注意，这里面有两个then，其中第二个then把第一个then的结果拿了过来。而第一个then做的事情是把网络请求的结果转化为JSON对象。 那么什么是Promise对象呢？ Promise 是异步编程的一种解决方案，Promise对象可以获取某个异步操作的消息。它里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 它分为三种状态： Pending（进行中）、Resolved（已成功）和Rejected（已失败） 它的构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject： resolve函数的作用：将Promise对象的状态从“未完成”变成“成功”(即从Pending变为Resolved)，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject函数的作用：将Promise对象的状态从“未完成”变成“成功”(即从Pending变为Rejected)，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 GET 请求封装：123456789101112static get(url)&#123; return new Promise((resolve,reject)=&gt;&#123; fetch(url) .then(response=&gt;response.json()) .then(result=&gt;&#123; resolve(result); &#125;) .catch(error=&gt;&#123; reject(error); &#125;) &#125;) &#125; 因为只是GET请求，所以不需要配置请求体，而且因为这个fetch函数返回值是一个Promise对象， 所以我们可以用.then和.catch来捕捉正确和错误的结果。 功能调试我们可以使用浏览器的开发者工具来调试React Native项目，可以通过打断点的方式来看数据信息以及方法的调用： 首先在iOS模拟器中点击command + D，然后再弹出菜单里点击Debug JS Remotely。随后就打开了浏览器进入了调试。 浏览器一般会展示下面的页面，然后点击command + option + J进入真生的调试界面。 双平台适配因为React Native讲求的是一份代码跑在两个平台上，而客观上这两个平台又有一些不一样的地方，所以就需要在别要的时候做一下两个平台的适配。 例如导航栏：在iOS设备中是存在导航栏的，而安卓设备上是没有的。所以在定制导航栏的时候，在不同平台下给导航栏设置不同的高度： 12345678910const NAV_BAR_HEIGHT_IOS = 54;const NAV_BAR_HEIGHT_ANDROID = 50;// css navBar: &#123; flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', height: Platform.OS === 'ios' ? NAV_BAR_HEIGHT_IOS : NAV_BAR_HEIGHT_ANDROID, &#125;, 上面的Platform是React Native内置的用于区分平台的库，可以在引入后直接使用。 建议在调试程序的时候，同时打开iOS和Android的模拟器进行调试，因为有些地方可能在某个平台上是没问题的，但是另一个平台上有问题，这就需要使用Platform来区分平台。 开源组件库的使用ReactNative 的组件与原生的组件有许多共同之处，如下拉刷新，同样的 Github 中开源组件已经相当完善。 开源组件库方法如下，安装最新版本：1npm install react-native-tab-navigator --save 安装指定版本：1npm install --save react-native-tab-navigator@0.4.0 react-native 集成组件绑定(ReactNative 0.27以后，自集成RNPM)：1react-native link react-native-splash-screen 常用开源库：12345678npm install --save react-native-tab-navigator@0.4.0npm install --save react-native-scrollable-tab-view@0.7.0npm install --save react-native-check-box@1.0.4npm install --react-native-easy-toast@1.0.9npm install --save GitHubTrending@2.0.0npm install --save react-native-htmlview@0.5.0npm install --save react-native-popover@0.5.0npm install --react-native-splash-screen@2.0.0 下图为使用 react-native-splash-screen 后的效果演示： 热更新CodePush 是微软提供的一套用于热更新 React Native 和 Cordova 应用的服务。 CodePush 是提供给 React Native 和 Cordova 开发者直接部署移动应用更新给用户设备的云服务。CodePush 作为一个中央仓库，开发者可以推送更新 (JS, HTML, CSS and images)，应用可以从客户端 SDK 里面查询更新。 Code-Push 推包命令：1code-push release-react &lt;appName&gt; &lt;platform&gt; [options] 示例：1code-push release-react RNAPPGithub ios --t 1.0.0 --dev false --d Staging --des &quot;1.热更新我的页面背景色&quot; --m true 1code-push release-react RNAPPGithub ios --t 1.0.1 --dev false --d Staging --des &quot;1.热更新相关设置&quot; --m true Code-Push 线上查看更新：1code-push deployment ls RNAPPGithub Code-Push 查看项目Key：1code-push deployment ls RNAPPGithub -k Code-Push iOS更新打包方法：1react-native bundle --platform ios --entry-file index.ios.js --bundle-output release_ios/main.jsbundle --assets-dest release_ios/ --dev fasle 总结之前也有零零散散的调研这门技术，但是经过系统的 15 个下午的坚持学习，深感跨平台技术的独到之处，特别是在与原生交互的编写上简直让人欲生欲死，还好在 Github 上已经有各路大神开源的各种方便开发的组件库可以供我们使用。 分享链接《React Native 开发常用命令行（持续更新）》(https://juejin.im/post/5abc54c86fb9a028da7c998c) 《ReactNative 开发常用的三方模块》(https://www.jianshu.com/p/53ff78168acc) 《使用VS Code调试React-Native程序》（https://jingyan.baidu.com/article/ad310e80fb13fc1849f49ed1.html） 参考资料 React Native中文网 贾鹏辉的技术博客 从一个实战项目来看一下React Native开发的几个关键技术点 Marno:给所有开发者的React Native详细入门指南 大漠:一个完整的Flexbox指南 阮一峰:Flex 布局教程：语法篇 八段代码彻底掌握 Promise 阮一峰：Promise对象 asce1885:React Native 高质量学习资料汇总 世锋日上:ReactNative 学习资源大汇集","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/tags/Project/"}]},{"title":"Jenkins + Fastlane 自动打包脚本","slug":"AutoBuildScript","date":"2017-06-20T13:55:38.000Z","updated":"2018-11-15T13:19:25.616Z","comments":true,"path":"2017/06/20/AutoBuildScript/","link":"","permalink":"https://reversescale.github.io/2017/06/20/AutoBuildScript/","excerpt":"使用 Jenkins 运行 Fastlane 命令，实现定时自动打包、修改版本号、上传 Fir 或者 TestFlight 等功能，从此再也不用被小伙伴追着要测试包。 三步配置，杜绝污染，一步操作自动上传~","text":"使用 Jenkins 运行 Fastlane 命令，实现定时自动打包、修改版本号、上传 Fir 或者 TestFlight 等功能，从此再也不用被小伙伴追着要测试包。 三步配置，杜绝污染，一步操作自动上传~ 📺 故事背景记得大约两年前，当时在创业公司，开发任务重，提测前常常加班到晚上 12 点，就算 bug 修完，也要看着 Xcode 不慌不忙的花半个多小时打包完成，再上传测试平台，发了邮件才能安心回家。鉴于这种惨痛经历，利用闲暇时间就搞一搞自动打包脚本，后期有配上 Jenkins，从此过上了没羞没臊的生活。（已适配 Xcode 8.2 之后版本） 🚀 框架的优势 1.市面上文件最少，使用最便捷的自动化打包脚本 2.冗余方法少，结构清晰，注释齐全 3.同时支持多平台上传，如：Dir、Fir、蒲公英、App Store等 4.具备较高自定义性 5.[自编脚本的时代] -&gt; [Fastlane 的时代] █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🚂 自编脚本的时代 [🚂 自编脚本的时代] 了解一下即可，有些准备工作提供参考，如环境已经配置好，请直接阅读 [🚄 Fastlane 的时代] 第一步 安装fir-cilfir-cli 使用 Ruby 构建, 无需编译, 只要安装相应 gem 即可. 12$ ruby -v # &gt; 1.9.3$ gem install fir-cli 常见的安装问题(1)使用系统自带的 Ruby 安装, 需确保 ruby-dev 已被正确的安装: 12$ xcode-select --install # OS X 系统$ sudo apt-get install ruby-dev # Linux 系统 (2)现 Permission denied 相关错误: 解决：在命令前加上 sudo (3)出现 Gem::RemoteFetcher::FetchError 相关错误: 解决：更换 Ruby 的淘宝源(由于国内网络原因, 你懂的), 并升级下系统自带的 gem12345678$ gem sources --remove https://rubygems.org/$ gem sources -a https://ruby.taobao.org/$ gem sources -l*** CURRENT SOURCES ***https://ruby.taobao.org# 请确保只有 ruby.taobao.org, 如果有其他的源, 请 remove 掉gem update --systemgem install fir-cli (4)Mac OS X 10.11 以后的版本, 由于10.11引入了 rootless, 无法直接安装 fir-cli, 有以下三种解决办法: 方法一： 使用 Homebrew 及 RVM 安装 Ruby, 再安装 fir-cli(推荐)12345# Install Homebrew:$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;# Install RVM:$ \\curl -sSL https://get.rvm.io | bash -s stable --ruby$ gem install fir-cli 方法二： 指定 fir-cli 中 bin 文件的 PATH1$ export PATH=/usr/local/bin:$PATH;gem install -n /usr/local/bin fir-cli 方法三： 重写 Ruby Gem 的 bindir12$ echo &apos;gem: --bindir /usr/local/bin&apos; &gt;&gt; ~/.gemrc$ gem install fir-cli 第二步 登录fir.im先到 https://fir.im 创建项目，得到 API Token 并复制。 1fir login 命令用于使用 API token 登录 fir.im, 并使用发布应用等相关命令. 1fir me 命令用于查看当前登录用户信息. 显示信息如下：12345678$ fir login XXX_YOUR_API_TOKEN_XXXI, [2016-03-08T12:48:56.499435 #13043] INFO -- : Login succeed, previous user&apos;s email: xxx@fir.imI, [2016-03-08T12:48:56.507044 #13043] INFO -- : Login succeed, current user&apos;s email: xxx@fir.imI, [2016-03-08T12:48:56.507147 #13043] INFO -- :$ fir meI, [2016-03-08T12:48:14.175488 #12986] INFO -- : Login succeed, current user&apos;s email: xxx@fir.imI, [2016-03-08T12:48:14.175687 #12986] INFO -- : Login succeed, current user&apos;s name: xxxI, [2016-03-08T12:48:14.175765 #12986] INFO -- : 第三步 下载并配置 shell 脚本1.把文件夹导入工程目录根目录下 2.配置 shell 脚本 12345678# 需要改动的地方 (根据项目具体信息改动)PROJECT_NAME = &quot;***&quot; #项目名称VERSION = &quot;1.0.0&quot; #打包版本号 会根据不同的版本创建文件夹（与项目本身的版本号无关）TAGREAT_NAME = &quot;***&quot; #项目对应target的名称如 &quot;Meifabao_User&quot; &quot;Miefabao_stylist&quot;CONFIGURATION = &quot;Release&quot; #打包的环境设置 Release 环境 Debug 环境PROFILE = &quot;AdHoc&quot; #配置文件分为四种 AdHoc Dev AppStore Ent 分别对应四种配置文件OUTPUT = &quot;./Packge/%s&quot; %(CONFIGURATION) #打包导出ipa文件路径（请确保 “%s” 之前的文件夹正确并存在） 根据具体项目填写 3.控制台到项目所在目录下，启动脚本(必要时加管理员权限) 可以将 autobuild.py 拖拽到控制台，执行脚本 注：其他的功能脚本由于实用性不高（其实我懒得搞），暂时没有适配，有兴趣的朋友可以自行配置试用，包括：邮件发送、打包 App Store 等等。 当看到 时，打包好的项目已经躺在你的 Fir 测试平台中了。 █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🚄 Fastlane 的时代2018.08.20 更新：Jenkins + Fastlane + GitLab + fir (或者蒲公英)第一步 安装 FastlaneFastlane 是一套使用Ruby写的自动化工具集，用于iOS和Android的自动化打包、发布等工作，可以节省大量的时间 1sudo gem install fastlane --verbose 第二步 移动脚本至项目目录下根据注释完善脚本配置信息 脚本说明： 支持版本号自增长 支持传入自定的宏，用于在代码里使用此预编译的宏来区分开发环境和发布环境 支持自动上传到 fir 和 testflight 上传成功后弹窗提示 第三步 上传上传到 fir 的用法：1./build.sh -m &quot;xxxx_app_test&quot; -t test 上传到 testflight 的用法：1./build.sh -m &quot;xxxx_app_pro&quot; -t pro 第四步 配置 JenkinsJenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。 下载 Jenkins：点击 http://mirrors.jenkins.io/war-stable/latest/jenkins.war 下载最新的Jenkins.war 运行服务器：需要先安装 java sdk （http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html） 1java -jar jenkins.war 运行 Jenkins1jenkins 配置 Jenkins：浏览器打开 http://localhost:8080/ 输入安全密码，安全密码命令行输出的一个文件里面。 然后自动安装推荐的插件，并新建管理员账号密码。 安装插件登录http://localhost:8080/ ，选择系统管理 - 管理插件。在可选插件中选择GitLab Plugin，Gitlab Hook Plugin，和 Cocoapod plugin 进行安装。 构建任务 点击新建，输入名称，构建一个自由风格的软件项目。 配置 Git 仓库地址，并添加 git 账号。 配置构建脚本 附录 执行脚本过程中遇到的问题和解决方案fir: command not found这个是因为没有安装fir-cil，导致找不到相应的命令行，只需要安装一下就行了，详情见上文写的如何安装fir-cil。 README: No such file or directory那是因为你的脚本目录下没有README的文件，只需要建一个README的文件就行了，打开终端，cd到当前位置，然后执行下面的命令： 1touch README ERROR – : Token can not be blank这个原因是因为你没有登录fir导致的，你执行这个脚本之前应该先登录一下fir，详情请看上文写的登录fir.im。 ERROR – : Code=14 (没有试用的设备 Domain=IDEDistributionErrorDomain Code=14 “No applicable devices原因：rvm ruby 配置错误 解决：控制台 rvm system █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 2018.08.20 更新：Jenkins 相关设置方法查看端口占用端口占用 使用 lsof 会列举所有占用的端口列表： 1lsof 使用less可以用于分页展示，如： 1lsof | less 也可以使用 -i 查看某个端口是否被占用，如： 1lsof -i:3000 杀死进程 1kill PID（进程的PID，如2044） Jenkins 改时区http://your-jenkins/systemInfo，查看user.timezone变量的值 在jenkins的【系统管理】-【脚本命令行】里运行 1System.setProperty(&apos;org.apache.commons.jelly.tags.fmt.timeZone&apos;, &apos;Asia/Shanghai&apos;) Jenkins 构建超时jenkins的”build timeout plugin”插件可以帮我们完成该任务。我使用的是jenkins-2.7.1, 默认就已经安装了该插件，如果默认没有安装可在插件管理中搜索进行安装。 Jenkins 定时构建和Poll SCM的区别 Build periodically：周期进行项目构建（源码是否发生变化没有关系） Poll SCM：定时检查源码变更，如果有更新就checkout最新code下来，然后执行构建动作 12345678910111213每15分钟构建一次：H/15 * * * * 或 */5 * * * *每天8点构建一次：0 8 * * *每天8点~17点，两小时构建一次：0 8-17/2 * * *周一到周五，8点~17点，两小时构建一次：0 8-17/2 * * 1-5每月1号、15号各构建一次，除12月：H H 1,15 1-11 **/5 * * * * （每5分钟检查一次源码变化）0 2 * * * （每天2:00 必须build一次源码） █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🕹 agvtool 命令行2018.08.20 更新：agvtool 命令行 管理版本号常用命令行：设置 版本号 为 1.1.01xcrun agvtool new-marketing-version 1.1.0 设置 build 号 自动加11xcrun agvtool next-version -all 简介agvtool 是一个命令行工具，允许你自动递增到下一个最高的数量或具体的数字这些数字。 修改Xcode的默认设置默认情况下，在不使用任何版本控制系统。设置版本系统苹果通用确保 Xcode 将包括在你的项目中生成的所有agvtool版本信息。 上图：设置当前项目的版本和版本控制系统的构建设置 设置你的版本号和 bulid 版本号agvtool 查询应用程序的 Info.plist 得到你的版本和 bulid 版本号。 所以确保 CFBundleVersion (Bundle version) 和 CFBundleShortVersionString (Bundle versions string, short）的 key 在你的 Info.plist 中。 上图：info.plist 命令行操作更新版本号退出Xcode，然后导航到包含项目的目录，运行下列命令在终端应用 agvtool 属性工作。 设置 版本号 为 1.1.01xcrun agvtool new-marketing-version 1.1.0 设置 build 号 自动加11xcrun agvtool next-version -all 设置 build 号为 311xcrun agvtool new-version -all 31 查看 Version Numbers1xcrun agvtool what-marketing-version 查看 Build Numbers1xcrun agvtool what-version 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Script","slug":"Script","permalink":"https://reversescale.github.io/categories/Script/"}],"tags":[{"name":"Script","slug":"Script","permalink":"https://reversescale.github.io/tags/Script/"}]},{"title":"GoF 设计模式 + 情景再现","slug":"Design patterns Gof","date":"2017-03-01T12:29:16.000Z","updated":"2018-11-15T13:19:15.263Z","comments":true,"path":"2017/03/01/Design patterns Gof/","link":"","permalink":"https://reversescale.github.io/2017/03/01/Design patterns Gof/","excerpt":"《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995），这几位作者常被称为”四人组（Gang of Four）”~","text":"《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995），这几位作者常被称为”四人组（Gang of Four）”~ 设计模式和情景再现创建型模式1、ABSTRACT FACTORY—追MM少不了请吃饭了，麦当劳的套餐和肯德基的套餐都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说“两个B套餐”就行了。麦当劳和肯德基就是B套餐的Abstract Factory, B套餐里含有汉堡, 鸡翅和饮料. 麦当劳或肯德基会根据B套餐的规格, 让汉堡Factory, 鸡翅Factory, 饮料Factory分别生产对应B套餐的材料。抽象工厂模式：客户类和工厂类分开。消费者任何时候需要某套产品集合时，只需向抽象工厂请求即可。抽象工厂会再向具体的工厂生产出符合产品集规格的产品。 2、BUILDER—MM最爱听的就是“我爱你”这句话了，见到不同地方的MM,要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出“我爱你”这句话了，国外的MM也可以轻松搞掂，这就是我的“我爱你”builder。（这一定比美军在伊拉克用的翻译机好卖）建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。 3、FACTORY METHOD—请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说“要一个汉堡”，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。 4、PROTOTYPE—跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype了。（100块钱一份，你要不要）原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。 5、SINGLETON—俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Singleton，她们只要说道“老公”，都是指的同一个人，那就是我。(刚才做了个梦啦，哪有这么好的事)单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。 结构型模式6、ADAPTER—在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的Adapter，让我和Sarah可以相互交谈了(也不知道他会不会耍我)适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。 7、BRIDGE—早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我“早上碰到MM新做了个发型怎么说”这种问题，自己用BRIDGE组合一下不就行了。桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。 8、COMPOSITE—Mary今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM都会用Composite模式了，你会了没有？合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。 9、DECORATOR—Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上“最好的的礼物，就是爱你的Fita”，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来……，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。 10、FACADE—我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。 11、FLYWEIGHT—每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。享元模式：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。 12、PROXY—跟MM在网上聊天，一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。 行为模式13、CHAIN OF RESPONSIBILITY—晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi,可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了，听说是个老处女呀，快跑!责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。 14、COMMAND—俺有一个MM家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送COMMAND，就数你最小气，才请我吃面。” :-(命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。 15、INTERPRETER—俺有一个《泡MM真经》，上面有各种泡MM的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟MM约会时，只要做一个Interpreter，照着上面的脚本执行就可以了。解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。 16、ITERATOR—我爱上了Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件”我：“什么条件我都答应，你说吧”Mary：“我看上了那个一克拉的钻石”我：“我买，我买，还有吗？”Mary：“我看上了湖边的那栋别墅”我：“我买，我买，还有吗？”……迭代子模式：迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。 17、MEDIATOR—四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。 18、MEMENTO—同时跟几个MM聊天时，一定要记清楚刚才跟MM说了些什么话，不然MM发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个MM说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。 19、OBSERVER—想知道咱们公司最新MM情报吗？加入公司的MM情报邮件组就行了，tom负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦观察者模式：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。 20、STATE—跟MM交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的MM就会说“有事情啦”，对你不讨厌但还没喜欢上的MM就会说“好啊，不过可以带上我同事么？”，已经喜欢上你的MM就会说“几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把MM的状态从不讨厌不喜欢变成喜欢哦。状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。 21、STRATEGY—跟不同类型的MM约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到MM的芳心，我的追MM锦囊中有好多Strategy哦。策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模式把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。 22、TEMPLATE METHOD——看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤(Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦(具体实现)；模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。 23、VISITOR—情人节到了，要给每个MM送一束鲜花和一张卡片，可是每个MM送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下Visitor，让花店老板根据MM的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。 设计模式之间的关系图： 设计模式的六大原则1、开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle）为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle）原则是尽量使用合成/聚合的方式，而不是使用继承。","categories":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/categories/Book/"}],"tags":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/tags/Book/"}]},{"title":"iOS 开发中常用的设计模式","slug":"Design patterns iOS","date":"2017-02-21T06:56:27.000Z","updated":"2018-11-15T13:23:48.042Z","comments":true,"path":"2017/02/21/Design patterns iOS/","link":"","permalink":"https://reversescale.github.io/2017/02/21/Design patterns iOS/","excerpt":"之前有朋友问到设计模式，便特意找了一篇文章，专门介绍在 iOS 开发中，对设计模式的具体应用，同时推荐一本书《Head First设计模式》~","text":"之前有朋友问到设计模式，便特意找了一篇文章，专门介绍在 iOS 开发中，对设计模式的具体应用，同时推荐一本书《Head First设计模式》~ （一）代理模式应用场景：当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。优势：解耦合敏捷原则：开放-封闭原则实例：tableview的 数据源delegate，通过和protocol的配合，完成委托诉求。列表row个数delegate自定义的delegate （二）观察者模式应用场景：一般为model层对，controller和view进行的通知方式，不关心谁去接收，只负责发布信息。优势：解耦合敏捷原则：接口隔离原则，开放-封闭原则实例：Notification通知中心，注册通知中心，任何位置可以发送消息，注册观察者的对象可以接收。kvo，键值对改变通知的观察者，平时基本没用过。 （三）MVC模式应用场景：是一中非常古老的设计模式，通过数据模型，控制器逻辑，视图展示将应用程序进行逻辑划分。优势：使系统，层次清晰，职责分明，易于维护敏捷原则：对扩展开放-对修改封闭实例：model-即数据模型，view-视图展示，controller进行UI展现和数据交互的逻辑控制。 （四）单例模式应用场景：确保程序运行期某个类，只有一份实例，用于进行资源共享控制。优势：使用简单，延时求值，易于跨模块敏捷原则：单一职责原则实例：[UIApplication sharedApplication]。注意事项：确保使用者只能通过 getInstance方法才能获得，单例类的唯一实例。java，C++中使其没有公有构造函数，私有化并覆盖其构造函数。object c中，重写allocWithZone方法，保证即使用户用 alloc方法直接创建单例类的实例，返回的也只是此单例类的唯一静态变量。 （五）策略模式应用场景：定义算法族，封装起来，使他们之间可以相互替换。优势：使算法的变化独立于使用算法的用户敏捷原则：接口隔离原则；多用组合，少用继承；针对接口编程，而非实现。实例：排序算法，NSArray的sortedArrayUsingSelector；经典的鸭子会叫，会飞案例。注意事项：1，剥离类中易于变化的行为，通过组合的方式嵌入抽象基类2，变化的行为抽象基类为，所有可变变化的父类3，用户类的最终实例，通过注入行为实例的方式，设定易变行为防止了继承行为方式，导致无关行为污染子类。完成了策略封装和可替换性。 （六）工厂模式应用场景：工厂方式创建类的实例，多与proxy模式配合，创建可替换代理类。优势：易于替换，面向抽象编程，application只与抽象工厂和易变类的共性抽象类发生调用关系。敏捷原则：DIP依赖倒置原则实例：项目部署环境中依赖多个不同类型的数据库时，需要使用工厂配合proxy完成易用性替换注意事项：项目初期，软件结构和需求都没有稳定下来时，不建议使用此模式，因为其劣势也很明显，增加了代码的复杂度，增加了调用层次，增加了内存负担。所以要注意防止模式的滥用。 设计模式六大原则1、开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle）为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle）原则是尽量使用合成/聚合的方式，而不是使用继承。 《Head First设计模式》http://pan.baidu.com/s/1nvTqSdj 验证码：DG58","categories":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/categories/Book/"}],"tags":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/tags/Book/"}]}]}