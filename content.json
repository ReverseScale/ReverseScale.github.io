{"meta":{"title":"Technology","subtitle":"","description":"","author":"Steven's Blog","url":"https://reversescale.github.io"},"pages":[{"title":"Not found","date":"2018-11-15T12:15:47.151Z","updated":"2018-11-15T02:35:05.000Z","comments":true,"path":"404.html","permalink":"https://reversescale.github.io/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#fff;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#000;margin-top:260px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=5; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2018-01-25T14:41:06.000Z","comments":false,"path":"categories/index.html","permalink":"https://reversescale.github.io/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2015-08-16T06:58:08.000Z","updated":"2018-11-15T12:29:41.694Z","comments":false,"path":"about/index.html","permalink":"https://reversescale.github.io/about/index.html","excerpt":"","text":"Excellence is a continuous process and not an accident. Thanks for reading! ~ 👨🏻‍💻 职业：程序员劝退师📟 WeChat：WhatsXie🤪 不只生产 bug 更是 bug 的搬运工📮 邮件：ReverseScale@iCloud.com🤖 Github：https://github.com/ReverseScale 博客新装修，历史文章正在路上…"},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2018-01-25T14:41:06.000Z","comments":true,"path":"tags/index.html","permalink":"https://reversescale.github.io/tags/index.html","excerpt":"","text":""},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2018-01-25T14:41:06.000Z","comments":true,"path":"archives/index.html","permalink":"https://reversescale.github.io/archives/index.html","excerpt":"","text":""}],"posts":[{"title":"使用 ngrok 快速实现内网穿透","slug":"Ngrok through","date":"2018-08-13T03:56:27.000Z","updated":"2018-11-15T13:18:46.822Z","comments":true,"path":"2018/08/13/Ngrok through/","link":"","permalink":"https://reversescale.github.io/2018/08/13/Ngrok through/","excerpt":"实现内网穿透的工具很多，之所以介绍 ngrok，主要还是因为它使用便捷，不用搭建服务器等等麻烦的工序，适合前段开发过程中，快速评估检测项目~","text":"实现内网穿透的工具很多，之所以介绍 ngrok，主要还是因为它使用便捷，不用搭建服务器等等麻烦的工序，适合前段开发过程中，快速评估检测项目~ Ngrok是什么ngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放。 而我用来在家里快速访问 Jenkins，偷个懒🤪 搭建方法由于要完成一个网页优化的作业找了很久ngrok的使用方法，都不够简便易行最后终于发现了一个好方法。 下载 MAC 版的 ngrok：https://ngrok.com/download 解压到指定目录：Safari 浏览器下载 Mac OS X 环境一般直接解压（反正我是自动解压的），将 ngrok 放进项目目录。 进入到 ngrok 所在路径：1cd /tmp 开启服务1./ngrok http localhost:8080 会出现如下 ngrok 控制台 等待 Session Status 状态为 online（变绿），就可以在外网通过 Forwarding 的地址进行连接了。 注意：Forwarding地址中的 c33faf1b 不是固定的，在每次开始 ngrok 服务的时候都会变更，想固定？ ngrok:😛要钱。 测试一下例如： ngrok 穿透前在局域网中访问地址：http://localhost:8080 ngrok 穿透后局域网 + 公网访问地址：https://c33faf1b.ngrok.io","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/tags/Tips/"}]},{"title":"如何用 Swift 打造你的第一个区块链 App","slug":"How to build DApp","date":"2018-07-06T14:51:21.000Z","updated":"2018-11-15T13:19:04.032Z","comments":true,"path":"2018/07/06/How to build DApp/","link":"","permalink":"https://reversescale.github.io/2018/07/06/How to build DApp/","excerpt":"区块链(Blockchain) 是一种突破性技术(Disruptive Technologies)，近年渐获关注，号称将互联网从信息共享，推向价值传递，让我们一步一步的来探索它设计上的奇思妙想~","text":"区块链(Blockchain) 是一种突破性技术(Disruptive Technologies)，近年渐获关注，号称将互联网从信息共享，推向价值传递，让我们一步一步的来探索它设计上的奇思妙想~ 因为区块链是许多加密货币(Cryptocurrencies) 如比特币(Bitcoin)、以太坊(Ethereum)、莱特币(Litecoin) 的创始技术。那区块链是如何运作的呢？在本次的教学里，我将会谈到所有关于区块链技术的知识，以及如何用Swift 来制作自己的「区块链」。那么，让我们开始吧！ 区块链的运作顾名思义，区块链就是一个由不同的区块串连在一起的「链」，每个区块包含三则资讯：资料(Data)、杂凑值(Hash)、和前一个区块的杂凑值。 资料 ──依据使用情境，储存在区块的资料会因区块链的类型而不同。例如，在比特币区块链中，储存资料就是与交易有关的资讯，即是转帐的金额、以及参与交易二人的资讯。 杂凑值 ──你可以把杂凑想成是一种数位指纹，它是用来识别一个区块及其资料。杂凑最重要的地方，就是它是一个独一无二的字母数字(Alphanumeric)程式码，通常会由64个字元组成。当一个区块被创造时，杂凑值也同时产生。当一个区块被更动时，杂凑值也会同时被更动。透过这种方式，当你想要查看区块上的任何变动时，杂凑值就非常重要。 前一个区块的杂凑值 ──每个区块就是藉由储存前个区块的杂凑来链结在一起，组成一个区块链！这就是让区块链如此安全的原因。看看这张图片： 如你所见，每个区块由资料（未显示）、杂凑值、和前一个区块杂凑值所组成。举个例子，黄色区块包含了自己的杂凑值H7S6、和红色区块的杂凑值8SD9。以这种方式，它们组成了一个链结，并以此连结在一起。现在，假设有个骇客入侵并尝试更动红色区块。请记住，每次一个区块以任何方式被更动时，区块的杂值凑也会被更动！因此，当下一个区块执行确认、并看到前一个区块的杂凑值并不吻合时，它会有效地将自己从「链」中分离出来，而不会被骇客读取。 这就是区块练会如此安全的原因，你几乎不可能尝试回溯并更改任何资料。杂凑值提供了不错的保密及隐私，但还有两个安全机制来让区块链更加安全：验证(Proof-of-work)及智慧合约(Smart Contract)。虽然我不会详述，但你可以在这里了解更多。区块链最后一个保全方式就是基于它的位置。与大多储存在伺服器或是资料库内的资料不同，区块链使用点对点网路(Peer-To-Peer, P2P)，它是一种网路型态，允许任何人加入并将该网路上的资料分发给每位接收者。每当有人加入这个网路时，他们就会得到区块链的完整拷贝；每当有人建立一个新区块时，就会传送到网路内的所有人。然后，透过一些复杂的程式，让节点(Node)在加入这个区块到区块链之前，先确认该区块有否被窜改。就这样，任何地方的任何人都可以取得这些资讯。如果你是HBO矽谷群瞎传(Silicon Valley)的忠实粉丝，这听起来可能有点熟悉，因为在这出美剧里，主角就是用了类似的技术来建立一个全新网路。 因为每个人或节点都有一份区块链的拷贝，他们可以有共识并确认哪些区块是合法的。因此，如果你想要骇入一个区块，你必须骇入网路上超过50% 的区块来通过你的资讯。这就是为什么区块链或许是过去十年以来最安全的技术之一。 关于范例应用现在你了解区块链是如何运作了，那么开始来制作我们的范例App吧！请先下载初始项目。（https://raw.githubusercontent.com/appcoda/BlockchainDemo/master/BlockchainStarter.zip） 如你所见，我们有两个比特币钱包。第一个帐号Account 1065 拥有500 BTC，而第二个帐号0217 则什么都没有。我们利用传送按钮来传送比特币到其他帐号。为了赚取BTC，我们按下Mine 按钮就可以获得50 BTC 为奖励。基本来说，我们做的是当App 执行时，利用控制台来观察两个比特币帐号间的交易情况。 你会注意到，侧边栏里有两个重要的类别：Block及Blockchain。打开这些档案，你会看到档案是空的，那是因为我将会引导你写出这些类别的逻辑。那我们开始吧！ 在Swift 定义Block前往Block.swift并添加程式码以定义一个区块。首先，让我们了解一下区块是什么。我们先前定义了一个区块由三个部分组成：杂凑值、记录的实际资料、以及前一个区块的杂凑值。当我们想建立自己的区块链时，必须要知道区块的排序，这一点可以很容易地在Swift中定义。添加以下程式码到类别里： 1234var hash: String!var data: String!var previousHash: String!var index: Int! 现在，我们需要添加最后一个重要的程式码。我之前提到每次一个区块被更动，杂凑就会改变；这就是区块链如此安全的特色之一。所以我们必须建立一个函式来产生一个随机字母数字的杂凑。这个函式只需要几行程式码： 123func generateHash() -&gt; String &#123; return NSUUID().uuidString.replacingOccurrences(of: \"-\", with: \"\")&#125; NSUUID是一个物件，代表桥接UUID的通用唯一值。它内置于Swift中，而且非常适合用来产生32字元的字串。这个函式产生一个UUID，消除所有连字符(-)，然后回传String，即区块的杂凑。Block.swift现在应该看起来像这样： 我们已经定义了Block类别，接着让我们定义Blockchain类别吧。切换到Blockchain.swift。 在Swift 定义Blockchain如前文所说，让我们尝试从基本面来了解区块链。在基本的术语里，区块链只是区块串在一起组成的链；换句话说，它是一个包含所有项目的列表。听起来是不是有点熟悉呢？因为这就是阵列的定义，而这个阵列就是由区块所组成！让我们把下列的程式码加进去吧： 1var chain = [Block]() 小提示：这几乎可以应用在电脑科学世界的所有事上。如果你曾遇过大问题，试着将它拆解成小组件，然后以自己的方法来解决问题；就像我们弄清楚如何在Swift中加入区块及区块链一样！ 你会注意到在阵列里面包含了先前定义的Block类别，那是我们在区块链中需要的所有变数。加入两个函式到类别里，我们就完成了。试着用我前文所教的来回答这个问题： 在一个区块链中，两个主要的函式是什么？ 希望你能够回答这个问题！这两个区块链拥有的主要函式，是用来建立初始区块，以及在后面新增新的区块。当然，现在我不会下放这个链并加入智慧合约，但是这些是基本函式！加入以下程式码到Blockchain.swift： 1234567891011121314151617func createGenesisBlock(data:String) &#123; let genesisBlock = Block() genesisBlock.hash = genesisBlock.generateHash() genesisBlock.data = data genesisBlock.previousHash = \"0000\" genesisBlock.index = 0 chain.append(genesisBlock)&#125; func createBlock(data:String) &#123; let newBlock = Block() newBlock.hash = newBlock.generateHash() newBlock.data = data newBlock.previousHash = chain[chain.count-1].hash newBlock.index = chain.count chain.append(newBlock)&#125; 我们加入的第一个函式是用来建立初始区块。为此，我们建立了一个函式来把区块的资料作为Input。然后，我们定义一个名为genesisBlock的变数，并将它设为Block型别。因为它是Block型别，所以它有我们之前在Block.swift定义的所有变数及函式。我们设定generateHash()为杂凑、 Input data为资料。因为这是第一个区块，所以我们将前一个区块的杂凑设定为000，好让我们知道这是初始区块。我们将它的索引值设为0 ，然后放到区块链chain。 我们建立的下一个函式则适用于所有genesisBlock后的区块，而它会建立剩下的所有区块。你会注意到它跟之前的函式非常相似，唯一的不同的是我们将previousHash设定为前一个区块的杂凑，并将index设为它在区块练的位置。完成了！我们已经成功定义自己的Blockchain！你的程式码应该如下图所示！ 接着，我们将所有的部分连接到ViewController.swift档案，并看看执行成果吧！ 钱包后台(Wallet Backend)切换到ViewController.swift，我们可以看到所有的UI元件都已经连结完毕。我们所需要做的就是处理交易，并将交易列印到控制台上。然而在开始之前，我们应该稍微探讨一下比特币区块链。比特币来自一个总帐号，假设这个帐号的编号是000。当你挖掘一颗比特币时，就表示你解答了数学问题，并获得一定数量的比特币作为奖励。这是发行货币一个很聪明的方法，同时也创造了让更多人去挖掘的动机。在我们的App 里，我们将100 BTC 作为奖励。首先，让我们在ViewController 添加需要的变数： 123456let firstAccount = 1065let secondAccount = 0217let bitcoinChain = Blockchain()let reward = 100var accounts: [String: Int] = [\"0000\": 10000000]let invalidAlert = UIAlertController(title: \"Invalid Transaction\", message: \"Please check the details of your transaction as we were unable to process this.\", preferredStyle: .alert) 我们定义两个帐号：一个编号为1065，另一个编号为0217。我们同时新增一个bitcoinChain变数来作为我们的区块链，并将reward设定为100。我们需要一个作为比特币来源的主帐号：这是我们的初始帐号，编号为0000，它拥有一千万个比特币。你可以把这个帐号当成银行，在每一次的奖励中，就会从中取出100个比特币，并转至合法的帐号里。我们也定义一个警告，在每次交易无法完成时显示。 现在，让我们来写些将会执行的泛用函式。你可以猜到这些函式是什么吗？ 第一个函式是用来处理交易的。我们要确认传送者及接收者的帐号中，接收或扣除的金额是正确的，而且这个资讯会被记录在我们的区块链上。 下一个函式是要在控制台里印出完整的纪录，它会显示每个区块及每个区块内的资料。 最后一个函式是用来验证区块链是否合法，方法为确认前个区块的杂凑是否符合下一个区块的资讯。因为我们不会示范任何骇客方法，所以范例中的链永远都是合法的。 Transaction 函式以下是我们的泛用交易函式。在定义变数之下输入以下程式码： 1234567891011121314151617181920212223242526func transaction(from: String, to: String, amount: Int, type: String) &#123; // 1 if accounts[from] == nil &#123; self.present(invalidAlert, animated: true, completion: nil) return &#125; else if accounts[from]!-amount &lt; 0 &#123; self.present(invalidAlert, animated: true, completion: nil) return &#125; else &#123; accounts.updateValue(accounts[from]!-amount, forKey: from) &#125; // 2 if accounts[to] == nil &#123; accounts.updateValue(amount, forKey: to) &#125; else &#123; accounts.updateValue(accounts[to]!+amount, forKey: to) &#125; // 3 if type == \"genesis\" &#123; bitcoinChain.createGenesisBlock(data: \"From: \\(from); To: \\(to); Amount: \\(amount)BTC\") &#125; else if type == \"normal\" &#123; bitcoinChain.createBlock(data: \"From: \\(from); To: \\(to); Amount: \\(amount)BTC\") &#125;&#125; 看起来程式码很多，但是它的核心只是为每次的交易定义一些规则。在开头的地方，我们有四个参数：to、from、amount以及type。To、From、及Amount的含义一目了然，而Type基本上就是定义交易的类型。这里有两种Type：Normal和Genesis。一个Normal的交易类型会是在帐号1065与0217之间进行，而Genesis交易类型则会涉及到帐号0000。 第一个if-else条件式是关于来源帐号。如果来源帐号不存在或金额不足，我们会显示交易无效的警告，然后结束函式。而如果通过的话，我们会更新数值。 第二个if-else条件式是关于接收帐号。如果接收帐号不存在，那么我们随它而去，然后结束函式。要不然，我们就会传送正确的比特币数量到帐号。 第三个if-else条件式处理交易的类型。如果一个交易涉及初始区块，我们就建立一个新的初始区块；反之我们建立一个新区块来储存资料。 Printing 函式在每次交易的最后，我们想要看到一个清单列出所有交易，来确保我们知道所有发生的事情。以下是我们在transaction函式下输入的程式码： 123456789func chainState() &#123; for i in 0...bitcoinChain.chain.count-1 &#123; print(\"\\tBlock: \\(bitcoinChain.chain[i].index!)\\n\\tHash: \\(bitcoinChain.chain[i].hash!)\\n\\tPreviousHash: \\(bitcoinChain.chain[i].previousHash!)\\n\\tData: \\(bitcoinChain.chain[i].data!)\") &#125; redLabel.text = \"Balance: \\(accounts[String(describing: firstAccount)]!) BTC\" blueLabel.text = \"Balance: \\(accounts[String(describing: secondAccount)]!) BTC\" print(accounts) print(chainValidity())&#125; 这是一个简单的for回圈，包含bitcoinChain的每个区块。我们印出区块的编号、杂凑值、前个区块的杂凑、以及储存的资料，再更新UILabel来显示每个帐号内正确的BTC数目。最后，印出一个列出每个帐号的清单（应该会有三个），并验证链的合法性。现在，你应该会在函式最后一行中发生错误。这是因为我们还没定义chainValidity()函式，那么就来开始吧！ Validity 函式记住，如果前一个区块的杂凑值符合目前区块所描述的内容，那么这一个链就是合法的。我们可以轻易地用另一个for 回圈来重复验证每个区块。 123456789func chainValidity() -&gt; String &#123; var isChainValid = true for i in 1...bitcoinChain.chain.count-1 &#123; if bitcoinChain.chain[i].previousHash != bitcoinChain.chain[i-1].hash &#123; isChainValid = false &#125; &#125; return \"Chain is valid: \\(isChainValid)\\n\"&#125; 跟之前有点相似，我们在bitcoinChain中重复验证每个区块，来确认前一个区块的杂凑值是否与目前区块所描述的内容符合。这样就完成了！我们已经定义了函式，并将会每次都用到它们！你的ViewController.swift现在应该看起来像这样： 现在我们只需要将按钮连接到函式就完成了，来开始最后的篇章吧！ 将所有东西连结在一起当我们的App首次启动时，我们想让初始帐号0000传送50 BTC到我们的第一个帐号。然后，我们将让第一个帐号传送10 BTC到第二个帐号。这个步骤仅需三行程式码就可以完成。如此更改你的viewDidLoad函式： 1234567override func viewDidLoad() &#123; super.viewDidLoad() transaction(from: \"0000\", to: \"\\(firstAccount)\", amount: 50, type: \"genesis\") transaction(from: \"\\(firstAccount)\", to: \"\\(secondAccount)\", amount: 10, type: \"normal\") chainState() self.invalidAlert.addAction(UIAlertAction(title: \"OK\", style: .default, handler: nil))&#125; 我们使用先前定义好的函式，并在最后呼叫chainState()。同时，我们新增一个OK按钮到交易无效的警告中。现在让我们来看看剩下的四个函式里要加入什么：redMine()、blueMine()、redSend()及blueSend()。 挖矿函式挖矿函式非常地简单，只要三行程式码就行了。这就是我们要添加的程式码： 1234567891011@IBAction func redMine(_ sender: Any) &#123; transaction(from: \"0000\", to: \"\\(firstAccount)\", amount: 100, type: \"normal\") print(\"New block mined by: \\(firstAccount)\") chainState()&#125; @IBAction func blueMine(_ sender: Any) &#123; transaction(from: \"0000\", to: \"\\(secondAccount)\", amount: 100, type: \"normal\") print(\"New block mined by: \\(secondAccount)\") chainState()&#125; 在第一个挖矿函式中，我们使用transaction函式从初始帐号传送100 BTC到第一个帐号，先印出一个区块被挖出，再印出chainState。同样地，我们在blueMine函式里将100 BTC传送到第二个帐号。 传送函式传送函式与先前的函式也稍微相似。 123456789101112131415161718192021@IBAction func redSend(_ sender: Any) &#123; if redAmount.text == \"\" &#123; present(invalidAlert, animated: true, completion: nil) &#125; else &#123; transaction(from: \"\\(firstAccount)\", to: \"\\(secondAccount)\", amount: Int(redAmount.text!)!, type: \"normal\") print(\"\\(redAmount.text!) BTC sent from \\(firstAccount) to \\(secondAccount)\") chainState() redAmount.text = \"\" &#125;&#125; @IBAction func blueSend(_ sender: Any) &#123; if blueAmount.text == \"\" &#123; present(invalidAlert, animated: true, completion: nil) &#125; else &#123; transaction(from: \"\\(secondAccount)\", to: \"\\(firstAccount)\", amount: Int(blueAmount.text!)!, type: \"normal\") print(\"\\(blueAmount.text!) BTC sent from \\(secondAccount) to \\(firstAccount)\") chainState() blueAmount.text = \"\" &#125;&#125; 首先，我们确认redAmount或blueAmount中的文字栏位是否为空值。如果是，我们会显示一个交易无效的警告。如果不是，我们就可以继续。我们使用transaction函式输入金额，并把交易设为normal型态，以将第一个帐号的金额传送到第二个帐号（或相反）。我们印出被传送的金额，然后呼叫chainState()函式。最后，把文字栏位清空。这样我们就完成啰！确认一下你的程式码是否符合下图所示。 执行App 试试看！从前端来说，它看起来就如一个普通的交易App，但你会知道它后台的运作。试试使用App 将BTC 从一个帐号交易给另一个帐号、并试着欺骗App 吧！ 结论在这次的教学中，你学到了如何使用Swift 来建立一个区块链，并建立自己的比特币交易。请注意在真实的加密货币后台里，实作部分是跟上文是完全不一样的东西，因为它需要藉由智慧合约来分散，但是上面的示范内容用来学习的。在这个范例中，我们运用了比特币来当加密货币，但你能想到区块链还的其他用途吗？欢迎在下面留言分享你的看法！希望你在此学到新的东西！你可以在Github下载完整项目作参考。 完整项目：https://github.com/appcoda/BlockchainDemo原文链接：https://www.appcoda.com/blockchain-introduction/","categories":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://reversescale.github.io/categories/Blockchain/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://reversescale.github.io/tags/Blockchain/"}]},{"title":"走在技术前沿的 iOS 架构实现","slug":"iOS Architecture","date":"2018-05-01T13:56:27.000Z","updated":"2018-11-15T15:14:12.443Z","comments":true,"path":"2018/05/01/iOS Architecture/","link":"","permalink":"https://reversescale.github.io/2018/05/01/iOS Architecture/","excerpt":"我理解的框架，就好比计算机的主板，房屋的建筑骨架，道路的基础设施配套，框架搭的好，能直接影响开发者的开发心情，更能让项目健壮性和扩展性大大增强~","text":"我理解的框架，就好比计算机的主板，房屋的建筑骨架，道路的基础设施配套，框架搭的好，能直接影响开发者的开发心情，更能让项目健壮性和扩展性大大增强~ 基于 Objective-C 实现的框架设计，YTKNetwork网络层 + AOP替代基类 + MVVM + ReactiveObjC + JLRoutes路由 👨🏻‍💻 Github Demo 🤖 要求 iOS 8.0+ Xcode 8.0+ Objective-C 🎨 测试 UI 什么样子？ 1.展示页 2.展示页 3.展示页 4.说明页 登录视图 示例展示 跳转页面 介绍页面 🎯 安装方法安装在 iOS, 你需要在 Podfile 中添加.123456789101112131415161718source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;9.0&apos;use_frameworks! # 提示组件框架 pod &apos;SVProgressHUD&apos;, &apos;~&gt; 2.2.2&apos; # 网络请求框架 pod &apos;YTKNetwork&apos;, &apos;~&gt; 2.0.3&apos; # AOP面向切面 pod &apos;Aspects&apos;, &apos;~&gt; 1.4.1&apos; # 响应函数式框架 pod &apos;ReactiveObjC&apos;, &apos;~&gt; 3.0.0&apos; # 路由组件化解耦 pod &apos;JLRoutes&apos;, &apos;~&gt; 2.0.5&apos; # 提示组件框架 pod &apos;SVProgressHUD&apos;, &apos;~&gt; 2.2.2&apos; # 自动布局 pod &apos;Masonry&apos;, &apos;~&gt; 1.0.2&apos; 🛠 框架介绍AOP 模式（Aspects-RunTime 代替基类）+ Category 方法交换采用AOP思想，使用 Aspects 来完成替换 Controller ，View，ViewModel基类，和基类说拜拜 Casa反革命工程师 iOS应用架构谈 view层的组织和调用方案 博客中提到一个疑问是否有必要让业务方统一派生ViewController Casa大神回答是NO，原因如下 使用派生比不使用派生更容易增加业务方的使用成本 不使用派生手段一样也能达到统一设置的目的对于第一点，从 集成成本 ，上手成本 ，架构维护成本等因素入手，大神博客中也已经很详细。 框架不需要通过继承即能够对ViewController进行统一配置。业务即使脱离环境，也能够跑完代码，ViewController一旦放入框架环境，不需要添加额外的或者只需添加少量代码，框架也能够起到相应的作用 对于本人来说 ，具备这点的吸引力，已经足够让我有尝试一番的心思了。 对于OC来说，方法拦截很容易就想到自带的黑魔法方法调配 Method Swizzling， 至于为ViewController做动态配置，自然非Category莫属了Method Swizzling 业界已经有非常成熟的三方库 Aspects, 所以Demo代码采用 Aspects 做方法拦截。 12345678910111213141516171819202122+ (void)load &#123; [super load]; [FKViewControllerIntercepter sharedInstance];&#125;// .... 单例初始化代码- (instancetype)init &#123; self = [super init]; if (self) &#123; /* 方法拦截 */ // 拦截 viewDidLoad 方法 [UIViewController aspect_hookSelector:@selector(viewDidLoad) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt;aspectInfo)&#123; [self _viewDidLoad:aspectInfo.instance]; &#125; error:nil]; // 拦截 viewWillAppear: [UIViewController aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, BOOL animated)&#123; [self _viewWillAppear:animated controller:aspectInfo.instance]; &#125; error:NULL]; &#125; return self;&#125; 至于 Category 已经非常熟悉了 12345678910111213141516171819202122232425262728@interface UIViewController (NonBase)/** 去Model&amp;&amp;表征化参数列表 */@property (nonatomic, strong) NSDictionary *params;/** ViewModel 属性 */@property (nonatomic, strong) id &lt;FKViewControllerProtocol&gt; viewModel;#pragma mark - 通用类/** 返回Controller的当前bounds @param hasNav 是否有导航栏 @param hasTabBar 是否有tabbar @return 坐标 */- (CGRect)fk_visibleBoundsShowNav:(BOOL)hasNav showTabBar:(BOOL)hasTabBar;/** 隐藏键盘 */- (void)fk_hideKeyBoard;@end 至此，我们已经实现了不继承基类来实现对ViewController的配置，项目中的 View ViewModel 去基类原理如出一辙。 View层采用 MVVM 设计模式，使用 ReactiveObjC 进行数据绑定-MVC- 作为老牌思想MVC，大家早已耳熟能详，MVC素有 Massive VC之称，随着业务增加，Controller将会越来越复杂，最终Controller会变成一个”神类”, 即有网络请求等代码，又充斥着大量业务逻辑，所以为Controller减负，在某些情况下变得势在必行 -MVVM- MVVM是基于胖Model的架构思路建立的，然后在胖Model中拆出两部分：Model和ViewModel (注：胖Model 是指包含了一些弱业务逻辑的Model)胖Model实际上是为了减负 Controller 而存在的，而 MVVM 是为了拆分胖Model , 最终目的都是为了减负Controller。 我们知道，苹果MVC并没有专门为网络层代码分专门的层级，按照以往习惯，大家都写在了Controller 中，这也是Controller 变Massive得元凶之一，现在我们可以将网络请求等诸如此类的代码放到ViewModel中了 （文章后半部分将会描述ViewModel中的网络请求） -数据流向- 正常的网络请求获取数据，然后更新View自然不必多说，那么如果View产生了数据要怎么把数据给到Model，由于View不直接持有ViewModel，所以我们需要有个桥梁 ReactiveCocoa, 通过 Signal 来和 ViewModel 通信，这个过程我们使用 通知 或者 Target-Action也可以实现相同的效果，只不过没有 ReactiveCocoa 如此方便罢了 123456789101112131415161718/* View -&gt; ViewModel 传递数据示例 */#pragma mark - Bind ViewModel- (void)bindViewModel:(id&lt;FKViewModelProtocol&gt;)viewModel withParams:(NSDictionary *)params &#123; if ([viewModel isKindOfClass:[FKLoginViewModel class]])&#123; FKLoginViewModel *_viewModel = (FKLoginViewModel *)viewModel; // 绑定账号 View -&gt; ViewModel 传递数据 @weakify(self); RAC(_viewModel, userAccount) = [[self.inputTextFiled.rac_textSignal takeUntil:self.rac_prepareForReuseSignal] map:^id _Nullable(NSString * _Nullable account) &#123; @strongify(self); // 限制账号长度 if (account.length &gt; 25) &#123; self.inputTextFiled.text = [account substringToIndex:25]; &#125; return self.inputTextFiled.text; &#125;]; &#125;&#125; 上面代码给出了 View -&gt; ViewModel 绑定的一个例子 具体一些详情，可以直接看DemoMVVM一些总结： View C ViewModel Model 实际上应该称之为MVCVM Controller 将不再直接和 Model 进行绑定，而通过桥梁ViewModel 最终 Controller 的作用变成一些UI的处理逻辑，和进行View和ViewModel的绑定 MVVM 和 MVC 兼容 由于多了一层 ViewModel, 会需要写一些胶水代码，所以代码量会增加 网络层使用 YTKNetwork 配合 ReactiveCocoa 封装网络请求，解决如何交付数据，交付什么样的数据（去Model化)等问题YTKNetwork 是猿题库 iOS 研发团队基于 AFNetworking 封装的 iOS 网络库，其实现了一套 High Level 的 API，提供了更高层次的网络访问抽象。 笔者对 YTKNetwork 进行了一些封装，结合 ReactiveCocoa，并提供 reFormatter 接口对服务器响应数据重新处理，灵活交付给业务层。接下来，本文会回答两个问题 以什么方式将数据交付给业务层？ 交付什么样的数据 ?对于第一个问题 以什么方式将数据交付给业务层？ 虽然 iOS应用架构谈 网络层设计方案 中 Casa大神写到 尽量不要用block，应该使用代理的确，Block难以追踪和定位错误，容易内存泄漏， YTKNetwork 也提供代理方式回调 1234567891011121314@protocol YTKRequestDelegate &lt;NSObject&gt;@optional/// Tell the delegate that the request has finished successfully.////// @param request The corresponding request.- (void)requestFinished:(__kindof YTKBaseRequest *)request;/// Tell the delegate that the request has failed.////// @param request The corresponding request.- (void)requestFailed:(__kindof YTKBaseRequest *)request;@end 前文有说过，MVVM 并不等于 ReactiveCocoa , 但是想要体验最纯正的 ReactiveCocoa 还是Block较为酸爽，Demo中笔者两者都给出了代码, 大家可以自行选择和斟酌哈我们看一下 YTKNetwork 和 ReactiveCocoa 结合的代码 123456789101112131415161718192021222324252627- (RACSignal *)rac_requestSignal &#123; [self stop]; RACSignal *signal = [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; // 请求起飞 [self startWithCompletionBlockWithSuccess:^(__kindof YTKBaseRequest * _Nonnull request) &#123; // 成功回调 [subscriber sendNext:[request responseJSONObject]]; [subscriber sendCompleted]; &#125; failure:^(__kindof YTKBaseRequest * _Nonnull request) &#123; // 错误回调 [subscriber sendError:[request error]]; &#125;]; return [RACDisposable disposableWithBlock:^&#123; // Signal销毁 停止请求 [self stop]; &#125;]; &#125;] takeUntil:[self rac_willDeallocSignal]]; //设置名称 便于调试 if (DEBUG) &#123; [signal setNameWithFormat:@\"%@ -rac_xzwRequest\", RACDescription(self)]; &#125; return signal;&#125; 写了一个简单的 Category FKBaseRequest+Rac.hViewModel 中使用 RACCommand 封装调用：1234567891011- (RACCommand *)loginCommand &#123; if (!_loginCommand) &#123; @weakify(self); _loginCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id _Nullable input) &#123; @strongify(self); return [[[FKLoginRequest alloc] initWithUsr:self.userAccount pwd:self.password] rac_requestSignal]; &#125;]; &#125; return _loginCommand;&#125; Block方式交付业务1234567FKLoginRequest *loginRequest = [[FKLoginRequest alloc] initWithUsr:self.userAccount pwd:self.password];return [[[loginRequest rac_requestSignal] doNext:^(id _Nullable x) &#123; // 解析数据 [[NSUserDefaults standardUserDefaults] setObject:@(YES) forKey:@\"isLogin\"]; &#125;] materialize]; Delegate方式交付业务12345678910FKLoginRequest *loginRequest = [[FKLoginRequest alloc] initWithUsr:self.userAccount pwd:self.password];// 数据请求响应代理 通过代理回调loginRequest.delegate = self;return [loginRequest rac_requestSignal];#pragma mark - YTKRequestDelegate- (void)requestFinished:(__kindof YTKBaseRequest *)request &#123; // 解析数据 [[NSUserDefaults standardUserDefaults] setObject:@(YES) forKey:@\"isLogin\"];&#125; 交付什么样的数据 ? 现在诸如 JSONModel ，YYModel 之类的Json转Model的库也非常多，大多数Json对象，网络请求成功直接就被转成Model了然而 iOS应用架构谈 网络层设计方案 中给出了两种有意思的交付思路 使用 reformer 对数据进行清洗 去特定对象表征 （去Model） Casa文章中好处已经写得很详细了，通过不同的 reformer 来重塑和交付不同的业务数据，可以说是非常灵活了 使用 reformer 对数据进行清洗 在网络层封装 FKBaseRequest.h 中 给出了 FKBaseRequestFeformDelegate 接口来重塑数据1234567891011121314151617181920@protocol FKBaseRequestFeformDelegate &lt;NSObject&gt;/** 自定义解析器解析响应参数 @param request 当前请求 @param jsonResponse 响应数据 @return 自定reformat数据 */- (id)request:(FKBaseRequest *)request reformJSONResponse:(id)jsonResponse;@end然后在对应的 reformer 对数据进行重塑#pragma mark - FKBaseRequestFeformDelegate- (id)request:(FKBaseRequest *)request reformJSONResponse:(id)jsonResponse &#123; if([request isKindOfClass:FKLoginRequest.class])&#123; // 在这里对json数据进行重新格式化 &#125; return jsonResponse;&#125; 也可以直接在子类的 RequestManager 中覆盖父类方法达到一样的效果12345/* FKLoginRequest.m */// 可以在这里对response 数据进行重新格式化， 也可以使用delegate 设置 reformattor- (id)reformJSONResponse:(id)jsonResponse &#123;&#125; 去特定对象表征 （去Model） 这思路可以说是业界的泥石流了去Model也就是说，使用NSDictionary形式交付数据，对于网络层而言，只需要保持住原始数据即可，不需要主动转化成数据原型但是会存在一些小问题 去Model如何保持可读性？ 复杂和多样的数据结构如何解析？ Casa大神 提出了 使用EXTERN + Const 字符串形式，并建议字符串跟着reformer走，个人觉得很多时候API只需要一种解析格式，所以Demo跟着 APIManager 走，其他情况下常量字符串建议听从 Casa大神 的建议，常量定义： 123456/* FKBaseRequest.h */// 登录token keyFOUNDATION_EXTERN NSString *FKLoginAccessTokenKey;/* FKBaseRequest.m */NSString *FKLoginAccessTokenKey = @\"accessToken\"; 在 .h 和 .m 文件中要同时写太多代码，我们也可以使用局部常量的形式，只要在 .h 文件中定义即可 12345678910111213// 也可以写成 局部常量形式static const NSString *FKLoginAccessTokenKey2 = @\"accessToken\";最终那么我们的reformer可能会变成这样子- (id)request:(FKBaseRequest *)request reformJSONResponse:(id)jsonResponse &#123; if([request isKindOfClass:FKLoginRequest.class])&#123; // 在这里对json数据进行重新格式化 return @&#123; FKLoginAccessTokenKey : jsonResponse[@\"token\"], &#125;; &#125; return jsonResponse;&#125; 复杂和多样的数据结构如何解析？有时候，reformer 交付过来的数据，我们需要解析的可能是字符串类型，也可能是NSNumber类型，也有可能是数组为此，笔者提供了一系列 Encode Decode方法，来降低解析的复杂度和安全性1234567891011121314151617181920212223242526#pragma mark - Encode Decode 方法// NSDictionary -&gt; NSStringFK_EXTERN NSString* DecodeObjectFromDic(NSDictionary *dic, NSString *key);// NSArray + index -&gt; idFK_EXTERN id DecodeSafeObjectAtIndex(NSArray *arr, NSInteger index);// NSDictionary -&gt; NSStringFK_EXTERN NSString * DecodeStringFromDic(NSDictionary *dic, NSString *key);// NSDictionary -&gt; NSString ？ NSString ： defaultStrFK_EXTERN NSString* DecodeDefaultStrFromDic(NSDictionary *dic, NSString *key,NSString * defaultStr);// NSDictionary -&gt; NSNumberFK_EXTERN NSNumber * DecodeNumberFromDic(NSDictionary *dic, NSString *key);// NSDictionary -&gt; NSDictionaryFK_EXTERN NSDictionary *DecodeDicFromDic(NSDictionary *dic, NSString *key);// NSDictionary -&gt; NSArrayFK_EXTERN NSArray *DecodeArrayFromDic(NSDictionary *dic, NSString *key);FK_EXTERN NSArray *DecodeArrayFromDicUsingParseBlock(NSDictionary *dic, NSString *key, id(^parseBlock)(NSDictionary *innerDic));#pragma mark - Encode Decode 方法// (nonull Key: nonull NSString) -&gt; NSMutableDictionaryFK_EXTERN void EncodeUnEmptyStrObjctToDic(NSMutableDictionary *dic,NSString *object, NSString *key);// nonull objec -&gt; NSMutableArrayFK_EXTERN void EncodeUnEmptyObjctToArray(NSMutableArray *arr,id object);// (nonull (Key ? key : defaultStr) : nonull Value) -&gt; NSMutableDictionaryFK_EXTERN void EncodeDefaultStrObjctToDic(NSMutableDictionary *dic,NSString *object, NSString *key,NSString * defaultStr);// (nonull Key: nonull object) -&gt; NSMutableDictionaryFK_EXTERN void EncodeUnEmptyObjctToDic(NSMutableDictionary *dic,NSObject *object, NSString *key); 我们的reformer可以写成这样子1234567891011#pragma mark - FKBaseRequestFeformDelegate- (id)request:(FKBaseRequest *)request reformJSONResponse:(id)jsonResponse &#123; if([request isKindOfClass:FKLoginRequest.class])&#123; // 在这里对json数据进行重新格式化 return @&#123; FKLoginAccessTokenKey : DecodeStringFromDic(jsonResponse, @\"token\") &#125;; &#125; return jsonResponse;&#125; 解析有可能是这样子1NSString *token = DecodeStringFromDic(jsonResponse, FKLoginAccessTokenKey) 好了，至此我们解决了两个问题 以什么方式将数据交付给业务层答：delegate 最佳，block为次 交付什么样的数据答：纯字典，去Model 采用 JLRoutes 路由对应用进行组件化解耦 带着问题思考如何才能设计出最好的组件化路由： 1）3D-Touch功能或者点击推送消息，要求外部跳转到App内部一个很深层次的一个界面。 2）自家的一系列App之间如何相互跳转？ 3）如何解除App组件之间和App页面之间的耦合性？ 4）如何能统一iOS和Android两端的页面跳转逻辑？甚至如何能统一三端的请求资源的方式？ 5）如果使用了动态下发配置文件来配置App的跳转逻辑，那么如果做到iOS和Android两边只要共用一套配置文件？ 6）如果App出现bug了，如何不用JSPatch，就能做到简单的热修复功能？ 7）如何在每个组件间调用和页面跳转时都进行埋点统计？每个跳转的地方都手写代码埋点？利用Runtime AOP ？ 8）如何在每个组件间调用的过程中，加入调用的逻辑检查，令牌机制，配合灰度进行风控逻辑？ 9）如何在App任何界面都可以调用同一个界面或者同一个组件？只能在AppDelegate里面注册单例来实现？ iOS应用架构谈 组件化方案 一文中 Casa 针对 蘑菇街组件化 提出了质疑，质疑点主要在这几方面 App启动时组件需要注册URL URL调用组件方式不太好传递类似 UIImage 等非常规对象 URL需要添加额外参数可读性差，所以没必要使用URL 对于 App启动时组件需要注册URL 顾虑主要在于，注册的URL需要在应用生存周期内常驻内存，如果是注册Class还好些，如果注册的是实例，消耗的内存就非常可观了 12345#pragma mark - 路由表NSString *const FKNavPushRoute = @\"/com_madao_navPush/:viewController\";NSString *const FKNavPresentRoute = @\"/com_madao_navPresent/:viewController\";NSString *const FKNavStoryBoardPushRoute = @\"/com_madao_navStoryboardPush/:viewController\";NSString *const FKComponentsCallBackRoute = @\"/com_madao_callBack/*\"; 而且JLRoutes 还支持 * 来进行通配，路由表如何编写大家可以自由发挥对应的路由事件 handler 12345678910111213141516171819202122232425262728293031323334353637// push// 路由 /com_madao_navPush/:viewController[[JLRoutes globalRoutes] addRoute:FKNavPushRoute handler:^BOOL(NSDictionary&lt;NSString *,id&gt; * _Nonnull parameters) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [self _handlerSceneWithPresent:NO parameters:parameters]; &#125;); return YES;&#125;];// present// 路由 /com_madao_navPresent/:viewController[[JLRoutes globalRoutes] addRoute:FKNavPresentRoute handler:^BOOL(NSDictionary&lt;NSString *,id&gt; * _Nonnull parameters) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [self _handlerSceneWithPresent:YES parameters:parameters]; &#125;); return YES;&#125;];#pragma mark - Private/// 处理跳转事件- (void)_handlerSceneWithPresent:(BOOL)isPresent parameters:(NSDictionary *)parameters &#123; // 当前控制器 NSString *controllerName = [parameters objectForKey:FKControllerNameRouteParam]; UIViewController *currentVC = [self _currentViewController]; UIViewController *toVC = [[NSClassFromString(controllerName) alloc] init]; toVC.params = parameters; if (currentVC &amp;&amp; currentVC.navigationController) &#123; if (isPresent) &#123; [currentVC.navigationController presentViewController:toVC animated:YES completion:nil]; &#125;else &#123; [currentVC.navigationController pushViewController:toVC animated:YES]; &#125; &#125;&#125; 通过URL中传入的组件名动态注册，处理相应跳转事件，并不需要每个组件一一注册使用URL路由，必然URL会散落到代码各个地方 1234NSString *key = @\"key\";NSString *value = @\"value\";NSString *url = [NSString stringWithFormat:@\"/com_madao_navPush/%@?%@=%@\", NSStringFromClass(ViewController.class), key, value];[[UIApplication sharedApplication] openURL:[NSURL URLWithString:url]]; 诸如此类丑陋的代码，散落在各个地方的话简直会让人头皮发麻, 所以笔者在 JLRoutes+GenerateURL.h 写了一些 Helper方法1234567891011121314151617181920212223242526272829303132333435/** 避免 URL 散落各处， 集中生成URL @param pattern 匹配模式 @param parameters 附带参数 @return URL字符串 */+ (NSString *)fk_generateURLWithPattern:(NSString *)pattern parameters:(NSArray *)parameters;/** 避免 URL 散落各处， 集中生成URL 额外参数将被 ?key=value&amp;key2=value2 样式给出 @param pattern 匹配模式 @param parameters 附加参数 @param extraParameters 额外参数 @return URL字符串 */+ (NSString *)fk_generateURLWithPattern:(NSString *)pattern parameters:(NSArray *)parameters extraParameters:(NSDictionary *)extraParameters;/** 解析NSURL对象中的请求参数http://madao?param1=value1¶m2=value2 解析成 @&#123;param1:value1, param2:value2&#125; @param URL NSURL对象 @return URL字符串 */+ (NSDictionary *)fk_parseParamsWithURL:(NSURL *)URL;/** 将参数对象进行url编码 将@&#123;param1:value1, param2:value2&#125; 转换成 ?param1=value1&amp;param2=value2 @param dic 参数对象 @return URL字符串 */+ (NSString *)fk_mapDictionaryToURLQueryString:(NSDictionary *)dic; 宏定义Helper12345678910#undef JLRGenRoute#define JLRGenRoute(Schema, path) \\([NSString stringWithFormat: @\"%@:/%@\", \\Schema, \\path])#undef JLRGenRouteURL#define JLRGenRouteURL(Schema, path) \\([NSURL URLWithString: \\JLRGenRoute(Schema, path)]) 最终我们的调用可以变成12NSString *router = [JLRoutes fk_generateURLWithPattern:FKNavPushRoute parameters:@[NSStringFromClass(ViewController.class)] extraParameters:nil];[[UIApplication sharedApplication] openURL:JLRGenRouteURL(FKDefaultRouteSchema, router)]; 📝 整理制作Casa Taloyum：https://casatwy.com/modulization_in_action.html 简书博客：http://www.jianshu.com/p/921dd65e79cb 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/tags/Project/"}]},{"title":"ReactNative 开发常用命令行（持续更新）","slug":"ReactNative command","date":"2018-03-29T14:56:27.000Z","updated":"2018-11-15T13:53:41.655Z","comments":true,"path":"2018/03/29/ReactNative command/","link":"","permalink":"https://reversescale.github.io/2018/03/29/ReactNative command/","excerpt":"记录一些 ReactNative 常用的命令行，包括了例如安装、启动服务、插件管理、热更新等一些日常经常使用的命令，会随着使用的深入不断的补充 ~","text":"记录一些 ReactNative 常用的命令行，包括了例如安装、启动服务、插件管理、热更新等一些日常经常使用的命令，会随着使用的深入不断的补充 ~ Node 相关查看所有安装的node版本信息：1nvm list 查看更新了的node的版本(可能需要翻墙)：1nvm ls-remote 安装node：1nvm install v7.4.0 设置默认的node版本(这里设置成了7.4.0)，解决有些版本有些兼容性的问题：1nvm alias default v7.4.0 React 相关卸载命令：1npm uninstall -g react-native-cli 安装命令：1npm install -g react-native-cli 查看某个模块最新发布版本信息(这里查看react-native发布的版本信息)：1npm info react-native 升级或者降级react-native的版本并且更新package.json，需要用在react-native项目目录下：1npm install --save react-native@0.41.1 新建 react-native 项目并指定版本：1react-native init demo --version 0.40.0 开启服务：1react-native start 运行Android：1react-native run-android 运行iOS：1react-native run-ios 版本查看：1react-native --version 项目版本查看：1react-native -v 查看react-native的帮助信息：1react-native --help 使用 Cocoapods 管理 ReactNativePodfile 文件格式：1234567891011pod &apos;React&apos;, :path =&gt; &apos;./node_modules/react-native&apos;, :subspecs =&gt; [ &apos;Core&apos;, &apos;RCTText&apos;, &apos;RCTImage&apos;, &apos;RCTActionSheet&apos;, &apos;RCTGeolocation&apos;, &apos;RCTNetwork&apos;, &apos;RCTSettings&apos;, &apos;RCTVibration&apos;, &apos;RCTWebSocket&apos;, ] ReactNative 0.42.0 以上版本需在 Podfile 配置 yoga：12# 如果你的RN版本 &gt;= 0.42.0，请加入下面这行pod &quot;yoga&quot;, :path =&gt; &quot;./node_modules/react-native/ReactCommon/yoga&quot; 开源组件库：安装最新版本：1npm install react-native-tab-navigator --save 安装指定版本：1npm install --save react-native-tab-navigator@0.4.0 react-native 集成组件绑定(ReactNative 0.27以后，自集成RNPM)：1react-native link react-native-splash-screen 常用开源库：12345678npm install --save react-native-tab-navigator@0.4.0npm install --save react-native-scrollable-tab-view@0.7.0npm install --save react-native-check-box@1.0.4npm install --react-native-easy-toast@1.0.9npm install --save GitHubTrending@2.0.0npm install --save react-native-htmlview@0.5.0npm install --save react-native-popover@0.5.0npm install --react-native-splash-screen@2.0.0 Code-Push 常用命令Code-Push 推包命令：1code-push release-react &lt;appName&gt; &lt;platform&gt; [options] 示例： 1code-push release-react RNAPPGithub ios --t 1.0.2 --dev false --d Staging --des &quot;1.热更新相关设置&quot; --m true Code-Push 线上查看更新：1code-push deployment ls RNAPPGithub Code-Push 查看项目Key：1code-push deployment ls RNAPPGithub -k Code-Push iOS更新打包方法：1react-native bundle --platform ios --entry-file index.js --bundle-output release_ios/main.jsbundle --assets-dest release_ios/ --dev fasle IDE 技巧《使用VS Code调试React-Native程序》（https://jingyan.baidu.com/article/ad310e80fb13fc1849f49ed1.html）","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/tags/Tips/"}]},{"title":"ReactNative 学习成果总结","slug":"ReactNative APP","date":"2018-03-29T11:56:27.000Z","updated":"2018-11-15T15:02:07.961Z","comments":true,"path":"2018/03/29/ReactNative APP/","link":"","permalink":"https://reversescale.github.io/2018/03/29/ReactNative APP/","excerpt":"ReactNative 这几年风生水起，当然除了 React 社区生态圈的加持和 Facebook 的大力推广以外，另外一个最主要的原因就是其在开发效率和应用性能方面取得了一个比较好的平衡~","text":"ReactNative 这几年风生水起，当然除了 React 社区生态圈的加持和 Facebook 的大力推广以外，另外一个最主要的原因就是其在开发效率和应用性能方面取得了一个比较好的平衡~ 学习课程：《双平台真实开发GitHub App React Native技术全面掌握》399 大洋，含着泪吃了一个月泡面.. 👨🏻‍💻 Github Demo 知识点： 1.整理 ReactNative 网络封装及常用的三方模块 2.ReactNative 的 AsyncStorage数据库技术、离线缓存 3.ReactNative 的数据 DAO 层设计技巧，数据状态实时更新 4.ReactNative 的代码提取技巧，组合模式应用技巧，数据异步刷新与动态添加 5.ReactNative 的版本升级、数据统计、社会化分享、第三方登录，热更新等 6.ReactNative 项目发布前的优化、打包与上线 目录结构： 生命周期及使用场景 项目介绍 组件化 集成与管理 布局约束 组件封装 本地持久化 网络请求封装 功能调试 双平台适配 开源组件库的使用 热更新 生命周期及使用场景常用方法： constructor: componentWillMount: render: componentDidMount: componentWillReceiveProps: shouldComponentUpdate: componentWillUpdate: componentDidUpdate componentWillUnmount: constructor:在组件创建的时候调用一次,这个方法进行this.state初始化状态机。123456constructor(props) &#123; super(props); // 初始状态 this.state = &#123; isShow:true &#125;;&#125; componentWillMount:在组件生命周期中只会被执行一次,在初始渲染(render函数)前被执行。注意: 如果这个函数通过setState函数修改状态机变量,RN框架不会额外执行渲染(界面刷新) 如果子组件也有componentWillMount函数使用,会在父组件之后调用 需要从本地存储中读取数据用于显示,常用这个函数 render:该函数组件必有的，通过返回JSX或其他组件来构成DOM，换言之，就是组件的核心渲染过程。 componentDidMount:在React Native组件的生命周期中,这个函数只会被执行一次，它在初始渲染完成后会马上被调用。在这之后开发者可以通过子组件的引用来访问，操作任何子组件。如果RN组件的子组件也有componentDidMount函数，并会在父组件的componentDidMount函数之前被调用。 常用来网络请求数据 componentWillReceiveProps:在React Native组件的初始渲染完成后，props改变时，这个函数被调用，参数是个新的props。 shouldComponentUpdate:React Native组件的初始渲染执行完成后, RN组件接收到新的state或者props时这个函数会调用。 通过这个函数阻止无必要的重新渲染，是提高React Native应用程序性能的一大技巧。 componentWillUpdate:初始渲染完成后,重新渲染前会调用这个函数。 这个函数不能通过this.setState再次改变状态机变量的值。 组件更新时调用。 componentDidUpdateRN组件初始渲染完成后，RN框架在重新渲染RN组件完成后调用。参数是渲染前的props和state。 组件更新完毕时调用。 componentWillUnmount:ReactNative 组件被卸载前会调用，通常做一些清理内容。 项目介绍双平台效果预览： React Native是React在移动端的跨平台方案。如果想更快地理解和掌握React Native开发，就必须先了解React。 React是FaceBook开源的一个前端框架，它起源于 Facebook 的内部项目，并于 2013 年 5 月开源。因为React 拥有较高的性能，代码逻辑非常简单，所以越来越多的人已开始关注和使用它，目前该框架在Github上已经有7万+star。 ReactNative 技术导图： 组件化React采用组件化的方式开发，通过将view构建成组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。有一句话说的很形象：在React中，构建应用就像搭积木一样。 组件化特征React认为一个组件应该具有如下特征： 可组合（Composeable）：一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部。如果一个组件内部创建了另一个组件，那么说父组件拥有它创建的子组件，通过这个特性，一个复杂的UI可以拆分成多个简单的UI组件； 可重用（Reusable）：每个组件都是具有独立功能的，它可以被使用在多个UI场景； 可维护（Maintainable）：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护； 封装好的导航栏就可以被称之为一个组件，它符合上述三个特点： 可组合：可以将导航栏组件放在页面组件中作为页面组件的子组件。而且在导航栏组件的内部，也有按钮组件等子组件。 可重用：如果封装好了该组件，就可以放在任意需要导航栏的页面（组件）使用，也可以放在其他项目中使用。 可维护：因为具有独立的功能和展示逻辑，所以便于定位和修改。 组件的属性与状态在React Native（React.js）里，组件所持有的数据分为两种： 属性（props）：组件的props是不可变的，它只能从其他的组件（例如父组件）传递过来。 状态（state）：组件的state是可变的，它负责处理与用户的交互。在通过用户点击事件等操作以后，如果使得当前组件的某个state发生了改变，那么当前组件就会触发render()方法刷新自己。 我们可以看到这个页面有两个子页面，一个是‘最热’页面（组件），另一个是‘趋势‘页面（组件）。那么这两个组件都有什么props和state呢？ 1.props：由于props是从其父组件传递过来的，那么可想而知，props的声明应该是在当前组件的父组件里来做。在React Native中，通常props的声明是和当前组件的声明放在一起的： 1234//最热子页面&lt;FavoriteTabPage &#123;...this.props&#125; tabLabel='最热' flag=&#123;FlAG_STORAGE.flag_popular&#125;/&gt;//趋势子页面&lt;FavoriteTabPage &#123;...this.props&#125; tabLabel='趋势' flag=&#123;FlAG_STORAGE.flag_trending&#125;/&gt; 在这里，收藏页面是父组件，而最热页面和趋势页面是其子组件。在收藏页面组件里声明了最热页面和趋势页面的组件。 而且我们也可以看到，最热页面和趋势页面组件都用的是同一个组件：FavoriteTabPage，而这两个页面的不同点只在于传入的两个props的不同：tabLabel和flag。 而在FavoriteTabPage组件内部，如果想调用flag这个props，可以使用this.props.flag来调用。 2.state: 下面是最热和趋势页面的组件： 12345678class FavoriteTabPage extends Component&#123;//组件的构造方法constructor(props)&#123; super(props); this.state=&#123; dataSource:new ListView.DataSource(&#123;rowHasChanged:(r1,r2)=&gt;r1!==r2&#125;),isLoading:false, &#125;&#125; 这里面定义了两个state: dataSource:列表的数据源 isLoading:是否正在刷新 这两个state都是将来可能经常变化的。比如在网络请求以后，列表的数据源会被替换掉，这个时候就要调用: 1234this.setState(&#123; //把新的值newDataArr对象传给dataSource dataSource:newDataArr&#125;) 3.DOMDOM 是前端的一个概念，暂时可以粗略理解为一个页面的树形结构。React 生命周期的三大阶段 Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM 在每个阶段都有相应的状态和与之对应的回调函数，具体可以看下图： 上图来自：贾鹏辉的技术博客：React Native之React速学教程(中) 集成与管理1.指定版本初始化在终端输入react-native demo –version 0.40.0命令以后，就会初始化一个React Native版本为0.40.0的项目。这个最初项目里面直接就包含了iOS和Android的工程文件夹，可以用对应的IDE打开后编译运行。 在新建一个React Native项目之后的根目录结构是这样的： 2.使用 Cocoapods 管理 ReactNativePodfile 文件格式：1234567891011pod &apos;React&apos;, :path =&gt; &apos;./node_modules/react-native&apos;, :subspecs =&gt; [ &apos;Core&apos;, &apos;RCTText&apos;, &apos;RCTImage&apos;, &apos;RCTActionSheet&apos;, &apos;RCTGeolocation&apos;, &apos;RCTNetwork&apos;, &apos;RCTSettings&apos;, &apos;RCTVibration&apos;, &apos;RCTWebSocket&apos;, ] ReactNative 0.42.0 以上版本需在 Podfile 配置 yoga：12# 如果你的RN版本 &gt;= 0.42.0，请加入下面这行pod &quot;yoga&quot;, :path =&gt; &quot;./node_modules/react-native/ReactCommon/yoga&quot; 输入react-native run-ios或者react-native run-android指令， 就会自动打开模拟器运行项目(前提是安装了相应的开发环境)。 但是一个比较完整的项目仅仅有这些类别的文件是不够的，还需要一些工具类，模型类，资源等文件。为了很好地区分它们，使项目结构一目了然，需要组织好项目文件夹以及类的命名，下面是我将教程里的文件夹命名和结构稍加修改后的一个方案，可供大家参考： 布局约束采用Flex布局的元素，被称为Flex container，其所有子元素被称为Flex item；容器默认存在两个轴，分别是主轴（main axis）和垂直的交叉轴（cross axis）,主轴开始的位置叫做main start，结束的位置叫main end；交叉轴的开始位置叫做cross start，结束的位置叫做cross end；单个item占据的主轴空间叫做main size，占据的交叉轴控件叫做cross size。 如下图所示： 组件化驱动下，搜索结果页中展示的 Cell 与之前的列表页 Cell 可以重用： 我们把该组件定名为：RespositoryCell，结合代码来看一下具体的实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960export default class RepositoryCell extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; isFavorite: this.props.projectModel.isFavorite, favoriteIcon: this.props.projectModel.isFavorite ? require('../../res/images/ic_star.png') : require('../../res/images/ic_unstar_transparent.png'), &#125;; &#125; componentWillReceiveProps(nextProps) &#123; this.setFavoriteState(nextProps.projectModel.isFavorite) &#125; setFavoriteState(isFavorite) &#123; this.props.projectModel.isFavorite = isFavorite; this.setState(&#123; isFavorite: isFavorite, favoriteIcon: isFavorite ? require('../../res/images/ic_star.png') : require('../../res/images/ic_unstar_transparent.png') &#125;) &#125; onPressFavorite() &#123; this.setFavoriteState(!this.state.isFavorite) this.props.onFavorite(this.props.projectModel.item, !this.state.isFavorite) &#125; render() &#123; let item = this.props.projectModel.item? this.props.projectModel.item:this.props.projectModel; let favoriteButton=this.props.projectModel.item? &lt;TouchableOpacity style=&#123;&#123;padding:6&#125;&#125; onPress=&#123;()=&gt;this.onPressFavorite()&#125; underlayColor='transparent'&gt; &lt;Image ref='favoriteIcon' style=&#123;[&#123;width: 22, height: 22,&#125;,this.props.theme.styles.tabBarSelectedIcon]&#125; source=&#123;this.state.favoriteIcon&#125;/&gt; &lt;/TouchableOpacity&gt;:null; return ( &lt;TouchableOpacity onPress=&#123;this.props.onSelect&#125; style=&#123;styles.container&#125; &gt; &lt;View style=&#123;styles.cell_container&#125;&gt; &lt;Text style=&#123;styles.title&#125;&gt;&#123;item.full_name&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.description&#125;&gt;&#123;item.description&#125;&lt;/Text&gt; &lt;View style=&#123;styles.row&#125;&gt; &lt;View style=&#123;styles.row&#125;&gt; &lt;Text&gt;Author:&lt;/Text&gt; &lt;Image style=&#123;&#123;height: 22, width: 22&#125;&#125; source=&#123;&#123;uri: item.owner.avatar_url&#125;&#125; /&gt; &lt;/View&gt; &lt;View style=&#123;&#123;justifyContent: 'space-between', flexDirection: 'row'&#125;&#125;&gt; &lt;Text&gt;Star:&lt;/Text&gt; &lt;Text&gt;&#123;item.stargazers_count&#125;&lt;/Text&gt; &lt;/View&gt; &#123;favoriteButton&#125; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) &#125;&#125; 这里声明了RespositoryCell组件，它继承于Component，也就是组件类，即是说，声明组件的时候必须都要继承与这个类。 集中看一下该组件的render方法，它返回的是该组件的实际布局：在语法上使用JSX，类似于HTML的标签式语法，很清楚地将cell的层级展现了出来： 最外层被一个View组件包裹着，里面第一层有三个子组件：两个Text组件和一个作为底部背景的View组件。 底部背景的View组件又有三个子组件：View组件（显示作者信息），View组件（显示star信息）,收藏按钮。 结构分解图： 组件封装 我的页面 个人中心 对于“我的页面”和“个人中心”这类结构相似的页面，建议进行组件封装，封装后的 AboutPage 实现代码简洁如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768export default class AboutPage extends Component&#123; constructor(props) &#123; super(props); this.aboutCommon=new AboutCommon(props,(dic)=&gt;this.updateState(dic),FLAG_ABOUT.flag_about,config); this.state = &#123; projectModels: [], author:config.author &#125; &#125; componentDidMount() &#123; this.aboutCommon.componentDidMount(); &#125; componentWillUnmount() &#123; this.aboutCommon.componentWillUnmount(); &#125; updateState(dic)&#123; this.setState(dic); &#125; onClick(tab) &#123; let TargetComponent, params = &#123;...this.props,menuType:tab&#125;; switch (tab) &#123; case MORE_MENU.About_Author: TargetComponent = AboutMePage; break; case MORE_MENU.Website: TargetComponent = WebViewPage; params.title='GitHubPopular'; var url='https://reversescale.github.io'; params.url=url; break; case MORE_MENU.Feedback: var url='mailto://reversescale@icloud.com'; Linking.canOpenURL(url).then(supported =&gt; &#123; if (!supported) &#123; console.log('Can\\'t handle url: ' + url); &#125; else &#123; return Linking.openURL(url); &#125; &#125;).catch(err =&gt; console.error('An error occurred', err)); break; case MORE_MENU.Share: break; &#125; if (TargetComponent) &#123; this.props.navigator.push(&#123; component: TargetComponent, params: params, &#125;); &#125; &#125; render() &#123; let content=&lt;View&gt; &#123;this.aboutCommon.renderRepository(this.state.projectModels)&#125; &#123;ViewUtils.getSettingItem(()=&gt;this.onClick(MORE_MENU.Website), require('../../../res/images/ic_computer.png'), MORE_MENU.Website, this.props.theme.styles.tabBarSelectedIcon)&#125; &lt;View style=&#123;GlobalStyles.line&#125;/&gt; &#123;ViewUtils.getSettingItem(()=&gt;this.onClick(MORE_MENU.About_Author), require('../my/img/ic_insert_emoticon.png'), MORE_MENU.About_Author, this.props.theme.styles.tabBarSelectedIcon)&#125; &lt;View style=&#123;GlobalStyles.line&#125;/&gt; &#123;ViewUtils.getSettingItem(()=&gt;this.onClick(MORE_MENU.Feedback), require('../../../res/images/ic_feedback.png'), MORE_MENU.Feedback, this.props.theme.styles.tabBarSelectedIcon)&#125; &lt;/View&gt; return this.aboutCommon.render(content, &#123; 'name': 'GitHub Popular', 'description': '这是一个用来查看GitHub最受欢迎与最热项目的App,它基于React Native支持Android和iOS双平台。', \"avatar\": \"http://og1yl0w9z.bkt.clouddn.com/18-3-28/61685877.jpg\", \"backgroundImg\": \"http://og1yl0w9z.bkt.clouddn.com/18-3-28/37407402.jpg\", &#125;); &#125;&#125; 本地持久化 主题选择界面 切换主题后界面 在涉及如主题变更等操作时，需要将状态信息保存，这时就需要用到类似于iOS 中的NSUserDefault， AsyncStorage 是React Native中的 Key-Value 存储系统，可以做本地持久化。 首先看它主要的几个接口： 根据键来获取值，获取的结果会放在回调函数中：1static getItem(key: string, callback:(error, result)) 根据键来设置值：1static setItem(key: string, value: string, callback:(error)) 根据键来移除项：1static removeItem(key: string, callback:(error)) 获取所有的键：1static getAllKeys(callback:(error, keys)) 设置多项，其中 keyValuePairs 是字符串的二维数组，比如：[[‘k1’, ‘val1’], [‘k2’, ‘val2’]]：1static multiSet(keyValuePairs, callback:(errors)) 获取多项，其中 keys 是字符串数组，比如：[‘k1’, ‘k2’]：1static multiGet(keys, callback:(errors, result)) 删除多项，其中 keys 是字符串数组，比如：[‘k1’, ‘k2’]：1static multiRemove(keys, callback:(errors)) 清除所有的项目：1static clear(callback:(error)) 网络请求封装在React Native中，经常使用Fetch函数来实现网络请求，它支持GET和POST请求并返回一个Promise对象，这个对象包含一个正确的结果和一个错误的结果。 来看一下用Fetch发起的POST请求封装： 12345678910111213141516171819static post(url,data)&#123; return new Promise((resolve,reject)=&gt;&#123; fetch(url,&#123; method:'POST', header:&#123; 'Accept':'application/json', 'Content-Type':'application/json' &#125;, body:JSON.stringify(data) &#125;) .then(response=&gt;response.json()) .then(result=&gt;&#123; resolve(result); &#125;) .catch(error=&gt;&#123; reject(error); &#125;) &#125;) &#125; 从上面的代码中，我们可以大致看到：Fetch函数中，第一个参数是请求url，第二个参数是一个字典，包括方法，请求头，请求体等信息。 随后的then和catch分别捕捉了fetch函数的返回值：一个Promise对象的正确结果和错误结果。注意，这里面有两个then，其中第二个then把第一个then的结果拿了过来。而第一个then做的事情是把网络请求的结果转化为JSON对象。 那么什么是Promise对象呢？ Promise 是异步编程的一种解决方案，Promise对象可以获取某个异步操作的消息。它里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 它分为三种状态： Pending（进行中）、Resolved（已成功）和Rejected（已失败） 它的构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject： resolve函数的作用：将Promise对象的状态从“未完成”变成“成功”(即从Pending变为Resolved)，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject函数的作用：将Promise对象的状态从“未完成”变成“成功”(即从Pending变为Rejected)，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 GET 请求封装：123456789101112static get(url)&#123; return new Promise((resolve,reject)=&gt;&#123; fetch(url) .then(response=&gt;response.json()) .then(result=&gt;&#123; resolve(result); &#125;) .catch(error=&gt;&#123; reject(error); &#125;) &#125;) &#125; 因为只是GET请求，所以不需要配置请求体，而且因为这个fetch函数返回值是一个Promise对象， 所以我们可以用.then和.catch来捕捉正确和错误的结果。 功能调试我们可以使用浏览器的开发者工具来调试React Native项目，可以通过打断点的方式来看数据信息以及方法的调用： 首先在iOS模拟器中点击command + D，然后再弹出菜单里点击Debug JS Remotely。随后就打开了浏览器进入了调试。 浏览器一般会展示下面的页面，然后点击command + option + J进入真生的调试界面。 双平台适配因为React Native讲求的是一份代码跑在两个平台上，而客观上这两个平台又有一些不一样的地方，所以就需要在别要的时候做一下两个平台的适配。 例如导航栏：在iOS设备中是存在导航栏的，而安卓设备上是没有的。所以在定制导航栏的时候，在不同平台下给导航栏设置不同的高度： 12345678910const NAV_BAR_HEIGHT_IOS = 54;const NAV_BAR_HEIGHT_ANDROID = 50;// css navBar: &#123; flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', height: Platform.OS === 'ios' ? NAV_BAR_HEIGHT_IOS : NAV_BAR_HEIGHT_ANDROID, &#125;, 上面的Platform是React Native内置的用于区分平台的库，可以在引入后直接使用。 建议在调试程序的时候，同时打开iOS和Android的模拟器进行调试，因为有些地方可能在某个平台上是没问题的，但是另一个平台上有问题，这就需要使用Platform来区分平台。 开源组件库的使用ReactNative 的组件与原生的组件有许多共同之处，如下拉刷新，同样的 Github 中开源组件已经相当完善。 开源组件库方法如下，安装最新版本：1npm install react-native-tab-navigator --save 安装指定版本：1npm install --save react-native-tab-navigator@0.4.0 react-native 集成组件绑定(ReactNative 0.27以后，自集成RNPM)：1react-native link react-native-splash-screen 常用开源库：12345678npm install --save react-native-tab-navigator@0.4.0npm install --save react-native-scrollable-tab-view@0.7.0npm install --save react-native-check-box@1.0.4npm install --react-native-easy-toast@1.0.9npm install --save GitHubTrending@2.0.0npm install --save react-native-htmlview@0.5.0npm install --save react-native-popover@0.5.0npm install --react-native-splash-screen@2.0.0 下图为使用 react-native-splash-screen 后的效果演示： 热更新CodePush 是微软提供的一套用于热更新 React Native 和 Cordova 应用的服务。 CodePush 是提供给 React Native 和 Cordova 开发者直接部署移动应用更新给用户设备的云服务。CodePush 作为一个中央仓库，开发者可以推送更新 (JS, HTML, CSS and images)，应用可以从客户端 SDK 里面查询更新。 Code-Push 推包命令：1code-push release-react &lt;appName&gt; &lt;platform&gt; [options] 示例：1code-push release-react RNAPPGithub ios --t 1.0.0 --dev false --d Staging --des &quot;1.热更新我的页面背景色&quot; --m true 1code-push release-react RNAPPGithub ios --t 1.0.1 --dev false --d Staging --des &quot;1.热更新相关设置&quot; --m true Code-Push 线上查看更新：1code-push deployment ls RNAPPGithub Code-Push 查看项目Key：1code-push deployment ls RNAPPGithub -k Code-Push iOS更新打包方法：1react-native bundle --platform ios --entry-file index.ios.js --bundle-output release_ios/main.jsbundle --assets-dest release_ios/ --dev fasle 总结之前也有零零散散的调研这门技术，但是经过系统的 15 个下午的坚持学习，深感跨平台技术的独到之处，特别是在与原生交互的编写上简直让人欲生欲死，还好在 Github 上已经有各路大神开源的各种方便开发的组件库可以供我们使用。 分享链接《React Native 开发常用命令行（持续更新）》(https://juejin.im/post/5abc54c86fb9a028da7c998c) 《ReactNative 开发常用的三方模块》(https://www.jianshu.com/p/53ff78168acc) 《使用VS Code调试React-Native程序》（https://jingyan.baidu.com/article/ad310e80fb13fc1849f49ed1.html） 参考资料 React Native中文网 贾鹏辉的技术博客 从一个实战项目来看一下React Native开发的几个关键技术点 Marno:给所有开发者的React Native详细入门指南 大漠:一个完整的Flexbox指南 阮一峰:Flex 布局教程：语法篇 八段代码彻底掌握 Promise 阮一峰：Promise对象 asce1885:React Native 高质量学习资料汇总 世锋日上:ReactNative 学习资源大汇集","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/tags/Project/"}]},{"title":"基于 Aspects 深入了解 AOP（面向切面编程）","slug":"Library Aspects","date":"2018-03-23T13:56:27.000Z","updated":"2018-11-15T14:59:01.047Z","comments":true,"path":"2018/03/23/Library Aspects/","link":"","permalink":"https://reversescale.github.io/2018/03/23/Library Aspects/","excerpt":"AOP(Aspect-Oriented-Programming)，翻译过来就是「面向切面编程」，使用场景很多，如统计埋点、方法替换等~","text":"AOP(Aspect-Oriented-Programming)，翻译过来就是「面向切面编程」，使用场景很多，如统计埋点、方法替换等~ 👨🏻‍💻 Github Demo 🎨 测试 UI 什么样子？ 1.展示页 2.展示页 3.展示页 展示列表 拦截系统事件 自定义拦截 🎯 安装方法安装在 iOS, 你需要在 Podfile 中添加.12345source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;9.0&apos;use_frameworks!pod &quot;Aspects&quot; 🛠 配置系统级拦截拦截系统级级事件，如 viewWillAppear 等 1234567891011121314#import &lt;Aspects.h&gt;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. [UIViewController aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, BOOL animated) &#123; NSLog(@&quot;View Controller %@ will appear animated: %tu&quot;, aspectInfo.instance, animated); &#125; error:NULL];&#125;- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; NSLog(@&quot;System View Controller will appear&quot;);&#125; 自定义拦截拦截自定义事件，如对类的操作 12345678910111213141516171819202122232425262728// Cat.h 类@interface Cat: NSObject+ (void)classFee;@end// Cat.m 类@implementation Cat+ (void)classFee &#123; NSLog(@&quot;Miao~&quot;);&#125;@end// 实现方法#import &quot;Cat.h&quot;#import &lt;Aspects.h&gt;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. Class catMetal = objc_getMetaClass(NSStringFromClass(Cat.class).UTF8String); [catMetal aspect_hookSelector:@selector(classFee) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123; NSLog(@&quot;Miao~,I am angry~&quot;); &#125; error:NULL]; [Cat classFee];&#125; 📝 深入学习索引： AOP 简介 Aspects 简介 Aspects 结构剖析 Aspects 核心代码剖析 优秀 AOP 库应该具备的特质 总结 AOP 简介在 Objective-C 的实现结构中 Runtime 的动态派发机制保证了这么语言的灵活性，而在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是AOP(面向切面编程)。 AOP 是一种编程范式或者编程思想，它解决了 OOP (Object-oriented programming) 的延伸问题 什么时候需要使用 AOP假设随着我们所在的公司逐步发展，之前第三方的用户页面统计已经不能满足需求了，公司要求实现一个我们自己的用户页面统计。 在传统的 OOP 思想下，可能会如下操作： 一个熟悉 OOP 思想的程序猿会理所应当的想到要把用户页面统计这一任务放到 ViewController 中； 考虑到一个个的手动添加统计代码要死人（而且还会漏，以后新增 ViewController 也要手动加），于是想到了 OOP 思想中的继承； 不巧由于项目久远，所有的 ViewController 都是直接继承自系统类 UIViewController（笑），此时选择抽一个项目 RootViewController，替换所有 ViewController 继承 RootViewController； 然后在 RootViewController 的 viewWillAppear: 和 viewWillDisappear: 方法加入时间统计代码，记录 ViewController 以及 Router 传参。 其实 OOP 也有其特殊的定位，也能够实现上述的需求。 而 AOP 则更适合在给多个 App 写通用组件并以通用的形式实现统计的情况下。 一个简单的思路：Hook 方法交换的方法，在原方法执行之后记录需要统计的信息并上报。 单通过 Method Swizzling 来 Hook 的方法在处理不当的情况下容易出现安全隐患 Aspects 简介 Aspects 是一个使用起来简单愉快的 AOP 库，使用 Objective-C 编写，适用于 iOS 与 Mac OS X。 Aspects 简单易用，作者通过在 NSObject (Aspects) 分类中暴露出的两个接口分别提供了对实例和 Class 的 Hook 实现： 12345678910@interface NSObject (Aspects)+ (id)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;- (id)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;@end Aspects 支持实例 Hook，相较其他 Objective-C AOP 库而言可操作粒度更小，适合的场景更加多样化。作为使用者无需进行更多的操作即可 Hook 指定实例或者 Class 的指定 SEL，AspectOptions 参数可以指定 Hook 的点，以及是否执行一次之后就撤销 Hook。 Aspects 结构剖析 尽管 Aspects 只有不到千行的源码，但是其内部实现考虑到了很多 Hook 相关的安全问题和其他细节，对比其他 Objective-C AOP 开源项目来说 Aspects 更为健全。 Aspects 内部结构Aspects 内部定义了两个协议： AspectToken - 用于注销 Hook AspectInfo - 嵌入 Hook 中的 Block 首位参数 此外 Aspects 内部还定义了 4 个类： AspectInfo - 切面信息，遵循 AspectInfo 协议 AspectIdentifier - 切面 ID，应该遵循 AspectToken 协议（作者漏掉了，已提 PR） AspectsContainer - 切面容器 AspectTracker - 切面跟踪器 以及一个结构体： AspectBlockRef - 即 _AspectBlock，充当内部 Block如果你扒一遍源码，还会发现两个内部静态全局变量： static NSMutableDictionary *swizzledClassesDict; static NSMutableSet *swizzledClasses; Aspects 协议AspectToken AspectToken 协议旨在让使用者可以灵活的注销之前添加过的 Hook，内部规定遵守此协议的对象须实现 remove 方法。 12345/// 不透明的 Aspect Token，用于注销 Hook@protocol AspectToken /// 注销一个 aspect./// 返回 YES 表示注销成功，否则返回 NO- (BOOL)remove;@end AspectInfo AspectInfo 协议旨在规范对一个切面，即 aspect 的 Hook 内部信息的纰漏，我们在 Hook 时添加切面的 Block 第一个参数就遵守此协议。 12345678/// AspectInfo 协议是我们块语法的第一个参数。@protocol AspectInfo /// 当前被 Hook 的实例- (id)instance;/// 被 Hook 方法的原始 invocation- (NSInvocation *)originalInvocation;/// 所有方法参数（装箱之后的）惰性执行- (NSArray *)arguments;@end 装箱是一个开销昂贵操作，所以用到再去执行 Aspects 内部类接着协议，我们下面详细介绍一下 Aspects 的内部类。 AspectInfo AspectInfo 在这里是一个 Class，其遵守上文中讲到的 AspectInfo 协议，不要混淆。 123456@interface AspectInfo : NSObject - (id)initWithInstance:(__unsafe_unretained id)instance invocation:(NSInvocation *)invocation;@property (nonatomic, unsafe_unretained, readonly) id instance;@property (nonatomic, strong, readonly) NSArray *arguments;@property (nonatomic, strong, readonly) NSInvocation *originalInvocation;@end AspectInfo 比较简单，参考 ReactiveCocoa 团队提供的 NSInvocation 参数通用方法可将参数装箱为 NSValue，简单来说 AspectInfo 扮演了一个提供 Hook 信息的角色。 AspectIdentifier AspectIdentifier 类定义： 123456789@interface AspectIdentifier : NSObject+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;- (BOOL)invokeWithInfo:(id)info;@property (nonatomic, assign) SEL selector;@property (nonatomic, strong) id block;@property (nonatomic, strong) NSMethodSignature *blockSignature;@property (nonatomic, weak) id object;@property (nonatomic, assign) AspectOptions options;@end AspectIdentifier 实际上是添加切面的 Block 的第一个参数，其应该遵循 AspectToken 协议，事实上也的确如此，其提供了 remove 方法的实现。 AspectIdentifier 内部需要注意的是由于使用 Block 来写 Hook 中我们加的料，这里生成了 blockSignature，在 AspectIdentifier 初始化的过程中会去判断 blockSignature 与入参 object 的 selector 得到的 methodSignature 的兼容性，兼容性判断成功才会顺利初始化。 AspectsContainer AspectsContainer 作为切面的容器类，关联指定对象的指定方法，内部有三个切面队列，分别容纳关联指定对象的指定方法中相对应 AspectOption 的 Hook： NSArray *beforeAspects; - AspectPositionBefore NSArray *insteadAspects; - AspectPositionInstead NSArray *afterAspects; - AspectPositionAfter AspectsContainer 在 NSObject 分类中通过 AssociatedObject 方法与当前要 Hook 的目标关联在一起的。 12345678@interface AspectsContainer : NSObject- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;- (BOOL)removeAspect:(id)aspect;- (BOOL)hasAspects;@property (atomic, copy) NSArray *beforeAspects;@property (atomic, copy) NSArray *insteadAspects;@property (atomic, copy) NSArray *afterAspects;@end 关联目标是 Hook 之后的 Selector，即 aliasSelector（原始 SEL 名称加 aspects_ 前缀对应的 SEL） AspectTracker AspectTracker 类定义： 123456@interface AspectTracker : NSObject- (id)initWithTrackedClass:(Class)trackedClass parent:(AspectTracker *)parent;@property (nonatomic, strong) Class trackedClass;@property (nonatomic, strong) NSMutableSet *selectorNames;@property (nonatomic, weak) AspectTracker *parentEntry;@end AspectTracker 作为切面追踪器，原理大致如下： 12345678910111213// Add the selector as being modified.currentClass = klass;AspectTracker *parentTracker = nil;do &#123; AspectTracker *tracker = swizzledClassesDict[currentClass]; if (!tracker) &#123; tracker = [[AspectTracker alloc] initWithTrackedClass:currentClass parent:parentTracker]; swizzledClassesDict[(id)currentClass] = tracker; &#125; [tracker.selectorNames addObject:selectorName]; // All superclasses get marked as having a subclass that is modified. parentTracker = tracker;&#125;while ((currentClass = class_getSuperclass(currentClass))); 全局变量 swizzledClassesDict 中的 value 对应着 AspectTracker 指针。 AspectTracker 是从下而上追踪，最底层的 parentEntry 为 nil，父类的 parentEntry 为子类的 tracker。 Aspects 静态全局变量 1）static NSMutableDictionary *swizzledClassesDict; static NSMutableDictionary *swizzledClassesDict; 在 Aspects 中扮演着已混写类字典的角色，Aspects 内部提供了专门访问这个全局字典的方法： 12345678static NSMutableDictionary *aspect_getSwizzledClassesDict() &#123; static NSMutableDictionary *swizzledClassesDict; static dispatch_once_t pred; dispatch_once(&amp;pred, ^&#123; swizzledClassesDict = [NSMutableDictionary new]; &#125;); return swizzledClassesDict;&#125; 这个全局变量可以简单理解为记录整个 Hook 影响的 Class 包含其 SuperClass 的追踪记录的全局字典。 2）static NSMutableSet *swizzledClasses; static NSMutableSet *swizzledClasses; 在 Aspects 中担当记录已混写类的角色，Aspects 内部提供一个用于修改这个全局变量内容的方法： 12345678910static void _aspect_modifySwizzledClasses(void (^block)(NSMutableSet *swizzledClasses)) &#123; static NSMutableSet *swizzledClasses; static dispatch_once_t pred; dispatch_once(&amp;pred, ^&#123; swizzledClasses = [NSMutableSet new]; &#125;); @synchronized(swizzledClasses) &#123; block(swizzledClasses); &#125;&#125; Aspects 核心代码剖析Hook Class &amp;&amp; Hook InstanceAspects 不光支持 Hook Class 还支持 Hook Instance，这提供了更小粒度的控制，配合 Hook 的撤销功能可以更加灵活精准的实现功能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static Class aspect_hookClass(NSObject *self, NSError **error) &#123; // 断言 self NSCParameterAssert(self); // classClass statedClass = self.class;// isaClass baseClass = object_getClass(self);NSString *className = NSStringFromClass(baseClass); // 已经子类化过了if ([className hasSuffix:AspectsSubclassSuffix]) &#123;return baseClass; // 我们混写了一个 class 对象，而非一个单独的 object&#125;else if (class_isMetaClass(baseClass)) &#123; // baseClass 是元类，则 self 是 Class 或 MetaClass，混写 self return aspect_swizzleClassInPlace((Class)self); // 可能是一个 KVO'ed class。混写就位。也要混写 meta classes。 &#125;else if (statedClass != baseClass) &#123; // 当 .class 和 isa 指向不同的情况，混写 baseClass return aspect_swizzleClassInPlace(baseClass); &#125; // 默认情况下，动态创建子类 // 拼接子类后缀 AspectsSubclassSuffixconst char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;// 尝试用拼接后缀的名称获取 isaClass subclass = objc_getClass(subclassName); // 找不到 isa，代表还没有动态创建过这个子类if (subclass == nil) &#123; // 创建一个 class pair，baseClass 作为新类的 superClass，类名为 subclassNamesubclass = objc_allocateClassPair(baseClass, subclassName, 0);if (subclass == nil) &#123; // 返回 nil，即创建失败 NSString *errrorDesc = [NSString stringWithFormat:@\"objc_allocateClassPair failed to allocate class %s.\", subclassName]; AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc); return nil; &#125; // 混写 forwardInvocation:aspect_swizzleForwardInvocation(subclass);// subClass.class = statedClassaspect_hookedGetClass(subclass, statedClass);// subClass.isa.class = statedClassaspect_hookedGetClass(object_getClass(subclass), statedClass);// 注册新类objc_registerClassPair(subclass);&#125; // 覆盖 isaobject_setClass(self, subclass);return subclass;&#125; 难点就在于对 .class 和 object_getClass 的区分。 .class 当 target 是 Instance 则返回 Class，当 target 是 Class 则返回自身 object_getClass 返回 isa 指针的指向 动态创建一个 Class 的完整步骤也是我们应该注意的。 objc_allocateClassPair class_addMethod class_addIvar objc_registerClassPair Hook 的实现在上面 aspect_hookClass 方法中，不仅仅是返回一个要 Hook 的 Class，期间还做了一些细节操作，不论是 Class 还是 Instance，都会调用 aspect_swizzleForwardInvocation 方法，这个方法没什么难点，简单贴一下代码让大家有个印象： 123456789101112static void aspect_swizzleForwardInvocation(Class klass) &#123; // 断言 klass NSCParameterAssert(klass); // 如果没有 method，replace 实际上会像是 class_addMethod 一样 IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, \"v@:@\"); // 拿到 originalImplementation 证明是 replace 而不是 add，情况少见 if (originalImplementation) &#123; // 添加 AspectsForwardInvocationSelectorName 的方法，IMP 为原生 forwardInvocation: class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, \"v@:@\"); &#125; AspectLog(@\"Aspects: %@ is now aspect aware.\", NSStringFromClass(klass));&#125; 上面的方法就是把要 Hook 的目标 Class 的 forwardInvocation: 混写了，混写之后 forwardInvocation: 的具体实现在 ASPECTS_ARE_BEING_CALLED 中，里面能看到 invoke 标识位的不同是如何实现的，还有一些其他的实现细节： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 宏定义，以便于我们有一个更明晰的 stack trace#define aspect_invoke(aspects, info) \\for (AspectIdentifier *aspect in aspects) &#123;\\ [aspect invokeWithInfo:info];\\ if (aspect.options &amp; AspectOptionAutomaticRemoval) &#123; \\ aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \\ &#125; \\&#125;static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) &#123; // __unsafe_unretained NSObject *self 不解释了 // 断言 self, invocation NSCParameterAssert(self); NSCParameterAssert(invocation); // 从 invocation 可以拿到很多东西，比如 originalSelector SEL originalSelector = invocation.selector; // originalSelector 加前缀得到 aliasSelectorSEL aliasSelector = aspect_aliasForSelector(invocation.selector);// 用 aliasSelector 替换 invocation.selector invocation.selector = aliasSelector; // Instance 的容器 AspectsContainer *objectContainer = objc_getAssociatedObject(self, aliasSelector); // Class 的容器 AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(self), aliasSelector); AspectInfo *info = [[AspectInfo alloc] initWithInstance:self invocation:invocation]; NSArray *aspectsToRemove = nil; // Before hooks. aspect_invoke(classContainer.beforeAspects, info); aspect_invoke(objectContainer.beforeAspects, info); // Instead hooks. BOOL respondsToAlias = YES; if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123; // 如果有任何 insteadAspects 就直接替换了 aspect_invoke(classContainer.insteadAspects, info); aspect_invoke(objectContainer.insteadAspects, info); &#125;else &#123; // 否则正常执行 // 遍历 invocation.target 及其 superClass 找到实例可以响应 aliasSelector 的点 invoke Class klass = object_getClass(invocation.target); do &#123; if ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) &#123; [invocation invoke]; break; &#125; &#125;while (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass))); &#125; // After hooks. aspect_invoke(classContainer.afterAspects, info); aspect_invoke(objectContainer.afterAspects, info); // 如果没有 hook，则执行原始实现（通常会抛出异常） if (!respondsToAlias) &#123; invocation.selector = originalSelector; SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName); // 如果可以响应 originalForwardInvocationSEL，表示之前是 replace method 而非 add method if ([self respondsToSelector:originalForwardInvocationSEL]) &#123; ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation); &#125;else &#123; [self doesNotRecognizeSelector:invocation.selector]; &#125; &#125; // 移除 aspectsToRemove 队列中的 AspectIdentifier，执行 remove [aspectsToRemove makeObjectsPerformSelector:@selector(remove)];&#125;#undef aspect_invoke aspect_invoke 宏定义的作用域 代码实现对应了 Hook 的 AspectOptions 参数的 Before，Instead 和 After。 aspect_invoke 中 aspectsToRemove 是一个 NSArray，里面容纳着需要被销户的 Hook，即 AspectIdentifier（之后会调用 remove 移除）。 遍历 invocation.target 及其 superClass 找到实例可以响应 aliasSelector 的点 invoke 实现代码。 Block Hook Aspects 让我们在指定 Class 或 Instance 的特定 Selector 执行时，根据 AspectOptions 插入我们自己的 Block 做 Hook，而这个 Block 内部有我们想要的有关于当前 Target 和 Selector 的信息，我们来看一下 Aspects 是怎么办到的： 1234567891011121314151617181920212223242526272829303132333435363738- (BOOL)invokeWithInfo:(id)info &#123; NSInvocation *blockInvocation = [NSInvocation invocationWithMethodSignature:self.blockSignature]; NSInvocation *originalInvocation = info.originalInvocation; NSUInteger numberOfArguments = self.blockSignature.numberOfArguments; // 偏执。我们已经在 hook 注册的时候检查过了，（不过这里我们还要检查）。 if (numberOfArguments &gt; originalInvocation.methodSignature.numberOfArguments) &#123; AspectLogError(@\"Block has too many arguments. Not calling %@\", info); return NO; &#125; // block 的 `self` 将会是 AspectInfo。可选的。 if (numberOfArguments &gt; 1) &#123; [blockInvocation setArgument:&amp;info atIndex:1]; &#125; // 简历参数分配内存 argBuf 然后从 originalInvocation 取 argument 赋值给 blockInvocationvoid *argBuf = NULL; for (NSUInteger idx = 2; idx &lt; numberOfArguments; idx++) &#123; const char *type = [originalInvocation.methodSignature getArgumentTypeAtIndex:idx];NSUInteger argSize;NSGetSizeAndAlignment(type, &amp;argSize, NULL); // reallocf 优点，如果创建内存失败会自动释放之前的内存，讲究if (!(argBuf = reallocf(argBuf, argSize))) &#123; AspectLogError(@\"Failed to allocate memory for block invocation.\");return NO;&#125; [originalInvocation getArgument:argBuf atIndex:idx];[blockInvocation setArgument:argBuf atIndex:idx]; &#125; // 执行 [blockInvocation invokeWithTarget:self.block]; // 释放 argBuf if (argBuf != NULL) &#123; free(argBuf); &#125; return YES;&#125; 考虑两个问题： [blockInvocation setArgument:&amp;info atIndex:1]; 为什么要在索引 1 处插入呢？ for (NSUInteger idx = 2; idx &lt; numberOfArguments; idx++) 为什么要从索引 2 开始遍历参数呢？ 优秀 AOP 库应该具备的特质 良好的使用体验 可控粒度小 使用 Block 做 Hook 支持撤销 Hook 安全性 良好的使用体验Aspects 使用 NSObject + Categroy 的方式提供接口，非常巧妙的涵盖了 Instance 和 Class。 Aspects 提供的接口保持高度一致（本着易用，简单，方便的原则设计接口和整个框架的实现会让你的开源项目更容易被人们接纳和使用）： 12345678+ (id)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;- (id)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error; 可控粒度小Aspects 不仅支持大部分 AOP 框架应该做到的对于 Class 的 Hook，还支持粒度更小的 Instance Hook，而其在内部实现中为了支持 Instance Hook 所做的代码也非常值得我们参考和学习（已在上文 Aspects 核心代码剖析处单独分析）。 为使用者提供更为自由的 Hook 方式以达到更加精准的控制是每个使用者乐于见到的事。 使用 Block 做 HookAspects 使用 Block 来做 Hook 应该考虑到了很多东西，支持使用者通过在 Block 中获取到相关的信息，书写自己额外的操作就可以实现 Hook 需求。 支持撤销 HookAspects 还支持撤销之前做的 Hook 以及已混写的 Method，为了实现这个功能 Aspects 设计了全局容器，把 Hook 和混写用全局容器做记录，让一切都可以复原，这不正是我们想要的吗？ 安全性在学习 Runtime 的时候，就应该看到过不少文章讲解 Method Swizzling 要注意的安全性问题，由于用到了大量 Runtime 方法，加上 AOP 是面向整个切面的，所以一单发现问题就会比较严重，设计的面会比较广，而且难以调试。 不能因为容易造成问题就可以回避 Method Swizzling，就好比大学老师讲到递归时强调容易引起循环调用，很多人就在内心回避使用递归，甚至于非常适合使用递归来写的算法题（这里指递归来写会易读写、易维护）只会用复杂的方式来思考。 总结 文章简单介绍了 AOP 的概念，希望能给各位读者对 AOP 思想的理解提供微薄的帮助。 文章系统的剖析了 Aspects 开源库的内部结构，希望能让大家在浏览 Aspects 源码时快速定位代码位置，找到核心内容。 文章重点分析了 Aspects 的核心代码，提炼了一些笔者认为值得注意的点，但愿可以在大家扒源码时提供一些指引。 文章结尾总结了 Aspects 作为一个比较优秀的 AOP 开源库所具有的特质，不过毕竟是很久之前的代码了，如果有哪位想要造一个关于 AOP 的轮子，希望这篇文章能够产生些许帮助。 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/tags/Project/"}]},{"title":"iOS RAC 的使用总结","slug":"Reactive Cocoa","date":"2018-03-16T14:56:27.000Z","updated":"2018-11-15T14:12:52.976Z","comments":true,"path":"2018/03/16/Reactive Cocoa/","link":"","permalink":"https://reversescale.github.io/2018/03/16/Reactive Cocoa/","excerpt":"Reactive Cocoa(简称RAC),是 GitHub 上开源的一个应用于 iOS 和 OS X 开发的一个新框架，RAC具有函数式编程和响应者编程的特性~","text":"Reactive Cocoa(简称RAC),是 GitHub 上开源的一个应用于 iOS 和 OS X 开发的一个新框架，RAC具有函数式编程和响应者编程的特性~ ReactiveCocoa解决的问题: 1.传统iOS开发过程中,状态以及状态之间依赖过多的问题 2.传统MVC架构的问题:Controller比较复杂,可测试性差 3.提供统一的消息传递机制 键值观察–监听 TF 的值发生变化123456789101112- (void)demo1&#123; @weakify(self); [self.tF.rac_textSignal subscribeNext:^(NSString *value) &#123; @strongify(self); self.value = value; &#125;]; //当self.value的值变化时调用Block，这是用KVO的机制，RAC封装了KVO [RACObserve(self, value) subscribeNext:^(NSString *value) &#123; NSLog(@&quot;%@&quot;,value); &#125;];&#125; map 的使用1234567891011121314151617- (void)demo2&#123; //创建一个信号 RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; //这个信号里面有一个Next事件的玻璃球和一个complete事件的玻璃球 [subscriber sendNext:@&quot;唱歌&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //对信号进行改进,当信号里面流的是唱歌.就改进为&apos;跳舞&apos;返还给self.value RAC(self, tF.text) = [signalA map:^id(NSString *value) &#123; if ([value isEqualToString:@&quot;唱歌&quot;]) &#123; return @&quot;跳舞&quot;; &#125; return @&quot;&quot;; &#125;]; &#125; filter 使用,你向西，他就向东，他向左，你就向右1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void)demo3&#123; //创建两个通道,一个从A流出的通道A,和一个从B流出的通道B RACChannelTerminal *channelA = RACChannelTo(self, value); RACChannelTerminal *channelB = RACChannelTo(self, value2); //改造通道A,使通过通道A的值,如果等于&apos;西&apos;,就改为&apos;东&apos; [[channelA map:^id(NSString *value) &#123; if ([value isEqualToString:@&quot;西&quot;]) &#123; NSLog(@&quot;东&quot;); return @&quot;东&quot;; &#125; NSLog(@&quot;====== %@&quot;,value); return value; &#125;] subscribe:channelB];//通道A流向B //改造通道B,使通过通道B的值,如果等于&apos;左&apos;,就改为&apos;右&apos;传出去 [[channelB map:^id(id value) &#123; if ([value isEqualToString:@&quot;左&quot;]) &#123; NSLog(@&quot;右&quot;); return @&quot;右&quot;; &#125; NSLog(@&quot;====== %@&quot;,value); return value; &#125;] subscribe:channelA];//通道B流向通道A //KVO监听valueA的值的变化,过滤valueA的值,返回Yes表示通过 //只有value有值,才可通过 [[RACObserve(self, value) filter:^BOOL(id value) &#123; return value ? YES : NO; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;你向%@&quot;,x); &#125;]; //KVO监听value2的变化 [[RACObserve(self, value2) filter:^BOOL(id value) &#123; return value ? YES: NO; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;他向%@&quot;,x); &#125;]; //下面使value的值和value2的值发生改变 self.value = @&quot;西&quot;; self.value2 = @&quot;左&quot;; &#125; 代理1)代理的第一种写法 .m文件123- (void)demo4&#123; [self.delegate makeAnApp:@&quot;12345上山打老虎&quot; String:@&quot;老虎不在家,怎么办&quot;];&#125; .h文件12345- (void)makeAnApp:(NSString *)string String:(NSString *)string;@end@interface Base5Controller : UIViewController@property (nonatomic, assign)id&lt;ProgrammerDelegate&gt; delegate; 第一个控制器的.h123456789101112131415161718192021222324Base5Controller *base = [[Base5Controller alloc] init]; // base.delegate = self; [self demo4]; // 这里是个坑,必须将代理最后设置,否则信号是无法订阅到的 // 雷纯峰大大是这样子解释的:在设置代理的时候，系统会缓存这个代理对象实现了哪些代码方法 // 如果将代理放在订阅信号前设置,那么当控制器成为代理时是无法缓存这个代理对象实现了哪些代码方法的 base.delegate = self; [self.navigationController pushViewController:base animated:YES]; &#125; else &#123; [self.navigationController pushViewController:[cl new] animated:YES]; &#125;&#125;#pragma mark---demo4//使用RAC代替代理时,rac_signalForSelector: fromProtocol:这个代替代理的方法使用时,切记要将self设为代理这句话放在订阅代理信号的后面写,否则会无法执行- (void)demo4&#123; //为self添加一个信号,表示代理ProgrammerDelegate的makeAnApp; //RACTuple 相当于swift中的元祖 [[self rac_signalForSelector:@selector(makeAnApp:String:) fromProtocol:@protocol(ProgrammerDelegate)] subscribeNext:^(RACTuple *x) &#123; //这里可以立即为makeAnApp的方法要执行的代码 NSLog(@&quot;%@ &quot;,x.first); NSLog(@&quot;%@&quot;,x.second); &#125;];&#125; 2)方法2 使用RACSubject替代代理123456789101112131415161718192021/*** RACSubject:信号提供者,自己可以充当信号,又能发送信号创建方法:1.创建RACSubject2.订阅信号3.发送信号工作流程:1.订阅信号,内部保存了订阅者,和订阅者相应block2.当发送信号的,遍历订阅者,调用订阅者的nextBolck注:如果订阅信号,必须在发送信号之前订阅信号,不然收不到信号,有利用区别RACReplaySubject*/-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; RacSubjectController *racsub = [[RacSubjectController alloc] init]; racsub.subject = [RACSubject subject]; [racsub.subject subscribeNext:^(id x) &#123; NSLog(@&quot;被通知了%@&quot;,x); &#125;]; [self.navigationController pushViewController:racsub animated:YES];&#125; 在RacSubjectController.h里面声明属性1@property (nonatomic, strong) RACSubject *subject; .m里面进行数据的传递12345-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; if (self.subject) &#123; [self.subject sendNext:@1]; &#125;&#125; 广播12345678910111213141516//发送通知- (void)demo5&#123; NSNotificationCenter *center = [NSNotificationCenter defaultCenter]; //发送广播通知 [center postNotificationName:@&quot;妇女之友&quot; object:nil userInfo:@&#123;@&quot;技巧&quot;:@&quot;用心听&quot;&#125;];&#125;//接收通知NSNotificationCenter *center = [NSNotificationCenter defaultCenter];//RAC的通知不需要我们手动移除//注册广播通知RACSignal *siganl = [center rac_addObserverForName:@&quot;妇女之友&quot; object:nil];//设置接收通知的回调处理[siganl subscribeNext:^(NSNotification *x) &#123; NSLog(@&quot;技巧: %@&quot;,x.userInfo[@&quot;技巧&quot;]);&#125;]; 两个信号串联,两个管串联,一个管处理完自己的东西,下一个管才开始处理自己的东西12345678910111213141516171819202122- (void)demo6&#123; //创建一个信号管A RACSignal *siganlA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;吃饭&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //创建一个信号管B RACSignal *siganlB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;吃的饱饱的,才可以睡觉的&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //串联管A和管B RACSignal *concatSiganl = [siganlA concat:siganlB]; //串联后的接收端处理 ,两个事件,走两次,第一个打印siggnalA的结果,第二次打印siganlB的结果 [concatSiganl subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125; 并联,只要有一个管有东西,就可以打印123456789101112131415161718192021- (void)demo7&#123; //创建信号A RACSignal *siganlA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;纸厂污水&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //创建信号B RACSignal *siganlB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;电镀厂污水&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //并联两个信号,根上面一样,分两次打印 RACSignal *mergeSiganl = [RACSignal merge:@[siganlA,siganlB]]; [mergeSiganl subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125; 组合,只有两个信号都有值,才可以组合1234567891011121314151617181920- (void)demo8&#123; //定义2个自定义信号 RACSubject *letters = [RACSubject subject]; RACSubject *numbers = [RACSubject subject]; //组合信号 [[RACSignal combineLatest:@[letters,numbers] reduce:^(NSString *letter, NSString *number)&#123; return [letter stringByAppendingString:number]; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;]; //自己控制发生信号值 [letters sendNext:@&quot;A&quot;]; [letters sendNext:@&quot;B&quot;]; [numbers sendNext:@&quot;1&quot;]; //打印B1 [letters sendNext:@&quot;C&quot;];//打印C1 [numbers sendNext:@&quot;2&quot;];//打印C2&#125; 合流压缩12345678910111213141516171819202122- (void)demo9&#123; //创建信号A RACSignal *siganlA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;红&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //创建信号B RACSignal *siganlB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;白&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //合流后处理的是压缩包,需要解压后才能取到里面的值 [[siganlA zipWith:siganlB] subscribeNext:^(id x) &#123; //解压缩 RACTupleUnpack(NSString *stringA, NSString *stringB) = x; NSLog(@&quot;%@ %@&quot;,stringA, stringB); &#125;];&#125; 映射,我可以点石成金12345678910111213141516171819- (void)demo10&#123; RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:nil]; [subscriber sendCompleted]; return nil; &#125;]; //对信号进行改造,改&quot;石&quot;成&quot;金&quot; siganl = [siganl map:^id(NSString *value) &#123; if ([value isEqualToString:@&quot;石&quot;]) &#123; return @&quot;金&quot;; &#125; return value; &#125;]; //打印,不论信号发送的是什么,这一步都会走的 [siganl subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125; 过滤,未满18岁,禁止入内12345678910111213141516171819- (void)demo11&#123; RACSignal *singal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@(15)]; [subscriber sendNext:@(17)]; [subscriber sendNext:@(21)]; [subscriber sendNext:@(14)]; [subscriber sendNext:@(30)]; [subscriber sendCompleted]; return nil; &#125;]; //过滤信号,打印 [[singal filter:^BOOL(NSNumber *value) &#123; //大于18岁的,才可以通过 return value.integerValue &gt;= 18;//return为yes可以通过 &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125; 秩序(flattenMap 方法也可以换成 then 方法,效果一样)123456789101112131415161718192021222324252627282930313233-(void)demo12&#123; RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;打蛋液&quot;); [subscriber sendNext:@&quot;蛋液&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //对信号进行秩序秩序的第一步 siganl = [siganl flattenMap:^RACStream *(NSString *value) &#123; //处理上一步的RACSiganl的信号value.这里的value=@&quot;蛋液&quot; NSLog(@&quot;把%@倒进锅里面煎&quot;,value); return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;煎蛋&quot;]; [subscriber sendCompleted]; return nil; &#125;]; &#125;]; //对信号进行第二步处理 siganl = [siganl flattenMap:^RACStream *(id value) &#123; NSLog(@&quot;把%@装载盘里&quot;,value); return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;上菜&quot;]; [subscriber sendCompleted]; return nil; &#125;]; &#125;]; //最后打印 最后带有===上菜 [siganl subscribeNext:^(id x) &#123; NSLog(@&quot;====%@&quot;,x); &#125;];&#125; 命令12345678910111213-(void)demo13&#123; RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; //打印：今天我投降了 //命令执行代理 NSLog(@&quot;%@我投降了&quot;,input); //返回一个RACSignal信号 return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; return nil; &#125;]; &#125;]; //执行命令 [command execute:@&quot;今天&quot;];&#125; 延迟12345678910111213- (void)demo14&#123; RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;等等我,我还有10s就到了&quot;); [subscriber sendNext:@&quot;北极&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //延迟10s接受next的玻璃球 [[siganl delay:10] subscribeNext:^(id x) &#123; NSLog(@&quot;我到了%@&quot;,x); &#125;];&#125; 重放123456789101112131415161718- (void)demo15&#123; RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;电影&quot;); [subscriber sendNext:@&quot;电影&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //创建该普通信号的重复信号 RACSignal *replaySiganl = [siganl replay]; //重复接受信号 [replaySiganl subscribeNext:^(NSString *x) &#123; NSLog(@&quot;小米%@&quot;,x); &#125;]; [replaySiganl subscribeNext:^(NSString *x) &#123; NSLog(@&quot;小红%@&quot;,x); &#125;];&#125; 定时—每隔 8 小时服用一次药12345678- (void)demo16&#123; //创建定时器信号.定时8小时 RACSignal *siganl = [RACSignal interval:60 * 60 * 8 onScheduler:[RACScheduler mainThreadScheduler]]; //定时器执行代码 [siganl subscribeNext:^(id x) &#123; NSLog(@&quot;吃药&quot;); &#125;];&#125; 超时12345678910111213141516171819202122- (void)demo17&#123; RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;我快到了&quot;); RACSignal *sendSiganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:nil]; [subscriber sendCompleted]; return nil; &#125;]; //发生信号要1个小时10分钟才到 [[sendSiganl delay:60 * 70] subscribeNext:^(id x) &#123; //这里才发送next玻璃球到siganl [subscriber sendNext:@&quot;我到了&quot;]; [subscriber sendCompleted]; &#125;]; return nil; &#125;]; [[siganl timeout:60 * 60 onScheduler:[RACScheduler mainThreadScheduler]] subscribeNext:^(id x) &#123; NSLog(@&quot;等了你一个小时,你一直没来,我走了&quot;); &#125;];&#125; 重试12345678910111213141516171819202122- (void)demo18&#123; __block int failedCount = 0; //创建信号 RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; if (failedCount &lt; 100) &#123; failedCount ++; NSLog(@&quot;我失败了&quot;); [subscriber sendError:nil]; &#125;else&#123; NSLog(@&quot;经历了数百次后,我成功了&quot;); [subscriber sendNext:nil]; &#125; return nil; &#125;]; //重试 RACSignal *retrySiganl = [siganl retry]; //直到发生next的玻璃球 [retrySiganl subscribeNext:^(id x) &#123; NSLog(@&quot;重要成功了&quot;); &#125;];&#125; 节流,不好意思,这里每一秒只能通过一个人,如果 1s 内发生多个,只通过最后一个1234567891011121314151617181920212223242526272829- (void)demo19&#123; RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; //即使发送一个next的玻璃球 [subscriber sendNext:@&quot;A&quot;]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@&quot;B&quot;]; &#125;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@&quot;C&quot;]; [subscriber sendNext:@&quot;D&quot;]; [subscriber sendNext:@&quot;E&quot;]; &#125;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@&quot;F&quot;]; &#125;); return nil; &#125;]; //对信号进行节流,限制时间内一次只能通过一个玻璃球 [[signal throttle:1] subscribeNext:^(id x) &#123; NSLog(@&quot;%@通过了&quot;,x); &#125;]; /* [2015-08-16 22:08:45.677]旅客A [2015-08-16 22:08:46.737]旅客B [2015-08-16 22:08:47.822]旅客E [2015-08-16 22:08:48.920]旅客F */&#125; 条件(takeUntil 方法,当给定的 signal 完成前一直取值)1234567891011121314151617181920212223242526- (void)demo20&#123; RACSignal *takeSiganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; //创建一个定时器信号,每一秒触发一次 RACSignal *siganl = [RACSignal interval:1 onScheduler:[RACScheduler mainThreadScheduler]]; [siganl subscribeNext:^(id x) &#123; //在这里定时发送next玻璃球 [subscriber sendNext:@&quot;直到世界尽头&quot;]; &#125;]; return nil; &#125;]; //创建条件信号 RACSignal *conditionSiganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; //设置5s后发生complete玻璃球 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;世界的今天到了,请下车&quot;); [subscriber sendCompleted]; &#125;); return nil; &#125;]; //设置条件,takeSiganl信号在conditionSignal信号接收完成前,不断取值 [[takeSiganl takeUntil:conditionSiganl] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125; RACReplaySubject 使用12345678910111213141516171819202122232425/*** RACReplaySubject创建方法 1.创建RACSubject 2.订阅信号 3.发送信号 工作流程: 1.订阅信号,内部保存了订阅者,和订阅者相应的block 2.当发送信号的,遍历订阅者,调用订阅者的nextBlock 3.发送的信号会保存起来,当订阅者订阅信号的时候,会将之前保存的信号,一个个作用于新的订阅者,保存信号的容量由capacity决定,这也是有别于RACSubject的*/-(void)RACReplaySubject&#123; RACReplaySubject *replaySubject = [RACReplaySubject subject]; [replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot; 1 %@&quot;,x); &#125;]; [replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot;2 %@&quot;,x); &#125;]; [replaySubject sendNext:@7]; [replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot;3 %@&quot;,x); &#125;];&#125; rac_liftSelector:withSignals 使用12345678910111213141516171819//这里的rac_liftSelector:withSignals 就是干这件事的，它的意思是当signalA和signalB都至少sendNext过一次，接下来只要其中任意一个signal有了新的内容，doA:withB这个方法就会自动被触发-(void)test&#123; RACSignal *sigalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; double delayInSeconds = 2.0; dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds *NSEC_PER_SEC)); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(popTime * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@&quot;A&quot;]; &#125;); return nil; &#125;]; RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;B&quot;]; [subscriber sendNext:@&quot;Another B&quot;]; [subscriber sendCompleted]; return nil; &#125;]; [self rac_liftSelector:@selector(doA:withB:) withSignals:sigalA,signalB, nil];&#125; 来源：简书作者未魏雨辰 《iOS RAC的使用总结》","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/tags/Tips/"}]},{"title":"Swift 4.0 中对 Dictionary 的改进","slug":"Swift 4 Dictionary","date":"2018-03-13T13:56:27.000Z","updated":"2018-11-15T14:04:15.042Z","comments":true,"path":"2018/03/13/Swift 4 Dictionary/","link":"","permalink":"https://reversescale.github.io/2018/03/13/Swift 4 Dictionary/","excerpt":"Swift 4 发布已经有一段时间了，不知道大家有没有切换到 4.0 版本。 这次 4.0 更新给我最大的感受就是没有了前几次升级的跳跃式变化。 不用为了更新语言版本，完全推翻已有的项目，这也是 Swift 慢慢趋向于稳定的标志~","text":"Swift 4 发布已经有一段时间了，不知道大家有没有切换到 4.0 版本。 这次 4.0 更新给我最大的感受就是没有了前几次升级的跳跃式变化。 不用为了更新语言版本，完全推翻已有的项目，这也是 Swift 慢慢趋向于稳定的标志~ 咱们这次说说 Swift 4.0 对 Dictionary 这个经常会用到的类的改进。 自动根据 key 分组Dictionary 新增了一个构造方法，可以将给定的一个数组，根据指定的条件进行分组。 来看一个例子: 123456789struct Person &#123; var name: String var gender: Gender var age: Int enum Gender &#123; case male case female &#125;&#125; 这里有一个 Person 结构, 然后我们初始化一个数组： 12345let p1 = Person(name: \"aa\", gender: .female, age: 22)let p2 = Person(name: \"bb\", gender: .male, age: 24)let p3 = Person(name: \"cc\", gender: .male, age: 21)let persons = [p1, p2, p3] 现在用新的 Dictionary 构造方法，可以立即将这组 Person 实例根据他们的 gender 属性进行分组： 123let groupedDict = Dictionary(grouping: persons) &#123; p in return p.gender&#125; 这个构造方法，第一个参数 grouping 接收的是 persons 数组， 第二个参数是一个闭包，用于返回根据进行分组的依据，我们这里返回的是 p.gender。结果一目了然： 123456789[ .male: [ Person(name: \"bb\", gender: .male, age: 24), Person(name: \"cc\", gender: .male, age: 21) ], .female: [ Person(name: \"aa\", gender: .female, age: 22) ]] 以往要实现这样的功能，就需要手动遍历整个数组，取出 key， 然后生成字典， 现在方便很多。 value 无缝转换另外一个比较有用的特性是，Dictionary 提供的 mapValues 方法。 还以我们刚才生成的 groupedDict 为例，可以进行这样的操作： 123let count = groupedDict.mapValues &#123; persons in persons.count&#125; 先看一下输出，大家可能就猜到这个方法的用途是什么了： 1234[ .male: 2, .female: 1] 上面的输出可以看到， mapValues 会遍历每一个 key 对应的 values， 然后传递给闭包进行自定义转换。 我们例子中的闭包返回的就是每个 key 对应的 Person 集合的数量，最生成了一个新的 Dictionary，里面的 key 和之前一样，只是对应的值变成了我们闭包中自定义的了。 mapValues 方法同样是一个帮助我们解决繁杂操作的工具方法。 从键值对元组中直接构建假如我们有这样一个数组: 1let personsTuples = [(\"group 1\", [p1, p2]), (\"group 2\", [p3])] 然后可以调用 uniqueKeysWithValues 构造方法直接初始化字典： 1let dict = Dictionary(uniqueKeysWithValues: personsTuples) personsTuples 数组中，每一个元素都是一个元组(Tuple)， 这个构造方法把元组中的第一项当做 key， 第二项当做 value， 生成一个新的 Dictionary，如下所示： 123456789[ \"group 1\": [ Person(name: \"aa\", gender: .female, age: 22), Person(name: \"bb\", gender: .male, age: 24) ], \"group 2\": [ Person(name: \"cc\", gender: .male, age: 21) ]] 使用 uniqueKeysWithValues 构造方法时候需要注意，就是传入的数组中，不能有重复的 key， 否则会报运行时错误，比如这个数组就会报错： 1let personsTuples = [(\"group 1\", [p1, p2]), (\"group 2\", [p3]), (\"group 2\", [p4])] 上面数组中 group 2 出现了两次。 如果用它来初始化的话，就会出错。 所以 Swift 4.0 还提供了另外一个初始化方法， 对于上面这个数组，可以调用： 123let dict = Dictionary(personsTuples) &#123; old, new in return new&#125; 第二个闭包参数，会在遇到重复的 key 时候调用。 它提供两个参数，一个是同样这个 key 的上一个值 old， 还有当前的值 new。 我们这里直接返回 new，意思就是 每次遇到重复的 key， 就用新的值代替老的值。 这样初始化后，生成的 Dictionary 结构如下： 123456789[ \"group 1\": [ p1, p2 ], \"group 2\": [ p4 ]] group 2 中的值， 是第二次 key 所对应的 p4。 提供默认值如果我们访问了一个字典中不存在的 key， 会返回 nil： 1dict[\"group 3\"] 因为上面字典中，不存在 group 3 这个 key， 所以它返回了 nil。 Swift 4 中新增了指定默认值的能力： 1dict[\"group 3\", default: []] 这样调用，如果 group 3 这个 key 不存在的话， 就会返回我们指定的默认值空数组， 而不是 nil 了。 这个特性在我们处理 JSON 数据解析这类的问题上很实用。 过滤器过滤器对于集合类来说是比较常用的功能。 Swift 4 中对 Dictionary 类型也提供了过滤器的支持： 123let filteredDict = dict.filter &#123; key, val in return val.count &gt;= 2&#125; filter 方法接收一个闭包，它会遍历 Dictionary 中所有的元素，并且作为闭包的参数传入。 我们需要通过闭包的返回值确定这个元素是否被保留。 上面的例子中，比如我们 dict 中的元素是 ： 123456789[ \"group 1\": [ p1, p2 ], \"group 2\": [ p4 ]] 调用 filter 后，我们只保留数量大于 2 的集合： 123456[ \"group 1\": [ p1, p2 ]] 总结以上就是 Swift 4.0 对于 Dictionary 的主要改进。 这些新增的工具方法对于提高我们开发效率和代码质量都有帮助，希望这里的介绍对你有帮助。 关于 Dictionary 更完整的信息，大家还可以参考苹果官方的文档，还有 Swift Blog 中的介绍。 参考文献Dictionary 官方文档：https://developer.apple.com/documentation/swift/dictionarySwift Blog: https://swift.org/blog/dictionary-and-set-improvements/","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/tags/Tips/"}]},{"title":"使用 CocoaPods 对公有库开源和私有库组件","slug":"Open source library","date":"2018-03-12T13:56:27.000Z","updated":"2018-11-15T14:01:12.844Z","comments":true,"path":"2018/03/12/Open source library/","link":"","permalink":"https://reversescale.github.io/2018/03/12/Open source library/","excerpt":"最近在研究使用 CocoaPods 对 iOS 工程组件化，创建公有 Pod 库和私有 Pod 库方法，为了方便整理和学习就整理了这篇文章~","text":"最近在研究使用 CocoaPods 对 iOS 工程组件化，创建公有 Pod 库和私有 Pod 库方法，为了方便整理和学习就整理了这篇文章~ 创建公有 Pod 库或者私有 Pod 库，实际上原理是一样的，都是基于 git 服务和 repo 协议，不一样的是，两者的版本索引查询方式不一样，公有库的 podspec 由 CocoaPods/Specs 管理，而内部私有使用的 pod 库需要自己建立一个仓库来管理 podspec。 实用：开源公有库例子: 我有封装过一个工具CollectionIndexTools，CollectionIndexTools 可以给 Collection 添加一个类似 TableView 右侧的索引条，我想通过 Podfile 中添加 pod ‘CollectionIndexToolsLib’ 即可使用. 注册 CocoaPods 账户信息想要创建一个开源 pod 库，首先我们需要注册 CocoaPods, 这里使用 trunk 方式，作为一个 iOS 开发人员你一定安装了 CocoaPods，那么只需要在终端执行： 1pod trunk register 邮箱地址 &apos;用户名&apos; --verbose 这里我们一般使用 Github 邮箱和用户名，然后在你的邮箱中会收到确认邮件，在浏览器中点击链接确认即注册成功，成功之后可以终端执行： 1pod trunk me 查看自己的注册信息，以后当你有了自己的开源Pod库，也可以用此方式随时查看自己发布过的Pods： 创建共享库文件并上传到公有仓库共享库需要三个必不可少的部分: 1.共享文件夹(文件夹存放着你要共享的内容, 也就是其他人pod得到的文件, .podspec文件中的source_files需要指定此文件路径及文件类型); 2.LICENSE文件(默认一般选择MIT); 3.库描述文件.podspec(本库的各项信息描述, 需要提交给CocoaPods, pod通过这个文件查找到你共享的库, .podspec文件的格式见第3点). 这一步分两种场景: 场景一：如果你已经有了现成的想要共享的文件,你只需要满足上面三个部分,即可上传到公有仓库即可继续其他的步骤; 场景二：你想要创建一个全新的工程去做自己的共享, 可以使用终端命令: 1pod lib create CollectionIndexToolsLib 需要输入一些模板参数： Cocoapods 会自动生成一个模板项目，目录结构： 123456789101112131415CollectionIndexToolsLib├── Example #demo APP│ ├── CollectionIndexToolsLib│ ├── CollectionIndexToolsLib.xcodeproj│ ├── CollectionIndexToolsLib.xcworkspace│ ├── Podfile #demo APP 的依赖描述文件│ ├── Podfile.lock│ ├── Pods #demo APP 的依赖文件│ └── Tests├── LICENSE #开源协议 默认MIT├── Pod #组件的目录│ ├── Assets #资源文件│ └── Classes #类文件├── PodCollectionIndexToolsLib.podspec #第三步要创建的podspec文件└── README.md #markdown格式的README 编辑.podspec文件以CollectionIndexToolsLib.podspec为例:123456789101112131415161718192021Pod::Spec.new do |s| s.name = 'CollectionIndexToolsLib' s.version = '0.1.0' s.summary = 'Custom IndexTools similar to TableViews index bar' s.description = &lt;&lt;-DESC I believe you must have thought about adding an index like Table View to Collection View. I will give you one today. DESC s.homepage = 'https://github.com/ReverseScale/CollectionIndexToolsLib' s.license = 'MIT' s.author = &#123; 'ReverseScale' =&gt; 'reversescale@icloud.com' &#125; s.source = &#123; :git =&gt; 'https://github.com/ReverseScale/CollectionIndexToolsLib.git', :tag =&gt; s.version.to_s &#125; s.ios.deployment_target = '8.0' s.source_files = 'CollectionIndexToolsLib/Classes/**/*' s.requires_arc = trueend 理论上前面的设置就可以通过验证，下面是注释参照：1234567891011121314151617181920212223242526272829Pod::Spec.new do |s| s.name = \"PodTestLibrary\" #名称 s.version = \"0.1.0\" #版本号 s.summary = \"Just Testing.\" #简短介绍，下面是详细介绍 s.description = &lt;&lt;-DESC Testing Private Podspec. * Markdown format. * Don't worry about the indent, we strip it! DESC s.homepage = \"https://coding.net/u/wtlucky/p/podTestLibrary\" #主页,这里要填写可以访问到的地址，不然验证不通过 # s.screenshots = \"www.example.com/screenshots_1\", \"www.example.com/screenshots_2\" #截图 s.license = 'MIT' #开源协议 s.author = &#123; \"wtlucky\" =&gt; \"wtlucky@foxmail.com\" &#125; #作者信息 s.source = &#123; :git =&gt; \"https://coding.net/wtlucky/podTestLibrary.git\", :tag =&gt; \"0.1.0\" &#125; #项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS # s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;' #多媒体介绍地址 s.platform = :ios, '7.0' #支持的平台及版本 s.requires_arc = true #是否使用ARC，如果指定具体文件，则具体的问题使用ARC s.source_files = 'Pod/Classes/**/*' #代码源文件地址，**/*表示Classes目录及其子目录下所有文件，如果有多个目录下则用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置 s.resource_bundles = &#123; 'PodTestLibrary' =&gt; ['Pod/Assets/*.png'] &#125; #资源文件地址 s.public_header_files = 'Pod/Classes/**/*.h' #公开头文件地址 s.frameworks = 'UIKit' #所需的framework，多个用逗号隔开 s.dependency 'AFNetworking', '~&gt; 2.3' #依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependencyend 编写完成后, 我们需要验证.podspec文件的合法性, 这里需要终端cd到.podspec文件所在文件夹, 执行:忽视警告：–allow-warnings 1pod lib lint CollectionIndexToolsLib.podspec 如有警告或者错误请重新检查你的编写正确性，如果没有问题会出现： 123-&gt; CollectionIndexToolsLib (0.1.0)CollectionIndexToolsLib passed validation. 打tag, 发布一个release版本一切准备就绪后, 我们需要在你的git仓库里面存在一个与.podspec文件中一致的version, 这里你可以在你的git仓库中的releases一项去手动发布, 也可以在当前文件夹下使用终端命令: 12git tag -m &apos;🔖:Releasing tags.&apos; &apos;0.1.0&apos;git push --tag #推送tag到远端仓库 成功之后即可在你的 releases 里面看到这个 tag 的版本. 发布自己的库描述文件podspec给cocoapods同样在这个文件夹下, 终端执行:忽视警告：–allow-warnings 1pod trunk push CollectionIndexToolsLib.podspec 将你的库文件.podspec文件提交到公有的specs上面, 这一步做的操作是验证你的podspec文件是否合法+提交到specs中(等同于fork;commit;push)+将上传的podspec文件转成json格式文件)，成功后会出现Congrats信息。 成功上传后等待片刻就可以用查找命令找到你的库： 1pod search CollectionIndexToolsLib 日后维护更新开源库如果有错误或者需要迭代版本,修改工程文件后推送到远端仓库后, 需要修改podspec中的版本号, 并重新打tag上传, 再进行新一轮的验证和发布.如果在开发过程中发现某基础组件存在 bug 需要更新 Pod，具体操作步骤如下： 修改 podspec 文件中的 s.version; 修复 bug 并对项目打 tag，tag 名称和 s.version 一直并 push 到远程仓库。 验证 podspec 文件的有效性； 推送 podspec 文件到远程仓库； 执行 pod search RRCache 验证结果； 实用：组件化私有库组件化的实用之处请参考《移动端 iOS 年终工作总结-纯干货请自备酒水》（https://juejin.im/post/5a934dfa6fb9a0634514d8a9） 私有Pod库和公有Pod库的创建方式没有什么区别, 不一样的是管理他们的 spec repo 不一样. 所以我们需要自己创建一个跟CocoaPods/Specs类似的仓库来管理内部创建的Pod库的podspec文件, 供内部人员更新和依赖使用内部Pod组件库. 私有repo的构建形式有两种, 一种是私有git服务器上面创建，一种是本机创建. 本机创建请参考官方文档:Private Pods, 这里介绍的是在公司内部搭建的git服务器上面创建整个服务的方式. 创建一个git仓库用来做内部私有库的Spec Repo在私有服务器一个仓库,一个用来存放所有共享库的podspec, 这里创建好之后的内部SSH协议地址是:https://gitee.com/WhatsXie/LibComponent.git, 花钱买git的私有仓库或者使用其他免费的第三方git服务(如Bitbucket等)创建的私有仓库给到的http/https地址也一样.终端输入命令:1pod repo add LibComponent https://gitee.com/WhatsXie/LibComponent.git 将LibComponent添加到本地repo, 添加成功后可以在/.cocoapods/repos/目录下可以看到官方的specs:master和刚刚加入的specs:LibComponent 如果有其他合作人员共同使用这个私有Spec Repo的话在他有对应Git仓库的权限的前提下执行相同的命令添加这个Spec Repo即可. 创建私有Pod组件库继续创建一个私有仓库,用来建立需要共享的内部组件, 以RSGuidePageLib为例:https://gitee.com/WhatsXie/RSGuidePageLib.git 可以创建示例工程, 像创建公有的库一样, 填写自己的podspec文件 1234567891011121314151617181920212223242526272829Pod::Spec.new do |s|s.name = 'RSGuidePageLib's.version = '0.3.0's.summary = 'Custom guide page package's.description = &lt;&lt;-DESCSwift implementation of the guide page package, support for multiple pictures and video guide pageDESCs.homepage = 'https://gitee.com/WhatsXie/RSGuidePageLib.git's.license = &#123; :type =&gt; 'MIT', :file =&gt; 'LICENSE' &#125;s.author = &#123; 'ReverseScale@icloud.com' =&gt; 'reversescale' &#125;s.source = &#123; :git =&gt; 'https://gitee.com/WhatsXie/RSGuidePageLib.git', :tag =&gt; s.version.to_s &#125;s.ios.deployment_target = '8.0's.swift_version = '3.2's.source_files = 'RSGuidePageLib/Classes/**/*'s.requires_arc = true 值得注意的是:podspec文件中的homepage和source不支持ssh协议地址,所以我们得放入http/https地址. 与公有库的创建方式一样, pod lib lint Category.podspec验证成功之后push到仓库, 然后打tag发布release版本. 然后将podspec加入私有Sepc repo中公有库使用trunk方式将.podspec文件发布到CocoaPods/Specs, 内部的pod组件库则是添加到我们第一步创建的私有Spec repo中去, 在终端执行:–allow-warnings 忽略警告–private 私有库 1pod repo push LibComponent RSGuidePageLib.podspec 添加成功之后LibComponent中会包含RSGuidePageLib库的podspec信息, 可以前往~/.cocoapods/repos下的LibComponent文件夹中查看, 同时git服务器中的远端也更新了. 移除私有Repo 1pod repo remove [name] 查找和使用内部组件库执行pod search Category就能查到刚刚创建好的Category库了, 然后在想要使用此组件的工程的Podfile中加入pod ‘Category’, ‘~&gt;1.0.1’即可使用内部组件啦！ 值得注意的是:必须在Podfile前面需要添加你的私有Spec repo的git地址source, pod install时, 才能在私有repo中查找到私有库, 像这样: 1234567891011# Uncomment the next line to define a global platform for your projectsource &apos;https://github.com/CocoaPods/Specs.git&apos;source &apos;https://gitee.com/WhatsXie/LibComponent.git&apos;# platform :ios, &apos;9.0&apos;target &apos;Demo&apos; dopod &apos;RSGuidePageLib&apos;, &apos;~&gt;0.3.0’end 经过测试, 这种方式可以把你的所有可以拆分出来的组件, 甚至是业务都来使用Pod管理, 这样达到了解耦和单项更新优化。某些组件不影响老版本的依赖使用, 出现问题修改Podfile中的依赖版本即可随时回滚, 给开发了带来极大的便利。 参考链接: CocoaPods创建公有和私有Pod库方法总结（https://www.aliyun.com/jiaocheng/376300.html） CocoaPods Guides(https://guides.cocoapods.org) Private Pods(https://guides.cocoapods.org/making/private-cocoapods.html) 手把手教你发布代码到CocoaPods(Trunk方式)(http://www.cnblogs.com/wengzilin/p/4742530.html) 使用Cocoapods创建私有podspec(http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/) COCOAPODS创建私有PODS(http://www.cnblogs.com/tufeibo/p/5654268.html) CocoaPods 组件化实践 - 私有Pod(https://www.jianshu.com/p/475d6b6d5600)","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/tags/Tips/"}]},{"title":"Swift 4.0 新特征汇总及演示附 Demo","slug":"Swift 4 New feature","date":"2018-03-09T13:16:27.000Z","updated":"2018-11-15T15:01:55.488Z","comments":true,"path":"2018/03/09/Swift 4 New feature/","link":"","permalink":"https://reversescale.github.io/2018/03/09/Swift 4 New feature/","excerpt":"Swift 在不断的版本迭代中，由于其 ABI 尚不稳定，所以给开发者带来许多的挑战，但也正因为如此，这门语言才有无限可能~","text":"Swift 在不断的版本迭代中，由于其 ABI 尚不稳定，所以给开发者带来许多的挑战，但也正因为如此，这门语言才有无限可能~ 👨🏻‍💻 Github Demo Key Paths 新语法key-path 通常是用在键值编码（KVC）与键值观察（KVO）上的，KVC、KVO 相关内容可以参考我之前写的这篇文章：Swift - 反射（Reflection）的介绍与使用样例（附KVC介绍） 1.Swift 3 之前使用的是 String 类型的 key-Path1234567891011121314151617//用户类class User: NSObject&#123; @objc var name:String = &quot;&quot; //姓名 @objc var age:Int = 0 //年龄&#125; //创建一个User实例对象let user1 = User()user1.name = &quot;hangge&quot;user1.age = 100 //使用KVC取值let name = user1.value(forKey: &quot;name&quot;)print(name) //使用KVC赋值user1.setValue(&quot;hangge.com&quot;, forKey: &quot;name&quot;) 具体显示如下： 2.到了 Swift 3 新增了 #keyPath() 写法使用 #keyPath() 写法，可以避免我们因为拼写错误而引发问题。1234567891011121314151617//用户类class User: NSObject&#123; @objc var name:String = &quot;&quot; //姓名 @objc var age:Int = 0 //年龄&#125; //创建一个User实例对象let user1 = User()user1.name = &quot;hangge&quot;user1.age = 100 //使用KVC取值let name = user1.value(forKeyPath: #keyPath(User.name))print(name) //使用KVC赋值user1.setValue(&quot;hangge.com&quot;, forKeyPath: #keyPath(User.name)) 3.Swift 4 中直接用 \\ 作为开头创建 KeyPath新的方式不仅使用更加简单，而且有如下优点： 类型可以定义为 class、struct 定义类型时无需加上 @objc 等关键字 性能更好 类型安全和类型推断，例如：user1.value(forKeyPath: #keyPath(User.name)) 返回的类型是 Any，user1[keyPath: \\User.name] 直接返回 String 类型 可以在所有值类型上使用（1）比如上面的样例在 Swift4 中可以这么写：1234567891011121314151617//用户类class User: NSObject&#123; var name:String = &quot;&quot; //姓名 var age:Int = 0 //年龄&#125; //创建一个User实例对象let user1 = User()user1.name = &quot;hangge&quot;user1.age = 100 //使用KVC取值let name = user1[keyPath: \\User.name]print(name) //使用KVC赋值user1[keyPath: \\User.name] = &quot;hangge.com&quot; （2）keyPath 定义在外面也是可以的：123456let keyPath = \\User.name let name = user1[keyPath: keyPath]print(name) user1[keyPath: keyPath] = &quot;hangge.com&quot; （3）可以使用 appending 方法向已定义的 Key Path 基础上填加新的 Key Path。12let keyPath1 = \\User.phonelet keyPath2 = keyPath1.appending(path: \\.number) 类与协议的组合类型在 Swift 4 中，可以把类（Class）和协议（Protocol）用 &amp; 组合在一起作为一个类型使用。 使用样例1：12345678910111213protocol MyProtocol &#123; &#125; class View &#123; &#125; class ViewSubclass: View, MyProtocol &#123; &#125; class MyClass &#123; var delegate: (View &amp; MyProtocol)?&#125; let myClass = MyClass()myClass.delegate = ViewSubclass() //这个编译正常myClass.delegate = View() //这个编译报错: 具体错误信息如下： 使用样例2：123456789101112131415161718192021protocol Shakeable &#123; func shake()&#125; extension UIButton: Shakeable &#123; func shake() &#123; /* ... */ &#125;&#125; extension UISlider: Shakeable &#123; func shake() &#123; /* ... */ &#125;&#125; func shakeEm(controls: [UIControl &amp; Shakeable]) &#123; for control in controls where control.isEnabled &#123; control.shake() &#125;&#125; 下标支持泛型1.下标的返回类型支持泛型有时候我们会写一些数据容器，Swift 支持通过下标来读写容器中的数据。但是如果容器类中的数据类型定义为泛型，过去下标语法就只能返回 Any，在取出值后需要用 as? 来转换类型。现在 Swift 4 定义下标也可以使用泛型了。12345678910111213141516171819202122struct GenericDictionary&lt;Key: Hashable, Value&gt; &#123; private var data: [Key: Value] init(data: [Key: Value]) &#123; self.data = data &#125; subscript&lt;T&gt;(key: Key) -&gt; T? &#123; return data[key] as? T &#125;&#125; //字典类型: [String: Any]let earthData = GenericDictionary(data: [&quot;name&quot;: &quot;Earth&quot;, &quot;population&quot;: 7500000000, &quot;moons&quot;: 1]) //自动转换类型，不需要在写 &quot;as? String&quot;let name: String? = earthData[&quot;name&quot;]print(name) //自动转换类型，不需要在写 &quot;as? Int&quot;let population: Int? = earthData[&quot;population&quot;]print(population) 2.下标类型同样支持泛型12345678910111213141516extension GenericDictionary &#123; subscript&lt;Keys: Sequence&gt;(keys: Keys) -&gt; [Value] where Keys.Iterator.Element == Key &#123; var values: [Value] = [] for key in keys &#123; if let value = data[key] &#123; values.append(value) &#125; &#125; return values &#125;&#125; // Array下标let nameAndMoons = earthData[[&quot;moons&quot;, &quot;name&quot;]] // [1, &quot;Earth&quot;]// Set下标let nameAndMoons2 = earthData[Set([&quot;moons&quot;, &quot;name&quot;])] // [1, &quot;Earth&quot;] Codable 序列化如果要将一个对象持久化，需要把这个对象序列化。过去的做法是实现 NSCoding 协议，但实现 NSCoding 协议的代码写起来很繁琐，尤其是当属性非常多的时候。Swift 4 中引入了 Codable 协议，可以大大减轻了我们的工作量。我们只需要让需要序列化的对象符合 Codable 协议即可，不用再写任何其他的代码。1234struct Language: Codable &#123; var name: String var version: Int&#125; 1.Encode 操作我们可以直接把符合了 Codable 协议的对象 encode 成 JSON 或者 PropertyList。12345678let swift = Language(name: &quot;Swift&quot;, version: 4) //encoded对象let encodedData = try JSONEncoder().encode(swift) //从encoded对象获取Stringlet jsonString = String(data: encodedData, encoding: .utf8)print(jsonString) 2.Decode 操作12let decodedData = try JSONDecoder().decode(Language.self, from: encodedData)print(decodedData.name, decodedData.version) SubtringSwift 4 中有一个很大的变化就是 String 可以当做 Collection 来用，并不是因为 String 实现了 Collection 协议，而是 String 本身增加了很多 Collection 协议中的方法，使得 String 在使用时看上去就是个 Collection。1234567let str = &quot;hangge.com&quot; print(str.prefix(5)) // &quot;hangg&quot;print(str.suffix(5)) // &quot;e.com&quot; print(str.dropFirst()) // &quot;angge.com&quot;print(str.dropLast()) // &quot;hangge.co&quot; 比如上面的样例，我们使用一些 Collection 协议的方法对字符串进行截取，只不过它们的返回结果不是 String 类型，而是 Swift 4 新增的 Substring 类型。 1.为何要引入 Substring？既然我们想要的到的就是字符串，那么直接返回 String 就好了，为什么还要多此一举返回 Substring。原因只有一个：性能。具体可以参考下图：当我们用一些 Collection 的方式得到 String 里的一部分时，创建的都是 Substring。Substring 与原 String 是共享一个 Storage。这意味我们在操作这个部分的时候，是不需要频繁的去创建内存，从而使得 Swift 4 的 String 相关操作可以获取比较高的性能。而当我们显式地将 Substring 转成 String 的时候，才会 Copy 一份 String 到新的内存空间来，这时新的 String 和之前的 String 就没有关系了。 2.使用 Substring 的注意事项由于 Substring 与原 String 是共享存储空间的，只要我们使用了 Substring，原 String 就会存在内存空间中。只有 Substring 被释放以后，整个 String 才会被释放。而且 Substring 类型无法直接赋值给需要 String 类型的地方，我们必须用 String() 包一层。当然这时系统就会通过复制创建出一个新的字符串对象，之后原字符串就会被释放。 3.使用样例这里对 String 进行扩展，新增一个 subString 方法。直接可以根据起始位置（Int 类型）和需要的长度（Int 类型），来截取出子字符串。123456789101112extension String &#123; //根据开始位置和长度截取字符串 func subString(start:Int, length:Int = -1) -&gt; String &#123; var len = length if len == -1 &#123; len = self.count - start &#125; let st = self.index(startIndex, offsetBy:start) let en = self.index(st, offsetBy:len) return String(self[st ..&lt; en]) &#125;&#125; 使用样例：1234let str1 = &quot;欢迎访问hangge.com&quot;let str2 = str1.subString(start: 4, length: 6)print(&quot;原字符串：\\(str1)&quot;)print(&quot;截取出的字符串：\\(str2)&quot;) 运行结果如下： 注意：这个方法最后我们会将 Substring 显式地转成 String 再返回。 废除 swap 方法（1）过去我们会使用 swap(_:_:) 来将两个变量的值进行交换：1234var a = 1var b = 2swap(&amp;a, &amp;b)print(a, b) （2）后面 swap() 方法将会被废弃，建议使用 tuple（元组）特性来实现值交换，也只需要一句话就能实现：1234var a = 1var b = 2(b, a) = (a, b)print(a, b) 使用 tuple 方式的好处是，多个变量值也可以一起进行交换：12345var a = 1var b = 2var c = 3(a, b, c) = (b, c, a)print(a, b, c) （3）补充一下：现在数组增加了个 swapAt 方法可以实现两个元素的位置交换。1234var fruits = [&quot;apple&quot;, &quot;pear&quot;, &quot;grape&quot;, &quot;banana&quot;]//交换元素位置（第2个和第3个元素位置进行交换）fruits.swapAt(1, 2)print(fruits) 减少隐式 @objc 自动推断1.过去的情况（Swift 3）（1）在项目中如果想把 Swift 写的 API 暴露给 Objective-C 调用，需要增加 @objc。在 Swift 3 中，编译器会在很多地方为我们隐式的加上 @objc。（2）比如当一个类继承于 NSObject，那么这个类的所有方法都会被隐式的加上 @objc。1234class MyClass: NSObject &#123; func print() &#123; &#125; // 包含隐式的 @objc func show() &#123; &#125; // 包含隐式的 @objc&#125; （3）但这样做很多并不需要暴露给 Objective-C 也被加上了 @objc。而大量 @objc 会导致二进制文件大小的增加。 2.现在的情况（Swift 4）（1）在 Swift 4 中隐式 @objc 自动推断只会发生在下面这种必须要使用 @objc 的情况： 覆盖父类的 Objective-C 方法 符合一个 Objective-C 的协议 （2）大多数地方必须手工显示地加上 @objc。1234class MyClass: NSObject &#123; @objc func print() &#123; &#125; //显示的加上 @objc @objc func show() &#123; &#125; //显示的加上 @objc&#125; （3）如果在类前加上 @objcMembers，那么它、它的子类、扩展里的方法都会隐式的加上 @objc。123456789@objcMembersclass MyClass: NSObject &#123; func print() &#123; &#125; //包含隐式的 @objc func show() &#123; &#125; //包含隐式的 @objc&#125; extension MyClass &#123; func baz() &#123; &#125; //包含隐式的 @objc&#125; （4）如果在扩展（extension）前加上 @objc，那么该扩展里的方法都会隐式的加上 @objc。123456class SwiftClass &#123; &#125; @objc extension SwiftClass &#123; func foo() &#123; &#125; //包含隐式的 @objc func bar() &#123; &#125; //包含隐式的 @objc&#125; （5）如果在扩展（extension）前加上 @nonobjc，那么该扩展里的方法都不会隐式的加上 @objc。12345678@objcMembersclass MyClass : NSObject &#123; func wibble() &#123; &#125; //包含隐式的 @objc&#125; @nonobjc extension MyClass &#123; func wobble() &#123; &#125; //不会包含隐式的 @objc&#125;","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/tags/Project/"}]},{"title":"移动端 iOS 年终工作总结 - 纯干货请自备酒水","slug":"iOS 2017","date":"2018-02-26T15:56:27.000Z","updated":"2018-11-15T15:29:48.050Z","comments":true,"path":"2018/02/26/iOS 2017/","link":"","permalink":"https://reversescale.github.io/2018/02/26/iOS 2017/","excerpt":"时间匆匆，一转眼 2017 年已经过去了，这一年依旧在不断学习，厚积而薄发~","text":"时间匆匆，一转眼 2017 年已经过去了，这一年依旧在不断学习，厚积而薄发~ 主题：发展 内容大纲观点： Swift 发展观 ReactNative 发展观 进阶： 模块化 Pods 依赖库及组件化 环境自动切换 + 自动化打包测试 + 线上质量监控 管理： 团队核心组成架构 硬件设备投入 例会和文档化 组织 CodeReview 工具： Gitlab 及 Git 相关规范 Sketch 设计工具 + Zeplin 标注工具 成果： Github 原创开源项目 90+，共计 400+ 贡献力 参与维护开源项目 fastlane 20.5k（至2018.02.08） 完成 Swifter 功能展示应用研发 观点Swift 发展观Apple 在 WWDC 2017 大会上发布 Swift 4，Swift 4 带来了更快、更容易使用的 String 实现，可以保持 Unicode 的正确性，并增加对创建、使用广告管理子串的支持，它提高了开发者创建、使用和管理集合类型的能力，它支持结构化枚举类型的归档并允许对外部格式进行类型安全的序列化，包括 JSON 和 plist。 既然提到了 WWDC（https://developer.apple.com/wwdc/），相信 Swift 的发展观就没有太多争议了，近几年所有的官方演示视频都是基于 Swift 来演示的，作为 iOS 的开发人员可能会继续使用 Objective-C，但是如果对 Swift 是持抗拒心理的，那无疑对自身发展是不负责任的。 Apple 于 2017 年宣布 Swift 5 后会锁定 ABI，也就标志着这门语言会正式作为 iOS、macOS 的主流语言。同年 12 月，Apple 宣布会着手计划 iOS 和 macOS 的应用层面合并。配合 Apple 一直以来的对 Swift 幼儿教育以及在 AI、AR 等领域的推进，不难看出这门语言未来的发展潜力。 ReactNative 发展观提到 ReactNative 就不得不说 FaceBook，其实现在主流的移动端开发规范就是这家公司设计的。当然除了 React 社区生态圈的加持和 Facebook 的大力推广以外，另外一个最主要的原因就是其在开发效率和应用性能方面取得了一个比较好的平衡： 开发效率通过 JS 工程实践，逻辑跨平台复用得到极大提升 性能则通过全 Native 的 UI 层得到满足 跨平台这一特性对于小公司的吸引力则更体现在节约用人成本上，对简单的需求能做到一端多用，随时变更线上内容。 对于已经正在运营的项目，完全切 ReactNative 总是不太现实，其实大多数厂商的方法是对运营引流有影响的关键性页面（如：首页）进行 ReactNative 改版，这里可能就会引入一个 模块化 的概念，后面会有讲到。 对于想要入门的朋友，慕课网上一个入门级 ReactNative 教学还不错。 教学视频：http://coding.imooc.com/class/89.html 源码：https://github.com/crazycodeboy/GitHubPopular/ 进阶模块化模块化、组件化我后半年一直在调研的课题，对这些的研究也给我带来了从量变到质变的提升。 什么是模块化？ 那么什么是模块化呢？《 Java 应用架构设计：模块化模式与 OSGi 》一书中对它的定义是：模块化是一种处理复杂系统分解为更好的可管理模块的方式。 我们可以把软件看做是一辆汽车，开发一款软件的过程就是生产一辆汽车的过程。一辆汽车由车架、发动机、变数箱、车轮等一系列模块组成；同样，一款大型商业软件也是由各个不同的模块组成的。 汽车的这些模块是由不同的工厂生产的，一辆 BMW 的发动机可能是由位于德国的工厂生产的，它的自动变数箱可能是 Jatco（世界三大变速箱厂商之一）位于日本的工厂生产的，车轮可能是中国的工厂生产的，最后交给华晨宝马的工厂统一组装成一辆完整的汽车。这就类似于我们在软件工程领域里说的多团队并行开发，最后将各个团队开发的模块统一打包成我们可使用的 App 。 一款发动机、一款变数箱都不可能只应用于一个车型，比如同一款 Jatco 的 6AT 自动变速箱既可能被安装在 BMW 的车型上，也可能被安装在 Mazda 的车型上。这就如同软件开发领域里的模块重用。 到了冬天，特别是在北方我们可能需要开着车走雪路，为了安全起见往往我们会将汽车的公路胎升级为雪地胎；轮胎可以很轻易的更换，这就是我们在软件开发领域谈到的低耦合。一个模块的升级替换不会影响到其它模块，也不会受其它模块的限制；同时这也类似于我们在软件开发领域提到的可插拔。 20180906 更新 再谈模块化、组件化、插件化定义 模块化：一个可实现的单元，核心是内聚和分离，如登录模块的抽离 组件化：也称构件，最理想情况下是与业务无关，强调复用，如可复用 Library 插件化：与组件化不同，组件化在编译时合并模块，插件化在运行时合并模块，如可实现远程替换功能 模块化分层设计 上面的类比很清晰的说明的模块化带来的好处： 多团队并行开发测试； 模块间解耦、重用； 可单独编译打包某一模块，提升开发效率。 在《安居客 Android 项目架构演进》这篇文章中，作者介绍了安居客 Android 端的模块化设计方案，这里作者还是拿它来举例。但首先要对本文中的组件和模块做个区别定义： 组件：指的是单一的功能组件，如地图组件（MapSDK）、支付组件（AnjukePay）、路由组件（Router）等等； 模块：指的是独立的业务模块，如新房模块（NewHouseModule）、二手房模块（SecondHouseModule）、即时通讯模块（InstantMessagingModule）等等；模块相对于组件来说粒度更大。 针对模块化作者的团队也定义了一些自己的游戏规则: 对于 Business Module Layer，各业务模块之间不允许存在相互依赖关系，它们之间的跳转通讯采用路由框架 Router 来实现（后面会介绍 Router 框架的实现）; 对于 Business Component Layer，单一业务组件只能对应某一项具体的业务，个性化需求对外部提供接口让调用方定制; 合理控制各组件和各业务模块的拆分粒度，太小的公有模块不足以构成单独组件或者模块的，作者先放到类似于 CommonBusiness 的组件中，在后期不断的重构迭代中视情况进行进一步的拆分; 上层的公有业务或者功能模块可以逐步下放到下层，合理把握好度就好； 各 Layer 间严禁反向依赖，横向依赖关系由各业务 Leader 和技术小组商讨决定。 自从 Oasis Feng 在去年的 MDCC2016 上分享了模块化的经验后，模块化在 Android 社区越来越多的被提起。作者自然也不落俗的去做了一些研究和探索。安居客现在面临很多问题：例如全量编译时间太长（我这台13款的 MacBook Pro 上打一次包得花十多分钟）；例如新房、二手房、租房等等模块间耦合严重，不利于多团队并行开发测试；另外在17年初安居客重新将租房 App 捡起推广，单独让人来开发维护一个三年前的项目并不划算，所以作者希望能直接从现在的安居客用户端中拆分出租房模块作为一个单独的 App 发布上线。这样看来模块化似乎是一个不错的选择。 所以作者做模块化的目的大致是这样的： 业务模块间解耦 单个业务模块单独编译打包，加快编译速度 多团队间并行开发、测试 解决好租App需要单独维护的问题，降低研发成本 关于模块化组件化的生动解读来自安居客 Android 组组长张磊的博客 http://baronzhang.com Pods 依赖库及组件化组件化与模块化安居客的 Android 团队内部成立了技术小组，基础组件的开发是技术小组很重要的一部分工作；模块化更多的是现有的方案受到来自业务上的挑战以及受到了 Oasis Feng 在 MDCC 上的分享和整个大环境的启发，现在正处于设计规划和 Demo 开发的阶段。 组件化组件化不是个新概念，通俗的讲组件化就是基于可重用的目的，将一个大的软件系统拆分成一个个独立组件。 组件化的带来的好处不言而喻： 避免重复造轮子，节省开发维护成本； 降低项目复杂性，提升开发效率； 多个团队公用同一个组件，在一定层度上确保了技术方案的统一性。 现在的安居客有是三个业务团队：安居客用户 App、经纪人 App、集客家 App。为了避免各个业务团队重复造轮子，团队中也需要有一定的技术沉淀，因此组件化是必须的。现在我们需要提供更多的、职能单一、性能更优的组件供业务团队使用。根据业务相关性，我们将这些组件分为：基础组件和业务组件。 阿里架构组同样是组件化的先驱者，以下是阿里架构组 Evans 对组件化的观点： 首先，我的理解分块化应该是有四种，组件化+模块化+插件化+解耦 第一，组件和组件其实是没有什么鬼明确的约束 ，因为组件一般都是单独开发、单独测试，不能直接放到主项目中开发，测试也是单独针对性的测试 （里面涉及到短链+组件的生命周期+….） 第二，模块化我的理解是，怎么做好project的模块化的拆分，我们内部一直在说越底层的模块，应该越稳定，越抽象，越具有高复用度，但是其实有一个壁垒就是怎么去提升模块的复用度，怎么去快速具备复用性高于代码复用性，这我们就要做好每个模块只做好一件事情，模块化结构要更加清晰，每个模块都只做一件事情，具有良好的延展性和拓展性，但愿不要出现下层模块依赖上层模块的现象，业务模块之间也尽量不要耦合。好处是同样的功能模块，可以在多个app中复用，业务隔离了跨团队开发代码控制和版本风险都变小了。 第三，解耦其实理解很简单就是在基于模块设计原则上, 让模块之间没有循环依赖, 让业务模块之间解除依赖，不相互调用。 概况的理解就是 组件化：单独开发、测试、维护的开发模式 模块化：对 Project 进行拆分，根据业务、功能进行分类 解耦：模块设计原则上, 让模块之间没有非必要依赖 而组件化现在主流的做法是通过 CocoaPods 对要包装的内容进行打包，提交到公司的私有库（开源项目是公有库），进行日常维护及开发。 环境自动切换 + 自动化打包测试 + 线上质量监控环境自动切换 Debug 和 Release 仅仅是编译选项的不同，那么为什么要区分 Debug 和 Release 版本呢？ Debug 和 Release，主要是针对其面向的目标不同的而进行区分的。 Debug 通常称为调试版本，通过一系列编译选项的配合，编译的结果通常包含调试信息，而且不做任何优化，为开发人员提供强大的应用程序调试能力。 而 Release 通常称为发布版本，是为用户使用的，一般客户不允许在发布版本上进行调试。所以不保存调试信息，同时，它往往进行了各种优化，以期达到代码最小和速度最优。为用户的使用提供便利。 对于一些企业版应用或者有内部测试的需求其实还可以新增 Beta 版，收集核心用户的建议或者测试新开发的功能模块，对反馈做出迅速反应，灵活控制。 由于之前引入了组件化开发模式，所有我又加入了 UnitTest（单元测试）模式，只要用于对组件的分离化测试，快速定位问题。 切换环境的同时会对应切换应用的图标，能有效避免测试环节中的环境混淆和降低辨别成本。 自动化打包测试 关于自动化打包就不得不说在创业公司的经历，那时开发任务重，提测前常常加班到晚上 12 点，就算 bug 修完，也要等半个小时看着 Xcode 不慌不忙的打包完成上传测试平台发邮件才能安心回家。 鉴于这种惨痛经历，利用闲暇时间就搞了个自动打包脚本，后期又整理一遍并适配 Xcode 8.2 之后的版本。 做的了三步配置，杜绝污染，一行命令自动上传。 也是鉴于 Xcode 版本升级后的苦逼适配经历，最终选择了开源的 fastlane 包，从此搭上了组织的小火车，配合 Testflight 终于可以放心的玩耍了… FastLane 是一种配置 iOS 和 Android 自动化 Beta 部署和发布的最简单的方法之一。它可以简化一些乏味、单调、重复的工作，像截图、代码签名以及发布 App。也能无缝衔接蒲公英、Fir等测试平台，这酸爽… 省时：每次将新版本推送到商店或Beta测试服务时，都可节省时间。 集成：集成当前开发环境中所有存在的工具和服务。 开源：100%基于MIT许可开源。 简单：简单的设置助手，几分钟配置即可使用。 运行：基于你的app和数据，运行在本地机器上。 CI：集成几乎所有CI系统。 支持：支持iOS、Mac以及Android 应用。 自定义：根据自身需要扩展和定制fastlane，不依赖任何人。 命令行：不需要记住除fastlane以外的任何命令。 配置：可以在任何电脑上配置，包括CI服务器。 对于 Testflight，就像没故事的卓同学所说的。 Testflight 有个较大的使用门槛，需要收集用户的邮箱，之后在 Testflight 里输入苹果发出的邀请码才能开始测试。很多用户嫌麻烦就退出了，运营认为这样会给测试带来很大的不便。但是冷静了心态后其实事情并没有那么糟糕。真正对这个产品有兴趣的用户不会因为要填个邮箱就放弃了。那些流失的只是普通的用户。用户使用了 Testflight 后，后续的测试包的发布也会收到更新。不会像企业版那样，只能手动的告诉用户我们有新的测试包。当 beta 测试活跃用户超过 100 个会有一个质变。这些都是积极的重度用户，一群重度用户使用你的新版本几天，至少可以保证核心业务逻辑是没有纰漏的。 这里推荐配合测试的 SDK 质量监控服务——Bugtags，Bugtags 可以通过悬浮窗或者摇一摇的方式进行截图，并将捕获的 bug 图片上传到测试平台，其自身也包括 Crash 的自动上传。 线上质量监控Crashlytics 成立于2011年，是专门为移动应用开者发提供的保存和分析应用崩溃信息的工具。 Crashlytics 不会漏掉任何应用崩溃信息。在发生崩溃后，用户再次进入 APP 并联网情况下，日志自动上传。 Crashlytics 可以象 Bug 管理工具那样，管理这些崩溃日志。例如：Crashlytics 会根据每种类型的 Crash 的出现频率以及影响的用户量来自动设置优先级。对于每种类型的 Crash，Crashlytics 除了会像一般的工具提供 Call Stack 外，还会显示更多相关的有助于诊断的信息，例如：设备是否越狱，当时的内存量，当时的 iOS 版本等。对于修复掉的 Crash 日志，可以在 Crashlytics 的后台将其关掉。 Crashlytics 可以每天和每周将崩溃信息汇总发到你的邮箱。 提供在线的报告，解释崩溃原因，甚至能给出是哪一行代码导致的崩溃。 Crashlytics 有配套的 macOS 应用 Fabric 用户体验值得国内 SDK 服务商学习。 2013 年 Twitter 对 Crashlytics 进行人才和服务的多重收购，一年后 Google 收购 Firebase，从此 Fabric 和 Firebase 这对好基友就成为了应用崩溃报告的黄金搭档。 管理团队核心组成架构关于团队的观点，我基本和没故事的卓同学看法一致，除了技术的硬指标，在早期团队还有一个工程团队文化的问题。一个几十个人的项目，里面某个特定的人的积极性对于项目其实是不太重要的。他只要完成应该完成的工作。甚至和其他人不说话也影响不大。一个大的项目也不能因为任何一个人不在了就运行不下去。 我之前思考过团队文化是什么，怎么形容团队文化。后来看到一个说法感觉挺贴切。文化是空气，无处不在。公司没有规定下班后社交平台上看到用户反馈需要你去回应，也不会规定你发现其他部门的产品有问题是不当回事还是应该去和其他部门的人沟通，又或者看到一个更好的建议是不是要和公司提出来。这些行为背后的支撑就是团队文化。在团队里的人决定了价值观。 技术团队做事就像古代的八抬大轿，公司业务就像轿子里的小娘子，团队文化就像抬轿子时喊的号子，团队里的每个人就像是抬轿子的车夫。抬轿子的大多数人走的快，每个人的步子齐，那轿子里的小娘子就坐得很舒服，如果哪个环节出现问题都会对坐轿子的人有影响。 所以，车夫水平要挑好，号子要响亮提气，每个人的步伐要协调，轿子就能平稳上路，可是如果想快点赶路，那可能就要尝试不同的抬轿姿势，换更响亮的号子，排练更协调步子，甚至换个更轻的轿子、换个轮子… 硬件设备投入接着上面的“花轿”说，硬件投入的重要性就不言而喻了，别人已经换上了带轮子的马车了，当然跑的飞快。 拿 Swift 的编译速度讲，MacBook Air 和 MacBook Pro 的处理器芯片和内存容量决定了两种电脑的编译耗时可能相差1倍左右，而一块外接显示屏能节省的频繁操作更是以少积多。 如果把一个工程师的薪资换算成时薪，配合硬件设备浪费掉的时间，将是一笔不那么明智的开销，当然如果你的工程师每天只是喝凉水看新闻，那请配给他一个保温杯和老花镜~ 例会和文档化有哪些会？ 当我打算写这个主题时，反思了下过去都参加过哪些会议，发现有时会莫名其妙的就参加了一些完全无意义的会议。下面我们先看看一般程序员都会碰到哪些会议。 需求会 这类会议一般是产品或项目经理召集，组织参与项目的程序员一起讨论需求并确定排期。这类会议容易出的问题是，程序员到了会上才第一次知道需求，并陷入到需求细节的无休止讨论中。更好的方式是提前让程序员详细了解需求，会上只需敲定排期并让互相有协作依赖的程序员之间达成一致和形成承诺。 讨论会 这类会议的场景比较广泛，比如：项目进行过程中同组程序员之间就设计或实现的讨论，或与其他组项目合作人之间的讨论等等。这类会议容易出现的问题是临时把一堆人拉到会上，然后陷入混乱的自由讨论，失去焦点。 还有一类讨论会叫头脑风暴会，也是容易把一堆人拉到会上，开动头脑风暴。如今遗憾的领悟到这是最没效率也没效果的方式。头脑风暴会需要就待解决的问题让参与人员提前准备，搜集或阅读材料，不同人从不同角度各自提出自己的观点或方案，然后到了会上将所有观点和方案列出来，再开动头脑，碰撞连接一下，看看能不能风暴出一些新的观点或方案去有效解决问题。 周例会 一般来说一个部门或小组都会每周开个例会，例会容易被当作日常的例行工作而不被重视。例会应该有固定的时间和议程，而且例会是一群经常一起工作并熟悉的人开会。虽然开例会的人都在同一个部门，但并不意味着他们都会相互合作完成同一个项目或事情。所以，例会是通过了解各自工作来完成了解整个部门或小组工作进展的机会，而不是每周固定的休闲时光。当然我们也可以在每周的例会留出一段自由讨论时间，可以畅所欲言，增加工作之外交流。 除了周例会，有些实施敏捷方法的团队也会开每日站立会，每日站立会的一般内容是： 昨天干了什么 今天计划干什么 遇到了什么障碍 每日站立会议的主要目的是让团队成员互相交流互通工作情况，而不是为了让经理们了解情况而召开的会议。每日站立会不是一个团队的人站一圈各自说下工作情况，因为曾经发现彼此并不关心对方工作内容的人站一圈开这个站立会，其意义何在？ 分享会 部门内、公司内或行业内都会有各类不同规模分享会，想清楚你为什么要去参加一个分享会？一般来说我只有两个原因，我对分享的内容感兴趣，这应该是大部分人参会的原因。另一个，即使分享内容我已经很熟悉，那么参会的原因一般就是对分享人感兴趣，想要去通过这个分享了解分享人。 还有一种情况可能是碍于面子参加一些完全没兴趣的分享会，恩，这种还是尽量规避吧。 临时会 总会碰到这种情况，突然有个人过来叫你临时去参加个会，然后你就一脸懵逼的去了。这种会似乎属于身不由己，不好规避，这类会议多是非计划性的任务驱动型会议。英特尔前 CEO 安迪·格鲁夫说过： 在现实中，有 20% 的情况还得靠任务导向会议来解决。但如果经理人将超过 25% 的时间用在应急的任务导向会议上，这个组织就一定有了毛病。这种类型的会议随时召开，而且会针对具体情况产生决策，若这种临时紧急的任务驱动会议太多了，那问题肯定出在平时的工作中。 总结会 可能是项目上线或产品发布后的总结会，也可能是线上故障后的经验教训总结会。我以前开过的很多总结会都变成了领导的总结会，关于这类会大家有什么好想法吗？ 对于以上这些千奇百怪的会议，于是有人制作了这幅漫画： 其实呢，凡事都有两面性，最难把控的永远是人，作为有效的讨论活动，会议本事没有问题，精耕细作也会在一定程度上保证质量。重要的是会议的气氛、主题以及控场力。 高效会议的三个要诀：1.提前通知议题并发给参会人相关资料，不要求可参加可不参加的人2.会议必须有主持人，引导大家时刻盯住会议主题3.要有会议纪要，会后对会议结论、行动计划、负责人、进度表和考核目标的提炼总结 我之前遇到一个项目领导就很有特色，由于采取封闭式敏捷开发模式，需要每天确定工作内容，调节各部门间工作进展，所以需要每天做午会，但是当时并不枯燥而且团队协作融洽，因为在例会过后有组织抽签买饮料、零食和惩罚倒霉鬼的活动，如今想来，他确实是一个优秀的组织者。 以上这些会议内容来自博客园的 mindwind，让我们同情他一刻钟~ 文档化文档化和例会一样是充满争议的举措，本质上是为了让一切有据可查，方便后期查阅和减少交接工作负担。但也不乏反对者，认为是在浪费时间，形势主义。 还是一样的道理，稳定的方法不会错，难把握的是个人。把每一个账号密码整理保存也是文档化。保持会议记录、工作聊天日志也能在必要时不接受飞来的横“锅”~ 组织 CodeReview还是引用没故事的卓同学的话，Code review 是一件神奇的事情。所有有素养的工程师都觉得 code review 好，据我们所知国外很多优秀的 IT 企业都很注重 code review，但是在国内却很少看到有团队执行 code review。或者中小团队里很少看到 code review。 作为一个 leader，在 review 的时候帮助成员成长，和只是看下代码是不是能完成功能最后会引向不同的结果。看过一句很有触动的话，现在很多 leader 知道自己的工作里需要管理其他人，但是却忽略了还需要 lead 。老实说推进 code review 确实遇到很多阻力。有团队里的也有团队外的。团队外的看法是 code review 拖慢了项目进度。我作为一个核心的开发成员，每天超过 20% 的时间是没有可见的工作产出的。有时别人写的有问题被我打回去改，一个已经完成的功能又多花了几个小时。团队内遇到的问题是，很多成员不理解这项工作背后的价值。 同样的感触来自上面提到的那家公司，负责我们的小组组长是一名有着 6 年移动端开发经验的优秀工程师，在一套严格的代码规范要求和 code review 的锻炼下，我的成长几乎是肉眼可见的（对比回看之前的代码），他对我们的指导也是无私且专业的，以至于我现在依然在感谢着他。 CodeReview 的方式 开 Code Review 会议 团队内部会整理 Check List 团队内部成员交换代码 找出可优化方案 多问问题，例如：“这块儿是怎么工作的？”、“如果有XXX 情况，你这个怎么处理？” 区分重点，优先抓住设计，可读性，健壮性等重点问题 整理好的编码实践，用来作为 Code Review 的参考 CodeReview 的内容 [1]架构/设计/常规1.单一职责原则这是经常被违背的原则。一个类只能干一个事情，一个方法最好也只干一件事情。比较常见的违背是一个类既干UI的事情，又干逻辑的事情，这个在低质量的客户端代码里很常见2.行为是否统一，例如：1)缓存是否统一2)错误处理是否统一3)错误提示是否统一4)弹出框是否统一5)……3.代码污染代码有没有对其他模块强耦合4.重复代码–&gt;应该抽取5.开闭原则6.面向接口编程7.健壮性1)是否考虑线程安全2)数据访问是否一致性3)边界处理是否完整4)逻辑是否健壮5)是否有内存泄漏6)有没有循环依赖7)有没有野指针8)是否检查了数组的“越界“错误9)……8.错误处理9.改动是不是对代码的提升新的改动是打补丁，让代码质量继续恶化，还是对代码质量做了修复10.效率/性能1)关键算法的时间复杂度多少？有没有可能有潜在的性能瓶颈2)客户端程序对频繁消息和较大数据等耗时操作是否处理得当 [2]代码风格1.可读性衡量可读性的可以有很好实践的标准，就是 Reviewer 能否非常容易的理解这个代码。如果不是，那意味着代码的可读性要进行改进2.命名1)命名对可读性非常重要2)是否跟系统属性命名造成冲突3)英语用词尽量准确一点，必要时可以查字典3.函数长度/类长度1)函数太长的不好阅读2)类太长了，检查是否违反的 单一职责 原则4.注释恰到好处的注释,不是注释越多越好5.参数个数不要太多，一般不要超过 3 个 工具Gitlab 及 Git 相关规范Gitlab对于代码仓库开源首选 GitHub，不开源现在也有许多服务商，如：Gitee 等，如果有钱任性 GitHub 普通的团队套餐每个月每人 9 刀，但我相信大多数中小企业会选择 Gitlab。 还有就是服务端如果要自己配置 CI 服务不太方便。如果部署在自己的服务器上，其他一些服务脚本也部署在一起，会有很大的自主权。综合之后选择了主流的 Gitlab。 第三方仓库都可能遇到父爱如山般的维护时期。 Git 相关规范Git 相比 SVN 能避免大多数非人为问题，这点相信已经不需要论证了。但是那些人为的问题怎么办，那当然需要规范了。 首先，做好分工，特别是 Storyboard 和 XIB 多种，尽量避免出现多人修改同一个文件。 每个人的所有开发工作都只在自己的分支开发。例如小明开发，你就在本地切换到自己的 xiaoming_gittutorial 分支然后进行开发。 每个人只允许在自己的分支直接push远程分支。 合并的时候必须遵循以下条件： 首先，本地切换到develop分支。pull```123* 例如你是小明，那么在 pull 到远程的 develop 最新的内容之后。```git merge xiaoming_gittutorial 如果出现 conflict 那么清除 conflict 之后，commit 然后把本地 develop push 到远程的 develop。 每完成一个功能就提交一次，不要累计代码。 保证主分支代码永远可运行，版本完整（用于脚本自动化发测试包）。 这样的流程有什么好处呢？ 几乎不会出现 conflict。 你永远也不会污染 develop 分支。 每次都是在本地 merge 完清除了 conflict 之后再 push 会远端，那么别人更新本地 develop 分支，再合并的时候，就算出现 conflict 也只会是自己最新代码产生的 conflict。 Sketch 设计工具 + Zeplin 标注工具移动端也属于前端，是做直接和用户打交道的事情，当然也包括设计狮，设计狮是一种很厉害的猫科动物，他们有着令人恐惧的像素眼和血统中的强迫症。（以上我喝多了说的，不要当真哈~） Sketch 作为一款移动时代设计师新宠，自然有其存在的道理。 自动保存和版本管理 矢量编辑和完美像素 智能参考线 自由编辑元素 布尔运算 单图层多重混合模式 四舍五入像素数值取整 共享样式和组件 优秀的输出 分配间距 移动设备模版 自带格栅 出色的文字渲染 丰富的插件（标注、内容填充） 多种软件高度配合 旋转复制 手机实时预览 Zeplin 面向的用户是设计师和前端（Web、Mobile）工程师，相当于做的是中间桥梁这一块，核心功能为标注、Style Guide、备注文档与简单的团队协作。 sketch支持多画板，便于同时预览，占用内存较ps小很多 sketch支持导出flinto，便于制作交互动效原型 zeplin解放设计师的双手，从此告别切图和标注 zeplin降低工程师的沟通成本，提高设计还原度 Abstract 就是一个借助 Git 对 Sketch 文件进行版本控制的软件。 详情参见《Git 与 Sketch 的神奇邂逅：Abstract》（https://sspai.com/post/40595） 成果年终总结 Github 原创开源项目 90+，共计 400+ 贡献力 参与维护开源项目 fastlane 20.5k（至2018.02.08） 完成 Swifter 功能展示应用研发 Swifter 是一款基于 Swift 开发的，采用 MVVM 模式、RxSwift 函数式响应编程、组件化和 ReactNative 等技术的技术示例应用。","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/tags/Tips/"}]},{"title":"让 Async 帮你解决线程问题","slug":"Library Async","date":"2018-02-23T03:56:27.000Z","updated":"2018-11-15T14:59:55.147Z","comments":true,"path":"2018/02/23/Library Async/","link":"","permalink":"https://reversescale.github.io/2018/02/23/Library Async/","excerpt":"线程这种东西一般封装比较深，很微观，也很考察计算机基础知识，虽然系统为我们封装的 GCD、NSOperation 已经很好用了，但是我发现了个更好用的~","text":"线程这种东西一般封装比较深，很微观，也很考察计算机基础知识，虽然系统为我们封装的 GCD、NSOperation 已经很好用了，但是我发现了个更好用的~ 👨🏻‍💻 Github Demo 🤖 要求 iOS 9.0+ Xcode 9.0+ Swift 4 🎨 测试 UI 什么样子？ 1.展示页 2.展示页 3.展示页 常见场景列表 耗时操作场景示例 黑科技操作场景示例 🎯 安装方法在 iOS, 你需要在 Podfile 中添加.12345source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;9.0&apos;use_frameworks!pod &apos;AsyncSwift&apos; 🛠 配置耗时操作这是应用最广泛的场景，为了避免阻塞主线程，将耗时操作放在子线程处理，然后在主线程使用处理结果。比如读取沙盒中的一些数据，然后将读取的数据展示在 UI，这个场景还有几个细分：1.1 执行一个耗时操作后回调主线程123456Async.background &#123;print(\"A: This is run on the \\(qos_class_self().description) (expected \\(QOS_CLASS_BACKGROUND.description))\") sleep(2)&#125;.main &#123; print(\"B: This is run on the \\(qos_class_self().description) (expected \\(qos_class_main().description)), after the previous block\")&#125; 1.2 串行耗时操作 每一段子任务依赖上一个任务完成，全部完成后回调主线程：1234567891011let backgroundBlock = Async.background &#123; print(\"This is run on the first\\(qos_class_self().description) (expected \\(QOS_CLASS_BACKGROUND.description))\") sleep(2) print(\"This is run on the second \\(qos_class_self().description) (expected \\(QOS_CLASS_BACKGROUND.description))\") sleep(2)&#125;// Run other code here...backgroundBlock.main &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(qos_class_main().description)), after the previous block\")&#125; 1.3 并发耗时操作 每一段子任务独立，所有子任务完成后回调主线程：12345678910111213141516Async.main &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(qos_class_main().description))\") // Prints: \"This is run on the Main (expected Main) count: 1 (expected 1)\" &#125;.userInteractive &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(QOS_CLASS_USER_INTERACTIVE.description))\") // Prints: \"This is run on the Main (expected Main) count: 2 (expected 2)\" &#125;.userInitiated &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(QOS_CLASS_USER_INITIATED.description)) \") // Prints: \"This is run on the User Initiated (expected User Initiated) count: 3 (expected 3)\" &#125;.utility &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(QOS_CLASS_UTILITY.description)) \") // Prints: \"This is run on the Utility (expected Utility) count: 4 (expected 4)\" &#125;.background &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(QOS_CLASS_BACKGROUND.description)) \") // Prints: \"This is run on the User Interactive (expected User Interactive) count: 5 (expected 5)\"&#125; 延时执行延时一段时间后执行代码，一般见于打开 App 一段时间后，弹出求好评对话框。123456let seconds = 3.0Async.main(after: seconds) &#123; print(\"Is called after 3 seconds\")&#125;.background(after: 6.0) &#123; print(\"At least 3.0 seconds after previous block, and 6.0 after Async code is called\")&#125; 其他用法请见 Demo。 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/tags/Project/"}]},{"title":"最简便的方式让你的应用接入 Emoji","slug":"Emoji Keyboard","date":"2018-02-10T03:56:27.000Z","updated":"2018-11-15T15:00:32.762Z","comments":true,"path":"2018/02/10/Emoji Keyboard/","link":"","permalink":"https://reversescale.github.io/2018/02/10/Emoji Keyboard/","excerpt":"不知道从什么时候开始，Emoji 表情无处不在。它们每天被数百万人使用，或喜或悲或猥琐，是一个无与伦比的表达工具~","text":"不知道从什么时候开始，Emoji 表情无处不在。它们每天被数百万人使用，或喜或悲或猥琐，是一个无与伦比的表达工具~ 我们相信，用户不应该被限制在 Unicode 库中，我们构建了这个键盘，以增加所有与我们合作的应用程序的参与度，保留率和收入。 👨🏻‍💻 Github Demo 🤖 要求 iOS 9.0+ &amp; Android Xcode 9.0+ Swift / Objective-C 🚀 准备开始Makemoji 应用内键盘是我们 SDK 的核心。 这是一个动态控制的表情符号键盘与紧密集成的文本输入，由我们的CMS和仪表板支持。 您可以创建自己的类别，上传 emoji / gifs 并沿着 unicode 表情符号跟踪其使用情况。 我们的文本输入的输出是一个简单的 HTML 消息，以及一个纯文本版本和我们所谓的“替代”版本，它使用一个简单的模板系统。 这个输出可以保存在您的设备上，后端或您选择的任何地方。 🎨 测试 UI 什么样子？ 1.展示页 2.展示页 3.展示页 4.展示页 输入前样式 文字键盘样式 表情包键盘样式 表情键盘样式 🎯 安装方法安装在 iOS, 你需要在 Podfile 中添加.1pod &quot;Makemoji-SDK&quot; 如果你使用 Android, 添加在工程 build.gradle 目录下123456789dependencies &#123; compile &apos;com.makemoji:makemoji-sdk-android:0.9.777&apos;&#125; repositories &#123; jcenter() maven &#123; url &quot;https://dl.bintray.com/mm/maven/&quot; &#125;&#125; 设置你的 SDK Key要获得您的SDK密钥，请发送电子邮件至sdk@makemoji.com 要开始使用MakemojiSDK，您将首先设置您的SDK密钥。 iOS 在 AppDelegate 中:1#import &quot;MakemojiSDK.h&quot; 12345- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // setup your SDK key [MakemojiSDK setSDKKey:@&quot;YOUR-SDK-KEY&quot;]; return YES;&#125; Android 在 AndroidManifest.xml:123&lt;application android:name=&quot;com.makemoji.sbaar.mojilist.App&quot; ... 和 App.java12345public void onCreate()&#123; super.onCreate(); Moji.initialize(this,&quot;YOUR_KEY_HERE&quot;); //Moji.setUserId(&quot;Google ad id here if needed&quot;); // optional custom user id for analytics&#125; 🛠 配置设置假设您有一个应用程序的聊天区域，并且您希望使用我们的键盘来让用户在对话中共享独特的表情符号。 让我们开始设置我们的文本输入对象属性。 1234#import &quot;METextInputView.h&quot;@interface ViewController : UIViewController &lt;METextInputViewDelegate&gt;@property (nonatomic, retain) METextInputView * meTextInputView; METextInputView 是一个容器对象，它包含导航/趋势图栏以及文本输入。 这是为了解决苹果的InputAccessoryView的某些技术限制，尽管这种行为非常相似。 在 viewDidLoad 或 init 视图控制器中，初始化 METextInputView。12self.meTextInputView = [[METextInputView alloc] initWithFrame:CGRectZero];self.meTextInputView.delegate = self; 您需要将自己分配给委托，以侦听事件的回调，如点击发送或照相机按钮和键盘事件。 接下来，我们需要确定我们要在页面上使用什么类型的输入。 浮动输入如果你的应用程序需要一个浮动的 iMessage 类型的文本输入，你可以简单地将 METextInputView 添加到你的视图中。 1[self.view addSubview:self.meTextInputView]; 这个默认模式在键盘之后，随着一个摄像头/发送按钮，并且当用户输入一个长消息时，扩展到全屏。 METextInputView 遵循 ‘firstResponder` 模式来隐藏/显示键盘。 有很多方法可以定制这个输入和导航栏的外观和感觉。 我们将在 Customizations 中介绍 分离的输入如果您需要从键盘分离的文本输入，您将需要调用 detachTextInputView 方法，然后将 textInputContainerView 添加到您的视图。 12[self.meTextInputView detachTextInputView:YES];[self.view addSubview:self.meTextInputView.textInputContainerView]; 由于“发送按钮”和“摄像头”按钮在此模式下处于隐藏状态，因此您需要在 METextInputView 的 sendMessage 方法上附加一个按钮来触发捕获文本。 输入大小变化当使用我们的浮动输入时，您将希望在显示键盘时使用 didChangeFrame 委托回调来调整周围的视图。 123-(void)meTextInputView:(METextInputView *)inputView didChangeFrame:(CGRect)frame &#123; self.tableView.frame = CGRectMake(self.tableView.frame.origin.x, self.tableView.frame.origin.y, self.tableView.frame.size.width, self.meTextInputView.frame.origin.y);&#125; 发送消息Makemoji 消息由三部分组成：一个完全形成的HTML消息，一个ASCII兼容的明文消息和一个 substitute 消息。 你使用哪一个取决于你的消息存储是如何配置的。 替代文本允许您将带有Makemoji表情符号占位符的明文存储为文本的一部分。 这是一个示例消息。 12345&#123; html = &quot;&lt;p dir=\\&quot;auto\\&quot; style=\\&quot;margin-bottom:16px;font-family:&apos;.SF UI Text&apos;;font-size:16px;font-weight:bold;\\&quot;&gt;&lt;span style=\\&quot;color:#000000;\\&quot;&gt;Hey lets play &lt;/span&gt;&lt;img style=\\&quot;vertical-align:middle;width:20px;height:20px;\\&quot; src=\\&quot;https://d1tvcfe0bfyi6u.cloudfront.net/emoji/14-large@2x.png\\&quot; id=\\&quot;14\\&quot; link=\\&quot;\\&quot; name=\\&quot;Pacman\\&quot; /&gt;&lt;span style=\\&quot;color:#000000;\\&quot;&gt; at the &lt;/span&gt;&lt;img style=\\&quot;vertical-align:middle;width:20px;height:20px;\\&quot; src=\\&quot;https://d1tvcfe0bfyi6u.cloudfront.net/emoji/692-large@2x.png\\&quot; id=\\&quot;692\\&quot; name=\\&quot;Arcade\\&quot; link=\\&quot;\\&quot; /&gt;&lt;/p&gt;\\n&quot;; plaintext = &quot;Hey lets play at the \\n&quot;; substitute = &quot;Hey lets play [Pacman.E] at the [Arcade.BA]&quot;;&#125; 当用户点击 ‘sendButton时，didTapSend` 委托回调被触发，并返回一个包含html，plaintext和substitute消息的字符串的NSDictionary。 12345-(void)meTextInputView:(METextInputView *)inputView didTapSend:(NSDictionary *)message &#123; // send message to your backend here [self.messages addObject:message]; [self.tableView reloadData];&#125; 然后，您可以将选择的部分发送到后端以存储消息。 显示消息现在你已经有Makemoji消息了，我们需要设置一个显示它们的方法。 通常这将在 UITableViewCell 中，但您也可以使用任何自定义视图来显示消息。 我们已经包括一个优化的UITableViewCells用于显示HTML消息和一种方法来自动缓存你的表单元格高度。 这可以防止任何不必要的表情符号和文本布局，并提高性能。 这里是我们提供的信息显示的概述。 MESimpleTableViewCell这个单元格提供了一个基本的布局，默认情况下尝试使用整个单元格区域。 您将使用此单元格作为子类快速实现自定义表格单元格。 MEChatTableViewCell聊天单元提供一个iMessage，如聊天泡泡，间距，可设定的方向和颜色设置。 MECollectionViewCell简单表格单元格的集合视图版本。 MEMessageView单元的底层视图，消息的核心显示视图。 替代文字使用 substitute 类型的消息时，可以通过在 METextInputView 上使用下面的静态方法将其转换回HTML 1+(NSString *)convertSubstituedToHTML:(NSString *)substitute withFontName:(NSString *)fontName pointSize:(CGFloat)pointSize textColor:(UIColor *)color 高度缓存使用 cellHeightForHTML 方法获取消息的行高。 此方法缓存单元高度以提高性能。 123456789101112// determine row height with HTML- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; if (self.meTextInputView == nil) &#123; return 0; &#125; NSDictionary * message = [self.messages objectAtIndex:indexPath.row]; return [self.meTextInputView cellHeightForHTML:[message objectForKey:@&quot;html&quot;] atIndexPath:indexPath maxCellWidth:self.tableView.frame.size.width cellStyle:MECellStyleChat];&#125; 您可以通过重置 METextInputView 上的 cachedHeights 属性来手动重置 UITableViewCell 高度缓存。 表格单元格使用MEChatTableViewCell，您可以使用setCellDisplay在左侧或右侧显示聊天气泡。 这应该发生在为每个消息设置您的HTML之前。 12345678910111213141516171819202122- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; static NSString *CellIdentifier = @&quot;Cell&quot;; MEChatTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; if (cell == nil) &#123; cell = [[MEChatTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier]; &#125; // display chat cell on right side [cell setCellDisplay:MECellDisplayRight]; // display chat cell on left side if (indexPath.row % 2) &#123; [cell setCellDisplay:MECellDisplayLeft]; &#125; NSDictionary * message = [self.messages objectAtIndex:indexPath.row]; [cell setHTMLString:[message objectForKey:@&quot;html&quot;]]; return cell; &#125; Hypermoji - 带有URL的表情符号我们已经创建了一种新的方式来共享内容，浏览网页，观看视频或听音乐，而不用离开Hypermoji的应用程序。 要在Hypermoji（具有URL链接的表情符号）上点击时显示网页，请使用 didTapHypermoji 委托回调 1234// handle tapping of links (Hypermoji)-(void)meTextInputView:(METextInputView *)inputView didTapHypermoji:(NSString*)urlString &#123; // open webview here&#125; 相机按钮这是一个标准的UIButton，可以用图像或文本进行自定义。 要处理相机按钮的操作，请使用didTapCameraButton委托回调。 123-(void)meTextInputView:(METextInputView *)inputView didTapCameraButton:(UIButton*)cameraButton &#123; // Present image controller&#125; 自定义您可以通过在 METextInputView 上设置 displayCameraButton 属性来显示或隐藏内置摄像头 1self.meTextInputView.displayCameraButton = NO; 您可以通过在 METextInputView 上设置 displaySendButton 属性来显示或隐藏内置的发送按钮 1self.meTextInputView.displaySendButton = NO; 使用setFont你可以设置你的文本输入的默认字体。 1[self.meTextInputView setFont:[UIFont systemFontOfSize:20]]; 更改占位符文本的颜色 1self.meTextInputView.placeholderLabel.textColor = [UIColor darkGrayColor]; 控制锁定的类别您将需要侦听NSNotification MECategorySelectedLockedCategory 来确定什么时候锁定了一个类别。 要解锁一个类别，您需要调用 [MakemojiSDK unlockCategory：@“category”] 您可以收听 ‘MECategoryUnlockedSuccessNotification和MECategoryUnlockedFailedNotification` 以确定解锁呼叫是否成功。 📝 应用程序提交Makemoji SDK 使用IDFA跟踪ID来为您的应用程序中的视图，共享和点击进行归因。 将应用程序提交到 App Store 时，您需要检查“将此应用程序安装到以前投放的广告”选项。 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/tags/Project/"}]},{"title":"门罗币(Monero XMR)给你最轻巧的矿工生活(包教包会)","slug":"Monero XMR","date":"2018-02-08T18:56:27.000Z","updated":"2018-11-15T14:40:15.273Z","comments":true,"path":"2018/02/09/Monero XMR/","link":"","permalink":"https://reversescale.github.io/2018/02/09/Monero XMR/","excerpt":"你向往躺着赚钱吗？你想不努力工作就实现财务自由吗？你想什么都不做就有数不完的钱吗？洗洗睡吧~","text":"你向往躺着赚钱吗？你想不努力工作就实现财务自由吗？你想什么都不做就有数不完的钱吗？洗洗睡吧~ 从2017年8月21日开始，XMR一路走高，从$55左右，一路上涨，到本文写作时，已经达到$269（≈￥1,699）。数据来源：Crypto coins mining profit calculator compared to Ethereum 门罗币（Monero，代号XMR）是一个创建于2014年4月开源加密货币，它着重于隐私、分权和可扩展性。与自比特币衍生的许多加密货币不同，Monero基于CryptoNote协议，并在区块链模糊化方面有显著的算法差异。Monero的模块化代码结构得到了比特币核心维护者之一的Wladimir J. van der Laan的赞赏。Monero致力于成为可代替的不可追踪的电子货币。相比比特币及其分叉，Monero具有更高程度的匿名性。 Monero于2014年4月18日发布。 高涨的币价使得在国内一直默默无闻的XMR瞬间成为焦点，现在已经变成挖矿收益最高的币种之一。以1060 3G为例，在不超频的情况下，挖掘XMR的速度在430H/s左右，不计电费，单卡日收益达到$1.62，超过了之前收益之王ETH。 如何挖矿？ 作为矿工，大家最关心的应该还是怎么挖矿了，下面就向大家介绍一下挖矿的最轻巧姿势。 获得一个钱包地址（推荐）使用在线钱包：https://mymonero.com/特点：使用方便，安全性差 或者在XMR的官方网站下载钱包 App：Monero: Downloads(https://getmonero.org/downloads/)特点：相对安全，方便性差 参与挖矿在网上，你可能看到过许许多多硬件驱动的挖矿方式，组合多少显卡的矿池，但是这里的主题是“最轻巧”，所以我们只做帮工好了。 Coinhive是一个提供恶意JS脚本的网站平台（https://coinhive.com），允许攻击者将脚本挂在到自己的或入侵的网站上，所有访问该网站的用户都可能成为门罗币的挖掘矿工。该工具在网络犯罪分子中间迅速扩散，俨然已经成为了互联网的“Martin Shkreli”。 Coinhive工具其实是一个Java库，用户访问加载该JS的网站后，Coinhive的JS代码库在用户的浏览器上运行，开始为网站所有者挖掘门罗币，消耗的是用户自己的CPU资源。 不得不说，这个想法相当地有创意！Coinhive于9月14日推出，作者向站长们推广Coinhive时声称，站长们加载了Coinhive JS就可以实现盈利：它仅耗费访问用户的少部分CPU，就可以为网站所有者赚取利润，用于支持他们的业务，再也不用添加各种烦人的广告了。 这一想法获得了某些人的支持，在The Pirate Bay（全球知名的BT下载网站）试运行了两天后，由于用户的负面反馈，最后放弃了。 未开情况下 CPU 占用： 理论上你可以使用闲置的那 54.08% 进行挖矿，实测对 CPU 的负荷还是很大的下图是开通100 Threads 下处理器占用情况： 矿工分成之前已经介绍过这种机制的原理了，轻量也注定着收益不会太高，但是简单的使用却可以为你省下大把时间，相信你的时间才是最宝贵的。 上面那些对于刚刚接触的你可能不是很受用，那来看看下面这些 以为这样以后每天的早餐钱就有了？😆那你最好仔细读读下面的东西…","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/tags/Tips/"}]},{"title":"iOS 模块化路由之 JLRoute","slug":"Library JLRoute","date":"2018-02-01T13:56:27.000Z","updated":"2018-11-15T15:08:30.895Z","comments":true,"path":"2018/02/01/Library JLRoute/","link":"","permalink":"https://reversescale.github.io/2018/02/01/Library JLRoute/","excerpt":"基于 JLRoute 实现的模块化路由，支持自动注册映射表、Url 跳转原生页面、WebView 页面和 ReactNative 页面、跳转传参及回调等~","text":"基于 JLRoute 实现的模块化路由，支持自动注册映射表、Url 跳转原生页面、WebView 页面和 ReactNative 页面、跳转传参及回调等~ 模块化已经成为调剂庞大项目结构的一剂良药，对项目的开发、维护和后续的扩展的好处已经不言而喻。 👨🏻‍💻 Github Demo 🤖 要求 iOS 8.0+ Xcode 7.0+ 🎯 安装方法安装在 iOS, 你需要在 Podfile 中添加.1234567891011121314151617source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;9.0&apos;use_frameworks!pod &apos;JLRoutes&apos;, &apos;~&gt; 2.0.1&apos;# &apos;node_modules&apos;目录一般位于根目录中# 但是如果你的结构不同，那你就要根据实际路径修改下面的`:path`pod &apos;React&apos;, :path =&gt; &apos;./node_modules/react-native&apos;, :subspecs =&gt; [ &apos;Core&apos;, &apos;RCTText&apos;, &apos;RCTNetwork&apos;, &apos;RCTWebSocket&apos;, # 这个模块是用于调试功能的 # 在这里继续添加你所需要的模块]# 如果你的RN版本 &gt;= 0.42.0，请加入下面这行pod &quot;Yoga&quot;, :path =&gt; &quot;./node_modules/react-native/ReactCommon/yoga&quot; 启动 ReactNative 环境1.修改项目ModuleARNPageViewController.m IP 跳转地址 2.进入项目所在目录，运行(首次运行需要 npm install) 1npm start 🛠 JLRoutes的工作流程和原理单一的Scheme注册过程： 1.调用注册方法（用户注册routePattern，默认优先级0） 1- (void)addRoute:(NSString *)routePattern handler:(BOOL (^__nullable)(NSDictionary&lt;NSString *, id&gt; *parameters))handlerBlock; 2.路由解析（这些解析跟我们设置路由的规则有直接关系） (1)判断接口URL是否设置可选性URL并将对应的URL封装成JLRRouteDefinition对象 (2)将JLRRouteDefinition对象装载进一个可变数组，内存保留了所有的对象！！ （JLRRouteDefinition对象包括有路径，参数解析，block等信息） 单一的Scheme调用过程：1.调用URL 1+ (BOOL)routeURL:(NSURL *)URL 2.解析URL，将参数，路由信息封装成JLRRouteRequest对象 1- (instancetype)initWithURL:(NSURL *)URL alwaysTreatsHostAsPathComponent:(BOOL)alwaysTreatsHostAsPathComponent 3.给JLrouteRequest对象和路由数组里的JLRRouteDefinition对象作比对，并且返回JLRRouteResponse 对象抽出参数和URL在数组里 1JLRRouteResponse *response = [route routeResponseForRequest:request decodePlusSymbols:shouldDecodePlusSymbols]; 4.调用JLRRouteResponse 对象里面的回调方法 1[route callHandlerBlockWithParameters:finalParameters]; JLRoutes的URL注册规则： 1.普通注册 123456JLRoutes *routes = [JLRoutes globalRoutes];[routes addRoute:@&quot;/user/view/:userID&quot; handler:^BOOL(NSDictionary *parameters) &#123;NSString *userID = parameters[@&quot;userID&quot;]; // defined in the route by specifying &quot;:userID&quot;// present UI for viewing user with ID &apos;userID&apos;return YES; // return YES to say we have handled the route&#125;]; URL里，分号表示这个是参数 另外一种注册方式，下标注册法 123JLRoutes.globalRoutes[@&quot;/route/:param&quot;] = ^BOOL(NSDictionary *parameters) &#123;// ...&#125;; 如何按照以上的方式注册，在任何时刻（包括在其它的APP）你都可以调用这个URL。 12NSURL *viewUserURL = [NSURL URLWithString:@&quot;myapp://user/view/joeldev&quot;];[[UIApplication sharedApplication] openURL:viewUserURL]; 在这个例子中，在parmameters字典里面的userID会传给block，它是一个键值对。”userID”: “joeldev”。给UI层或者任何需要它的地方用的。 字典参数： 字典参数总包括至少一下3个键： 12345&#123;&quot;JLRouteURL&quot;: &quot;(the NSURL that caused this block to be fired)&quot;,&quot;JLRoutePattern&quot;: &quot;(the actual route pattern string)&quot;,&quot;JLRouteScheme&quot;: &quot;(the route scheme, defaults to JLRoutesGlobalRoutesScheme)&quot;&#125; 处理Block 你会发现，每个注册的block都会返回一个YES。这个值，如果你返回NO，JLRoutes会跳过这个匹配，然后继续去匹配其它的。 如果你的block设置成nil，它会默认返回YES。 2.复杂注册 1234567[[JLRoutes globalRoutes] addRoute:@&quot;/:object/:action/:primaryKey&quot; handler:^BOOL(NSDictionary *parameters) &#123;NSString *object = parameters[@&quot;object&quot;];NSString *action = parameters[@&quot;action&quot;];NSString *primaryKey = parameters[@&quot;primaryKey&quot;];// stuffreturn YES;&#125;]; 这个地址会被匹配很多URL，如/user/view/joeldev or /post/edit/123。这些URL上的是参数。 12NSURL *editPost = [NSURL URLWithString:@&quot;myapp://post/edit/123?debug=true&amp;foo=bar&quot;];[[UIApplication sharedApplication] openURL:editPost]; 这时，pramater字典就会是以下这样的（传参） 12345678910&#123;&quot;object&quot;: &quot;post&quot;,&quot;action&quot;: &quot;edit&quot;,&quot;primaryKey&quot;: &quot;123&quot;,&quot;debug&quot;: &quot;true&quot;,&quot;foo&quot;: &quot;bar&quot;,&quot;JLRouteURL&quot;: &quot;myapp://post/edit/123?debug=true&amp;foo=bar&quot;,&quot;JLRoutePattern&quot;: &quot;/:object/:action/:primaryKey&quot;,&quot;JLRouteScheme&quot;: &quot;JLRoutesGlobalRoutesScheme&quot;&#125; 3.Scheme（有没有多态的感觉） JLRoutes支持用指定的URL scheme来创建路由。相同的scheme才能被匹配。默认地，所有的URL会设置进global scheme。 123456789101112[[JLRoutes globalRoutes] addRoute:@&quot;/foo&quot; handler:^BOOL(NSDictionary *parameters) &#123;// This block is called if the scheme is not &apos;thing&apos; or &apos;stuff&apos; (see below)return YES;&#125;];[[JLRoutes routesForScheme:@&quot;thing&quot;] addRoute:@&quot;/foo&quot; handler:^BOOL(NSDictionary *parameters) &#123;// This block is called for thing://fooreturn YES;&#125;];[[JLRoutes routesForScheme:@&quot;stuff&quot;] addRoute:@&quot;/foo&quot; handler:^BOOL(NSDictionary *parameters) &#123;// This block is called for stuff://fooreturn YES;&#125;]; 如果你调用的使用，是这样调用的 123[[JLRoutes globalRoutes] addRoute:@&quot;/global&quot; handler:^BOOL(NSDictionary *parameters) &#123;return YES;&#125;]; 它只会调用global scheme的对应的URL。不会调用ting scheme里面对应的URL。 当然，你可以设置，如果指定的scheme没有这个URL，去查询global scheme 有没有。你需要设置一个属性。 1[JLRoutes routesForScheme:@&quot;thing&quot;].shouldFallbackToGlobalRoutes = YES; 3.通配符的设置URL的方式 通配符为：* 通配符符后面所有的URL上的参数都会以一个数组保存在parameters字典里面的JLRouteWildcardComponentsKey对应的value里。 例如，如果你注册URL如下: 123456789[[JLRoutes globalRoutes] addRoute:@&quot;/wildcard/*&quot; handler:^BOOL(NSDictionary *parameters) &#123;NSArray *pathComponents = parameters[JLRouteWildcardComponentsKey];if ([pathComponents count] &gt; 0 &amp;&amp; [pathComponents[0] isEqualToString:@&quot;joker&quot;]) &#123;// the route matched; do stuffreturn YES;&#125;// not interested unless the joker&apos;s in itreturn NO;&#125;]; 如果调用的URL开始是／wildcard，这个路由就可能被触发！！如果第一个参数是joker，就被触发，如果不是，就被拒绝触发。。。 4.选择性路由 如果路由地址设置样式有括号，如：/the(/foo/:a)(/bar/:b)，其实它代表的URL有如下： 1234/the/foo/:a/bar/:b/the/foo/:a/the/bar/:b/the 5.查询Routes 下面的方式，你可以查看Routes里所有注册的URL Routes。 1234/// All registered routes, keyed by scheme+ (NSDictionary &lt;NSString *, NSArray &lt;JLRRouteDefinition *&gt; *&gt; *)allRoutes;/// Return all registered routes in the receiving scheme namespace.- (NSArray &lt;JLRRouteDefinition *&gt; *)routes; 自定义路由解析如果你想自己定制一个路由编辑，你可以继承JLRouteDefinition并且用 addRoute：方法去添加你自定义类的对象。 📝 调研来源JLRoutes：https://github.com/joeldev/JLRoutes JLRoutes资料博客：https://www.varsiri.com/archives/305 ⚖ 协议123456789101112131415161718192021MIT LicenseCopyright (c) 2017 ReverseScalePermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the &quot;Software&quot;), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in allcopies or substantial portions of the Software.THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THESOFTWARE. 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/tags/Project/"}]},{"title":"iPhone X + iOS 11 适配指南","slug":"iPhone X iOS 11","date":"2017-09-30T09:56:27.000Z","updated":"2018-11-15T14:50:44.938Z","comments":true,"path":"2017/09/30/iPhone X iOS 11/","link":"","permalink":"https://reversescale.github.io/2017/09/30/iPhone X iOS 11/","excerpt":"北京时间今天凌晨1点，苹果再一次让全世界沸腾。iPhone X 带给我们的最大改变：全屏 Super Retina显示屏。它提供了更多的内容显示空间，同时也营造了更加深入的沉浸感。作为 iOS 开发者，在为强大的 Face ID 和全面屏欣喜的同时，我更担忧“齐刘海”的适配！ 下面结合官方的人机交互指南，来了解下如何设计 App 才能在iPhone X 和其他所有 iOS 设备上都看起来很棒~","text":"北京时间今天凌晨1点，苹果再一次让全世界沸腾。iPhone X 带给我们的最大改变：全屏 Super Retina显示屏。它提供了更多的内容显示空间，同时也营造了更加深入的沉浸感。作为 iOS 开发者，在为强大的 Face ID 和全面屏欣喜的同时，我更担忧“齐刘海”的适配！ 下面结合官方的人机交互指南，来了解下如何设计 App 才能在iPhone X 和其他所有 iOS 设备上都看起来很棒~ 前言北京时间今天凌晨1点，苹果再一次让全世界沸腾。iPhone X 带给我们的最大改变：全屏 Super Retina显示屏。它提供了更多的内容显示空间，同时也营造了更加深入的沉浸感。作为 iOS 开发者，在为强大的 Face ID 和全面屏欣喜的同时，我更担忧“齐刘海”的适配！ 下面结合官方的人机交互指南，来了解下如何设计 App 才能在iPhone X 和其他所有 iOS 设备上都看起来很棒。 理论部分屏幕尺寸 在竖屏下，iPhone X 上的显示的宽度与 iPhone 6，iPhone 7和 iPhone 8的4.7英寸显示屏的宽度保持一致。然而，iPhone X 比4.7英寸显示屏高了145个点，这导致增加了大约20％的垂直高度内容。 大家在为设计师悲伤的同时也不要忘记添加启动图（LaunchImage or LaunchScreen.storyboard）呦~ 安全区 在 iPhone X 布局中，最关键的是：必须确保布局填满屏幕，同时又不会被设备的圆角，传感器外壳或用于访问主屏幕的指示灯所遮盖，苹果为称此区域为“安全区”。 可喜的是，大多数标准的系统提供的UI元素和控件（如 navigation bars，tables 和 collections）都已经为新外形做了很好的适配。 背景已经延伸到显示器的边缘，并且UI元件被很恰当地插入和定位在安全区域。 因此，对于具有自定义布局的 App，支持iPhone X 也应该比较容易，特别是如果使用了 AutoLayout 并遵守安全区域(safe area)和边距布局(margin layout)指南。这些在上文都已经有过较详细的阐述。 下面说几点需要特别注意的： 在 iPhone X 上预览 App: 在拿到新机之前，也可以先使用 Simulator 来预览和检查下布局问题。 但是一些依赖硬件的功能，如图像效果和交互体验，最好还是在真机上预览。 始终保持全屏体验: 确保背景延伸到显示区域的边缘，以及垂直可滚动的布局（如 tables 和 collections）一直延续到底部。 防止边缘内容被裁剪: 一般来说，内容应该是居中对称的，这样它在任何方向看起来都会很棒，不会被边角角或设备外壳夹住，或被主屏幕的指示器遮挡。 为了获得最佳效果，请使用标准的系统界面元素和 AutoLayout 构建界面。 所有 App 都应遵循 UIKit 定义的安全区域和布局边距，因为这些区域可以根据设备和上下文进行适当的填充。 安全区域还可以防止内容覆盖status bar, navigation bar, toolbar, 以及 tab bar. 注意 status bar 的高度: status bar 在iPhone X 上比在其他 iPhone上更高。 如果假定你固定 status bar 的高度用于将内容定位在 status bar 的下方，那么现在必须更新你的的 App，才能根据用户的设备动态定位内容。 特别需要注意，当后台任务（如录音和位置跟踪）处于活动状态时，iPhone X上的状态栏不会改变高度。 重新考虑隐藏 status bar: iPhone X 较之显示高度为4.7“iPhone 的显示屏提供了更多的内容垂直空间，status bar 占据的只是扩展出来的屏幕区域。况且 status bar 更直观的显示用户有用的信息，如果非要隐藏状态栏，那最好用与这些信息同等重要的内容替代。 注意长宽比差异: iPhone X 具有不同于4.7“iPhone 的长宽比。因此，全屏4.7英寸iPhone 图形在iPhone X 上全屏显示时出现裁剪或 letterboxing 。同样，全屏iPhone X 图形全屏显示在4.7“iPhone 上时也会被裁剪或 pillarboxing ，因此要确保重要的视觉内容适配这两种尺寸。 避免交互式控件出现在屏幕底部和角落: iPhone X 提供了显示屏底部的滑动手势来访问主屏幕和应用程序切换器的新交互方式，这些手势可能会取消在此区域中实现的自定义手势。 况且屏幕的两个角落过多复杂的交互也不是最佳体验的良好实践。 不要遮挡或者特别修饰显示特性来引起用户注意: 请勿尝试隐藏设备的圆角、传感器外壳，或者通过在屏幕顶部和底部放置控件来访问主屏幕的引导。也要特别注意不要试图使用像括号，边框或各种符号等视觉修饰这些特殊区域。 为了轻松访问主屏幕允许自动隐藏指示器: 当开启自动隐藏时，如果用户离开屏幕几秒钟，指示器将消失。 当用户再次触摸屏幕时，它会重新出现。 这种行为应该只能用于提升观看体验，如播放视频或照片幻灯片。 色彩iPhone X 的显示器支持 P3 色彩空间，它可以产生比 sRGB 更丰富，更饱和的颜色。 可以使用 wide color 来增强视觉体验。 它可以让照片和视频更加逼真生动。 更多内容可以参考官网Color management（https://developer.apple.com/ios/human-interface-guidelines/visual-design/color/#color-management） 手势想必大家都在发布会上看到了，iPhone X 上的显示屏可以使用屏幕边缘手势来访问主屏幕，应用程序切换器，通知中心和控制中心。适应这个新变化的同时，对于开发者要特别注意： 避免干扰系统范围的屏幕边缘手势:用户依赖这些手势在每个 App 中操作，所以在极少数情况下，比如游戏这种强调沉浸式体验的 App 可能需要自定义的屏幕边缘手势，优先级高于系统的手势。 这种行为（称为边缘保护）应该谨慎使用，因为它使得用户难以访问系统级的操作。 更多内容参考官网Gestures （https://developer.apple.com/ios/human-interface-guidelines/user-interaction/gestures/） 补充的注意事项 认证方法准确:iPhone X 支持 Face ID进行身份验证。 如果你的 App 集成了 Apple Pay 或其他系统身份验证功能，请务必注意不要在 iPhone X 上引用 Touch ID。同样地，也请确保不要在支持Touch ID 的设备上引用 Face ID。 更详细的内容请参考Authentication(https://developer.apple.com/ios/human-interface-guidelines/user-interaction/authentication/) 不要重复增加系统提供的键盘功能:在 iPhone X上，即使使用自定义键盘，Emoji / Globe 按钮和 Dictation 按钮也自动显示在键盘的下方。 你的 App 不能影响这些按钮，因此避免在键盘中重复增加这些按钮造成混乱。 由于 iPhone X的屏幕比例发生变化，对于长期靠“等比缩放”完成适配的H5活动页而言也有不小的影响，需要对页面结构进行适当微调。 更详细内容请参阅Custom-keyboards(https://developer.apple.com/ios/human-interface-guidelines/extensions/custom-keyboards/) 判断 iPhone X 机型 (Swift)如何判断当前的设备是 iPhone X 呢？有好几种办法，可以考虑取得「iPhone 10,1」这样的 Module Name 来判断，也可以用屏幕分辨率的形式来判断。我觉得要用屏幕分辨率的方式来做，因为这是目前为止最简单也最不容易出错的。因为 iPhone X 只有一种分辨率，那就是 812pt x 375pt (@3x），且没有任何其他设备用了一样的分辨率，特别是高度。 于是写了一个基于 UIDevice 的扩展（或者其他任意方法也行）： 12345678extension UIDevice &#123; public func isX() -&gt; Bool &#123; if UIScreen.main.bounds.height == 812 &#123; return true &#125; return false &#125;&#125; 在代码中，就可以用 UIDevice.current.isX() 来判断是不是跑在 iPhone X 机型上，然后做一些或不做一些特殊的 Hack 了。 当然如果你习惯用三方库，也可以尝试“DeviceKit” 1234567let device = Device()print(device) // prints, for example, \"iPhone X\"if device == .iPhoneX &#123; // Do something&#125; else &#123; // Do something else&#125; 代码适配部分当我们能够判断出设备型号就可以配合系统版本进行适配了 适配 UITableView 组件12345678if (@available(iOS 11.0, *)) &#123; self.contentInsetAdjustmentBehavior = .never self.estimatedRowHeight = 0 self.estimatedSectionHeaderHeight = 0 self.estimatedSectionFooterHeight = 0&#125; else &#123; // Fallback on earlier versions&#125; 适配 UIScrollView 组件12345if (@available(iOS 11.0, *)) &#123; scrollView?.contentInsetAdjustmentBehavior = .never&#125; else &#123; // Fallback on earlier versions&#125; UITableView中的sectionHeader或者Footer显示不正常还有的发现某些界面tableView的sectionHeader、sectionFooter高度与设置不符的问题，在iOS11中如果不实现-tableView: viewForHeaderInSection:和-tableView: viewForFooterInSection:，则-tableView: heightForHeaderInSection:和- tableView: heightForFooterInSection:不会被调用，导致它们都变成了默认高度，这是因为tableView在iOS11默认使用Self-Sizing，tableView的estimatedRowHeight、estimatedSectionHeaderHeight、estimatedSectionFooterHeight三个高度估算属性由默认的0变成了UITableViewAutomaticDimension，解决办法简单粗暴，就是实现对应方法或把这三个属性设为0。 1234567if #available(iOS 11.0, *) &#123; tableView.estimatedRowHeight = 0; tableView.estimatedSectionHeaderHeight = 0; tableView.estimatedSectionFooterHeight = 0;&#125; else &#123; automaticallyAdjustsScrollViewInsets = false;&#125;; 适配网页加载不全下面有白边1234if #available(iOS 11.0, *) &#123; webView.scrollView.contentInsetAdjustmentBehavior = .never&#125; else &#123;&#125;; 适配iPhoneX不能铺满屏的问题给Brand Assets添加一张1125*2436大小的图片 打开Assets.xcassets文件夹，找到Brand Assets 右键Show in Finder 添加一张1125*2436大小的图片 修改Contents.json文件,添加如下内容 123456789&#123;&quot;extent&quot; : &quot;full-screen&quot;,&quot;idiom&quot; : &quot;iphone&quot;,&quot;subtype&quot; : &quot;2436h&quot;,&quot;filename&quot; : &quot;1125_2436.png”,&quot;minimum-system-version&quot; : &quot;11.0&quot;,&quot;orientation&quot; : &quot;portrait&quot;,&quot;scale&quot; : &quot;3x&quot;&#125; 使用 LaunchScreen.storyboard 设置启动图 使用 LaunchScreen.storyboard 文件将简单视图约束定位，实现各种尺寸的自适应。 适配iPhoneX12345//适配iPhoneXlet LL_iPhoneX = (kScreenW == Double(375.0) &amp;&amp; kScreenH == Double(812.0) ?true:false)let kNavibarH = LL_iPhoneX ? Double(88.0) : Double(64.0)let kTabbarH = LL_iPhoneX ? Double(49.0+34.0) : Double(49.0)let kStatusbarH = LL_iPhoneX ? Double(44.0) : Double(20.0) Xcode9 打包注意事项Xcode9 打包版本只能是8.2及以下版本,或者9.0及更高版本 Xcode9 不支持8.3和8.4版本 Xcode9 新打包要在构建版本的时候加入1024*1024 AppSore icon Xcode9 沿用了之前的分包设计，可以配置打出多种设备的包文件，用户安装时根据设备不同分别安装不同的API包，减小安装包大小。 iOS 11 相册权限变更iOS11以前： NSPhotoLibraryUsageDescription：访问相册和存储照片到相册（读写），会出现用户授权。 iOS11之后： NSPhotoLibraryUsageDescription：无需添加。默认开启访问相册权限（读），无需用户授权。 NSPhotoLibraryAddUsageDescription： 添加内容到相册。（写），会出现用户授权。","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/tags/Tips/"}]},{"title":"Jenkins + Fastlane 自动打包脚本","slug":"AutoBuildScript","date":"2017-06-20T13:55:38.000Z","updated":"2018-11-15T13:19:25.616Z","comments":true,"path":"2017/06/20/AutoBuildScript/","link":"","permalink":"https://reversescale.github.io/2017/06/20/AutoBuildScript/","excerpt":"使用 Jenkins 运行 Fastlane 命令，实现定时自动打包、修改版本号、上传 Fir 或者 TestFlight 等功能，从此再也不用被小伙伴追着要测试包。 三步配置，杜绝污染，一步操作自动上传~","text":"使用 Jenkins 运行 Fastlane 命令，实现定时自动打包、修改版本号、上传 Fir 或者 TestFlight 等功能，从此再也不用被小伙伴追着要测试包。 三步配置，杜绝污染，一步操作自动上传~ 📺 故事背景记得大约两年前，当时在创业公司，开发任务重，提测前常常加班到晚上 12 点，就算 bug 修完，也要看着 Xcode 不慌不忙的花半个多小时打包完成，再上传测试平台，发了邮件才能安心回家。鉴于这种惨痛经历，利用闲暇时间就搞一搞自动打包脚本，后期有配上 Jenkins，从此过上了没羞没臊的生活。（已适配 Xcode 8.2 之后版本） 🚀 框架的优势 1.市面上文件最少，使用最便捷的自动化打包脚本 2.冗余方法少，结构清晰，注释齐全 3.同时支持多平台上传，如：Dir、Fir、蒲公英、App Store等 4.具备较高自定义性 5.[自编脚本的时代] -&gt; [Fastlane 的时代] █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🚂 自编脚本的时代 [🚂 自编脚本的时代] 了解一下即可，有些准备工作提供参考，如环境已经配置好，请直接阅读 [🚄 Fastlane 的时代] 第一步 安装fir-cilfir-cli 使用 Ruby 构建, 无需编译, 只要安装相应 gem 即可. 12$ ruby -v # &gt; 1.9.3$ gem install fir-cli 常见的安装问题(1)使用系统自带的 Ruby 安装, 需确保 ruby-dev 已被正确的安装: 12$ xcode-select --install # OS X 系统$ sudo apt-get install ruby-dev # Linux 系统 (2)现 Permission denied 相关错误: 解决：在命令前加上 sudo (3)出现 Gem::RemoteFetcher::FetchError 相关错误: 解决：更换 Ruby 的淘宝源(由于国内网络原因, 你懂的), 并升级下系统自带的 gem12345678$ gem sources --remove https://rubygems.org/$ gem sources -a https://ruby.taobao.org/$ gem sources -l*** CURRENT SOURCES ***https://ruby.taobao.org# 请确保只有 ruby.taobao.org, 如果有其他的源, 请 remove 掉gem update --systemgem install fir-cli (4)Mac OS X 10.11 以后的版本, 由于10.11引入了 rootless, 无法直接安装 fir-cli, 有以下三种解决办法: 方法一： 使用 Homebrew 及 RVM 安装 Ruby, 再安装 fir-cli(推荐)12345# Install Homebrew:$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;# Install RVM:$ \\curl -sSL https://get.rvm.io | bash -s stable --ruby$ gem install fir-cli 方法二： 指定 fir-cli 中 bin 文件的 PATH1$ export PATH=/usr/local/bin:$PATH;gem install -n /usr/local/bin fir-cli 方法三： 重写 Ruby Gem 的 bindir12$ echo &apos;gem: --bindir /usr/local/bin&apos; &gt;&gt; ~/.gemrc$ gem install fir-cli 第二步 登录fir.im先到 https://fir.im 创建项目，得到 API Token 并复制。 1fir login 命令用于使用 API token 登录 fir.im, 并使用发布应用等相关命令. 1fir me 命令用于查看当前登录用户信息. 显示信息如下：12345678$ fir login XXX_YOUR_API_TOKEN_XXXI, [2016-03-08T12:48:56.499435 #13043] INFO -- : Login succeed, previous user&apos;s email: xxx@fir.imI, [2016-03-08T12:48:56.507044 #13043] INFO -- : Login succeed, current user&apos;s email: xxx@fir.imI, [2016-03-08T12:48:56.507147 #13043] INFO -- :$ fir meI, [2016-03-08T12:48:14.175488 #12986] INFO -- : Login succeed, current user&apos;s email: xxx@fir.imI, [2016-03-08T12:48:14.175687 #12986] INFO -- : Login succeed, current user&apos;s name: xxxI, [2016-03-08T12:48:14.175765 #12986] INFO -- : 第三步 下载并配置 shell 脚本1.把文件夹导入工程目录根目录下 2.配置 shell 脚本 12345678# 需要改动的地方 (根据项目具体信息改动)PROJECT_NAME = &quot;***&quot; #项目名称VERSION = &quot;1.0.0&quot; #打包版本号 会根据不同的版本创建文件夹（与项目本身的版本号无关）TAGREAT_NAME = &quot;***&quot; #项目对应target的名称如 &quot;Meifabao_User&quot; &quot;Miefabao_stylist&quot;CONFIGURATION = &quot;Release&quot; #打包的环境设置 Release 环境 Debug 环境PROFILE = &quot;AdHoc&quot; #配置文件分为四种 AdHoc Dev AppStore Ent 分别对应四种配置文件OUTPUT = &quot;./Packge/%s&quot; %(CONFIGURATION) #打包导出ipa文件路径（请确保 “%s” 之前的文件夹正确并存在） 根据具体项目填写 3.控制台到项目所在目录下，启动脚本(必要时加管理员权限) 可以将 autobuild.py 拖拽到控制台，执行脚本 注：其他的功能脚本由于实用性不高（其实我懒得搞），暂时没有适配，有兴趣的朋友可以自行配置试用，包括：邮件发送、打包 App Store 等等。 当看到 时，打包好的项目已经躺在你的 Fir 测试平台中了。 █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🚄 Fastlane 的时代2018.08.20 更新：Jenkins + Fastlane + GitLab + fir (或者蒲公英)第一步 安装 FastlaneFastlane 是一套使用Ruby写的自动化工具集，用于iOS和Android的自动化打包、发布等工作，可以节省大量的时间 1sudo gem install fastlane --verbose 第二步 移动脚本至项目目录下根据注释完善脚本配置信息 脚本说明： 支持版本号自增长 支持传入自定的宏，用于在代码里使用此预编译的宏来区分开发环境和发布环境 支持自动上传到 fir 和 testflight 上传成功后弹窗提示 第三步 上传上传到 fir 的用法：1./build.sh -m &quot;xxxx_app_test&quot; -t test 上传到 testflight 的用法：1./build.sh -m &quot;xxxx_app_pro&quot; -t pro 第四步 配置 JenkinsJenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。 下载 Jenkins：点击 http://mirrors.jenkins.io/war-stable/latest/jenkins.war 下载最新的Jenkins.war 运行服务器：需要先安装 java sdk （http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html） 1java -jar jenkins.war 运行 Jenkins1jenkins 配置 Jenkins：浏览器打开 http://localhost:8080/ 输入安全密码，安全密码命令行输出的一个文件里面。 然后自动安装推荐的插件，并新建管理员账号密码。 安装插件登录http://localhost:8080/ ，选择系统管理 - 管理插件。在可选插件中选择GitLab Plugin，Gitlab Hook Plugin，和 Cocoapod plugin 进行安装。 构建任务 点击新建，输入名称，构建一个自由风格的软件项目。 配置 Git 仓库地址，并添加 git 账号。 配置构建脚本 附录 执行脚本过程中遇到的问题和解决方案fir: command not found这个是因为没有安装fir-cil，导致找不到相应的命令行，只需要安装一下就行了，详情见上文写的如何安装fir-cil。 README: No such file or directory那是因为你的脚本目录下没有README的文件，只需要建一个README的文件就行了，打开终端，cd到当前位置，然后执行下面的命令： 1touch README ERROR – : Token can not be blank这个原因是因为你没有登录fir导致的，你执行这个脚本之前应该先登录一下fir，详情请看上文写的登录fir.im。 ERROR – : Code=14 (没有试用的设备 Domain=IDEDistributionErrorDomain Code=14 “No applicable devices原因：rvm ruby 配置错误 解决：控制台 rvm system █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 2018.08.20 更新：Jenkins 相关设置方法查看端口占用端口占用 使用 lsof 会列举所有占用的端口列表： 1lsof 使用less可以用于分页展示，如： 1lsof | less 也可以使用 -i 查看某个端口是否被占用，如： 1lsof -i:3000 杀死进程 1kill PID（进程的PID，如2044） Jenkins 改时区http://your-jenkins/systemInfo，查看user.timezone变量的值 在jenkins的【系统管理】-【脚本命令行】里运行 1System.setProperty(&apos;org.apache.commons.jelly.tags.fmt.timeZone&apos;, &apos;Asia/Shanghai&apos;) Jenkins 构建超时jenkins的”build timeout plugin”插件可以帮我们完成该任务。我使用的是jenkins-2.7.1, 默认就已经安装了该插件，如果默认没有安装可在插件管理中搜索进行安装。 Jenkins 定时构建和Poll SCM的区别 Build periodically：周期进行项目构建（源码是否发生变化没有关系） Poll SCM：定时检查源码变更，如果有更新就checkout最新code下来，然后执行构建动作 12345678910111213每15分钟构建一次：H/15 * * * * 或 */5 * * * *每天8点构建一次：0 8 * * *每天8点~17点，两小时构建一次：0 8-17/2 * * *周一到周五，8点~17点，两小时构建一次：0 8-17/2 * * 1-5每月1号、15号各构建一次，除12月：H H 1,15 1-11 **/5 * * * * （每5分钟检查一次源码变化）0 2 * * * （每天2:00 必须build一次源码） █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🕹 agvtool 命令行2018.08.20 更新：agvtool 命令行 管理版本号常用命令行：设置 版本号 为 1.1.01xcrun agvtool new-marketing-version 1.1.0 设置 build 号 自动加11xcrun agvtool next-version -all 简介agvtool 是一个命令行工具，允许你自动递增到下一个最高的数量或具体的数字这些数字。 修改Xcode的默认设置默认情况下，在不使用任何版本控制系统。设置版本系统苹果通用确保 Xcode 将包括在你的项目中生成的所有agvtool版本信息。 上图：设置当前项目的版本和版本控制系统的构建设置 设置你的版本号和 bulid 版本号agvtool 查询应用程序的 Info.plist 得到你的版本和 bulid 版本号。 所以确保 CFBundleVersion (Bundle version) 和 CFBundleShortVersionString (Bundle versions string, short）的 key 在你的 Info.plist 中。 上图：info.plist 命令行操作更新版本号退出Xcode，然后导航到包含项目的目录，运行下列命令在终端应用 agvtool 属性工作。 设置 版本号 为 1.1.01xcrun agvtool new-marketing-version 1.1.0 设置 build 号 自动加11xcrun agvtool next-version -all 设置 build 号为 311xcrun agvtool new-version -all 31 查看 Version Numbers1xcrun agvtool what-marketing-version 查看 Build Numbers1xcrun agvtool what-version 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Script","slug":"Script","permalink":"https://reversescale.github.io/categories/Script/"}],"tags":[{"name":"Script","slug":"Script","permalink":"https://reversescale.github.io/tags/Script/"}]},{"title":"GoF 设计模式 + 情景再现","slug":"Design patterns Gof","date":"2017-03-01T12:29:16.000Z","updated":"2018-11-15T13:19:15.263Z","comments":true,"path":"2017/03/01/Design patterns Gof/","link":"","permalink":"https://reversescale.github.io/2017/03/01/Design patterns Gof/","excerpt":"《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995），这几位作者常被称为”四人组（Gang of Four）”~","text":"《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995），这几位作者常被称为”四人组（Gang of Four）”~ 设计模式和情景再现创建型模式1、ABSTRACT FACTORY—追MM少不了请吃饭了，麦当劳的套餐和肯德基的套餐都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说“两个B套餐”就行了。麦当劳和肯德基就是B套餐的Abstract Factory, B套餐里含有汉堡, 鸡翅和饮料. 麦当劳或肯德基会根据B套餐的规格, 让汉堡Factory, 鸡翅Factory, 饮料Factory分别生产对应B套餐的材料。抽象工厂模式：客户类和工厂类分开。消费者任何时候需要某套产品集合时，只需向抽象工厂请求即可。抽象工厂会再向具体的工厂生产出符合产品集规格的产品。 2、BUILDER—MM最爱听的就是“我爱你”这句话了，见到不同地方的MM,要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出“我爱你”这句话了，国外的MM也可以轻松搞掂，这就是我的“我爱你”builder。（这一定比美军在伊拉克用的翻译机好卖）建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。 3、FACTORY METHOD—请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说“要一个汉堡”，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。 4、PROTOTYPE—跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype了。（100块钱一份，你要不要）原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。 5、SINGLETON—俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Singleton，她们只要说道“老公”，都是指的同一个人，那就是我。(刚才做了个梦啦，哪有这么好的事)单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。 结构型模式6、ADAPTER—在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的Adapter，让我和Sarah可以相互交谈了(也不知道他会不会耍我)适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。 7、BRIDGE—早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我“早上碰到MM新做了个发型怎么说”这种问题，自己用BRIDGE组合一下不就行了。桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。 8、COMPOSITE—Mary今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM都会用Composite模式了，你会了没有？合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。 9、DECORATOR—Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上“最好的的礼物，就是爱你的Fita”，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来……，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。 10、FACADE—我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。 11、FLYWEIGHT—每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。享元模式：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。 12、PROXY—跟MM在网上聊天，一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。 行为模式13、CHAIN OF RESPONSIBILITY—晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi,可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了，听说是个老处女呀，快跑!责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。 14、COMMAND—俺有一个MM家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送COMMAND，就数你最小气，才请我吃面。” :-(命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。 15、INTERPRETER—俺有一个《泡MM真经》，上面有各种泡MM的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟MM约会时，只要做一个Interpreter，照着上面的脚本执行就可以了。解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。 16、ITERATOR—我爱上了Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件”我：“什么条件我都答应，你说吧”Mary：“我看上了那个一克拉的钻石”我：“我买，我买，还有吗？”Mary：“我看上了湖边的那栋别墅”我：“我买，我买，还有吗？”……迭代子模式：迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。 17、MEDIATOR—四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。 18、MEMENTO—同时跟几个MM聊天时，一定要记清楚刚才跟MM说了些什么话，不然MM发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个MM说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。 19、OBSERVER—想知道咱们公司最新MM情报吗？加入公司的MM情报邮件组就行了，tom负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦观察者模式：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。 20、STATE—跟MM交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的MM就会说“有事情啦”，对你不讨厌但还没喜欢上的MM就会说“好啊，不过可以带上我同事么？”，已经喜欢上你的MM就会说“几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把MM的状态从不讨厌不喜欢变成喜欢哦。状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。 21、STRATEGY—跟不同类型的MM约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到MM的芳心，我的追MM锦囊中有好多Strategy哦。策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模式把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。 22、TEMPLATE METHOD——看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤(Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦(具体实现)；模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。 23、VISITOR—情人节到了，要给每个MM送一束鲜花和一张卡片，可是每个MM送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下Visitor，让花店老板根据MM的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。 设计模式之间的关系图： 设计模式的六大原则1、开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle）为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle）原则是尽量使用合成/聚合的方式，而不是使用继承。","categories":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/categories/Book/"}],"tags":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/tags/Book/"}]},{"title":"iOS 开发中常用的设计模式","slug":"Design patterns iOS","date":"2017-02-21T06:56:27.000Z","updated":"2018-11-15T13:23:48.042Z","comments":true,"path":"2017/02/21/Design patterns iOS/","link":"","permalink":"https://reversescale.github.io/2017/02/21/Design patterns iOS/","excerpt":"之前有朋友问到设计模式，便特意找了一篇文章，专门介绍在 iOS 开发中，对设计模式的具体应用，同时推荐一本书《Head First设计模式》~","text":"之前有朋友问到设计模式，便特意找了一篇文章，专门介绍在 iOS 开发中，对设计模式的具体应用，同时推荐一本书《Head First设计模式》~ （一）代理模式应用场景：当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。优势：解耦合敏捷原则：开放-封闭原则实例：tableview的 数据源delegate，通过和protocol的配合，完成委托诉求。列表row个数delegate自定义的delegate （二）观察者模式应用场景：一般为model层对，controller和view进行的通知方式，不关心谁去接收，只负责发布信息。优势：解耦合敏捷原则：接口隔离原则，开放-封闭原则实例：Notification通知中心，注册通知中心，任何位置可以发送消息，注册观察者的对象可以接收。kvo，键值对改变通知的观察者，平时基本没用过。 （三）MVC模式应用场景：是一中非常古老的设计模式，通过数据模型，控制器逻辑，视图展示将应用程序进行逻辑划分。优势：使系统，层次清晰，职责分明，易于维护敏捷原则：对扩展开放-对修改封闭实例：model-即数据模型，view-视图展示，controller进行UI展现和数据交互的逻辑控制。 （四）单例模式应用场景：确保程序运行期某个类，只有一份实例，用于进行资源共享控制。优势：使用简单，延时求值，易于跨模块敏捷原则：单一职责原则实例：[UIApplication sharedApplication]。注意事项：确保使用者只能通过 getInstance方法才能获得，单例类的唯一实例。java，C++中使其没有公有构造函数，私有化并覆盖其构造函数。object c中，重写allocWithZone方法，保证即使用户用 alloc方法直接创建单例类的实例，返回的也只是此单例类的唯一静态变量。 （五）策略模式应用场景：定义算法族，封装起来，使他们之间可以相互替换。优势：使算法的变化独立于使用算法的用户敏捷原则：接口隔离原则；多用组合，少用继承；针对接口编程，而非实现。实例：排序算法，NSArray的sortedArrayUsingSelector；经典的鸭子会叫，会飞案例。注意事项：1，剥离类中易于变化的行为，通过组合的方式嵌入抽象基类2，变化的行为抽象基类为，所有可变变化的父类3，用户类的最终实例，通过注入行为实例的方式，设定易变行为防止了继承行为方式，导致无关行为污染子类。完成了策略封装和可替换性。 （六）工厂模式应用场景：工厂方式创建类的实例，多与proxy模式配合，创建可替换代理类。优势：易于替换，面向抽象编程，application只与抽象工厂和易变类的共性抽象类发生调用关系。敏捷原则：DIP依赖倒置原则实例：项目部署环境中依赖多个不同类型的数据库时，需要使用工厂配合proxy完成易用性替换注意事项：项目初期，软件结构和需求都没有稳定下来时，不建议使用此模式，因为其劣势也很明显，增加了代码的复杂度，增加了调用层次，增加了内存负担。所以要注意防止模式的滥用。 设计模式六大原则1、开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle）为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle）原则是尽量使用合成/聚合的方式，而不是使用继承。 《Head First设计模式》http://pan.baidu.com/s/1nvTqSdj 验证码：DG58","categories":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/categories/Book/"}],"tags":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/tags/Book/"}]}]}