{"meta":{"title":"Technology","subtitle":"","description":"","author":"Steven's Blog","url":"https://reversescale.github.io"},"pages":[{"title":"Not found","date":"2018-11-15T12:15:47.151Z","updated":"2018-11-15T02:35:05.000Z","comments":true,"path":"404.html","permalink":"https://reversescale.github.io/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#fff;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#000;margin-top:260px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=5; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2018-01-25T14:41:06.000Z","comments":false,"path":"categories/index.html","permalink":"https://reversescale.github.io/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2015-08-16T06:58:08.000Z","updated":"2018-11-15T12:29:41.694Z","comments":false,"path":"about/index.html","permalink":"https://reversescale.github.io/about/index.html","excerpt":"","text":"Excellence is a continuous process and not an accident. Thanks for reading! ~ 👨🏻‍💻 职业：程序员劝退师📟 WeChat：WhatsXie🤪 不只生产 bug 更是 bug 的搬运工📮 邮件：ReverseScale@iCloud.com🤖 Github：https://github.com/ReverseScale 博客新装修，历史文章正在路上…"},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2018-01-25T14:41:06.000Z","comments":true,"path":"archives/index.html","permalink":"https://reversescale.github.io/archives/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2018-01-25T14:41:06.000Z","comments":true,"path":"tags/index.html","permalink":"https://reversescale.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用 ngrok 快速实现内网穿透","slug":"Ngrok through","date":"2018-08-13T03:56:27.000Z","updated":"2018-11-15T13:18:46.822Z","comments":true,"path":"2018/08/13/Ngrok through/","link":"","permalink":"https://reversescale.github.io/2018/08/13/Ngrok through/","excerpt":"实现内网穿透的工具很多，之所以介绍 ngrok，主要还是因为它使用便捷，不用搭建服务器等等麻烦的工序，适合前段开发过程中，快速评估检测项目~","text":"实现内网穿透的工具很多，之所以介绍 ngrok，主要还是因为它使用便捷，不用搭建服务器等等麻烦的工序，适合前段开发过程中，快速评估检测项目~ Ngrok是什么ngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放。 而我用来在家里快速访问 Jenkins，偷个懒🤪 搭建方法由于要完成一个网页优化的作业找了很久ngrok的使用方法，都不够简便易行最后终于发现了一个好方法。 下载 MAC 版的 ngrok：https://ngrok.com/download 解压到指定目录：Safari 浏览器下载 Mac OS X 环境一般直接解压（反正我是自动解压的），将 ngrok 放进项目目录。 进入到 ngrok 所在路径：1cd /tmp 开启服务1./ngrok http localhost:8080 会出现如下 ngrok 控制台 等待 Session Status 状态为 online（变绿），就可以在外网通过 Forwarding 的地址进行连接了。 注意：Forwarding地址中的 c33faf1b 不是固定的，在每次开始 ngrok 服务的时候都会变更，想固定？ ngrok:😛要钱。 测试一下例如： ngrok 穿透前在局域网中访问地址：http://localhost:8080 ngrok 穿透后局域网 + 公网访问地址：https://c33faf1b.ngrok.io","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/tags/Tips/"}]},{"title":"如何用 Swift 打造你的第一个区块链 App","slug":"How to build DApp","date":"2018-07-06T14:51:21.000Z","updated":"2018-11-15T13:19:04.032Z","comments":true,"path":"2018/07/06/How to build DApp/","link":"","permalink":"https://reversescale.github.io/2018/07/06/How to build DApp/","excerpt":"区块链(Blockchain) 是一种突破性技术(Disruptive Technologies)，近年渐获关注，号称将互联网从信息共享，推向价值传递，让我们一步一步的来探索它设计上的奇思妙想~","text":"区块链(Blockchain) 是一种突破性技术(Disruptive Technologies)，近年渐获关注，号称将互联网从信息共享，推向价值传递，让我们一步一步的来探索它设计上的奇思妙想~ 因为区块链是许多加密货币(Cryptocurrencies) 如比特币(Bitcoin)、以太坊(Ethereum)、莱特币(Litecoin) 的创始技术。那区块链是如何运作的呢？在本次的教学里，我将会谈到所有关于区块链技术的知识，以及如何用Swift 来制作自己的「区块链」。那么，让我们开始吧！ 区块链的运作顾名思义，区块链就是一个由不同的区块串连在一起的「链」，每个区块包含三则资讯：资料(Data)、杂凑值(Hash)、和前一个区块的杂凑值。 资料 ──依据使用情境，储存在区块的资料会因区块链的类型而不同。例如，在比特币区块链中，储存资料就是与交易有关的资讯，即是转帐的金额、以及参与交易二人的资讯。 杂凑值 ──你可以把杂凑想成是一种数位指纹，它是用来识别一个区块及其资料。杂凑最重要的地方，就是它是一个独一无二的字母数字(Alphanumeric)程式码，通常会由64个字元组成。当一个区块被创造时，杂凑值也同时产生。当一个区块被更动时，杂凑值也会同时被更动。透过这种方式，当你想要查看区块上的任何变动时，杂凑值就非常重要。 前一个区块的杂凑值 ──每个区块就是藉由储存前个区块的杂凑来链结在一起，组成一个区块链！这就是让区块链如此安全的原因。看看这张图片： 如你所见，每个区块由资料（未显示）、杂凑值、和前一个区块杂凑值所组成。举个例子，黄色区块包含了自己的杂凑值H7S6、和红色区块的杂凑值8SD9。以这种方式，它们组成了一个链结，并以此连结在一起。现在，假设有个骇客入侵并尝试更动红色区块。请记住，每次一个区块以任何方式被更动时，区块的杂值凑也会被更动！因此，当下一个区块执行确认、并看到前一个区块的杂凑值并不吻合时，它会有效地将自己从「链」中分离出来，而不会被骇客读取。 这就是区块练会如此安全的原因，你几乎不可能尝试回溯并更改任何资料。杂凑值提供了不错的保密及隐私，但还有两个安全机制来让区块链更加安全：验证(Proof-of-work)及智慧合约(Smart Contract)。虽然我不会详述，但你可以在这里了解更多。区块链最后一个保全方式就是基于它的位置。与大多储存在伺服器或是资料库内的资料不同，区块链使用点对点网路(Peer-To-Peer, P2P)，它是一种网路型态，允许任何人加入并将该网路上的资料分发给每位接收者。每当有人加入这个网路时，他们就会得到区块链的完整拷贝；每当有人建立一个新区块时，就会传送到网路内的所有人。然后，透过一些复杂的程式，让节点(Node)在加入这个区块到区块链之前，先确认该区块有否被窜改。就这样，任何地方的任何人都可以取得这些资讯。如果你是HBO矽谷群瞎传(Silicon Valley)的忠实粉丝，这听起来可能有点熟悉，因为在这出美剧里，主角就是用了类似的技术来建立一个全新网路。 因为每个人或节点都有一份区块链的拷贝，他们可以有共识并确认哪些区块是合法的。因此，如果你想要骇入一个区块，你必须骇入网路上超过50% 的区块来通过你的资讯。这就是为什么区块链或许是过去十年以来最安全的技术之一。 关于范例应用现在你了解区块链是如何运作了，那么开始来制作我们的范例App吧！请先下载初始项目。（https://raw.githubusercontent.com/appcoda/BlockchainDemo/master/BlockchainStarter.zip） 如你所见，我们有两个比特币钱包。第一个帐号Account 1065 拥有500 BTC，而第二个帐号0217 则什么都没有。我们利用传送按钮来传送比特币到其他帐号。为了赚取BTC，我们按下Mine 按钮就可以获得50 BTC 为奖励。基本来说，我们做的是当App 执行时，利用控制台来观察两个比特币帐号间的交易情况。 你会注意到，侧边栏里有两个重要的类别：Block及Blockchain。打开这些档案，你会看到档案是空的，那是因为我将会引导你写出这些类别的逻辑。那我们开始吧！ 在Swift 定义Block前往Block.swift并添加程式码以定义一个区块。首先，让我们了解一下区块是什么。我们先前定义了一个区块由三个部分组成：杂凑值、记录的实际资料、以及前一个区块的杂凑值。当我们想建立自己的区块链时，必须要知道区块的排序，这一点可以很容易地在Swift中定义。添加以下程式码到类别里： 1234var hash: String!var data: String!var previousHash: String!var index: Int! 现在，我们需要添加最后一个重要的程式码。我之前提到每次一个区块被更动，杂凑就会改变；这就是区块链如此安全的特色之一。所以我们必须建立一个函式来产生一个随机字母数字的杂凑。这个函式只需要几行程式码： 123func generateHash() -&gt; String &#123; return NSUUID().uuidString.replacingOccurrences(of: \"-\", with: \"\")&#125; NSUUID是一个物件，代表桥接UUID的通用唯一值。它内置于Swift中，而且非常适合用来产生32字元的字串。这个函式产生一个UUID，消除所有连字符(-)，然后回传String，即区块的杂凑。Block.swift现在应该看起来像这样： 我们已经定义了Block类别，接着让我们定义Blockchain类别吧。切换到Blockchain.swift。 在Swift 定义Blockchain如前文所说，让我们尝试从基本面来了解区块链。在基本的术语里，区块链只是区块串在一起组成的链；换句话说，它是一个包含所有项目的列表。听起来是不是有点熟悉呢？因为这就是阵列的定义，而这个阵列就是由区块所组成！让我们把下列的程式码加进去吧： 1var chain = [Block]() 小提示：这几乎可以应用在电脑科学世界的所有事上。如果你曾遇过大问题，试着将它拆解成小组件，然后以自己的方法来解决问题；就像我们弄清楚如何在Swift中加入区块及区块链一样！ 你会注意到在阵列里面包含了先前定义的Block类别，那是我们在区块链中需要的所有变数。加入两个函式到类别里，我们就完成了。试着用我前文所教的来回答这个问题： 在一个区块链中，两个主要的函式是什么？ 希望你能够回答这个问题！这两个区块链拥有的主要函式，是用来建立初始区块，以及在后面新增新的区块。当然，现在我不会下放这个链并加入智慧合约，但是这些是基本函式！加入以下程式码到Blockchain.swift： 1234567891011121314151617func createGenesisBlock(data:String) &#123; let genesisBlock = Block() genesisBlock.hash = genesisBlock.generateHash() genesisBlock.data = data genesisBlock.previousHash = \"0000\" genesisBlock.index = 0 chain.append(genesisBlock)&#125; func createBlock(data:String) &#123; let newBlock = Block() newBlock.hash = newBlock.generateHash() newBlock.data = data newBlock.previousHash = chain[chain.count-1].hash newBlock.index = chain.count chain.append(newBlock)&#125; 我们加入的第一个函式是用来建立初始区块。为此，我们建立了一个函式来把区块的资料作为Input。然后，我们定义一个名为genesisBlock的变数，并将它设为Block型别。因为它是Block型别，所以它有我们之前在Block.swift定义的所有变数及函式。我们设定generateHash()为杂凑、 Input data为资料。因为这是第一个区块，所以我们将前一个区块的杂凑设定为000，好让我们知道这是初始区块。我们将它的索引值设为0 ，然后放到区块链chain。 我们建立的下一个函式则适用于所有genesisBlock后的区块，而它会建立剩下的所有区块。你会注意到它跟之前的函式非常相似，唯一的不同的是我们将previousHash设定为前一个区块的杂凑，并将index设为它在区块练的位置。完成了！我们已经成功定义自己的Blockchain！你的程式码应该如下图所示！ 接着，我们将所有的部分连接到ViewController.swift档案，并看看执行成果吧！ 钱包后台(Wallet Backend)切换到ViewController.swift，我们可以看到所有的UI元件都已经连结完毕。我们所需要做的就是处理交易，并将交易列印到控制台上。然而在开始之前，我们应该稍微探讨一下比特币区块链。比特币来自一个总帐号，假设这个帐号的编号是000。当你挖掘一颗比特币时，就表示你解答了数学问题，并获得一定数量的比特币作为奖励。这是发行货币一个很聪明的方法，同时也创造了让更多人去挖掘的动机。在我们的App 里，我们将100 BTC 作为奖励。首先，让我们在ViewController 添加需要的变数： 123456let firstAccount = 1065let secondAccount = 0217let bitcoinChain = Blockchain()let reward = 100var accounts: [String: Int] = [\"0000\": 10000000]let invalidAlert = UIAlertController(title: \"Invalid Transaction\", message: \"Please check the details of your transaction as we were unable to process this.\", preferredStyle: .alert) 我们定义两个帐号：一个编号为1065，另一个编号为0217。我们同时新增一个bitcoinChain变数来作为我们的区块链，并将reward设定为100。我们需要一个作为比特币来源的主帐号：这是我们的初始帐号，编号为0000，它拥有一千万个比特币。你可以把这个帐号当成银行，在每一次的奖励中，就会从中取出100个比特币，并转至合法的帐号里。我们也定义一个警告，在每次交易无法完成时显示。 现在，让我们来写些将会执行的泛用函式。你可以猜到这些函式是什么吗？ 第一个函式是用来处理交易的。我们要确认传送者及接收者的帐号中，接收或扣除的金额是正确的，而且这个资讯会被记录在我们的区块链上。 下一个函式是要在控制台里印出完整的纪录，它会显示每个区块及每个区块内的资料。 最后一个函式是用来验证区块链是否合法，方法为确认前个区块的杂凑是否符合下一个区块的资讯。因为我们不会示范任何骇客方法，所以范例中的链永远都是合法的。 Transaction 函式以下是我们的泛用交易函式。在定义变数之下输入以下程式码： 1234567891011121314151617181920212223242526func transaction(from: String, to: String, amount: Int, type: String) &#123; // 1 if accounts[from] == nil &#123; self.present(invalidAlert, animated: true, completion: nil) return &#125; else if accounts[from]!-amount &lt; 0 &#123; self.present(invalidAlert, animated: true, completion: nil) return &#125; else &#123; accounts.updateValue(accounts[from]!-amount, forKey: from) &#125; // 2 if accounts[to] == nil &#123; accounts.updateValue(amount, forKey: to) &#125; else &#123; accounts.updateValue(accounts[to]!+amount, forKey: to) &#125; // 3 if type == \"genesis\" &#123; bitcoinChain.createGenesisBlock(data: \"From: \\(from); To: \\(to); Amount: \\(amount)BTC\") &#125; else if type == \"normal\" &#123; bitcoinChain.createBlock(data: \"From: \\(from); To: \\(to); Amount: \\(amount)BTC\") &#125;&#125; 看起来程式码很多，但是它的核心只是为每次的交易定义一些规则。在开头的地方，我们有四个参数：to、from、amount以及type。To、From、及Amount的含义一目了然，而Type基本上就是定义交易的类型。这里有两种Type：Normal和Genesis。一个Normal的交易类型会是在帐号1065与0217之间进行，而Genesis交易类型则会涉及到帐号0000。 第一个if-else条件式是关于来源帐号。如果来源帐号不存在或金额不足，我们会显示交易无效的警告，然后结束函式。而如果通过的话，我们会更新数值。 第二个if-else条件式是关于接收帐号。如果接收帐号不存在，那么我们随它而去，然后结束函式。要不然，我们就会传送正确的比特币数量到帐号。 第三个if-else条件式处理交易的类型。如果一个交易涉及初始区块，我们就建立一个新的初始区块；反之我们建立一个新区块来储存资料。 Printing 函式在每次交易的最后，我们想要看到一个清单列出所有交易，来确保我们知道所有发生的事情。以下是我们在transaction函式下输入的程式码： 123456789func chainState() &#123; for i in 0...bitcoinChain.chain.count-1 &#123; print(\"\\tBlock: \\(bitcoinChain.chain[i].index!)\\n\\tHash: \\(bitcoinChain.chain[i].hash!)\\n\\tPreviousHash: \\(bitcoinChain.chain[i].previousHash!)\\n\\tData: \\(bitcoinChain.chain[i].data!)\") &#125; redLabel.text = \"Balance: \\(accounts[String(describing: firstAccount)]!) BTC\" blueLabel.text = \"Balance: \\(accounts[String(describing: secondAccount)]!) BTC\" print(accounts) print(chainValidity())&#125; 这是一个简单的for回圈，包含bitcoinChain的每个区块。我们印出区块的编号、杂凑值、前个区块的杂凑、以及储存的资料，再更新UILabel来显示每个帐号内正确的BTC数目。最后，印出一个列出每个帐号的清单（应该会有三个），并验证链的合法性。现在，你应该会在函式最后一行中发生错误。这是因为我们还没定义chainValidity()函式，那么就来开始吧！ Validity 函式记住，如果前一个区块的杂凑值符合目前区块所描述的内容，那么这一个链就是合法的。我们可以轻易地用另一个for 回圈来重复验证每个区块。 123456789func chainValidity() -&gt; String &#123; var isChainValid = true for i in 1...bitcoinChain.chain.count-1 &#123; if bitcoinChain.chain[i].previousHash != bitcoinChain.chain[i-1].hash &#123; isChainValid = false &#125; &#125; return \"Chain is valid: \\(isChainValid)\\n\"&#125; 跟之前有点相似，我们在bitcoinChain中重复验证每个区块，来确认前一个区块的杂凑值是否与目前区块所描述的内容符合。这样就完成了！我们已经定义了函式，并将会每次都用到它们！你的ViewController.swift现在应该看起来像这样： 现在我们只需要将按钮连接到函式就完成了，来开始最后的篇章吧！ 将所有东西连结在一起当我们的App首次启动时，我们想让初始帐号0000传送50 BTC到我们的第一个帐号。然后，我们将让第一个帐号传送10 BTC到第二个帐号。这个步骤仅需三行程式码就可以完成。如此更改你的viewDidLoad函式： 1234567override func viewDidLoad() &#123; super.viewDidLoad() transaction(from: \"0000\", to: \"\\(firstAccount)\", amount: 50, type: \"genesis\") transaction(from: \"\\(firstAccount)\", to: \"\\(secondAccount)\", amount: 10, type: \"normal\") chainState() self.invalidAlert.addAction(UIAlertAction(title: \"OK\", style: .default, handler: nil))&#125; 我们使用先前定义好的函式，并在最后呼叫chainState()。同时，我们新增一个OK按钮到交易无效的警告中。现在让我们来看看剩下的四个函式里要加入什么：redMine()、blueMine()、redSend()及blueSend()。 挖矿函式挖矿函式非常地简单，只要三行程式码就行了。这就是我们要添加的程式码： 1234567891011@IBAction func redMine(_ sender: Any) &#123; transaction(from: \"0000\", to: \"\\(firstAccount)\", amount: 100, type: \"normal\") print(\"New block mined by: \\(firstAccount)\") chainState()&#125; @IBAction func blueMine(_ sender: Any) &#123; transaction(from: \"0000\", to: \"\\(secondAccount)\", amount: 100, type: \"normal\") print(\"New block mined by: \\(secondAccount)\") chainState()&#125; 在第一个挖矿函式中，我们使用transaction函式从初始帐号传送100 BTC到第一个帐号，先印出一个区块被挖出，再印出chainState。同样地，我们在blueMine函式里将100 BTC传送到第二个帐号。 传送函式传送函式与先前的函式也稍微相似。 123456789101112131415161718192021@IBAction func redSend(_ sender: Any) &#123; if redAmount.text == \"\" &#123; present(invalidAlert, animated: true, completion: nil) &#125; else &#123; transaction(from: \"\\(firstAccount)\", to: \"\\(secondAccount)\", amount: Int(redAmount.text!)!, type: \"normal\") print(\"\\(redAmount.text!) BTC sent from \\(firstAccount) to \\(secondAccount)\") chainState() redAmount.text = \"\" &#125;&#125; @IBAction func blueSend(_ sender: Any) &#123; if blueAmount.text == \"\" &#123; present(invalidAlert, animated: true, completion: nil) &#125; else &#123; transaction(from: \"\\(secondAccount)\", to: \"\\(firstAccount)\", amount: Int(blueAmount.text!)!, type: \"normal\") print(\"\\(blueAmount.text!) BTC sent from \\(secondAccount) to \\(firstAccount)\") chainState() blueAmount.text = \"\" &#125;&#125; 首先，我们确认redAmount或blueAmount中的文字栏位是否为空值。如果是，我们会显示一个交易无效的警告。如果不是，我们就可以继续。我们使用transaction函式输入金额，并把交易设为normal型态，以将第一个帐号的金额传送到第二个帐号（或相反）。我们印出被传送的金额，然后呼叫chainState()函式。最后，把文字栏位清空。这样我们就完成啰！确认一下你的程式码是否符合下图所示。 执行App 试试看！从前端来说，它看起来就如一个普通的交易App，但你会知道它后台的运作。试试使用App 将BTC 从一个帐号交易给另一个帐号、并试着欺骗App 吧！ 结论在这次的教学中，你学到了如何使用Swift 来建立一个区块链，并建立自己的比特币交易。请注意在真实的加密货币后台里，实作部分是跟上文是完全不一样的东西，因为它需要藉由智慧合约来分散，但是上面的示范内容用来学习的。在这个范例中，我们运用了比特币来当加密货币，但你能想到区块链还的其他用途吗？欢迎在下面留言分享你的看法！希望你在此学到新的东西！你可以在Github下载完整项目作参考。 完整项目：https://github.com/appcoda/BlockchainDemo原文链接：https://www.appcoda.com/blockchain-introduction/","categories":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://reversescale.github.io/categories/Blockchain/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://reversescale.github.io/tags/Blockchain/"}]},{"title":"ReactNative 开发常用命令行（持续更新）","slug":"ReactNative command","date":"2018-03-29T14:56:27.000Z","updated":"2018-11-15T13:53:41.655Z","comments":true,"path":"2018/03/29/ReactNative command/","link":"","permalink":"https://reversescale.github.io/2018/03/29/ReactNative command/","excerpt":"记录一些 ReactNative 常用的命令行，包括了例如安装、启动服务、插件管理、热更新等一些日常经常使用的命令，会随着使用的深入不断的补充 ~","text":"记录一些 ReactNative 常用的命令行，包括了例如安装、启动服务、插件管理、热更新等一些日常经常使用的命令，会随着使用的深入不断的补充 ~ Node 相关查看所有安装的node版本信息：1nvm list 查看更新了的node的版本(可能需要翻墙)：1nvm ls-remote 安装node：1nvm install v7.4.0 设置默认的node版本(这里设置成了7.4.0)，解决有些版本有些兼容性的问题：1nvm alias default v7.4.0 React 相关卸载命令：1npm uninstall -g react-native-cli 安装命令：1npm install -g react-native-cli 查看某个模块最新发布版本信息(这里查看react-native发布的版本信息)：1npm info react-native 升级或者降级react-native的版本并且更新package.json，需要用在react-native项目目录下：1npm install --save react-native@0.41.1 新建 react-native 项目并指定版本：1react-native init demo --version 0.40.0 开启服务：1react-native start 运行Android：1react-native run-android 运行iOS：1react-native run-ios 版本查看：1react-native --version 项目版本查看：1react-native -v 查看react-native的帮助信息：1react-native --help 使用 Cocoapods 管理 ReactNativePodfile 文件格式：1234567891011pod &apos;React&apos;, :path =&gt; &apos;./node_modules/react-native&apos;, :subspecs =&gt; [ &apos;Core&apos;, &apos;RCTText&apos;, &apos;RCTImage&apos;, &apos;RCTActionSheet&apos;, &apos;RCTGeolocation&apos;, &apos;RCTNetwork&apos;, &apos;RCTSettings&apos;, &apos;RCTVibration&apos;, &apos;RCTWebSocket&apos;, ] ReactNative 0.42.0 以上版本需在 Podfile 配置 yoga：12# 如果你的RN版本 &gt;= 0.42.0，请加入下面这行pod &quot;yoga&quot;, :path =&gt; &quot;./node_modules/react-native/ReactCommon/yoga&quot; 开源组件库：安装最新版本：1npm install react-native-tab-navigator --save 安装指定版本：1npm install --save react-native-tab-navigator@0.4.0 react-native 集成组件绑定(ReactNative 0.27以后，自集成RNPM)：1react-native link react-native-splash-screen 常用开源库：12345678npm install --save react-native-tab-navigator@0.4.0npm install --save react-native-scrollable-tab-view@0.7.0npm install --save react-native-check-box@1.0.4npm install --react-native-easy-toast@1.0.9npm install --save GitHubTrending@2.0.0npm install --save react-native-htmlview@0.5.0npm install --save react-native-popover@0.5.0npm install --react-native-splash-screen@2.0.0 Code-Push 常用命令Code-Push 推包命令：1code-push release-react &lt;appName&gt; &lt;platform&gt; [options] 示例： 1code-push release-react RNAPPGithub ios --t 1.0.2 --dev false --d Staging --des &quot;1.热更新相关设置&quot; --m true Code-Push 线上查看更新：1code-push deployment ls RNAPPGithub Code-Push 查看项目Key：1code-push deployment ls RNAPPGithub -k Code-Push iOS更新打包方法：1react-native bundle --platform ios --entry-file index.js --bundle-output release_ios/main.jsbundle --assets-dest release_ios/ --dev fasle IDE 技巧《使用VS Code调试React-Native程序》（https://jingyan.baidu.com/article/ad310e80fb13fc1849f49ed1.html）","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/tags/Tips/"}]},{"title":"ReactNative 学习成果总结","slug":"ReactNative APP","date":"2018-03-29T11:56:27.000Z","updated":"2018-11-15T13:45:53.356Z","comments":true,"path":"2018/03/29/ReactNative APP/","link":"","permalink":"https://reversescale.github.io/2018/03/29/ReactNative APP/","excerpt":"ReactNative 这几年风生水起，当然除了 React 社区生态圈的加持和 Facebook 的大力推广以外，另外一个最主要的原因就是其在开发效率和应用性能方面取得了一个比较好的平衡~","text":"ReactNative 这几年风生水起，当然除了 React 社区生态圈的加持和 Facebook 的大力推广以外，另外一个最主要的原因就是其在开发效率和应用性能方面取得了一个比较好的平衡~ 学习课程：《双平台真实开发GitHub App React Native技术全面掌握》399 大洋，含着泪吃了一个月泡面.. Github 代码库：https://github.com/ReverseScale/RNAPPGithub.git 知识点： 1.整理 ReactNative 网络封装及常用的三方模块 2.ReactNative 的 AsyncStorage数据库技术、离线缓存 3.ReactNative 的数据 DAO 层设计技巧，数据状态实时更新 4.ReactNative 的代码提取技巧，组合模式应用技巧，数据异步刷新与动态添加 5.ReactNative 的版本升级、数据统计、社会化分享、第三方登录，热更新等 6.ReactNative 项目发布前的优化、打包与上线 目录结构： 生命周期及使用场景 项目介绍 组件化 集成与管理 布局约束 组件封装 本地持久化 网络请求封装 功能调试 双平台适配 开源组件库的使用 热更新 生命周期及使用场景常用方法： constructor: componentWillMount: render: componentDidMount: componentWillReceiveProps: shouldComponentUpdate: componentWillUpdate: componentDidUpdate componentWillUnmount: constructor:在组件创建的时候调用一次,这个方法进行this.state初始化状态机。123456constructor(props) &#123; super(props); // 初始状态 this.state = &#123; isShow:true &#125;;&#125; componentWillMount:在组件生命周期中只会被执行一次,在初始渲染(render函数)前被执行。注意: 如果这个函数通过setState函数修改状态机变量,RN框架不会额外执行渲染(界面刷新) 如果子组件也有componentWillMount函数使用,会在父组件之后调用 需要从本地存储中读取数据用于显示,常用这个函数 render:该函数组件必有的，通过返回JSX或其他组件来构成DOM，换言之，就是组件的核心渲染过程。 componentDidMount:在React Native组件的生命周期中,这个函数只会被执行一次，它在初始渲染完成后会马上被调用。在这之后开发者可以通过子组件的引用来访问，操作任何子组件。如果RN组件的子组件也有componentDidMount函数，并会在父组件的componentDidMount函数之前被调用。 常用来网络请求数据 componentWillReceiveProps:在React Native组件的初始渲染完成后，props改变时，这个函数被调用，参数是个新的props。 shouldComponentUpdate:React Native组件的初始渲染执行完成后, RN组件接收到新的state或者props时这个函数会调用。 通过这个函数阻止无必要的重新渲染，是提高React Native应用程序性能的一大技巧。 componentWillUpdate:初始渲染完成后,重新渲染前会调用这个函数。 这个函数不能通过this.setState再次改变状态机变量的值。 组件更新时调用。 componentDidUpdateRN组件初始渲染完成后，RN框架在重新渲染RN组件完成后调用。参数是渲染前的props和state。 组件更新完毕时调用。 componentWillUnmount:ReactNative 组件被卸载前会调用，通常做一些清理内容。 项目介绍双平台效果预览： React Native是React在移动端的跨平台方案。如果想更快地理解和掌握React Native开发，就必须先了解React。 React是FaceBook开源的一个前端框架，它起源于 Facebook 的内部项目，并于 2013 年 5 月开源。因为React 拥有较高的性能，代码逻辑非常简单，所以越来越多的人已开始关注和使用它，目前该框架在Github上已经有7万+star。 ReactNative 技术导图： 组件化React采用组件化的方式开发，通过将view构建成组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。有一句话说的很形象：在React中，构建应用就像搭积木一样。 组件化特征React认为一个组件应该具有如下特征： 可组合（Composeable）：一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部。如果一个组件内部创建了另一个组件，那么说父组件拥有它创建的子组件，通过这个特性，一个复杂的UI可以拆分成多个简单的UI组件； 可重用（Reusable）：每个组件都是具有独立功能的，它可以被使用在多个UI场景； 可维护（Maintainable）：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护； 封装好的导航栏就可以被称之为一个组件，它符合上述三个特点： 可组合：可以将导航栏组件放在页面组件中作为页面组件的子组件。而且在导航栏组件的内部，也有按钮组件等子组件。 可重用：如果封装好了该组件，就可以放在任意需要导航栏的页面（组件）使用，也可以放在其他项目中使用。 可维护：因为具有独立的功能和展示逻辑，所以便于定位和修改。 组件的属性与状态在React Native（React.js）里，组件所持有的数据分为两种： 属性（props）：组件的props是不可变的，它只能从其他的组件（例如父组件）传递过来。 状态（state）：组件的state是可变的，它负责处理与用户的交互。在通过用户点击事件等操作以后，如果使得当前组件的某个state发生了改变，那么当前组件就会触发render()方法刷新自己。 我们可以看到这个页面有两个子页面，一个是‘最热’页面（组件），另一个是‘趋势‘页面（组件）。那么这两个组件都有什么props和state呢？ 1.props：由于props是从其父组件传递过来的，那么可想而知，props的声明应该是在当前组件的父组件里来做。在React Native中，通常props的声明是和当前组件的声明放在一起的： 1234//最热子页面&lt;FavoriteTabPage &#123;...this.props&#125; tabLabel='最热' flag=&#123;FlAG_STORAGE.flag_popular&#125;/&gt;//趋势子页面&lt;FavoriteTabPage &#123;...this.props&#125; tabLabel='趋势' flag=&#123;FlAG_STORAGE.flag_trending&#125;/&gt; 在这里，收藏页面是父组件，而最热页面和趋势页面是其子组件。在收藏页面组件里声明了最热页面和趋势页面的组件。 而且我们也可以看到，最热页面和趋势页面组件都用的是同一个组件：FavoriteTabPage，而这两个页面的不同点只在于传入的两个props的不同：tabLabel和flag。 而在FavoriteTabPage组件内部，如果想调用flag这个props，可以使用this.props.flag来调用。 2.state: 下面是最热和趋势页面的组件： 12345678class FavoriteTabPage extends Component&#123;//组件的构造方法constructor(props)&#123; super(props); this.state=&#123; dataSource:new ListView.DataSource(&#123;rowHasChanged:(r1,r2)=&gt;r1!==r2&#125;),isLoading:false, &#125;&#125; 这里面定义了两个state: dataSource:列表的数据源 isLoading:是否正在刷新 这两个state都是将来可能经常变化的。比如在网络请求以后，列表的数据源会被替换掉，这个时候就要调用: 1234this.setState(&#123; //把新的值newDataArr对象传给dataSource dataSource:newDataArr&#125;) 3.DOMDOM 是前端的一个概念，暂时可以粗略理解为一个页面的树形结构。React 生命周期的三大阶段 Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM 在每个阶段都有相应的状态和与之对应的回调函数，具体可以看下图： 上图来自：贾鹏辉的技术博客：React Native之React速学教程(中) 集成与管理1.指定版本初始化在终端输入react-native demo –version 0.40.0命令以后，就会初始化一个React Native版本为0.40.0的项目。这个最初项目里面直接就包含了iOS和Android的工程文件夹，可以用对应的IDE打开后编译运行。 在新建一个React Native项目之后的根目录结构是这样的： 2.使用 Cocoapods 管理 ReactNativePodfile 文件格式：1234567891011pod &apos;React&apos;, :path =&gt; &apos;./node_modules/react-native&apos;, :subspecs =&gt; [ &apos;Core&apos;, &apos;RCTText&apos;, &apos;RCTImage&apos;, &apos;RCTActionSheet&apos;, &apos;RCTGeolocation&apos;, &apos;RCTNetwork&apos;, &apos;RCTSettings&apos;, &apos;RCTVibration&apos;, &apos;RCTWebSocket&apos;, ] ReactNative 0.42.0 以上版本需在 Podfile 配置 yoga：12# 如果你的RN版本 &gt;= 0.42.0，请加入下面这行pod &quot;yoga&quot;, :path =&gt; &quot;./node_modules/react-native/ReactCommon/yoga&quot; 输入react-native run-ios或者react-native run-android指令， 就会自动打开模拟器运行项目(前提是安装了相应的开发环境)。 但是一个比较完整的项目仅仅有这些类别的文件是不够的，还需要一些工具类，模型类，资源等文件。为了很好地区分它们，使项目结构一目了然，需要组织好项目文件夹以及类的命名，下面是我将教程里的文件夹命名和结构稍加修改后的一个方案，可供大家参考： 布局约束采用Flex布局的元素，被称为Flex container，其所有子元素被称为Flex item；容器默认存在两个轴，分别是主轴（main axis）和垂直的交叉轴（cross axis）,主轴开始的位置叫做main start，结束的位置叫main end；交叉轴的开始位置叫做cross start，结束的位置叫做cross end；单个item占据的主轴空间叫做main size，占据的交叉轴控件叫做cross size。 如下图所示： 组件化驱动下，搜索结果页中展示的 Cell 与之前的列表页 Cell 可以重用： 我们把该组件定名为：RespositoryCell，结合代码来看一下具体的实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960export default class RepositoryCell extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; isFavorite: this.props.projectModel.isFavorite, favoriteIcon: this.props.projectModel.isFavorite ? require('../../res/images/ic_star.png') : require('../../res/images/ic_unstar_transparent.png'), &#125;; &#125; componentWillReceiveProps(nextProps) &#123; this.setFavoriteState(nextProps.projectModel.isFavorite) &#125; setFavoriteState(isFavorite) &#123; this.props.projectModel.isFavorite = isFavorite; this.setState(&#123; isFavorite: isFavorite, favoriteIcon: isFavorite ? require('../../res/images/ic_star.png') : require('../../res/images/ic_unstar_transparent.png') &#125;) &#125; onPressFavorite() &#123; this.setFavoriteState(!this.state.isFavorite) this.props.onFavorite(this.props.projectModel.item, !this.state.isFavorite) &#125; render() &#123; let item = this.props.projectModel.item? this.props.projectModel.item:this.props.projectModel; let favoriteButton=this.props.projectModel.item? &lt;TouchableOpacity style=&#123;&#123;padding:6&#125;&#125; onPress=&#123;()=&gt;this.onPressFavorite()&#125; underlayColor='transparent'&gt; &lt;Image ref='favoriteIcon' style=&#123;[&#123;width: 22, height: 22,&#125;,this.props.theme.styles.tabBarSelectedIcon]&#125; source=&#123;this.state.favoriteIcon&#125;/&gt; &lt;/TouchableOpacity&gt;:null; return ( &lt;TouchableOpacity onPress=&#123;this.props.onSelect&#125; style=&#123;styles.container&#125; &gt; &lt;View style=&#123;styles.cell_container&#125;&gt; &lt;Text style=&#123;styles.title&#125;&gt;&#123;item.full_name&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.description&#125;&gt;&#123;item.description&#125;&lt;/Text&gt; &lt;View style=&#123;styles.row&#125;&gt; &lt;View style=&#123;styles.row&#125;&gt; &lt;Text&gt;Author:&lt;/Text&gt; &lt;Image style=&#123;&#123;height: 22, width: 22&#125;&#125; source=&#123;&#123;uri: item.owner.avatar_url&#125;&#125; /&gt; &lt;/View&gt; &lt;View style=&#123;&#123;justifyContent: 'space-between', flexDirection: 'row'&#125;&#125;&gt; &lt;Text&gt;Star:&lt;/Text&gt; &lt;Text&gt;&#123;item.stargazers_count&#125;&lt;/Text&gt; &lt;/View&gt; &#123;favoriteButton&#125; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) &#125;&#125; 这里声明了RespositoryCell组件，它继承于Component，也就是组件类，即是说，声明组件的时候必须都要继承与这个类。 集中看一下该组件的render方法，它返回的是该组件的实际布局：在语法上使用JSX，类似于HTML的标签式语法，很清楚地将cell的层级展现了出来： 最外层被一个View组件包裹着，里面第一层有三个子组件：两个Text组件和一个作为底部背景的View组件。 底部背景的View组件又有三个子组件：View组件（显示作者信息），View组件（显示star信息）,收藏按钮。 结构分解图： 组件封装 我的页面 个人中心 对于“我的页面”和“个人中心”这类结构相似的页面，建议进行组件封装，封装后的 AboutPage 实现代码简洁如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768export default class AboutPage extends Component&#123; constructor(props) &#123; super(props); this.aboutCommon=new AboutCommon(props,(dic)=&gt;this.updateState(dic),FLAG_ABOUT.flag_about,config); this.state = &#123; projectModels: [], author:config.author &#125; &#125; componentDidMount() &#123; this.aboutCommon.componentDidMount(); &#125; componentWillUnmount() &#123; this.aboutCommon.componentWillUnmount(); &#125; updateState(dic)&#123; this.setState(dic); &#125; onClick(tab) &#123; let TargetComponent, params = &#123;...this.props,menuType:tab&#125;; switch (tab) &#123; case MORE_MENU.About_Author: TargetComponent = AboutMePage; break; case MORE_MENU.Website: TargetComponent = WebViewPage; params.title='GitHubPopular'; var url='https://reversescale.github.io'; params.url=url; break; case MORE_MENU.Feedback: var url='mailto://reversescale@icloud.com'; Linking.canOpenURL(url).then(supported =&gt; &#123; if (!supported) &#123; console.log('Can\\'t handle url: ' + url); &#125; else &#123; return Linking.openURL(url); &#125; &#125;).catch(err =&gt; console.error('An error occurred', err)); break; case MORE_MENU.Share: break; &#125; if (TargetComponent) &#123; this.props.navigator.push(&#123; component: TargetComponent, params: params, &#125;); &#125; &#125; render() &#123; let content=&lt;View&gt; &#123;this.aboutCommon.renderRepository(this.state.projectModels)&#125; &#123;ViewUtils.getSettingItem(()=&gt;this.onClick(MORE_MENU.Website), require('../../../res/images/ic_computer.png'), MORE_MENU.Website, this.props.theme.styles.tabBarSelectedIcon)&#125; &lt;View style=&#123;GlobalStyles.line&#125;/&gt; &#123;ViewUtils.getSettingItem(()=&gt;this.onClick(MORE_MENU.About_Author), require('../my/img/ic_insert_emoticon.png'), MORE_MENU.About_Author, this.props.theme.styles.tabBarSelectedIcon)&#125; &lt;View style=&#123;GlobalStyles.line&#125;/&gt; &#123;ViewUtils.getSettingItem(()=&gt;this.onClick(MORE_MENU.Feedback), require('../../../res/images/ic_feedback.png'), MORE_MENU.Feedback, this.props.theme.styles.tabBarSelectedIcon)&#125; &lt;/View&gt; return this.aboutCommon.render(content, &#123; 'name': 'GitHub Popular', 'description': '这是一个用来查看GitHub最受欢迎与最热项目的App,它基于React Native支持Android和iOS双平台。', \"avatar\": \"http://og1yl0w9z.bkt.clouddn.com/18-3-28/61685877.jpg\", \"backgroundImg\": \"http://og1yl0w9z.bkt.clouddn.com/18-3-28/37407402.jpg\", &#125;); &#125;&#125; 本地持久化 主题选择界面 切换主题后界面 在涉及如主题变更等操作时，需要将状态信息保存，这时就需要用到类似于iOS 中的NSUserDefault， AsyncStorage 是React Native中的 Key-Value 存储系统，可以做本地持久化。 首先看它主要的几个接口： 根据键来获取值，获取的结果会放在回调函数中：1static getItem(key: string, callback:(error, result)) 根据键来设置值：1static setItem(key: string, value: string, callback:(error)) 根据键来移除项：1static removeItem(key: string, callback:(error)) 获取所有的键：1static getAllKeys(callback:(error, keys)) 设置多项，其中 keyValuePairs 是字符串的二维数组，比如：[[‘k1’, ‘val1’], [‘k2’, ‘val2’]]：1static multiSet(keyValuePairs, callback:(errors)) 获取多项，其中 keys 是字符串数组，比如：[‘k1’, ‘k2’]：1static multiGet(keys, callback:(errors, result)) 删除多项，其中 keys 是字符串数组，比如：[‘k1’, ‘k2’]：1static multiRemove(keys, callback:(errors)) 清除所有的项目：1static clear(callback:(error)) 网络请求封装在React Native中，经常使用Fetch函数来实现网络请求，它支持GET和POST请求并返回一个Promise对象，这个对象包含一个正确的结果和一个错误的结果。 来看一下用Fetch发起的POST请求封装： 12345678910111213141516171819static post(url,data)&#123; return new Promise((resolve,reject)=&gt;&#123; fetch(url,&#123; method:'POST', header:&#123; 'Accept':'application/json', 'Content-Type':'application/json' &#125;, body:JSON.stringify(data) &#125;) .then(response=&gt;response.json()) .then(result=&gt;&#123; resolve(result); &#125;) .catch(error=&gt;&#123; reject(error); &#125;) &#125;) &#125; 从上面的代码中，我们可以大致看到：Fetch函数中，第一个参数是请求url，第二个参数是一个字典，包括方法，请求头，请求体等信息。 随后的then和catch分别捕捉了fetch函数的返回值：一个Promise对象的正确结果和错误结果。注意，这里面有两个then，其中第二个then把第一个then的结果拿了过来。而第一个then做的事情是把网络请求的结果转化为JSON对象。 那么什么是Promise对象呢？ Promise 是异步编程的一种解决方案，Promise对象可以获取某个异步操作的消息。它里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 它分为三种状态： Pending（进行中）、Resolved（已成功）和Rejected（已失败） 它的构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject： resolve函数的作用：将Promise对象的状态从“未完成”变成“成功”(即从Pending变为Resolved)，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject函数的作用：将Promise对象的状态从“未完成”变成“成功”(即从Pending变为Rejected)，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 GET 请求封装：123456789101112static get(url)&#123; return new Promise((resolve,reject)=&gt;&#123; fetch(url) .then(response=&gt;response.json()) .then(result=&gt;&#123; resolve(result); &#125;) .catch(error=&gt;&#123; reject(error); &#125;) &#125;) &#125; 因为只是GET请求，所以不需要配置请求体，而且因为这个fetch函数返回值是一个Promise对象， 所以我们可以用.then和.catch来捕捉正确和错误的结果。 功能调试我们可以使用浏览器的开发者工具来调试React Native项目，可以通过打断点的方式来看数据信息以及方法的调用： 首先在iOS模拟器中点击command + D，然后再弹出菜单里点击Debug JS Remotely。随后就打开了浏览器进入了调试。 浏览器一般会展示下面的页面，然后点击command + option + J进入真生的调试界面。 双平台适配因为React Native讲求的是一份代码跑在两个平台上，而客观上这两个平台又有一些不一样的地方，所以就需要在别要的时候做一下两个平台的适配。 例如导航栏：在iOS设备中是存在导航栏的，而安卓设备上是没有的。所以在定制导航栏的时候，在不同平台下给导航栏设置不同的高度： 12345678910const NAV_BAR_HEIGHT_IOS = 54;const NAV_BAR_HEIGHT_ANDROID = 50;// css navBar: &#123; flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', height: Platform.OS === 'ios' ? NAV_BAR_HEIGHT_IOS : NAV_BAR_HEIGHT_ANDROID, &#125;, 上面的Platform是React Native内置的用于区分平台的库，可以在引入后直接使用。 建议在调试程序的时候，同时打开iOS和Android的模拟器进行调试，因为有些地方可能在某个平台上是没问题的，但是另一个平台上有问题，这就需要使用Platform来区分平台。 开源组件库的使用ReactNative 的组件与原生的组件有许多共同之处，如下拉刷新，同样的 Github 中开源组件已经相当完善。 开源组件库方法如下，安装最新版本：1npm install react-native-tab-navigator --save 安装指定版本：1npm install --save react-native-tab-navigator@0.4.0 react-native 集成组件绑定(ReactNative 0.27以后，自集成RNPM)：1react-native link react-native-splash-screen 常用开源库：12345678npm install --save react-native-tab-navigator@0.4.0npm install --save react-native-scrollable-tab-view@0.7.0npm install --save react-native-check-box@1.0.4npm install --react-native-easy-toast@1.0.9npm install --save GitHubTrending@2.0.0npm install --save react-native-htmlview@0.5.0npm install --save react-native-popover@0.5.0npm install --react-native-splash-screen@2.0.0 下图为使用 react-native-splash-screen 后的效果演示： 热更新CodePush 是微软提供的一套用于热更新 React Native 和 Cordova 应用的服务。 CodePush 是提供给 React Native 和 Cordova 开发者直接部署移动应用更新给用户设备的云服务。CodePush 作为一个中央仓库，开发者可以推送更新 (JS, HTML, CSS and images)，应用可以从客户端 SDK 里面查询更新。 Code-Push 推包命令：1code-push release-react &lt;appName&gt; &lt;platform&gt; [options] 示例：1code-push release-react RNAPPGithub ios --t 1.0.0 --dev false --d Staging --des &quot;1.热更新我的页面背景色&quot; --m true 1code-push release-react RNAPPGithub ios --t 1.0.1 --dev false --d Staging --des &quot;1.热更新相关设置&quot; --m true Code-Push 线上查看更新：1code-push deployment ls RNAPPGithub Code-Push 查看项目Key：1code-push deployment ls RNAPPGithub -k Code-Push iOS更新打包方法：1react-native bundle --platform ios --entry-file index.ios.js --bundle-output release_ios/main.jsbundle --assets-dest release_ios/ --dev fasle 总结之前也有零零散散的调研这门技术，但是经过系统的 15 个下午的坚持学习，深感跨平台技术的独到之处，特别是在与原生交互的编写上简直让人欲生欲死，还好在 Github 上已经有各路大神开源的各种方便开发的组件库可以供我们使用。 分享链接《React Native 开发常用命令行（持续更新）》(https://juejin.im/post/5abc54c86fb9a028da7c998c) 《ReactNative 开发常用的三方模块》(https://www.jianshu.com/p/53ff78168acc) 《使用VS Code调试React-Native程序》（https://jingyan.baidu.com/article/ad310e80fb13fc1849f49ed1.html） 参考资料 React Native中文网 贾鹏辉的技术博客 从一个实战项目来看一下React Native开发的几个关键技术点 Marno:给所有开发者的React Native详细入门指南 大漠:一个完整的Flexbox指南 阮一峰:Flex 布局教程：语法篇 八段代码彻底掌握 Promise 阮一峰：Promise对象 asce1885:React Native 高质量学习资料汇总 世锋日上:ReactNative 学习资源大汇集","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/tags/Project/"}]},{"title":"iOS RAC 的使用总结","slug":"Reactive Cocoa","date":"2018-03-16T14:56:27.000Z","updated":"2018-11-15T14:12:52.976Z","comments":true,"path":"2018/03/16/Reactive Cocoa/","link":"","permalink":"https://reversescale.github.io/2018/03/16/Reactive Cocoa/","excerpt":"Reactive Cocoa(简称RAC),是 GitHub 上开源的一个应用于 iOS 和 OS X 开发的一个新框架，RAC具有函数式编程和响应者编程的特性~","text":"Reactive Cocoa(简称RAC),是 GitHub 上开源的一个应用于 iOS 和 OS X 开发的一个新框架，RAC具有函数式编程和响应者编程的特性~ ReactiveCocoa解决的问题: 1.传统iOS开发过程中,状态以及状态之间依赖过多的问题 2.传统MVC架构的问题:Controller比较复杂,可测试性差 3.提供统一的消息传递机制 键值观察–监听 TF 的值发生变化123456789101112- (void)demo1&#123; @weakify(self); [self.tF.rac_textSignal subscribeNext:^(NSString *value) &#123; @strongify(self); self.value = value; &#125;]; //当self.value的值变化时调用Block，这是用KVO的机制，RAC封装了KVO [RACObserve(self, value) subscribeNext:^(NSString *value) &#123; NSLog(@&quot;%@&quot;,value); &#125;];&#125; map 的使用1234567891011121314151617- (void)demo2&#123; //创建一个信号 RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; //这个信号里面有一个Next事件的玻璃球和一个complete事件的玻璃球 [subscriber sendNext:@&quot;唱歌&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //对信号进行改进,当信号里面流的是唱歌.就改进为&apos;跳舞&apos;返还给self.value RAC(self, tF.text) = [signalA map:^id(NSString *value) &#123; if ([value isEqualToString:@&quot;唱歌&quot;]) &#123; return @&quot;跳舞&quot;; &#125; return @&quot;&quot;; &#125;]; &#125; filter 使用,你向西，他就向东，他向左，你就向右1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void)demo3&#123; //创建两个通道,一个从A流出的通道A,和一个从B流出的通道B RACChannelTerminal *channelA = RACChannelTo(self, value); RACChannelTerminal *channelB = RACChannelTo(self, value2); //改造通道A,使通过通道A的值,如果等于&apos;西&apos;,就改为&apos;东&apos; [[channelA map:^id(NSString *value) &#123; if ([value isEqualToString:@&quot;西&quot;]) &#123; NSLog(@&quot;东&quot;); return @&quot;东&quot;; &#125; NSLog(@&quot;====== %@&quot;,value); return value; &#125;] subscribe:channelB];//通道A流向B //改造通道B,使通过通道B的值,如果等于&apos;左&apos;,就改为&apos;右&apos;传出去 [[channelB map:^id(id value) &#123; if ([value isEqualToString:@&quot;左&quot;]) &#123; NSLog(@&quot;右&quot;); return @&quot;右&quot;; &#125; NSLog(@&quot;====== %@&quot;,value); return value; &#125;] subscribe:channelA];//通道B流向通道A //KVO监听valueA的值的变化,过滤valueA的值,返回Yes表示通过 //只有value有值,才可通过 [[RACObserve(self, value) filter:^BOOL(id value) &#123; return value ? YES : NO; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;你向%@&quot;,x); &#125;]; //KVO监听value2的变化 [[RACObserve(self, value2) filter:^BOOL(id value) &#123; return value ? YES: NO; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;他向%@&quot;,x); &#125;]; //下面使value的值和value2的值发生改变 self.value = @&quot;西&quot;; self.value2 = @&quot;左&quot;; &#125; 代理1)代理的第一种写法 .m文件123- (void)demo4&#123; [self.delegate makeAnApp:@&quot;12345上山打老虎&quot; String:@&quot;老虎不在家,怎么办&quot;];&#125; .h文件12345- (void)makeAnApp:(NSString *)string String:(NSString *)string;@end@interface Base5Controller : UIViewController@property (nonatomic, assign)id&lt;ProgrammerDelegate&gt; delegate; 第一个控制器的.h123456789101112131415161718192021222324Base5Controller *base = [[Base5Controller alloc] init]; // base.delegate = self; [self demo4]; // 这里是个坑,必须将代理最后设置,否则信号是无法订阅到的 // 雷纯峰大大是这样子解释的:在设置代理的时候，系统会缓存这个代理对象实现了哪些代码方法 // 如果将代理放在订阅信号前设置,那么当控制器成为代理时是无法缓存这个代理对象实现了哪些代码方法的 base.delegate = self; [self.navigationController pushViewController:base animated:YES]; &#125; else &#123; [self.navigationController pushViewController:[cl new] animated:YES]; &#125;&#125;#pragma mark---demo4//使用RAC代替代理时,rac_signalForSelector: fromProtocol:这个代替代理的方法使用时,切记要将self设为代理这句话放在订阅代理信号的后面写,否则会无法执行- (void)demo4&#123; //为self添加一个信号,表示代理ProgrammerDelegate的makeAnApp; //RACTuple 相当于swift中的元祖 [[self rac_signalForSelector:@selector(makeAnApp:String:) fromProtocol:@protocol(ProgrammerDelegate)] subscribeNext:^(RACTuple *x) &#123; //这里可以立即为makeAnApp的方法要执行的代码 NSLog(@&quot;%@ &quot;,x.first); NSLog(@&quot;%@&quot;,x.second); &#125;];&#125; 2)方法2 使用RACSubject替代代理123456789101112131415161718192021/*** RACSubject:信号提供者,自己可以充当信号,又能发送信号创建方法:1.创建RACSubject2.订阅信号3.发送信号工作流程:1.订阅信号,内部保存了订阅者,和订阅者相应block2.当发送信号的,遍历订阅者,调用订阅者的nextBolck注:如果订阅信号,必须在发送信号之前订阅信号,不然收不到信号,有利用区别RACReplaySubject*/-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; RacSubjectController *racsub = [[RacSubjectController alloc] init]; racsub.subject = [RACSubject subject]; [racsub.subject subscribeNext:^(id x) &#123; NSLog(@&quot;被通知了%@&quot;,x); &#125;]; [self.navigationController pushViewController:racsub animated:YES];&#125; 在RacSubjectController.h里面声明属性1@property (nonatomic, strong) RACSubject *subject; .m里面进行数据的传递12345-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; if (self.subject) &#123; [self.subject sendNext:@1]; &#125;&#125; 广播12345678910111213141516//发送通知- (void)demo5&#123; NSNotificationCenter *center = [NSNotificationCenter defaultCenter]; //发送广播通知 [center postNotificationName:@&quot;妇女之友&quot; object:nil userInfo:@&#123;@&quot;技巧&quot;:@&quot;用心听&quot;&#125;];&#125;//接收通知NSNotificationCenter *center = [NSNotificationCenter defaultCenter];//RAC的通知不需要我们手动移除//注册广播通知RACSignal *siganl = [center rac_addObserverForName:@&quot;妇女之友&quot; object:nil];//设置接收通知的回调处理[siganl subscribeNext:^(NSNotification *x) &#123; NSLog(@&quot;技巧: %@&quot;,x.userInfo[@&quot;技巧&quot;]);&#125;]; 两个信号串联,两个管串联,一个管处理完自己的东西,下一个管才开始处理自己的东西12345678910111213141516171819202122- (void)demo6&#123; //创建一个信号管A RACSignal *siganlA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;吃饭&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //创建一个信号管B RACSignal *siganlB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;吃的饱饱的,才可以睡觉的&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //串联管A和管B RACSignal *concatSiganl = [siganlA concat:siganlB]; //串联后的接收端处理 ,两个事件,走两次,第一个打印siggnalA的结果,第二次打印siganlB的结果 [concatSiganl subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125; 并联,只要有一个管有东西,就可以打印123456789101112131415161718192021- (void)demo7&#123; //创建信号A RACSignal *siganlA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;纸厂污水&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //创建信号B RACSignal *siganlB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;电镀厂污水&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //并联两个信号,根上面一样,分两次打印 RACSignal *mergeSiganl = [RACSignal merge:@[siganlA,siganlB]]; [mergeSiganl subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125; 组合,只有两个信号都有值,才可以组合1234567891011121314151617181920- (void)demo8&#123; //定义2个自定义信号 RACSubject *letters = [RACSubject subject]; RACSubject *numbers = [RACSubject subject]; //组合信号 [[RACSignal combineLatest:@[letters,numbers] reduce:^(NSString *letter, NSString *number)&#123; return [letter stringByAppendingString:number]; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;]; //自己控制发生信号值 [letters sendNext:@&quot;A&quot;]; [letters sendNext:@&quot;B&quot;]; [numbers sendNext:@&quot;1&quot;]; //打印B1 [letters sendNext:@&quot;C&quot;];//打印C1 [numbers sendNext:@&quot;2&quot;];//打印C2&#125; 合流压缩12345678910111213141516171819202122- (void)demo9&#123; //创建信号A RACSignal *siganlA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;红&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //创建信号B RACSignal *siganlB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;白&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //合流后处理的是压缩包,需要解压后才能取到里面的值 [[siganlA zipWith:siganlB] subscribeNext:^(id x) &#123; //解压缩 RACTupleUnpack(NSString *stringA, NSString *stringB) = x; NSLog(@&quot;%@ %@&quot;,stringA, stringB); &#125;];&#125; 映射,我可以点石成金12345678910111213141516171819- (void)demo10&#123; RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:nil]; [subscriber sendCompleted]; return nil; &#125;]; //对信号进行改造,改&quot;石&quot;成&quot;金&quot; siganl = [siganl map:^id(NSString *value) &#123; if ([value isEqualToString:@&quot;石&quot;]) &#123; return @&quot;金&quot;; &#125; return value; &#125;]; //打印,不论信号发送的是什么,这一步都会走的 [siganl subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125; 过滤,未满18岁,禁止入内12345678910111213141516171819- (void)demo11&#123; RACSignal *singal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@(15)]; [subscriber sendNext:@(17)]; [subscriber sendNext:@(21)]; [subscriber sendNext:@(14)]; [subscriber sendNext:@(30)]; [subscriber sendCompleted]; return nil; &#125;]; //过滤信号,打印 [[singal filter:^BOOL(NSNumber *value) &#123; //大于18岁的,才可以通过 return value.integerValue &gt;= 18;//return为yes可以通过 &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125; 秩序(flattenMap 方法也可以换成 then 方法,效果一样)123456789101112131415161718192021222324252627282930313233-(void)demo12&#123; RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;打蛋液&quot;); [subscriber sendNext:@&quot;蛋液&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //对信号进行秩序秩序的第一步 siganl = [siganl flattenMap:^RACStream *(NSString *value) &#123; //处理上一步的RACSiganl的信号value.这里的value=@&quot;蛋液&quot; NSLog(@&quot;把%@倒进锅里面煎&quot;,value); return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;煎蛋&quot;]; [subscriber sendCompleted]; return nil; &#125;]; &#125;]; //对信号进行第二步处理 siganl = [siganl flattenMap:^RACStream *(id value) &#123; NSLog(@&quot;把%@装载盘里&quot;,value); return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;上菜&quot;]; [subscriber sendCompleted]; return nil; &#125;]; &#125;]; //最后打印 最后带有===上菜 [siganl subscribeNext:^(id x) &#123; NSLog(@&quot;====%@&quot;,x); &#125;];&#125; 命令12345678910111213-(void)demo13&#123; RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; //打印：今天我投降了 //命令执行代理 NSLog(@&quot;%@我投降了&quot;,input); //返回一个RACSignal信号 return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; return nil; &#125;]; &#125;]; //执行命令 [command execute:@&quot;今天&quot;];&#125; 延迟12345678910111213- (void)demo14&#123; RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;等等我,我还有10s就到了&quot;); [subscriber sendNext:@&quot;北极&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //延迟10s接受next的玻璃球 [[siganl delay:10] subscribeNext:^(id x) &#123; NSLog(@&quot;我到了%@&quot;,x); &#125;];&#125; 重放123456789101112131415161718- (void)demo15&#123; RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;电影&quot;); [subscriber sendNext:@&quot;电影&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //创建该普通信号的重复信号 RACSignal *replaySiganl = [siganl replay]; //重复接受信号 [replaySiganl subscribeNext:^(NSString *x) &#123; NSLog(@&quot;小米%@&quot;,x); &#125;]; [replaySiganl subscribeNext:^(NSString *x) &#123; NSLog(@&quot;小红%@&quot;,x); &#125;];&#125; 定时—每隔 8 小时服用一次药12345678- (void)demo16&#123; //创建定时器信号.定时8小时 RACSignal *siganl = [RACSignal interval:60 * 60 * 8 onScheduler:[RACScheduler mainThreadScheduler]]; //定时器执行代码 [siganl subscribeNext:^(id x) &#123; NSLog(@&quot;吃药&quot;); &#125;];&#125; 超时12345678910111213141516171819202122- (void)demo17&#123; RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;我快到了&quot;); RACSignal *sendSiganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:nil]; [subscriber sendCompleted]; return nil; &#125;]; //发生信号要1个小时10分钟才到 [[sendSiganl delay:60 * 70] subscribeNext:^(id x) &#123; //这里才发送next玻璃球到siganl [subscriber sendNext:@&quot;我到了&quot;]; [subscriber sendCompleted]; &#125;]; return nil; &#125;]; [[siganl timeout:60 * 60 onScheduler:[RACScheduler mainThreadScheduler]] subscribeNext:^(id x) &#123; NSLog(@&quot;等了你一个小时,你一直没来,我走了&quot;); &#125;];&#125; 重试12345678910111213141516171819202122- (void)demo18&#123; __block int failedCount = 0; //创建信号 RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; if (failedCount &lt; 100) &#123; failedCount ++; NSLog(@&quot;我失败了&quot;); [subscriber sendError:nil]; &#125;else&#123; NSLog(@&quot;经历了数百次后,我成功了&quot;); [subscriber sendNext:nil]; &#125; return nil; &#125;]; //重试 RACSignal *retrySiganl = [siganl retry]; //直到发生next的玻璃球 [retrySiganl subscribeNext:^(id x) &#123; NSLog(@&quot;重要成功了&quot;); &#125;];&#125; 节流,不好意思,这里每一秒只能通过一个人,如果 1s 内发生多个,只通过最后一个1234567891011121314151617181920212223242526272829- (void)demo19&#123; RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; //即使发送一个next的玻璃球 [subscriber sendNext:@&quot;A&quot;]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@&quot;B&quot;]; &#125;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@&quot;C&quot;]; [subscriber sendNext:@&quot;D&quot;]; [subscriber sendNext:@&quot;E&quot;]; &#125;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@&quot;F&quot;]; &#125;); return nil; &#125;]; //对信号进行节流,限制时间内一次只能通过一个玻璃球 [[signal throttle:1] subscribeNext:^(id x) &#123; NSLog(@&quot;%@通过了&quot;,x); &#125;]; /* [2015-08-16 22:08:45.677]旅客A [2015-08-16 22:08:46.737]旅客B [2015-08-16 22:08:47.822]旅客E [2015-08-16 22:08:48.920]旅客F */&#125; 条件(takeUntil 方法,当给定的 signal 完成前一直取值)1234567891011121314151617181920212223242526- (void)demo20&#123; RACSignal *takeSiganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; //创建一个定时器信号,每一秒触发一次 RACSignal *siganl = [RACSignal interval:1 onScheduler:[RACScheduler mainThreadScheduler]]; [siganl subscribeNext:^(id x) &#123; //在这里定时发送next玻璃球 [subscriber sendNext:@&quot;直到世界尽头&quot;]; &#125;]; return nil; &#125;]; //创建条件信号 RACSignal *conditionSiganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; //设置5s后发生complete玻璃球 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;世界的今天到了,请下车&quot;); [subscriber sendCompleted]; &#125;); return nil; &#125;]; //设置条件,takeSiganl信号在conditionSignal信号接收完成前,不断取值 [[takeSiganl takeUntil:conditionSiganl] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125; RACReplaySubject 使用12345678910111213141516171819202122232425/*** RACReplaySubject创建方法 1.创建RACSubject 2.订阅信号 3.发送信号 工作流程: 1.订阅信号,内部保存了订阅者,和订阅者相应的block 2.当发送信号的,遍历订阅者,调用订阅者的nextBlock 3.发送的信号会保存起来,当订阅者订阅信号的时候,会将之前保存的信号,一个个作用于新的订阅者,保存信号的容量由capacity决定,这也是有别于RACSubject的*/-(void)RACReplaySubject&#123; RACReplaySubject *replaySubject = [RACReplaySubject subject]; [replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot; 1 %@&quot;,x); &#125;]; [replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot;2 %@&quot;,x); &#125;]; [replaySubject sendNext:@7]; [replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot;3 %@&quot;,x); &#125;];&#125; rac_liftSelector:withSignals 使用12345678910111213141516171819//这里的rac_liftSelector:withSignals 就是干这件事的，它的意思是当signalA和signalB都至少sendNext过一次，接下来只要其中任意一个signal有了新的内容，doA:withB这个方法就会自动被触发-(void)test&#123; RACSignal *sigalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; double delayInSeconds = 2.0; dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds *NSEC_PER_SEC)); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(popTime * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@&quot;A&quot;]; &#125;); return nil; &#125;]; RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;B&quot;]; [subscriber sendNext:@&quot;Another B&quot;]; [subscriber sendCompleted]; return nil; &#125;]; [self rac_liftSelector:@selector(doA:withB:) withSignals:sigalA,signalB, nil];&#125; 来源：简书作者未魏雨辰 《iOS RAC的使用总结》","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/tags/Tips/"}]},{"title":"Swift 4.0 中对 Dictionary 的改进","slug":"Swift 4 Dictionary","date":"2018-03-13T13:56:27.000Z","updated":"2018-11-15T14:04:15.042Z","comments":true,"path":"2018/03/13/Swift 4 Dictionary/","link":"","permalink":"https://reversescale.github.io/2018/03/13/Swift 4 Dictionary/","excerpt":"Swift 4 发布已经有一段时间了，不知道大家有没有切换到 4.0 版本。 这次 4.0 更新给我最大的感受就是没有了前几次升级的跳跃式变化。 不用为了更新语言版本，完全推翻已有的项目，这也是 Swift 慢慢趋向于稳定的标志~","text":"Swift 4 发布已经有一段时间了，不知道大家有没有切换到 4.0 版本。 这次 4.0 更新给我最大的感受就是没有了前几次升级的跳跃式变化。 不用为了更新语言版本，完全推翻已有的项目，这也是 Swift 慢慢趋向于稳定的标志~ 咱们这次说说 Swift 4.0 对 Dictionary 这个经常会用到的类的改进。 自动根据 key 分组Dictionary 新增了一个构造方法，可以将给定的一个数组，根据指定的条件进行分组。 来看一个例子: 123456789struct Person &#123; var name: String var gender: Gender var age: Int enum Gender &#123; case male case female &#125;&#125; 这里有一个 Person 结构, 然后我们初始化一个数组： 12345let p1 = Person(name: \"aa\", gender: .female, age: 22)let p2 = Person(name: \"bb\", gender: .male, age: 24)let p3 = Person(name: \"cc\", gender: .male, age: 21)let persons = [p1, p2, p3] 现在用新的 Dictionary 构造方法，可以立即将这组 Person 实例根据他们的 gender 属性进行分组： 123let groupedDict = Dictionary(grouping: persons) &#123; p in return p.gender&#125; 这个构造方法，第一个参数 grouping 接收的是 persons 数组， 第二个参数是一个闭包，用于返回根据进行分组的依据，我们这里返回的是 p.gender。结果一目了然： 123456789[ .male: [ Person(name: \"bb\", gender: .male, age: 24), Person(name: \"cc\", gender: .male, age: 21) ], .female: [ Person(name: \"aa\", gender: .female, age: 22) ]] 以往要实现这样的功能，就需要手动遍历整个数组，取出 key， 然后生成字典， 现在方便很多。 value 无缝转换另外一个比较有用的特性是，Dictionary 提供的 mapValues 方法。 还以我们刚才生成的 groupedDict 为例，可以进行这样的操作： 123let count = groupedDict.mapValues &#123; persons in persons.count&#125; 先看一下输出，大家可能就猜到这个方法的用途是什么了： 1234[ .male: 2, .female: 1] 上面的输出可以看到， mapValues 会遍历每一个 key 对应的 values， 然后传递给闭包进行自定义转换。 我们例子中的闭包返回的就是每个 key 对应的 Person 集合的数量，最生成了一个新的 Dictionary，里面的 key 和之前一样，只是对应的值变成了我们闭包中自定义的了。 mapValues 方法同样是一个帮助我们解决繁杂操作的工具方法。 从键值对元组中直接构建假如我们有这样一个数组: 1let personsTuples = [(\"group 1\", [p1, p2]), (\"group 2\", [p3])] 然后可以调用 uniqueKeysWithValues 构造方法直接初始化字典： 1let dict = Dictionary(uniqueKeysWithValues: personsTuples) personsTuples 数组中，每一个元素都是一个元组(Tuple)， 这个构造方法把元组中的第一项当做 key， 第二项当做 value， 生成一个新的 Dictionary，如下所示： 123456789[ \"group 1\": [ Person(name: \"aa\", gender: .female, age: 22), Person(name: \"bb\", gender: .male, age: 24) ], \"group 2\": [ Person(name: \"cc\", gender: .male, age: 21) ]] 使用 uniqueKeysWithValues 构造方法时候需要注意，就是传入的数组中，不能有重复的 key， 否则会报运行时错误，比如这个数组就会报错： 1let personsTuples = [(\"group 1\", [p1, p2]), (\"group 2\", [p3]), (\"group 2\", [p4])] 上面数组中 group 2 出现了两次。 如果用它来初始化的话，就会出错。 所以 Swift 4.0 还提供了另外一个初始化方法， 对于上面这个数组，可以调用： 123let dict = Dictionary(personsTuples) &#123; old, new in return new&#125; 第二个闭包参数，会在遇到重复的 key 时候调用。 它提供两个参数，一个是同样这个 key 的上一个值 old， 还有当前的值 new。 我们这里直接返回 new，意思就是 每次遇到重复的 key， 就用新的值代替老的值。 这样初始化后，生成的 Dictionary 结构如下： 123456789[ \"group 1\": [ p1, p2 ], \"group 2\": [ p4 ]] group 2 中的值， 是第二次 key 所对应的 p4。 提供默认值如果我们访问了一个字典中不存在的 key， 会返回 nil： 1dict[\"group 3\"] 因为上面字典中，不存在 group 3 这个 key， 所以它返回了 nil。 Swift 4 中新增了指定默认值的能力： 1dict[\"group 3\", default: []] 这样调用，如果 group 3 这个 key 不存在的话， 就会返回我们指定的默认值空数组， 而不是 nil 了。 这个特性在我们处理 JSON 数据解析这类的问题上很实用。 过滤器过滤器对于集合类来说是比较常用的功能。 Swift 4 中对 Dictionary 类型也提供了过滤器的支持： 123let filteredDict = dict.filter &#123; key, val in return val.count &gt;= 2&#125; filter 方法接收一个闭包，它会遍历 Dictionary 中所有的元素，并且作为闭包的参数传入。 我们需要通过闭包的返回值确定这个元素是否被保留。 上面的例子中，比如我们 dict 中的元素是 ： 123456789[ \"group 1\": [ p1, p2 ], \"group 2\": [ p4 ]] 调用 filter 后，我们只保留数量大于 2 的集合： 123456[ \"group 1\": [ p1, p2 ]] 总结以上就是 Swift 4.0 对于 Dictionary 的主要改进。 这些新增的工具方法对于提高我们开发效率和代码质量都有帮助，希望这里的介绍对你有帮助。 关于 Dictionary 更完整的信息，大家还可以参考苹果官方的文档，还有 Swift Blog 中的介绍。 参考文献Dictionary 官方文档：https://developer.apple.com/documentation/swift/dictionarySwift Blog: https://swift.org/blog/dictionary-and-set-improvements/","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/tags/Tips/"}]},{"title":"使用 CocoaPods 对公有库开源和私有库组件","slug":"Open source library","date":"2018-03-12T13:56:27.000Z","updated":"2018-11-15T14:01:12.844Z","comments":true,"path":"2018/03/12/Open source library/","link":"","permalink":"https://reversescale.github.io/2018/03/12/Open source library/","excerpt":"最近在研究使用 CocoaPods 对 iOS 工程组件化，创建公有 Pod 库和私有 Pod 库方法，为了方便整理和学习就整理了这篇文章~","text":"最近在研究使用 CocoaPods 对 iOS 工程组件化，创建公有 Pod 库和私有 Pod 库方法，为了方便整理和学习就整理了这篇文章~ 创建公有 Pod 库或者私有 Pod 库，实际上原理是一样的，都是基于 git 服务和 repo 协议，不一样的是，两者的版本索引查询方式不一样，公有库的 podspec 由 CocoaPods/Specs 管理，而内部私有使用的 pod 库需要自己建立一个仓库来管理 podspec。 实用：开源公有库例子: 我有封装过一个工具CollectionIndexTools，CollectionIndexTools 可以给 Collection 添加一个类似 TableView 右侧的索引条，我想通过 Podfile 中添加 pod ‘CollectionIndexToolsLib’ 即可使用. 注册 CocoaPods 账户信息想要创建一个开源 pod 库，首先我们需要注册 CocoaPods, 这里使用 trunk 方式，作为一个 iOS 开发人员你一定安装了 CocoaPods，那么只需要在终端执行： 1pod trunk register 邮箱地址 &apos;用户名&apos; --verbose 这里我们一般使用 Github 邮箱和用户名，然后在你的邮箱中会收到确认邮件，在浏览器中点击链接确认即注册成功，成功之后可以终端执行： 1pod trunk me 查看自己的注册信息，以后当你有了自己的开源Pod库，也可以用此方式随时查看自己发布过的Pods： 创建共享库文件并上传到公有仓库共享库需要三个必不可少的部分: 1.共享文件夹(文件夹存放着你要共享的内容, 也就是其他人pod得到的文件, .podspec文件中的source_files需要指定此文件路径及文件类型); 2.LICENSE文件(默认一般选择MIT); 3.库描述文件.podspec(本库的各项信息描述, 需要提交给CocoaPods, pod通过这个文件查找到你共享的库, .podspec文件的格式见第3点). 这一步分两种场景: 场景一：如果你已经有了现成的想要共享的文件,你只需要满足上面三个部分,即可上传到公有仓库即可继续其他的步骤; 场景二：你想要创建一个全新的工程去做自己的共享, 可以使用终端命令: 1pod lib create CollectionIndexToolsLib 需要输入一些模板参数： Cocoapods 会自动生成一个模板项目，目录结构： 123456789101112131415CollectionIndexToolsLib├── Example #demo APP│ ├── CollectionIndexToolsLib│ ├── CollectionIndexToolsLib.xcodeproj│ ├── CollectionIndexToolsLib.xcworkspace│ ├── Podfile #demo APP 的依赖描述文件│ ├── Podfile.lock│ ├── Pods #demo APP 的依赖文件│ └── Tests├── LICENSE #开源协议 默认MIT├── Pod #组件的目录│ ├── Assets #资源文件│ └── Classes #类文件├── PodCollectionIndexToolsLib.podspec #第三步要创建的podspec文件└── README.md #markdown格式的README 编辑.podspec文件以CollectionIndexToolsLib.podspec为例:123456789101112131415161718192021Pod::Spec.new do |s| s.name = 'CollectionIndexToolsLib' s.version = '0.1.0' s.summary = 'Custom IndexTools similar to TableViews index bar' s.description = &lt;&lt;-DESC I believe you must have thought about adding an index like Table View to Collection View. I will give you one today. DESC s.homepage = 'https://github.com/ReverseScale/CollectionIndexToolsLib' s.license = 'MIT' s.author = &#123; 'ReverseScale' =&gt; 'reversescale@icloud.com' &#125; s.source = &#123; :git =&gt; 'https://github.com/ReverseScale/CollectionIndexToolsLib.git', :tag =&gt; s.version.to_s &#125; s.ios.deployment_target = '8.0' s.source_files = 'CollectionIndexToolsLib/Classes/**/*' s.requires_arc = trueend 理论上前面的设置就可以通过验证，下面是注释参照：1234567891011121314151617181920212223242526272829Pod::Spec.new do |s| s.name = \"PodTestLibrary\" #名称 s.version = \"0.1.0\" #版本号 s.summary = \"Just Testing.\" #简短介绍，下面是详细介绍 s.description = &lt;&lt;-DESC Testing Private Podspec. * Markdown format. * Don't worry about the indent, we strip it! DESC s.homepage = \"https://coding.net/u/wtlucky/p/podTestLibrary\" #主页,这里要填写可以访问到的地址，不然验证不通过 # s.screenshots = \"www.example.com/screenshots_1\", \"www.example.com/screenshots_2\" #截图 s.license = 'MIT' #开源协议 s.author = &#123; \"wtlucky\" =&gt; \"wtlucky@foxmail.com\" &#125; #作者信息 s.source = &#123; :git =&gt; \"https://coding.net/wtlucky/podTestLibrary.git\", :tag =&gt; \"0.1.0\" &#125; #项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS # s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;' #多媒体介绍地址 s.platform = :ios, '7.0' #支持的平台及版本 s.requires_arc = true #是否使用ARC，如果指定具体文件，则具体的问题使用ARC s.source_files = 'Pod/Classes/**/*' #代码源文件地址，**/*表示Classes目录及其子目录下所有文件，如果有多个目录下则用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置 s.resource_bundles = &#123; 'PodTestLibrary' =&gt; ['Pod/Assets/*.png'] &#125; #资源文件地址 s.public_header_files = 'Pod/Classes/**/*.h' #公开头文件地址 s.frameworks = 'UIKit' #所需的framework，多个用逗号隔开 s.dependency 'AFNetworking', '~&gt; 2.3' #依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependencyend 编写完成后, 我们需要验证.podspec文件的合法性, 这里需要终端cd到.podspec文件所在文件夹, 执行:忽视警告：–allow-warnings 1pod lib lint CollectionIndexToolsLib.podspec 如有警告或者错误请重新检查你的编写正确性，如果没有问题会出现： 123-&gt; CollectionIndexToolsLib (0.1.0)CollectionIndexToolsLib passed validation. 打tag, 发布一个release版本一切准备就绪后, 我们需要在你的git仓库里面存在一个与.podspec文件中一致的version, 这里你可以在你的git仓库中的releases一项去手动发布, 也可以在当前文件夹下使用终端命令: 12git tag -m &apos;🔖:Releasing tags.&apos; &apos;0.1.0&apos;git push --tag #推送tag到远端仓库 成功之后即可在你的 releases 里面看到这个 tag 的版本. 发布自己的库描述文件podspec给cocoapods同样在这个文件夹下, 终端执行:忽视警告：–allow-warnings 1pod trunk push CollectionIndexToolsLib.podspec 将你的库文件.podspec文件提交到公有的specs上面, 这一步做的操作是验证你的podspec文件是否合法+提交到specs中(等同于fork;commit;push)+将上传的podspec文件转成json格式文件)，成功后会出现Congrats信息。 成功上传后等待片刻就可以用查找命令找到你的库： 1pod search CollectionIndexToolsLib 日后维护更新开源库如果有错误或者需要迭代版本,修改工程文件后推送到远端仓库后, 需要修改podspec中的版本号, 并重新打tag上传, 再进行新一轮的验证和发布.如果在开发过程中发现某基础组件存在 bug 需要更新 Pod，具体操作步骤如下： 修改 podspec 文件中的 s.version; 修复 bug 并对项目打 tag，tag 名称和 s.version 一直并 push 到远程仓库。 验证 podspec 文件的有效性； 推送 podspec 文件到远程仓库； 执行 pod search RRCache 验证结果； 实用：组件化私有库组件化的实用之处请参考《移动端 iOS 年终工作总结-纯干货请自备酒水》（https://juejin.im/post/5a934dfa6fb9a0634514d8a9） 私有Pod库和公有Pod库的创建方式没有什么区别, 不一样的是管理他们的 spec repo 不一样. 所以我们需要自己创建一个跟CocoaPods/Specs类似的仓库来管理内部创建的Pod库的podspec文件, 供内部人员更新和依赖使用内部Pod组件库. 私有repo的构建形式有两种, 一种是私有git服务器上面创建，一种是本机创建. 本机创建请参考官方文档:Private Pods, 这里介绍的是在公司内部搭建的git服务器上面创建整个服务的方式. 创建一个git仓库用来做内部私有库的Spec Repo在私有服务器一个仓库,一个用来存放所有共享库的podspec, 这里创建好之后的内部SSH协议地址是:https://gitee.com/WhatsXie/LibComponent.git, 花钱买git的私有仓库或者使用其他免费的第三方git服务(如Bitbucket等)创建的私有仓库给到的http/https地址也一样.终端输入命令:1pod repo add LibComponent https://gitee.com/WhatsXie/LibComponent.git 将LibComponent添加到本地repo, 添加成功后可以在/.cocoapods/repos/目录下可以看到官方的specs:master和刚刚加入的specs:LibComponent 如果有其他合作人员共同使用这个私有Spec Repo的话在他有对应Git仓库的权限的前提下执行相同的命令添加这个Spec Repo即可. 创建私有Pod组件库继续创建一个私有仓库,用来建立需要共享的内部组件, 以RSGuidePageLib为例:https://gitee.com/WhatsXie/RSGuidePageLib.git 可以创建示例工程, 像创建公有的库一样, 填写自己的podspec文件 1234567891011121314151617181920212223242526272829Pod::Spec.new do |s|s.name = 'RSGuidePageLib's.version = '0.3.0's.summary = 'Custom guide page package's.description = &lt;&lt;-DESCSwift implementation of the guide page package, support for multiple pictures and video guide pageDESCs.homepage = 'https://gitee.com/WhatsXie/RSGuidePageLib.git's.license = &#123; :type =&gt; 'MIT', :file =&gt; 'LICENSE' &#125;s.author = &#123; 'ReverseScale@icloud.com' =&gt; 'reversescale' &#125;s.source = &#123; :git =&gt; 'https://gitee.com/WhatsXie/RSGuidePageLib.git', :tag =&gt; s.version.to_s &#125;s.ios.deployment_target = '8.0's.swift_version = '3.2's.source_files = 'RSGuidePageLib/Classes/**/*'s.requires_arc = true 值得注意的是:podspec文件中的homepage和source不支持ssh协议地址,所以我们得放入http/https地址. 与公有库的创建方式一样, pod lib lint Category.podspec验证成功之后push到仓库, 然后打tag发布release版本. 然后将podspec加入私有Sepc repo中公有库使用trunk方式将.podspec文件发布到CocoaPods/Specs, 内部的pod组件库则是添加到我们第一步创建的私有Spec repo中去, 在终端执行:–allow-warnings 忽略警告–private 私有库 1pod repo push LibComponent RSGuidePageLib.podspec 添加成功之后LibComponent中会包含RSGuidePageLib库的podspec信息, 可以前往~/.cocoapods/repos下的LibComponent文件夹中查看, 同时git服务器中的远端也更新了. 移除私有Repo 1pod repo remove [name] 查找和使用内部组件库执行pod search Category就能查到刚刚创建好的Category库了, 然后在想要使用此组件的工程的Podfile中加入pod ‘Category’, ‘~&gt;1.0.1’即可使用内部组件啦！ 值得注意的是:必须在Podfile前面需要添加你的私有Spec repo的git地址source, pod install时, 才能在私有repo中查找到私有库, 像这样: 1234567891011# Uncomment the next line to define a global platform for your projectsource &apos;https://github.com/CocoaPods/Specs.git&apos;source &apos;https://gitee.com/WhatsXie/LibComponent.git&apos;# platform :ios, &apos;9.0&apos;target &apos;Demo&apos; dopod &apos;RSGuidePageLib&apos;, &apos;~&gt;0.3.0’end 经过测试, 这种方式可以把你的所有可以拆分出来的组件, 甚至是业务都来使用Pod管理, 这样达到了解耦和单项更新优化。某些组件不影响老版本的依赖使用, 出现问题修改Podfile中的依赖版本即可随时回滚, 给开发了带来极大的便利。 参考链接: CocoaPods创建公有和私有Pod库方法总结（https://www.aliyun.com/jiaocheng/376300.html） CocoaPods Guides(https://guides.cocoapods.org) Private Pods(https://guides.cocoapods.org/making/private-cocoapods.html) 手把手教你发布代码到CocoaPods(Trunk方式)(http://www.cnblogs.com/wengzilin/p/4742530.html) 使用Cocoapods创建私有podspec(http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/) COCOAPODS创建私有PODS(http://www.cnblogs.com/tufeibo/p/5654268.html) CocoaPods 组件化实践 - 私有Pod(https://www.jianshu.com/p/475d6b6d5600)","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/tags/Tips/"}]},{"title":"Swift 4.0 新特征汇总及演示附 Demo","slug":"Swift 4 New feature","date":"2018-03-09T13:16:27.000Z","updated":"2018-11-15T14:33:01.163Z","comments":true,"path":"2018/03/09/Swift 4 New feature/","link":"","permalink":"https://reversescale.github.io/2018/03/09/Swift 4 New feature/","excerpt":"Swift 在不断的版本迭代中，由于其 ABI 尚不稳定，所以给开发者带来许多的挑战，但也正因为如此，这门语言才有无限可能~","text":"Swift 在不断的版本迭代中，由于其 ABI 尚不稳定，所以给开发者带来许多的挑战，但也正因为如此，这门语言才有无限可能~ Key Paths 新语法key-path 通常是用在键值编码（KVC）与键值观察（KVO）上的，KVC、KVO 相关内容可以参考我之前写的这篇文章：Swift - 反射（Reflection）的介绍与使用样例（附KVC介绍） 1.Swift 3 之前使用的是 String 类型的 key-Path1234567891011121314151617//用户类class User: NSObject&#123; @objc var name:String = &quot;&quot; //姓名 @objc var age:Int = 0 //年龄&#125; //创建一个User实例对象let user1 = User()user1.name = &quot;hangge&quot;user1.age = 100 //使用KVC取值let name = user1.value(forKey: &quot;name&quot;)print(name) //使用KVC赋值user1.setValue(&quot;hangge.com&quot;, forKey: &quot;name&quot;) 具体显示如下： 2.到了 Swift 3 新增了 #keyPath() 写法使用 #keyPath() 写法，可以避免我们因为拼写错误而引发问题。1234567891011121314151617//用户类class User: NSObject&#123; @objc var name:String = &quot;&quot; //姓名 @objc var age:Int = 0 //年龄&#125; //创建一个User实例对象let user1 = User()user1.name = &quot;hangge&quot;user1.age = 100 //使用KVC取值let name = user1.value(forKeyPath: #keyPath(User.name))print(name) //使用KVC赋值user1.setValue(&quot;hangge.com&quot;, forKeyPath: #keyPath(User.name)) 3.Swift 4 中直接用 \\ 作为开头创建 KeyPath新的方式不仅使用更加简单，而且有如下优点： 类型可以定义为 class、struct 定义类型时无需加上 @objc 等关键字 性能更好 类型安全和类型推断，例如：user1.value(forKeyPath: #keyPath(User.name)) 返回的类型是 Any，user1[keyPath: \\User.name] 直接返回 String 类型 可以在所有值类型上使用（1）比如上面的样例在 Swift4 中可以这么写：1234567891011121314151617//用户类class User: NSObject&#123; var name:String = &quot;&quot; //姓名 var age:Int = 0 //年龄&#125; //创建一个User实例对象let user1 = User()user1.name = &quot;hangge&quot;user1.age = 100 //使用KVC取值let name = user1[keyPath: \\User.name]print(name) //使用KVC赋值user1[keyPath: \\User.name] = &quot;hangge.com&quot; （2）keyPath 定义在外面也是可以的：123456let keyPath = \\User.name let name = user1[keyPath: keyPath]print(name) user1[keyPath: keyPath] = &quot;hangge.com&quot; （3）可以使用 appending 方法向已定义的 Key Path 基础上填加新的 Key Path。12let keyPath1 = \\User.phonelet keyPath2 = keyPath1.appending(path: \\.number) 类与协议的组合类型在 Swift 4 中，可以把类（Class）和协议（Protocol）用 &amp; 组合在一起作为一个类型使用。 使用样例1：12345678910111213protocol MyProtocol &#123; &#125; class View &#123; &#125; class ViewSubclass: View, MyProtocol &#123; &#125; class MyClass &#123; var delegate: (View &amp; MyProtocol)?&#125; let myClass = MyClass()myClass.delegate = ViewSubclass() //这个编译正常myClass.delegate = View() //这个编译报错: 具体错误信息如下： 使用样例2：123456789101112131415161718192021protocol Shakeable &#123; func shake()&#125; extension UIButton: Shakeable &#123; func shake() &#123; /* ... */ &#125;&#125; extension UISlider: Shakeable &#123; func shake() &#123; /* ... */ &#125;&#125; func shakeEm(controls: [UIControl &amp; Shakeable]) &#123; for control in controls where control.isEnabled &#123; control.shake() &#125;&#125; 下标支持泛型1.下标的返回类型支持泛型有时候我们会写一些数据容器，Swift 支持通过下标来读写容器中的数据。但是如果容器类中的数据类型定义为泛型，过去下标语法就只能返回 Any，在取出值后需要用 as? 来转换类型。现在 Swift 4 定义下标也可以使用泛型了。12345678910111213141516171819202122struct GenericDictionary&lt;Key: Hashable, Value&gt; &#123; private var data: [Key: Value] init(data: [Key: Value]) &#123; self.data = data &#125; subscript&lt;T&gt;(key: Key) -&gt; T? &#123; return data[key] as? T &#125;&#125; //字典类型: [String: Any]let earthData = GenericDictionary(data: [&quot;name&quot;: &quot;Earth&quot;, &quot;population&quot;: 7500000000, &quot;moons&quot;: 1]) //自动转换类型，不需要在写 &quot;as? String&quot;let name: String? = earthData[&quot;name&quot;]print(name) //自动转换类型，不需要在写 &quot;as? Int&quot;let population: Int? = earthData[&quot;population&quot;]print(population) 2.下标类型同样支持泛型12345678910111213141516extension GenericDictionary &#123; subscript&lt;Keys: Sequence&gt;(keys: Keys) -&gt; [Value] where Keys.Iterator.Element == Key &#123; var values: [Value] = [] for key in keys &#123; if let value = data[key] &#123; values.append(value) &#125; &#125; return values &#125;&#125; // Array下标let nameAndMoons = earthData[[&quot;moons&quot;, &quot;name&quot;]] // [1, &quot;Earth&quot;]// Set下标let nameAndMoons2 = earthData[Set([&quot;moons&quot;, &quot;name&quot;])] // [1, &quot;Earth&quot;] Codable 序列化如果要将一个对象持久化，需要把这个对象序列化。过去的做法是实现 NSCoding 协议，但实现 NSCoding 协议的代码写起来很繁琐，尤其是当属性非常多的时候。Swift 4 中引入了 Codable 协议，可以大大减轻了我们的工作量。我们只需要让需要序列化的对象符合 Codable 协议即可，不用再写任何其他的代码。1234struct Language: Codable &#123; var name: String var version: Int&#125; 1.Encode 操作我们可以直接把符合了 Codable 协议的对象 encode 成 JSON 或者 PropertyList。12345678let swift = Language(name: &quot;Swift&quot;, version: 4) //encoded对象let encodedData = try JSONEncoder().encode(swift) //从encoded对象获取Stringlet jsonString = String(data: encodedData, encoding: .utf8)print(jsonString) 2.Decode 操作12let decodedData = try JSONDecoder().decode(Language.self, from: encodedData)print(decodedData.name, decodedData.version) SubtringSwift 4 中有一个很大的变化就是 String 可以当做 Collection 来用，并不是因为 String 实现了 Collection 协议，而是 String 本身增加了很多 Collection 协议中的方法，使得 String 在使用时看上去就是个 Collection。1234567let str = &quot;hangge.com&quot; print(str.prefix(5)) // &quot;hangg&quot;print(str.suffix(5)) // &quot;e.com&quot; print(str.dropFirst()) // &quot;angge.com&quot;print(str.dropLast()) // &quot;hangge.co&quot; 比如上面的样例，我们使用一些 Collection 协议的方法对字符串进行截取，只不过它们的返回结果不是 String 类型，而是 Swift 4 新增的 Substring 类型。 1.为何要引入 Substring？既然我们想要的到的就是字符串，那么直接返回 String 就好了，为什么还要多此一举返回 Substring。原因只有一个：性能。具体可以参考下图：当我们用一些 Collection 的方式得到 String 里的一部分时，创建的都是 Substring。Substring 与原 String 是共享一个 Storage。这意味我们在操作这个部分的时候，是不需要频繁的去创建内存，从而使得 Swift 4 的 String 相关操作可以获取比较高的性能。而当我们显式地将 Substring 转成 String 的时候，才会 Copy 一份 String 到新的内存空间来，这时新的 String 和之前的 String 就没有关系了。 2.使用 Substring 的注意事项由于 Substring 与原 String 是共享存储空间的，只要我们使用了 Substring，原 String 就会存在内存空间中。只有 Substring 被释放以后，整个 String 才会被释放。而且 Substring 类型无法直接赋值给需要 String 类型的地方，我们必须用 String() 包一层。当然这时系统就会通过复制创建出一个新的字符串对象，之后原字符串就会被释放。 3.使用样例这里对 String 进行扩展，新增一个 subString 方法。直接可以根据起始位置（Int 类型）和需要的长度（Int 类型），来截取出子字符串。123456789101112extension String &#123; //根据开始位置和长度截取字符串 func subString(start:Int, length:Int = -1) -&gt; String &#123; var len = length if len == -1 &#123; len = self.count - start &#125; let st = self.index(startIndex, offsetBy:start) let en = self.index(st, offsetBy:len) return String(self[st ..&lt; en]) &#125;&#125; 使用样例：1234let str1 = &quot;欢迎访问hangge.com&quot;let str2 = str1.subString(start: 4, length: 6)print(&quot;原字符串：\\(str1)&quot;)print(&quot;截取出的字符串：\\(str2)&quot;) 运行结果如下： 注意：这个方法最后我们会将 Substring 显式地转成 String 再返回。 废除 swap 方法（1）过去我们会使用 swap(_:_:) 来将两个变量的值进行交换：1234var a = 1var b = 2swap(&amp;a, &amp;b)print(a, b) （2）后面 swap() 方法将会被废弃，建议使用 tuple（元组）特性来实现值交换，也只需要一句话就能实现：1234var a = 1var b = 2(b, a) = (a, b)print(a, b) 使用 tuple 方式的好处是，多个变量值也可以一起进行交换：12345var a = 1var b = 2var c = 3(a, b, c) = (b, c, a)print(a, b, c) （3）补充一下：现在数组增加了个 swapAt 方法可以实现两个元素的位置交换。1234var fruits = [&quot;apple&quot;, &quot;pear&quot;, &quot;grape&quot;, &quot;banana&quot;]//交换元素位置（第2个和第3个元素位置进行交换）fruits.swapAt(1, 2)print(fruits) 减少隐式 @objc 自动推断1.过去的情况（Swift 3）（1）在项目中如果想把 Swift 写的 API 暴露给 Objective-C 调用，需要增加 @objc。在 Swift 3 中，编译器会在很多地方为我们隐式的加上 @objc。（2）比如当一个类继承于 NSObject，那么这个类的所有方法都会被隐式的加上 @objc。1234class MyClass: NSObject &#123; func print() &#123; &#125; // 包含隐式的 @objc func show() &#123; &#125; // 包含隐式的 @objc&#125; （3）但这样做很多并不需要暴露给 Objective-C 也被加上了 @objc。而大量 @objc 会导致二进制文件大小的增加。 2.现在的情况（Swift 4）（1）在 Swift 4 中隐式 @objc 自动推断只会发生在下面这种必须要使用 @objc 的情况： 覆盖父类的 Objective-C 方法 符合一个 Objective-C 的协议 （2）大多数地方必须手工显示地加上 @objc。1234class MyClass: NSObject &#123; @objc func print() &#123; &#125; //显示的加上 @objc @objc func show() &#123; &#125; //显示的加上 @objc&#125; （3）如果在类前加上 @objcMembers，那么它、它的子类、扩展里的方法都会隐式的加上 @objc。123456789@objcMembersclass MyClass: NSObject &#123; func print() &#123; &#125; //包含隐式的 @objc func show() &#123; &#125; //包含隐式的 @objc&#125; extension MyClass &#123; func baz() &#123; &#125; //包含隐式的 @objc&#125; （4）如果在扩展（extension）前加上 @objc，那么该扩展里的方法都会隐式的加上 @objc。123456class SwiftClass &#123; &#125; @objc extension SwiftClass &#123; func foo() &#123; &#125; //包含隐式的 @objc func bar() &#123; &#125; //包含隐式的 @objc&#125; （5）如果在扩展（extension）前加上 @nonobjc，那么该扩展里的方法都不会隐式的加上 @objc。12345678@objcMembersclass MyClass : NSObject &#123; func wibble() &#123; &#125; //包含隐式的 @objc&#125; @nonobjc extension MyClass &#123; func wobble() &#123; &#125; //不会包含隐式的 @objc&#125; Demo 演示 源码 : https://github.com/ReverseScale/Swift4.0NewFeature","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/tags/Project/"}]},{"title":"让 Async 帮你解决线程问题","slug":"Library Async","date":"2018-02-23T03:56:27.000Z","updated":"2018-11-15T14:21:40.758Z","comments":true,"path":"2018/02/23/Library Async/","link":"","permalink":"https://reversescale.github.io/2018/02/23/Library Async/","excerpt":"线程这种东西一般封装比较深，很微观，也很考察计算机基础知识，虽然系统为我们封装的 GCD、NSOperation 已经很好用了，但是我发现了个更好用的~","text":"线程这种东西一般封装比较深，很微观，也很考察计算机基础知识，虽然系统为我们封装的 GCD、NSOperation 已经很好用了，但是我发现了个更好用的~ 🤖 要求 iOS 9.0+ Xcode 9.0+ Swift 4 🎨 测试 UI 什么样子？ 1.展示页 2.展示页 3.展示页 常见场景列表 耗时操作场景示例 黑科技操作场景示例 🎯 安装方法在 iOS, 你需要在 Podfile 中添加.12345source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;9.0&apos;use_frameworks!pod &apos;AsyncSwift&apos; 🛠 配置耗时操作这是应用最广泛的场景，为了避免阻塞主线程，将耗时操作放在子线程处理，然后在主线程使用处理结果。比如读取沙盒中的一些数据，然后将读取的数据展示在 UI，这个场景还有几个细分：1.1 执行一个耗时操作后回调主线程123456Async.background &#123;print(\"A: This is run on the \\(qos_class_self().description) (expected \\(QOS_CLASS_BACKGROUND.description))\") sleep(2)&#125;.main &#123; print(\"B: This is run on the \\(qos_class_self().description) (expected \\(qos_class_main().description)), after the previous block\")&#125; 1.2 串行耗时操作 每一段子任务依赖上一个任务完成，全部完成后回调主线程：1234567891011let backgroundBlock = Async.background &#123; print(\"This is run on the first\\(qos_class_self().description) (expected \\(QOS_CLASS_BACKGROUND.description))\") sleep(2) print(\"This is run on the second \\(qos_class_self().description) (expected \\(QOS_CLASS_BACKGROUND.description))\") sleep(2)&#125;// Run other code here...backgroundBlock.main &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(qos_class_main().description)), after the previous block\")&#125; 1.3 并发耗时操作 每一段子任务独立，所有子任务完成后回调主线程：12345678910111213141516Async.main &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(qos_class_main().description))\") // Prints: \"This is run on the Main (expected Main) count: 1 (expected 1)\" &#125;.userInteractive &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(QOS_CLASS_USER_INTERACTIVE.description))\") // Prints: \"This is run on the Main (expected Main) count: 2 (expected 2)\" &#125;.userInitiated &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(QOS_CLASS_USER_INITIATED.description)) \") // Prints: \"This is run on the User Initiated (expected User Initiated) count: 3 (expected 3)\" &#125;.utility &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(QOS_CLASS_UTILITY.description)) \") // Prints: \"This is run on the Utility (expected Utility) count: 4 (expected 4)\" &#125;.background &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(QOS_CLASS_BACKGROUND.description)) \") // Prints: \"This is run on the User Interactive (expected User Interactive) count: 5 (expected 5)\"&#125; 延时执行延时一段时间后执行代码，一般见于打开 App 一段时间后，弹出求好评对话框。123456let seconds = 3.0Async.main(after: seconds) &#123; print(\"Is called after 3 seconds\")&#125;.background(after: 6.0) &#123; print(\"At least 3.0 seconds after previous block, and 6.0 after Async code is called\")&#125; 其他用法请见 Demo。 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io 源码 : https://github.com/ReverseScale/ThreadScenarioDemo","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/tags/Project/"}]},{"title":"门罗币(Monero XMR)给你最轻巧的矿工生活(包教包会)","slug":"Monero XMR","date":"2018-02-08T18:56:27.000Z","updated":"2018-11-15T14:40:15.273Z","comments":true,"path":"2018/02/09/Monero XMR/","link":"","permalink":"https://reversescale.github.io/2018/02/09/Monero XMR/","excerpt":"你向往躺着赚钱吗？你想不努力工作就实现财务自由吗？你想什么都不做就有数不完的钱吗？洗洗睡吧~","text":"你向往躺着赚钱吗？你想不努力工作就实现财务自由吗？你想什么都不做就有数不完的钱吗？洗洗睡吧~ 从2017年8月21日开始，XMR一路走高，从$55左右，一路上涨，到本文写作时，已经达到$269（≈￥1,699）。数据来源：Crypto coins mining profit calculator compared to Ethereum 门罗币（Monero，代号XMR）是一个创建于2014年4月开源加密货币，它着重于隐私、分权和可扩展性。与自比特币衍生的许多加密货币不同，Monero基于CryptoNote协议，并在区块链模糊化方面有显著的算法差异。Monero的模块化代码结构得到了比特币核心维护者之一的Wladimir J. van der Laan的赞赏。Monero致力于成为可代替的不可追踪的电子货币。相比比特币及其分叉，Monero具有更高程度的匿名性。 Monero于2014年4月18日发布。 高涨的币价使得在国内一直默默无闻的XMR瞬间成为焦点，现在已经变成挖矿收益最高的币种之一。以1060 3G为例，在不超频的情况下，挖掘XMR的速度在430H/s左右，不计电费，单卡日收益达到$1.62，超过了之前收益之王ETH。 如何挖矿？ 作为矿工，大家最关心的应该还是怎么挖矿了，下面就向大家介绍一下挖矿的最轻巧姿势。 获得一个钱包地址（推荐）使用在线钱包：https://mymonero.com/特点：使用方便，安全性差 或者在XMR的官方网站下载钱包 App：Monero: Downloads(https://getmonero.org/downloads/)特点：相对安全，方便性差 参与挖矿在网上，你可能看到过许许多多硬件驱动的挖矿方式，组合多少显卡的矿池，但是这里的主题是“最轻巧”，所以我们只做帮工好了。 Coinhive是一个提供恶意JS脚本的网站平台（https://coinhive.com），允许攻击者将脚本挂在到自己的或入侵的网站上，所有访问该网站的用户都可能成为门罗币的挖掘矿工。该工具在网络犯罪分子中间迅速扩散，俨然已经成为了互联网的“Martin Shkreli”。 Coinhive工具其实是一个Java库，用户访问加载该JS的网站后，Coinhive的JS代码库在用户的浏览器上运行，开始为网站所有者挖掘门罗币，消耗的是用户自己的CPU资源。 不得不说，这个想法相当地有创意！Coinhive于9月14日推出，作者向站长们推广Coinhive时声称，站长们加载了Coinhive JS就可以实现盈利：它仅耗费访问用户的少部分CPU，就可以为网站所有者赚取利润，用于支持他们的业务，再也不用添加各种烦人的广告了。 这一想法获得了某些人的支持，在The Pirate Bay（全球知名的BT下载网站）试运行了两天后，由于用户的负面反馈，最后放弃了。 未开情况下 CPU 占用： 理论上你可以使用闲置的那 54.08% 进行挖矿，实测对 CPU 的负荷还是很大的下图是开通100 Threads 下处理器占用情况： 矿工分成之前已经介绍过这种机制的原理了，轻量也注定着收益不会太高，但是简单的使用却可以为你省下大把时间，相信你的时间才是最宝贵的。 上面那些对于刚刚接触的你可能不是很受用，那来看看下面这些 以为这样以后每天的早餐钱就有了？😆那你最好仔细读读下面的东西…","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/tags/Tips/"}]},{"title":"Jenkins + Fastlane 自动打包脚本","slug":"AutoBuildScript","date":"2017-06-20T13:55:38.000Z","updated":"2018-11-15T13:19:25.616Z","comments":true,"path":"2017/06/20/AutoBuildScript/","link":"","permalink":"https://reversescale.github.io/2017/06/20/AutoBuildScript/","excerpt":"使用 Jenkins 运行 Fastlane 命令，实现定时自动打包、修改版本号、上传 Fir 或者 TestFlight 等功能，从此再也不用被小伙伴追着要测试包。 三步配置，杜绝污染，一步操作自动上传~","text":"使用 Jenkins 运行 Fastlane 命令，实现定时自动打包、修改版本号、上传 Fir 或者 TestFlight 等功能，从此再也不用被小伙伴追着要测试包。 三步配置，杜绝污染，一步操作自动上传~ 📺 故事背景记得大约两年前，当时在创业公司，开发任务重，提测前常常加班到晚上 12 点，就算 bug 修完，也要看着 Xcode 不慌不忙的花半个多小时打包完成，再上传测试平台，发了邮件才能安心回家。鉴于这种惨痛经历，利用闲暇时间就搞一搞自动打包脚本，后期有配上 Jenkins，从此过上了没羞没臊的生活。（已适配 Xcode 8.2 之后版本） 🚀 框架的优势 1.市面上文件最少，使用最便捷的自动化打包脚本 2.冗余方法少，结构清晰，注释齐全 3.同时支持多平台上传，如：Dir、Fir、蒲公英、App Store等 4.具备较高自定义性 5.[自编脚本的时代] -&gt; [Fastlane 的时代] █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🚂 自编脚本的时代 [🚂 自编脚本的时代] 了解一下即可，有些准备工作提供参考，如环境已经配置好，请直接阅读 [🚄 Fastlane 的时代] 第一步 安装fir-cilfir-cli 使用 Ruby 构建, 无需编译, 只要安装相应 gem 即可. 12$ ruby -v # &gt; 1.9.3$ gem install fir-cli 常见的安装问题(1)使用系统自带的 Ruby 安装, 需确保 ruby-dev 已被正确的安装: 12$ xcode-select --install # OS X 系统$ sudo apt-get install ruby-dev # Linux 系统 (2)现 Permission denied 相关错误: 解决：在命令前加上 sudo (3)出现 Gem::RemoteFetcher::FetchError 相关错误: 解决：更换 Ruby 的淘宝源(由于国内网络原因, 你懂的), 并升级下系统自带的 gem12345678$ gem sources --remove https://rubygems.org/$ gem sources -a https://ruby.taobao.org/$ gem sources -l*** CURRENT SOURCES ***https://ruby.taobao.org# 请确保只有 ruby.taobao.org, 如果有其他的源, 请 remove 掉gem update --systemgem install fir-cli (4)Mac OS X 10.11 以后的版本, 由于10.11引入了 rootless, 无法直接安装 fir-cli, 有以下三种解决办法: 方法一： 使用 Homebrew 及 RVM 安装 Ruby, 再安装 fir-cli(推荐)12345# Install Homebrew:$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;# Install RVM:$ \\curl -sSL https://get.rvm.io | bash -s stable --ruby$ gem install fir-cli 方法二： 指定 fir-cli 中 bin 文件的 PATH1$ export PATH=/usr/local/bin:$PATH;gem install -n /usr/local/bin fir-cli 方法三： 重写 Ruby Gem 的 bindir12$ echo &apos;gem: --bindir /usr/local/bin&apos; &gt;&gt; ~/.gemrc$ gem install fir-cli 第二步 登录fir.im先到 https://fir.im 创建项目，得到 API Token 并复制。 1fir login 命令用于使用 API token 登录 fir.im, 并使用发布应用等相关命令. 1fir me 命令用于查看当前登录用户信息. 显示信息如下：12345678$ fir login XXX_YOUR_API_TOKEN_XXXI, [2016-03-08T12:48:56.499435 #13043] INFO -- : Login succeed, previous user&apos;s email: xxx@fir.imI, [2016-03-08T12:48:56.507044 #13043] INFO -- : Login succeed, current user&apos;s email: xxx@fir.imI, [2016-03-08T12:48:56.507147 #13043] INFO -- :$ fir meI, [2016-03-08T12:48:14.175488 #12986] INFO -- : Login succeed, current user&apos;s email: xxx@fir.imI, [2016-03-08T12:48:14.175687 #12986] INFO -- : Login succeed, current user&apos;s name: xxxI, [2016-03-08T12:48:14.175765 #12986] INFO -- : 第三步 下载并配置 shell 脚本1.把文件夹导入工程目录根目录下 2.配置 shell 脚本 12345678# 需要改动的地方 (根据项目具体信息改动)PROJECT_NAME = &quot;***&quot; #项目名称VERSION = &quot;1.0.0&quot; #打包版本号 会根据不同的版本创建文件夹（与项目本身的版本号无关）TAGREAT_NAME = &quot;***&quot; #项目对应target的名称如 &quot;Meifabao_User&quot; &quot;Miefabao_stylist&quot;CONFIGURATION = &quot;Release&quot; #打包的环境设置 Release 环境 Debug 环境PROFILE = &quot;AdHoc&quot; #配置文件分为四种 AdHoc Dev AppStore Ent 分别对应四种配置文件OUTPUT = &quot;./Packge/%s&quot; %(CONFIGURATION) #打包导出ipa文件路径（请确保 “%s” 之前的文件夹正确并存在） 根据具体项目填写 3.控制台到项目所在目录下，启动脚本(必要时加管理员权限) 可以将 autobuild.py 拖拽到控制台，执行脚本 注：其他的功能脚本由于实用性不高（其实我懒得搞），暂时没有适配，有兴趣的朋友可以自行配置试用，包括：邮件发送、打包 App Store 等等。 当看到 时，打包好的项目已经躺在你的 Fir 测试平台中了。 █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🚄 Fastlane 的时代2018.08.20 更新：Jenkins + Fastlane + GitLab + fir (或者蒲公英)第一步 安装 FastlaneFastlane 是一套使用Ruby写的自动化工具集，用于iOS和Android的自动化打包、发布等工作，可以节省大量的时间 1sudo gem install fastlane --verbose 第二步 移动脚本至项目目录下根据注释完善脚本配置信息 脚本说明： 支持版本号自增长 支持传入自定的宏，用于在代码里使用此预编译的宏来区分开发环境和发布环境 支持自动上传到 fir 和 testflight 上传成功后弹窗提示 第三步 上传上传到 fir 的用法：1./build.sh -m &quot;xxxx_app_test&quot; -t test 上传到 testflight 的用法：1./build.sh -m &quot;xxxx_app_pro&quot; -t pro 第四步 配置 JenkinsJenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。 下载 Jenkins：点击 http://mirrors.jenkins.io/war-stable/latest/jenkins.war 下载最新的Jenkins.war 运行服务器：需要先安装 java sdk （http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html） 1java -jar jenkins.war 运行 Jenkins1jenkins 配置 Jenkins：浏览器打开 http://localhost:8080/ 输入安全密码，安全密码命令行输出的一个文件里面。 然后自动安装推荐的插件，并新建管理员账号密码。 安装插件登录http://localhost:8080/ ，选择系统管理 - 管理插件。在可选插件中选择GitLab Plugin，Gitlab Hook Plugin，和 Cocoapod plugin 进行安装。 构建任务 点击新建，输入名称，构建一个自由风格的软件项目。 配置 Git 仓库地址，并添加 git 账号。 配置构建脚本 附录 执行脚本过程中遇到的问题和解决方案fir: command not found这个是因为没有安装fir-cil，导致找不到相应的命令行，只需要安装一下就行了，详情见上文写的如何安装fir-cil。 README: No such file or directory那是因为你的脚本目录下没有README的文件，只需要建一个README的文件就行了，打开终端，cd到当前位置，然后执行下面的命令： 1touch README ERROR – : Token can not be blank这个原因是因为你没有登录fir导致的，你执行这个脚本之前应该先登录一下fir，详情请看上文写的登录fir.im。 ERROR – : Code=14 (没有试用的设备 Domain=IDEDistributionErrorDomain Code=14 “No applicable devices原因：rvm ruby 配置错误 解决：控制台 rvm system █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 2018.08.20 更新：Jenkins 相关设置方法查看端口占用端口占用 使用 lsof 会列举所有占用的端口列表： 1lsof 使用less可以用于分页展示，如： 1lsof | less 也可以使用 -i 查看某个端口是否被占用，如： 1lsof -i:3000 杀死进程 1kill PID（进程的PID，如2044） Jenkins 改时区http://your-jenkins/systemInfo，查看user.timezone变量的值 在jenkins的【系统管理】-【脚本命令行】里运行 1System.setProperty(&apos;org.apache.commons.jelly.tags.fmt.timeZone&apos;, &apos;Asia/Shanghai&apos;) Jenkins 构建超时jenkins的”build timeout plugin”插件可以帮我们完成该任务。我使用的是jenkins-2.7.1, 默认就已经安装了该插件，如果默认没有安装可在插件管理中搜索进行安装。 Jenkins 定时构建和Poll SCM的区别 Build periodically：周期进行项目构建（源码是否发生变化没有关系） Poll SCM：定时检查源码变更，如果有更新就checkout最新code下来，然后执行构建动作 12345678910111213每15分钟构建一次：H/15 * * * * 或 */5 * * * *每天8点构建一次：0 8 * * *每天8点~17点，两小时构建一次：0 8-17/2 * * *周一到周五，8点~17点，两小时构建一次：0 8-17/2 * * 1-5每月1号、15号各构建一次，除12月：H H 1,15 1-11 **/5 * * * * （每5分钟检查一次源码变化）0 2 * * * （每天2:00 必须build一次源码） █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🕹 agvtool 命令行2018.08.20 更新：agvtool 命令行 管理版本号常用命令行：设置 版本号 为 1.1.01xcrun agvtool new-marketing-version 1.1.0 设置 build 号 自动加11xcrun agvtool next-version -all 简介agvtool 是一个命令行工具，允许你自动递增到下一个最高的数量或具体的数字这些数字。 修改Xcode的默认设置默认情况下，在不使用任何版本控制系统。设置版本系统苹果通用确保 Xcode 将包括在你的项目中生成的所有agvtool版本信息。 上图：设置当前项目的版本和版本控制系统的构建设置 设置你的版本号和 bulid 版本号agvtool 查询应用程序的 Info.plist 得到你的版本和 bulid 版本号。 所以确保 CFBundleVersion (Bundle version) 和 CFBundleShortVersionString (Bundle versions string, short）的 key 在你的 Info.plist 中。 上图：info.plist 命令行操作更新版本号退出Xcode，然后导航到包含项目的目录，运行下列命令在终端应用 agvtool 属性工作。 设置 版本号 为 1.1.01xcrun agvtool new-marketing-version 1.1.0 设置 build 号 自动加11xcrun agvtool next-version -all 设置 build 号为 311xcrun agvtool new-version -all 31 查看 Version Numbers1xcrun agvtool what-marketing-version 查看 Build Numbers1xcrun agvtool what-version 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Script","slug":"Script","permalink":"https://reversescale.github.io/categories/Script/"}],"tags":[{"name":"Script","slug":"Script","permalink":"https://reversescale.github.io/tags/Script/"}]},{"title":"GoF 设计模式 + 情景再现","slug":"Design patterns Gof","date":"2017-03-01T12:29:16.000Z","updated":"2018-11-15T13:19:15.263Z","comments":true,"path":"2017/03/01/Design patterns Gof/","link":"","permalink":"https://reversescale.github.io/2017/03/01/Design patterns Gof/","excerpt":"《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995），这几位作者常被称为”四人组（Gang of Four）”~","text":"《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995），这几位作者常被称为”四人组（Gang of Four）”~ 设计模式和情景再现创建型模式1、ABSTRACT FACTORY—追MM少不了请吃饭了，麦当劳的套餐和肯德基的套餐都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说“两个B套餐”就行了。麦当劳和肯德基就是B套餐的Abstract Factory, B套餐里含有汉堡, 鸡翅和饮料. 麦当劳或肯德基会根据B套餐的规格, 让汉堡Factory, 鸡翅Factory, 饮料Factory分别生产对应B套餐的材料。抽象工厂模式：客户类和工厂类分开。消费者任何时候需要某套产品集合时，只需向抽象工厂请求即可。抽象工厂会再向具体的工厂生产出符合产品集规格的产品。 2、BUILDER—MM最爱听的就是“我爱你”这句话了，见到不同地方的MM,要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出“我爱你”这句话了，国外的MM也可以轻松搞掂，这就是我的“我爱你”builder。（这一定比美军在伊拉克用的翻译机好卖）建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。 3、FACTORY METHOD—请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说“要一个汉堡”，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。 4、PROTOTYPE—跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype了。（100块钱一份，你要不要）原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。 5、SINGLETON—俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Singleton，她们只要说道“老公”，都是指的同一个人，那就是我。(刚才做了个梦啦，哪有这么好的事)单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。 结构型模式6、ADAPTER—在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的Adapter，让我和Sarah可以相互交谈了(也不知道他会不会耍我)适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。 7、BRIDGE—早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我“早上碰到MM新做了个发型怎么说”这种问题，自己用BRIDGE组合一下不就行了。桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。 8、COMPOSITE—Mary今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM都会用Composite模式了，你会了没有？合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。 9、DECORATOR—Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上“最好的的礼物，就是爱你的Fita”，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来……，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。 10、FACADE—我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。 11、FLYWEIGHT—每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。享元模式：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。 12、PROXY—跟MM在网上聊天，一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。 行为模式13、CHAIN OF RESPONSIBILITY—晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi,可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了，听说是个老处女呀，快跑!责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。 14、COMMAND—俺有一个MM家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送COMMAND，就数你最小气，才请我吃面。” :-(命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。 15、INTERPRETER—俺有一个《泡MM真经》，上面有各种泡MM的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟MM约会时，只要做一个Interpreter，照着上面的脚本执行就可以了。解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。 16、ITERATOR—我爱上了Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件”我：“什么条件我都答应，你说吧”Mary：“我看上了那个一克拉的钻石”我：“我买，我买，还有吗？”Mary：“我看上了湖边的那栋别墅”我：“我买，我买，还有吗？”……迭代子模式：迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。 17、MEDIATOR—四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。 18、MEMENTO—同时跟几个MM聊天时，一定要记清楚刚才跟MM说了些什么话，不然MM发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个MM说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。 19、OBSERVER—想知道咱们公司最新MM情报吗？加入公司的MM情报邮件组就行了，tom负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦观察者模式：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。 20、STATE—跟MM交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的MM就会说“有事情啦”，对你不讨厌但还没喜欢上的MM就会说“好啊，不过可以带上我同事么？”，已经喜欢上你的MM就会说“几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把MM的状态从不讨厌不喜欢变成喜欢哦。状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。 21、STRATEGY—跟不同类型的MM约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到MM的芳心，我的追MM锦囊中有好多Strategy哦。策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模式把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。 22、TEMPLATE METHOD——看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤(Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦(具体实现)；模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。 23、VISITOR—情人节到了，要给每个MM送一束鲜花和一张卡片，可是每个MM送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下Visitor，让花店老板根据MM的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。 设计模式之间的关系图： 设计模式的六大原则1、开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle）为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle）原则是尽量使用合成/聚合的方式，而不是使用继承。","categories":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/categories/Book/"}],"tags":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/tags/Book/"}]},{"title":"iOS 开发中常用的设计模式","slug":"Design patterns iOS","date":"2017-02-21T06:56:27.000Z","updated":"2018-11-15T13:23:48.042Z","comments":true,"path":"2017/02/21/Design patterns iOS/","link":"","permalink":"https://reversescale.github.io/2017/02/21/Design patterns iOS/","excerpt":"之前有朋友问到设计模式，便特意找了一篇文章，专门介绍在 iOS 开发中，对设计模式的具体应用，同时推荐一本书《Head First设计模式》~","text":"之前有朋友问到设计模式，便特意找了一篇文章，专门介绍在 iOS 开发中，对设计模式的具体应用，同时推荐一本书《Head First设计模式》~ （一）代理模式应用场景：当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。优势：解耦合敏捷原则：开放-封闭原则实例：tableview的 数据源delegate，通过和protocol的配合，完成委托诉求。列表row个数delegate自定义的delegate （二）观察者模式应用场景：一般为model层对，controller和view进行的通知方式，不关心谁去接收，只负责发布信息。优势：解耦合敏捷原则：接口隔离原则，开放-封闭原则实例：Notification通知中心，注册通知中心，任何位置可以发送消息，注册观察者的对象可以接收。kvo，键值对改变通知的观察者，平时基本没用过。 （三）MVC模式应用场景：是一中非常古老的设计模式，通过数据模型，控制器逻辑，视图展示将应用程序进行逻辑划分。优势：使系统，层次清晰，职责分明，易于维护敏捷原则：对扩展开放-对修改封闭实例：model-即数据模型，view-视图展示，controller进行UI展现和数据交互的逻辑控制。 （四）单例模式应用场景：确保程序运行期某个类，只有一份实例，用于进行资源共享控制。优势：使用简单，延时求值，易于跨模块敏捷原则：单一职责原则实例：[UIApplication sharedApplication]。注意事项：确保使用者只能通过 getInstance方法才能获得，单例类的唯一实例。java，C++中使其没有公有构造函数，私有化并覆盖其构造函数。object c中，重写allocWithZone方法，保证即使用户用 alloc方法直接创建单例类的实例，返回的也只是此单例类的唯一静态变量。 （五）策略模式应用场景：定义算法族，封装起来，使他们之间可以相互替换。优势：使算法的变化独立于使用算法的用户敏捷原则：接口隔离原则；多用组合，少用继承；针对接口编程，而非实现。实例：排序算法，NSArray的sortedArrayUsingSelector；经典的鸭子会叫，会飞案例。注意事项：1，剥离类中易于变化的行为，通过组合的方式嵌入抽象基类2，变化的行为抽象基类为，所有可变变化的父类3，用户类的最终实例，通过注入行为实例的方式，设定易变行为防止了继承行为方式，导致无关行为污染子类。完成了策略封装和可替换性。 （六）工厂模式应用场景：工厂方式创建类的实例，多与proxy模式配合，创建可替换代理类。优势：易于替换，面向抽象编程，application只与抽象工厂和易变类的共性抽象类发生调用关系。敏捷原则：DIP依赖倒置原则实例：项目部署环境中依赖多个不同类型的数据库时，需要使用工厂配合proxy完成易用性替换注意事项：项目初期，软件结构和需求都没有稳定下来时，不建议使用此模式，因为其劣势也很明显，增加了代码的复杂度，增加了调用层次，增加了内存负担。所以要注意防止模式的滥用。 设计模式六大原则1、开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle）为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle）原则是尽量使用合成/聚合的方式，而不是使用继承。 《Head First设计模式》http://pan.baidu.com/s/1nvTqSdj 验证码：DG58","categories":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/categories/Book/"}],"tags":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/tags/Book/"}]}]}