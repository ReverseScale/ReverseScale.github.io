{"meta":{"title":"Technology","subtitle":"","description":"","author":"Steven's Blog","url":"https://reversescale.github.io"},"pages":[{"title":"Not found","date":"2018-11-15T12:15:47.151Z","updated":"2018-11-15T02:35:05.000Z","comments":true,"path":"404.html","permalink":"https://reversescale.github.io/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#fff;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#000;margin-top:260px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=5; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"About","date":"2015-08-16T06:58:08.000Z","updated":"2018-11-15T15:43:12.035Z","comments":false,"path":"about/index.html","permalink":"https://reversescale.github.io/about/index.html","excerpt":"","text":"Excellence is a continuous process and not an accident. Thanks for reading! ~ 👨🏻‍💻 职业：程序员劝退师📟 WeChat：WhatsXie🤪 不只生产 bug 更是 bug 的搬运工📮 邮件：ReverseScale@iCloud.com 博客新装修，历史文章正在路上…"},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2018-01-25T14:41:06.000Z","comments":true,"path":"archives/index.html","permalink":"https://reversescale.github.io/archives/index.html","excerpt":"","text":""},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2018-01-25T14:41:06.000Z","comments":false,"path":"categories/index.html","permalink":"https://reversescale.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2018-01-25T14:41:06.000Z","comments":true,"path":"tags/index.html","permalink":"https://reversescale.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用 Ngrok 快速实现内网穿透","slug":"Ngrok through","date":"2018-08-13T03:56:27.000Z","updated":"2018-11-16T13:22:10.603Z","comments":true,"path":"2018/08/13/Ngrok through/","link":"","permalink":"https://reversescale.github.io/2018/08/13/Ngrok through/","excerpt":"实现内网穿透的工具很多，之所以介绍 Ngrok，主要还是因为它使用便捷，不用搭建服务器等等麻烦的工序，适合前段开发过程中，快速评估检测项目~","text":"实现内网穿透的工具很多，之所以介绍 Ngrok，主要还是因为它使用便捷，不用搭建服务器等等麻烦的工序，适合前段开发过程中，快速评估检测项目~ Ngrok是什么ngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放。 而我用来在家里快速访问 Jenkins，偷个懒🤪 搭建方法由于要完成一个网页优化的作业找了很久ngrok的使用方法，都不够简便易行最后终于发现了一个好方法。 下载 MAC 版的 ngrok：https://ngrok.com/download 解压到指定目录：Safari 浏览器下载 Mac OS X 环境一般直接解压（反正我是自动解压的），将 ngrok 放进项目目录。 进入到 ngrok 所在路径：1cd /tmp 开启服务1./ngrok http localhost:8080 会出现如下 ngrok 控制台 等待 Session Status 状态为 online（变绿），就可以在外网通过 Forwarding 的地址进行连接了。 注意：Forwarding地址中的 c33faf1b 不是固定的，在每次开始 ngrok 服务的时候都会变更，想固定？ ngrok:😛要钱。 测试一下例如： ngrok 穿透前在局域网中访问地址：http://localhost:8080 ngrok 穿透后局域网 + 公网访问地址：https://c33faf1b.ngrok.io","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://reversescale.github.io/tags/Web/"}]},{"title":"如何用 Swift 打造你的第一个区块链 App","slug":"How to build DApp","date":"2018-07-06T14:51:21.000Z","updated":"2018-11-16T12:06:29.783Z","comments":true,"path":"2018/07/06/How to build DApp/","link":"","permalink":"https://reversescale.github.io/2018/07/06/How to build DApp/","excerpt":"区块链(Blockchain) 是一种突破性技术(Disruptive Technologies)，近年渐获关注，号称将互联网从信息共享，推向价值传递，让我们一步一步的来探索它设计上的奇思妙想~","text":"区块链(Blockchain) 是一种突破性技术(Disruptive Technologies)，近年渐获关注，号称将互联网从信息共享，推向价值传递，让我们一步一步的来探索它设计上的奇思妙想~ 因为区块链是许多加密货币(Cryptocurrencies) 如比特币(Bitcoin)、以太坊(Ethereum)、莱特币(Litecoin) 的创始技术。那区块链是如何运作的呢？在本次的教学里，我将会谈到所有关于区块链技术的知识，以及如何用Swift 来制作自己的「区块链」。那么，让我们开始吧！ 区块链的运作顾名思义，区块链就是一个由不同的区块串连在一起的「链」，每个区块包含三则资讯：资料(Data)、杂凑值(Hash)、和前一个区块的杂凑值。 资料 ──依据使用情境，储存在区块的资料会因区块链的类型而不同。例如，在比特币区块链中，储存资料就是与交易有关的资讯，即是转帐的金额、以及参与交易二人的资讯。 杂凑值 ──你可以把杂凑想成是一种数位指纹，它是用来识别一个区块及其资料。杂凑最重要的地方，就是它是一个独一无二的字母数字(Alphanumeric)程式码，通常会由64个字元组成。当一个区块被创造时，杂凑值也同时产生。当一个区块被更动时，杂凑值也会同时被更动。透过这种方式，当你想要查看区块上的任何变动时，杂凑值就非常重要。 前一个区块的杂凑值 ──每个区块就是藉由储存前个区块的杂凑来链结在一起，组成一个区块链！这就是让区块链如此安全的原因。看看这张图片： 如你所见，每个区块由资料（未显示）、杂凑值、和前一个区块杂凑值所组成。举个例子，黄色区块包含了自己的杂凑值H7S6、和红色区块的杂凑值8SD9。以这种方式，它们组成了一个链结，并以此连结在一起。现在，假设有个骇客入侵并尝试更动红色区块。请记住，每次一个区块以任何方式被更动时，区块的杂值凑也会被更动！因此，当下一个区块执行确认、并看到前一个区块的杂凑值并不吻合时，它会有效地将自己从「链」中分离出来，而不会被骇客读取。 这就是区块练会如此安全的原因，你几乎不可能尝试回溯并更改任何资料。杂凑值提供了不错的保密及隐私，但还有两个安全机制来让区块链更加安全：验证(Proof-of-work)及智慧合约(Smart Contract)。虽然我不会详述，但你可以在这里了解更多。区块链最后一个保全方式就是基于它的位置。与大多储存在伺服器或是资料库内的资料不同，区块链使用点对点网路(Peer-To-Peer, P2P)，它是一种网路型态，允许任何人加入并将该网路上的资料分发给每位接收者。每当有人加入这个网路时，他们就会得到区块链的完整拷贝；每当有人建立一个新区块时，就会传送到网路内的所有人。然后，透过一些复杂的程式，让节点(Node)在加入这个区块到区块链之前，先确认该区块有否被窜改。就这样，任何地方的任何人都可以取得这些资讯。如果你是HBO矽谷群瞎传(Silicon Valley)的忠实粉丝，这听起来可能有点熟悉，因为在这出美剧里，主角就是用了类似的技术来建立一个全新网路。 因为每个人或节点都有一份区块链的拷贝，他们可以有共识并确认哪些区块是合法的。因此，如果你想要骇入一个区块，你必须骇入网路上超过50% 的区块来通过你的资讯。这就是为什么区块链或许是过去十年以来最安全的技术之一。 关于范例应用现在你了解区块链是如何运作了，那么开始来制作我们的范例App吧！请先下载初始项目。（https://raw.githubusercontent.com/appcoda/BlockchainDemo/master/BlockchainStarter.zip） 如你所见，我们有两个比特币钱包。第一个帐号Account 1065 拥有500 BTC，而第二个帐号0217 则什么都没有。我们利用传送按钮来传送比特币到其他帐号。为了赚取BTC，我们按下Mine 按钮就可以获得50 BTC 为奖励。基本来说，我们做的是当App 执行时，利用控制台来观察两个比特币帐号间的交易情况。 你会注意到，侧边栏里有两个重要的类别：Block及Blockchain。打开这些档案，你会看到档案是空的，那是因为我将会引导你写出这些类别的逻辑。那我们开始吧！ 在Swift 定义Block前往Block.swift并添加程式码以定义一个区块。首先，让我们了解一下区块是什么。我们先前定义了一个区块由三个部分组成：杂凑值、记录的实际资料、以及前一个区块的杂凑值。当我们想建立自己的区块链时，必须要知道区块的排序，这一点可以很容易地在Swift中定义。添加以下程式码到类别里： 1234var hash: String!var data: String!var previousHash: String!var index: Int! 现在，我们需要添加最后一个重要的程式码。我之前提到每次一个区块被更动，杂凑就会改变；这就是区块链如此安全的特色之一。所以我们必须建立一个函式来产生一个随机字母数字的杂凑。这个函式只需要几行程式码： 123func generateHash() -&gt; String &#123; return NSUUID().uuidString.replacingOccurrences(of: \"-\", with: \"\")&#125; NSUUID是一个物件，代表桥接UUID的通用唯一值。它内置于Swift中，而且非常适合用来产生32字元的字串。这个函式产生一个UUID，消除所有连字符(-)，然后回传String，即区块的杂凑。Block.swift现在应该看起来像这样： 我们已经定义了Block类别，接着让我们定义Blockchain类别吧。切换到Blockchain.swift。 在Swift 定义Blockchain如前文所说，让我们尝试从基本面来了解区块链。在基本的术语里，区块链只是区块串在一起组成的链；换句话说，它是一个包含所有项目的列表。听起来是不是有点熟悉呢？因为这就是阵列的定义，而这个阵列就是由区块所组成！让我们把下列的程式码加进去吧： 1var chain = [Block]() 小提示：这几乎可以应用在电脑科学世界的所有事上。如果你曾遇过大问题，试着将它拆解成小组件，然后以自己的方法来解决问题；就像我们弄清楚如何在Swift中加入区块及区块链一样！ 你会注意到在阵列里面包含了先前定义的Block类别，那是我们在区块链中需要的所有变数。加入两个函式到类别里，我们就完成了。试着用我前文所教的来回答这个问题： 在一个区块链中，两个主要的函式是什么？ 希望你能够回答这个问题！这两个区块链拥有的主要函式，是用来建立初始区块，以及在后面新增新的区块。当然，现在我不会下放这个链并加入智慧合约，但是这些是基本函式！加入以下程式码到Blockchain.swift： 1234567891011121314151617func createGenesisBlock(data:String) &#123; let genesisBlock = Block() genesisBlock.hash = genesisBlock.generateHash() genesisBlock.data = data genesisBlock.previousHash = \"0000\" genesisBlock.index = 0 chain.append(genesisBlock)&#125; func createBlock(data:String) &#123; let newBlock = Block() newBlock.hash = newBlock.generateHash() newBlock.data = data newBlock.previousHash = chain[chain.count-1].hash newBlock.index = chain.count chain.append(newBlock)&#125; 我们加入的第一个函式是用来建立初始区块。为此，我们建立了一个函式来把区块的资料作为Input。然后，我们定义一个名为genesisBlock的变数，并将它设为Block型别。因为它是Block型别，所以它有我们之前在Block.swift定义的所有变数及函式。我们设定generateHash()为杂凑、 Input data为资料。因为这是第一个区块，所以我们将前一个区块的杂凑设定为000，好让我们知道这是初始区块。我们将它的索引值设为0 ，然后放到区块链chain。 我们建立的下一个函式则适用于所有genesisBlock后的区块，而它会建立剩下的所有区块。你会注意到它跟之前的函式非常相似，唯一的不同的是我们将previousHash设定为前一个区块的杂凑，并将index设为它在区块练的位置。完成了！我们已经成功定义自己的Blockchain！你的程式码应该如下图所示！ 接着，我们将所有的部分连接到ViewController.swift档案，并看看执行成果吧！ 钱包后台(Wallet Backend)切换到ViewController.swift，我们可以看到所有的UI元件都已经连结完毕。我们所需要做的就是处理交易，并将交易列印到控制台上。然而在开始之前，我们应该稍微探讨一下比特币区块链。比特币来自一个总帐号，假设这个帐号的编号是000。当你挖掘一颗比特币时，就表示你解答了数学问题，并获得一定数量的比特币作为奖励。这是发行货币一个很聪明的方法，同时也创造了让更多人去挖掘的动机。在我们的App 里，我们将100 BTC 作为奖励。首先，让我们在ViewController 添加需要的变数： 123456let firstAccount = 1065let secondAccount = 0217let bitcoinChain = Blockchain()let reward = 100var accounts: [String: Int] = [\"0000\": 10000000]let invalidAlert = UIAlertController(title: \"Invalid Transaction\", message: \"Please check the details of your transaction as we were unable to process this.\", preferredStyle: .alert) 我们定义两个帐号：一个编号为1065，另一个编号为0217。我们同时新增一个bitcoinChain变数来作为我们的区块链，并将reward设定为100。我们需要一个作为比特币来源的主帐号：这是我们的初始帐号，编号为0000，它拥有一千万个比特币。你可以把这个帐号当成银行，在每一次的奖励中，就会从中取出100个比特币，并转至合法的帐号里。我们也定义一个警告，在每次交易无法完成时显示。 现在，让我们来写些将会执行的泛用函式。你可以猜到这些函式是什么吗？ 第一个函式是用来处理交易的。我们要确认传送者及接收者的帐号中，接收或扣除的金额是正确的，而且这个资讯会被记录在我们的区块链上。 下一个函式是要在控制台里印出完整的纪录，它会显示每个区块及每个区块内的资料。 最后一个函式是用来验证区块链是否合法，方法为确认前个区块的杂凑是否符合下一个区块的资讯。因为我们不会示范任何骇客方法，所以范例中的链永远都是合法的。 Transaction 函式以下是我们的泛用交易函式。在定义变数之下输入以下程式码： 1234567891011121314151617181920212223242526func transaction(from: String, to: String, amount: Int, type: String) &#123; // 1 if accounts[from] == nil &#123; self.present(invalidAlert, animated: true, completion: nil) return &#125; else if accounts[from]!-amount &lt; 0 &#123; self.present(invalidAlert, animated: true, completion: nil) return &#125; else &#123; accounts.updateValue(accounts[from]!-amount, forKey: from) &#125; // 2 if accounts[to] == nil &#123; accounts.updateValue(amount, forKey: to) &#125; else &#123; accounts.updateValue(accounts[to]!+amount, forKey: to) &#125; // 3 if type == \"genesis\" &#123; bitcoinChain.createGenesisBlock(data: \"From: \\(from); To: \\(to); Amount: \\(amount)BTC\") &#125; else if type == \"normal\" &#123; bitcoinChain.createBlock(data: \"From: \\(from); To: \\(to); Amount: \\(amount)BTC\") &#125;&#125; 看起来程式码很多，但是它的核心只是为每次的交易定义一些规则。在开头的地方，我们有四个参数：to、from、amount以及type。To、From、及Amount的含义一目了然，而Type基本上就是定义交易的类型。这里有两种Type：Normal和Genesis。一个Normal的交易类型会是在帐号1065与0217之间进行，而Genesis交易类型则会涉及到帐号0000。 第一个if-else条件式是关于来源帐号。如果来源帐号不存在或金额不足，我们会显示交易无效的警告，然后结束函式。而如果通过的话，我们会更新数值。 第二个if-else条件式是关于接收帐号。如果接收帐号不存在，那么我们随它而去，然后结束函式。要不然，我们就会传送正确的比特币数量到帐号。 第三个if-else条件式处理交易的类型。如果一个交易涉及初始区块，我们就建立一个新的初始区块；反之我们建立一个新区块来储存资料。 Printing 函式在每次交易的最后，我们想要看到一个清单列出所有交易，来确保我们知道所有发生的事情。以下是我们在transaction函式下输入的程式码： 123456789func chainState() &#123; for i in 0...bitcoinChain.chain.count-1 &#123; print(\"\\tBlock: \\(bitcoinChain.chain[i].index!)\\n\\tHash: \\(bitcoinChain.chain[i].hash!)\\n\\tPreviousHash: \\(bitcoinChain.chain[i].previousHash!)\\n\\tData: \\(bitcoinChain.chain[i].data!)\") &#125; redLabel.text = \"Balance: \\(accounts[String(describing: firstAccount)]!) BTC\" blueLabel.text = \"Balance: \\(accounts[String(describing: secondAccount)]!) BTC\" print(accounts) print(chainValidity())&#125; 这是一个简单的for回圈，包含bitcoinChain的每个区块。我们印出区块的编号、杂凑值、前个区块的杂凑、以及储存的资料，再更新UILabel来显示每个帐号内正确的BTC数目。最后，印出一个列出每个帐号的清单（应该会有三个），并验证链的合法性。现在，你应该会在函式最后一行中发生错误。这是因为我们还没定义chainValidity()函式，那么就来开始吧！ Validity 函式记住，如果前一个区块的杂凑值符合目前区块所描述的内容，那么这一个链就是合法的。我们可以轻易地用另一个for 回圈来重复验证每个区块。 123456789func chainValidity() -&gt; String &#123; var isChainValid = true for i in 1...bitcoinChain.chain.count-1 &#123; if bitcoinChain.chain[i].previousHash != bitcoinChain.chain[i-1].hash &#123; isChainValid = false &#125; &#125; return \"Chain is valid: \\(isChainValid)\\n\"&#125; 跟之前有点相似，我们在bitcoinChain中重复验证每个区块，来确认前一个区块的杂凑值是否与目前区块所描述的内容符合。这样就完成了！我们已经定义了函式，并将会每次都用到它们！你的ViewController.swift现在应该看起来像这样： 现在我们只需要将按钮连接到函式就完成了，来开始最后的篇章吧！ 将所有东西连结在一起当我们的App首次启动时，我们想让初始帐号0000传送50 BTC到我们的第一个帐号。然后，我们将让第一个帐号传送10 BTC到第二个帐号。这个步骤仅需三行程式码就可以完成。如此更改你的viewDidLoad函式： 1234567override func viewDidLoad() &#123; super.viewDidLoad() transaction(from: \"0000\", to: \"\\(firstAccount)\", amount: 50, type: \"genesis\") transaction(from: \"\\(firstAccount)\", to: \"\\(secondAccount)\", amount: 10, type: \"normal\") chainState() self.invalidAlert.addAction(UIAlertAction(title: \"OK\", style: .default, handler: nil))&#125; 我们使用先前定义好的函式，并在最后呼叫chainState()。同时，我们新增一个OK按钮到交易无效的警告中。现在让我们来看看剩下的四个函式里要加入什么：redMine()、blueMine()、redSend()及blueSend()。 挖矿函式挖矿函式非常地简单，只要三行程式码就行了。这就是我们要添加的程式码： 1234567891011@IBAction func redMine(_ sender: Any) &#123; transaction(from: \"0000\", to: \"\\(firstAccount)\", amount: 100, type: \"normal\") print(\"New block mined by: \\(firstAccount)\") chainState()&#125; @IBAction func blueMine(_ sender: Any) &#123; transaction(from: \"0000\", to: \"\\(secondAccount)\", amount: 100, type: \"normal\") print(\"New block mined by: \\(secondAccount)\") chainState()&#125; 在第一个挖矿函式中，我们使用transaction函式从初始帐号传送100 BTC到第一个帐号，先印出一个区块被挖出，再印出chainState。同样地，我们在blueMine函式里将100 BTC传送到第二个帐号。 传送函式传送函式与先前的函式也稍微相似。 123456789101112131415161718192021@IBAction func redSend(_ sender: Any) &#123; if redAmount.text == \"\" &#123; present(invalidAlert, animated: true, completion: nil) &#125; else &#123; transaction(from: \"\\(firstAccount)\", to: \"\\(secondAccount)\", amount: Int(redAmount.text!)!, type: \"normal\") print(\"\\(redAmount.text!) BTC sent from \\(firstAccount) to \\(secondAccount)\") chainState() redAmount.text = \"\" &#125;&#125; @IBAction func blueSend(_ sender: Any) &#123; if blueAmount.text == \"\" &#123; present(invalidAlert, animated: true, completion: nil) &#125; else &#123; transaction(from: \"\\(secondAccount)\", to: \"\\(firstAccount)\", amount: Int(blueAmount.text!)!, type: \"normal\") print(\"\\(blueAmount.text!) BTC sent from \\(secondAccount) to \\(firstAccount)\") chainState() blueAmount.text = \"\" &#125;&#125; 首先，我们确认redAmount或blueAmount中的文字栏位是否为空值。如果是，我们会显示一个交易无效的警告。如果不是，我们就可以继续。我们使用transaction函式输入金额，并把交易设为normal型态，以将第一个帐号的金额传送到第二个帐号（或相反）。我们印出被传送的金额，然后呼叫chainState()函式。最后，把文字栏位清空。这样我们就完成啰！确认一下你的程式码是否符合下图所示。 执行App 试试看！从前端来说，它看起来就如一个普通的交易App，但你会知道它后台的运作。试试使用App 将BTC 从一个帐号交易给另一个帐号、并试着欺骗App 吧！ 结论在这次的教学中，你学到了如何使用Swift 来建立一个区块链，并建立自己的比特币交易。请注意在真实的加密货币后台里，实作部分是跟上文是完全不一样的东西，因为它需要藉由智慧合约来分散，但是上面的示范内容用来学习的。在这个范例中，我们运用了比特币来当加密货币，但你能想到区块链还的其他用途吗？欢迎在下面留言分享你的看法！希望你在此学到新的东西！你可以在Github下载完整项目作参考。 完整项目：https://github.com/appcoda/BlockchainDemo原文链接：https://www.appcoda.com/blockchain-introduction/","categories":[{"name":"Summary","slug":"Summary","permalink":"https://reversescale.github.io/categories/Summary/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://reversescale.github.io/tags/Blockchain/"}]},{"title":"iOS Principle：KVO","slug":"iOS Principle KVO","date":"2018-06-06T13:56:27.000Z","updated":"2018-11-18T05:15:15.406Z","comments":true,"path":"2018/06/06/iOS Principle KVO/","link":"","permalink":"https://reversescale.github.io/2018/06/06/iOS Principle KVO/","excerpt":"KVO 的全称 Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变~","text":"KVO 的全称 Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变~ 👨🏻‍💻 Github Demo 方便记忆： 作用：“键值监听”，可以用于监听某个对象属性值的改变 实现原理： 将监听对象的isa指针指向NSKVONotifyin_类（runtime动态创建的子类） 先实现NSKVONotifyin_类的set方法，先willChangeValueForKey赋值 再didChangeValueForKey调用监听器，到observeValueForKeyPath的方法 引子 123@interface Person : NSObject@property (nonatomic, assign) int age;@end 对 Person 的 age 进行监听的使用方法： 123456789101112131415161718- (void)test_kvo &#123; Person *p1 = [[Person alloc] init]; Person *p2 = [[Person alloc] init]; p1.age = 1; p2.age = 2; NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld; [p1 addObserver:self forKeyPath:@\"age\" options:options context:nil]; p1.age = 10; [p1 removeObserver:self forKeyPath:@\"age\"];&#125;// kvo action- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; NSLog(@\"监听到%@的%@改变了%@\", object, keyPath,change);&#125; 在添加监听之后，age属性的值在发生改变时，就会通知到监听者，执行监听者的observeValueForKeyPath方法。 探寻KVO底层实现原理通过上述代码我们发现，一旦age属性的值发生改变时，就会通知到监听者，并且我们知道赋值操作都是调用 set方法，我们可以来到Person类中重写age的set方法，观察是否是KVO在set方法内部做了一些操作来通知监听者。 我们发现即使重写了set方法，p1对象和p2对象调用同样的set方法，但是我们发现p1除了调用set方法之外还会另外执行监听器的observeValueForKeyPath方法。 说明KVO在运行时获取对p1对象做了一些改变。相当于在程序运行过程中，对p1对象做了一些变化，使得p1对象在调用setage方法的时候可能做了一些额外的操作，所以问题出在对象身上，两个对象在内存中肯定不一样，两个对象可能本质上并不一样。接下来来探索KVO内部是怎么实现的。 KVO底层实现分析首先我们对上述代码中添加监听的地方打断点，看观察一下，addObserver方法对p1对象做了什么处理？也就是说p1对象在经过addObserver方法之后发生了什么改变，我们通过打印isa指针如下图所示 通过上图我们发现，p1对象执行过addObserver操作之后，p1对象的isa指针由之前的指向类对象Person变为指向NSKVONotifyin_Person类对象，而p2对象没有任何改变。也就是说一旦p1对象添加了KVO监听以后，其isa指针就会发生变化，因此set方法的执行效果就不一样了。 那么我们先来观察p2对象在内容中是如何存储的，然后对比p2来观察p1。 首先我们知道，p2在调用setage方法的时候，首先会通过p2对象中的isa指针找到Person类对象，然后在类对象中找到setage方法。然后找到方法对应的实现。如下图所示 但是刚才我们发现p1对象的isa指针在经过KVO监听之后已经指向了NSKVONotifyin_Person类对象，NSKVONotifyin_Person其实是Person的子类，那么也就是说其superclass指针是指向Person类对象的，NSKVONotifyin_Person是runtime在运行时生成的。那么p1对象在调用setage方法的时候，肯定会根据p1的isa找到NSKVONotifyin_Person，在NSKVONotifyin_Person中找setage的方法及实现。 经过查阅资料我们可以了解到，NSKVONotifyin_Person中的setage方法中其实调用了 Fundation框架中C语言函数 _NSsetIntValueAndNotify，_NSsetIntValueAndNotify内部做的操作相当于，首先调用willChangeValueForKey 将要改变方法，之后调用父类的setage方法对成员变量赋值，最后调用didChangeValueForKey已经改变方法。didChangeValueForKey中会调用监听器的监听方法，最终来到监听者的observeValueForKeyPath方法中。 那么如何验证KVO真的如上面所讲的方式实现？首先经过之前打断点打印isa指针，我们已经验证了，在执行添加监听的方法时，会将isa指针指向一个通过runtime创建的Person的子类NSKVONotifyin_Person。另外我们可以通过打印方法实现的地址来看一下p1和p2的setage的方法实现的地址在添加KVO前后有什么变化。 12345678910111213&#123; [self methodForSelectorLogWithP1:p1 P2:p2]; NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld; [p1 addObserver:self forKeyPath:@\"age\" options:options context:nil]; [self methodForSelectorLogWithP1:p1 P2:p2];&#125;// kvo func to show working- (void)methodForSelectorLogWithP1:(NSObject *)p1 P2:(NSObject *)p2 &#123; NSLog(@\"添加KVO监听之前 - p1 = %p, p2 = %p\", [p1 methodForSelector: @selector(setAge:)],[p2 methodForSelector: @selector(setAge:)]);&#125; 我们发现在添加KVO监听之前，p1和p2的setAge方法实现的地址相同，而经过KVO监听之后，p1的setAge方法实现的地址发生了变化，我们通过打印方法实现来看一下前后的变化发现，确实如我们上面所讲的一样，p1的setAge方法的实现由Person类方法中的setAge方法转换为了C语言的Foundation框架的_NSsetIntValueAndNotify函数。 Foundation框架中会根据属性的类型，调用不同的方法。例如我们之前定义的int类型的age属性，那么我们看到Foundation框架中调用的_NSsetIntValueAndNotify函数。那么我们把age的属性类型变为double重新打印一遍 我们发现调用的函数变为了_NSSetDoubleValueAndNotify，那么这说明Foundation框架中有许多此类型的函数，通过属性的不同类型调用不同的函数。那么我们可以推测Foundation框架中还有很多例如_NSSetBoolValueAndNotify、_NSSetCharValueAndNotify、_NSSetFloatValueAndNotify、_NSSetLongValueAndNotify等等函数。我们可以找到Foundation框架文件，通过命令行查询关键字找到相关函数 NSKVONotifyin_Person内部结构是怎样的？首先我们知道，NSKVONotifyin_Person作为Person的子类，其superclass指针指向Person类，并且NSKVONotifyin_Person内部一定对setAge方法做了单独的实现，那么NSKVONotifyin_Person同Person类的差别可能就在于其内存储的对象方法及实现不同。我们通过runtime分别打印Person类对象和NSKVONotifyin_Person类对象内存储的对象方法 12345678910111213141516171819202122232425&#123; p1.age = 10; [self printMethods: object_getClass(p2)]; [self printMethods: object_getClass(p1)]; [p1 removeObserver:self forKeyPath:@\"age\"];&#125;// runtime to print class methods- (void)printMethods:(Class)cls &#123; unsigned int count ; Method *methods = class_copyMethodList(cls, &amp;count); NSMutableString *methodNames = [NSMutableString string]; [methodNames appendFormat:@\"%@ method list: \", cls]; for (int i = 0 ; i &lt; count; i++) &#123; Method method = methods[i]; NSString *methodName = NSStringFromSelector(method_getName(method)); [methodNames appendString:@\"\\n\"]; [methodNames appendString: methodName]; &#125; NSLog(@\"%@\",methodNames); free(methods);&#125; 上述打印内容如下 通过上述代码我们发现NSKVONotifyin_Person中有4个对象方法。分别为setAge: class dealloc _isKVOA，那么至此我们可以画出NSKVONotifyin_Person的内存结构以及方法调用顺序。 这里NSKVONotifyin_Person重写class方法是为了隐藏NSKVONotifyin_Person。不被外界所看到。我们在p1添加过KVO监听之后，分别打印p1和p2对象的class可以发现他们都返回Person。 1NSLog(@\"%@,%@\",[p1 class],[p2 class]); 如果NSKVONotifyin_Person不重写class方法，那么当对象要调用class对象方法的时候就会一直向上找来到nsobject，而nsobect的class的实现大致为返回自己isa指向的类，返回p1的isa指向的类那么打印出来的类就是NSKVONotifyin_Person，但是apple不希望将NSKVONotifyin_Person类暴露出来，并且不希望我们知道NSKVONotifyin_Person内部实现，所以在内部重写了class类，直接返回Person类，所以外界在调用p1的class对象方法时，是Person类。这样p1给外界的感觉p1还是Person类，并不知道NSKVONotifyin_Person子类的存在。那么我们可以猜测NSKVONotifyin_Person内重写的class内部实现大致为 1234- (Class) class &#123;// 得到类对象，在找到类对象父类 return class_getSuperclass(object_getClass(self));&#125; 验证验证 didChangeValueForKey:内部会调用observer的observeValueForKeyPath:ofObject:change:context:方法我们在Person类中重写willChangeValueForKey:和didChangeValueForKey:方法，模拟他们的实现。 1234567891011121314- (void)setAge:(int)age &#123; NSLog(@\"setAge:\"); _age = age;&#125;- (void)willChangeValueForKey:(NSString *)key &#123; NSLog(@\"willChangeValueForKey: - begin\"); [super willChangeValueForKey:key]; NSLog(@\"willChangeValueForKey: - end\");&#125;- (void)didChangeValueForKey:(NSString *)key &#123; NSLog(@\"didChangeValueForKey: - begin\"); [super didChangeValueForKey:key]; NSLog(@\"didChangeValueForKey: - end\");&#125; 再次运行来查看didChangeValueForKey的方法内运行过程，通过打印内容可以看到，确实在didChangeValueForKey方法内部已经调用了observer的observeValueForKeyPath:ofObject:change:context:方法。 如何手动调用 KVO被监听的属性的值被修改时，就会自动触发KVO。如果想要手动触发KVO，则需要我们自己调用willChangeValueForKey和didChangeValueForKey方法即可在不改变属性值的情况下手动触发KVO，并且这两个方法缺一不可。 123456789101112&#123; Person *p1 = [[Person alloc] init]; p1.age = 1.0; NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld; [p1 addObserver:self forKeyPath:@\"age\" options:options context:nil]; [p1 willChangeValueForKey:@\"age\"]; [p1 didChangeValueForKey:@\"age\"]; [p1 removeObserver:self forKeyPath:@\"age\"];&#125; 通过打印我们可以发现，didChangeValueForKey方法内部成功调用了observeValueForKeyPath:ofObject:change:context:，并且age的值并没有发生改变。 小结当一个对象使用了KVO监听，iOS系统会修改这个对象的isa指针，改为指向一个全新的通过Runtime动态创建的子类，子类拥有自己的set方法实现，set方法实现内部会顺序调用willChangeValueForKey方法、原来的setter方法实现、didChangeValueForKey方法，而didChangeValueForKey方法内部又会调用监听器的observeValueForKeyPath:ofObject:change:context:监听方法。 以上文章整理自：https://juejin.im/post/5adab70cf265da0b736d37a8","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS Principle：Runtime","slug":"iOS Principle Runtime","date":"2018-06-05T13:56:27.000Z","updated":"2018-11-16T13:15:05.076Z","comments":true,"path":"2018/06/05/iOS Principle Runtime/","link":"","permalink":"https://reversescale.github.io/2018/06/05/iOS Principle Runtime/","excerpt":"Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石~","text":"Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石~ 👨🏻‍💻 Github Demo 方便记忆 实质作用：从OC到C语言的过渡 消息传递方法：objec_msgSend 方法 objc_method 结构体内容：SEL method_name 方法名、char *method_types 方法类型、IMP method_imp 方法实现（方法指针） 消息转发：unrecognized selector 三次机会 动态方法解析：对象在接收到未知的消息时，首先会调用所属类的类方法+resolveInstanceMethod:(实例方法)或者+resolveClassMethod:(类方法)。 备用接收者：- (id)forwardingTargetForSelector:(SEL)aSelector;这是一个实例方法，因为是询问该实例对象是否有其他实例对象可以接收这个未知的selector，如果没有就返回nil 完整转发：- (void)forwardInvocation: (NSInvocation*)invocation;调用这个方法如果不能处理就会调用父类的相关方法，一直到NSObject的这个方法，如果NSObject都无法处理就会调用doesNotRecognizeSelector:方法抛出异常。 用途：做异常处理收集，避免crash，增强用户体验 常见的应用场景： 关联对象(Objective-C Associated Objects)：给分类增加属性 方法魔法(Method Swizzling)：方法添加和替换和KVO实现 消息转发(热更新)：解决Bug(JSPatch) 实现NSCoding的自动归档和自动解档 实现字典和模型的自动转换(MJExtension) Runtime 相关介绍Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。 Runtime 版本演化Runtime其实有两个版本: “modern” 和 “legacy”。 我们现在用的 Objective-C 2.0 采用的是现行 (Modern) 版的 Runtime 系统，只能运行在 iOS 和 macOS 10.5 之后的 64 位程序中。 而 macOS 较老的32位程序仍采用 Objective-C 1.0 中的（早期）Legacy 版本的 Runtime 系统。 这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。 Runtime 实质作用高级编程语言想要成为可执行文件需要先编译为汇编语言再汇编为机器语言，机器语言也是计算机能够识别的唯一语言，但是OC并不能直接编译为汇编语言，而是要先转写为纯C语言再进行编译和汇编的操作，从OC到C语言的过渡就是由runtime来实现的。 然而我们使用OC进行面向对象开发，而C语言更多的是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。 OC 中一个对象方法1[obj foo]; 编译器转成消息发送1objc_msgSend(obj, foo) 在上段代码中 Runtime 的执行流程： 首先，通过obj的isa指针找到它的 class ; 在 class 的 method list 找 foo ; 如果 class 中没到 foo，继续往它的 superclass 中找 ; 一旦找到 foo 这个函数，就去执行它的实现IMP 。 objc_cache 缓存机制但是，上面这种实现有个问题，效率低。 一个class 往往只有 20% 的函数会被经常调用，可能占总调用次数的 80% 。每个消息都需要遍历一次objc_method_list 并不合理。如果把经常被调用的函数缓存下来，那可以大大提高函数查询的效率。 这也就是 objc_class 中另一个重要成员 objc_cache 做的事情，再找到 foo 之后，把 foo 的 method_name 作为key，method_imp 作为 value 给存起来。当再次收到 foo 消息的时候，可以直接在 cache 里找到，避免去遍历 objc_method_list。 从前面的源代码可以看到objc_cache是存在objc_class 结构体中的。 objec_msgSend 方法objec_msgSend的方法定义如下：1OBJC_EXPORT id objc_msgSend(id self, SEL op, ...) 那消息传递是怎么实现的呢？我们看看对象(object)，类(class)，方法(method)这几个的结构体：1234567891011121314151617181920212223242526272829303132333435//对象struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;//类struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;//方法列表struct objc_method_list &#123; struct objc_method_list *obsolete OBJC2_UNAVAILABLE; int method_count OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif /* variable length structure */ struct objc_method method_list[1] OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE;//方法struct objc_method &#123; SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE;&#125; 1.系统首先找到消息的接收对象，然后通过对象的isa找到它的类。 2.在它的类中查找method_list，是否有selector方法。 3.没有则查找父类的method_list。 4.找到对应的method，执行它的IMP。 5.转发IMP的return值。 消息传递用到的概念：类对象(objc_class)Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。1typedef struct objc_class *Class; 查看objc/runtime.h中objc_class结构体的定义如下：1234567891011121314struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; struct objc_class结构体定义了很多变量，通过命名不难发现，结构体里保存了指向父类的指针、类的名字、版本、实例大小、实例变量列表、方法列表、缓存、遵守的协议列表等，一个类包含的信息也不就正是这些吗？ 没错，类对象就是一个结构体struct objc_class，这个结构体存放的数据称为元数据(metadata)，该结构体的第一个成员变量也是isa指针，这就说明了Class本身其实也是一个对象，因此我们称之为类对象，类对象在编译期产生用于创建实例对象，是单例。 实例(objc_object)123456/// Represents an instance of a class.struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id; 类对象中的元数据存储的都是如何创建一个实例的相关信息，那么类对象和类方法应该从哪里创建呢？ 就是从isa指针指向的结构体创建，类对象的isa指针指向的我们称之为元类(metaclass)，元类中保存了创建类对象以及类方法所需的所有信息，因此整个结构应该如下图所示: 元类(Meta Class)通过上图我们可以看出整个体系构成了一个自闭环，struct objc_object结构体实例它的isa指针指向类对象，类对象的isa指针指向了元类，super_class指针指向了父类的类对象，而元类的super_class指针指向了父类的元类，那元类的isa指针又指向了自己。 元类(Meta Class)是一个类对象的类。在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。为了调用类方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念，元类中保存了创建类对象以及类方法所需的所有信息。任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。 Method(objc_method)先看下定义 12345678runtime.h/// An opaque type that represents a method in a class definition.代表类定义中一个方法的不透明类型typedef struct objc_method *Method;struct objc_method &#123; SEL method_name OBJC2_UNAVAILABLE; // 方法名 char *method_types OBJC2_UNAVAILABLE; // 方法类型 IMP method_imp OBJC2_UNAVAILABLE; // 方法实现&#125; Method和我们平时理解的函数是一致的，就是表示能够独立完成一个功能的一段代码，比如：123- (void)logName &#123; NSLog(@\"name\");&#125; 这段代码，就是一个函数。我们来看下objc_method这个结构体的内容： SEL method_name 方法名 char *method_types 方法类型 IMP method_imp 方法实现 在这个结构体重，我们已经看到了SEL和IMP，说明SEL和IMP其实都是Method的属性。我们接着来看SEL。 SEL(objc_selector)先看下定义123Objc.h/// An opaque type that represents a method selector.代表一个方法的不透明类型typedef struct objc_selector *SEL; objc_msgSend函数第二个参数类型为SEL，它是selector在Objective-C中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:1@property SEL selector; 可以看到selector是SEL的一个实例。1A method selector is a C string that has been registered (or “mapped“) with the Objective-C runtime. Selectors generated by the compiler are automatically mapped by the runtime when the class is loaded. 其实selector就是个映射到方法的C字符串，你可以用 Objective-C 编译器命令@selector()或者 Runtime 系统的sel_registerName函数来获得一个 SEL 类型的方法选择器。 selector既然是一个string，我觉得应该是类似className+method的组合，命名规则有两条： 同一个类，selector不能重复 不同的类，selector可以重复 这也带来了一个弊端，我们在写C代码的时候，经常会用到函数重载，就是函数名相同，参数不同，但是这在Objective-C中是行不通的，因为selector只记了method的name，没有参数，所以没法区分不同的method。比如：12- (void)caculate(NSInteger)num;- (void)caculate(CGFloat)num; 是会报错的。 我们只能通过命名来区别：12- (void)caculateWithInt(NSInteger)num;- (void)caculateWithFloat(CGFloat)num; 在不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器。 IMP看下IMP的定义 12/// A pointer to the function of a method implementation. 指向一个方法实现的指针typedef id (*IMP)(id, SEL, ...); 就是指向最终实现程序的内存地址的指针。 在iOS的Runtime中，Method通过selector和IMP两个属性，实现了快速查询方法及实现，相对提高了性能，又保持了灵活性。 类缓存(objc_cache)当Objective-C运行时通过跟踪它的isa指针检查对象时，它可以找到一个实现许多方法的对象。然而，你可能只调用它们的一小部分，并且每次查找时，搜索所有选择器的类分派表没有意义。所以类实现一个缓存，每当你搜索一个类分派表，并找到相应的选择器，它把它放入它的缓存。所以当objc_msgSend查找一个类的选择器，它首先搜索类缓存。这是基于这样的理论：如果你在类上调用一个消息，你可能以后再次调用该消息。 为了加速消息分发， 系统会对方法和对应的地址进行缓存，就放在上述的objc_cache，所以在实际运行中，大部分常用的方法都是会被缓存起来的，Runtime系统实际上非常快，接近直接执行内存地址的程序速度。 Category(objc_category)Category是表示一个指向分类的结构体的指针，其定义如下：12345678struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties;&#125;; name：是指 class_name 而不是 category_name。 cls：要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对应到对应的类对象。 instanceMethods：category中所有给类添加的实例方法的列表。 classMethods：category中所有添加的类方法的列表。 protocols：category实现的所有协议的列表。 instanceProperties：表示Category里所有的properties，这就是我们可以通过objc_setAssociatedObject和objc_getAssociatedObject增加实例变量的原因，不过这个和一般的实例变量是不一样的。 从上面的category_t的结构体中可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，不可以添加成员变量。 Runtime消息转发前文介绍了进行一次发送消息会在相关的类对象中搜索方法列表，如果找不到则会沿着继承树向上一直搜索知道继承树根部（通常为NSObject），如果还是找不到并且消息转发都失败了就回执行doesNotRecognizeSelector:方法报unrecognized selector错。那么消息转发到底是什么呢？接下来将会逐一介绍最后的三次机会。 第一次机会: 所属类动态方法解析对象在接收到未知的消息时，首先会调用所属类的类方法+resolveInstanceMethod:(实例方法)或者+resolveClassMethod:(类方法)。1+(BOOL)resolveInstanceMethod:(SEL)name 动态转发1BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types); 第一个参数是需要添加方法的类，第二个参数是一个selector，也就是实例方法的名字，第三个参数是一个IMP类型的变量也就是函数实现，需要传入一个C函数，这个函数至少有两个参数，一个是id self一个是SEL _cmd，第四个参数是函数类型。 实现一个动态方法解析的例子如下：12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //执行foo函数 [self performSelector:@selector(foo:)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(foo:)) &#123;//如果是执行foo函数，就动态解析，指定新的IMP class_addMethod([self class], sel, (IMP)fooMethod, \"v@:\"); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;void fooMethod(id obj, SEL _cmd) &#123; NSLog(@\"Doing foo\");//新的foo函数&#125; 打印结果： 2018-04-01 12:23:35.952670+0800 ocram[87546:23235469] Doing foo 可以看到虽然没有实现foo:这个函数，但是我们通过class_addMethod动态添加fooMethod函数，并执行fooMethod这个函数的IMP。从打印结果看，成功实现了。 如果resolve方法返回 NO ，运行时就会移到下一步：forwardingTargetForSelector。 第二次机会: 备援接收者动态方法解析无法处理消息，则会走备用接受者。这个备用接受者只能是一个新的对象，不能是self本身，否则就会出现无限循环。如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。1- (id)forwardingTargetForSelector:(SEL)aSelector; 该方法的参数就是那个未知的selector，这是一个实例方法，因为是询问该实例对象是否有其他实例对象可以接收这个未知的selector，如果没有就返回nil，可以自行实验。 实现一个备用接收者的例子如下：12345678910111213141516171819202122232425262728293031323334353637#import \"ViewController.h\"#import \"objc/runtime.h\"@interface Person: NSObject@end@implementation Person- (void)foo &#123; NSLog(@\"Doing foo\");//Person的foo函数&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //执行foo函数 [self performSelector:@selector(foo)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; return YES;//返回YES，进入下一步转发&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (aSelector == @selector(foo)) &#123; return [Person new];//返回Person对象，让Person对象接收这个消息 &#125; return [super forwardingTargetForSelector:aSelector];&#125;@end 打印结果： 2018-04-01 12:45:04.757929+0800 ocram[88023:23260346] Doing foo 可以看到我们通过forwardingTargetForSelector把当前ViewController的方法转发给了Person去执行了。打印结果也证明我们成功实现了转发。 如果在这一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。 第三次机会: 消息重定向如果动态方法解析和备用接受者都没有处理这个消息，那么就会走完整消息转发。 首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。 如果-methodSignatureForSelector:返回nil ，Runtime则会发出 -doesNotRecognizeSelector: 消息，程序这时也就挂掉了。 如果返回了一个函数签名，Runtime就会创建一个NSInvocation 对象并发送 -forwardInvocation:消息给目标对象。 1- (void)forwardInvocation: (NSInvocation*)invocation; 调用这个方法如果不能处理就会调用父类的相关方法，一直到NSObject的这个方法，如果NSObject都无法处理就会调用doesNotRecognizeSelector:方法抛出异常。 实现一个完整转发的例子如下：123456789101112131415161718192021222324252627282930313233343536373839404142#import \"ViewController.h\"#import \"objc/runtime.h\"@interface Person: NSObject@end@implementation Person- (void)foo &#123; NSLog(@\"Doing foo\");//Person的foo函数&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //执行foo函数 [self performSelector:@selector(foo)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; return YES;//返回YES，进入下一步转发&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123; return nil;//返回nil，进入下一步转发&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; if ([NSStringFromSelector(aSelector) isEqualToString:@\"foo\"]) &#123; return [NSMethodSignature signatureWithObjCTypes:\"v@:\"];//签名，进入forwardInvocation &#125; return [super methodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; SEL sel = anInvocation.selector; Person *p = [Person new]; if([p respondsToSelector:sel]) &#123; [anInvocation invokeWithTarget:p]; &#125; else &#123; [self doesNotRecognizeSelector:sel]; &#125;&#125;@end 打印结果：2018-04-01 13:00:45.423385+0800 ocram[88353:23279961] Doing foo 从打印结果来看，我们实现了完整的转发。通过签名，Runtime生成了一个对象anInvocation，发送给了forwardInvocation，我们在forwardInvocation方法里面让Person对象去执行了foo函数。 签名参数v@:怎么解释呢，这里苹果文档Type Encodings有详细的解释。Type Encodings: https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1 以上就是Runtime的三次转发流程。下面我们讲讲Runtime的实际应用。 Runtime应用Runtime简直就是做大型框架的利器。它的应用场景非常多，下面就介绍一些常见的应用场景。 关联对象(Objective-C Associated Objects)：给分类增加属性 方法魔法(Method Swizzling)：方法添加和替换和KVO实现 消息转发(热更新)：解决Bug(JSPatch) 实现NSCoding的自动归档和自动解档 实现字典和模型的自动转换(MJExtension) 1）关联对象(Objective-C Associated Objects)：给分类增加属性 我们都是知道分类是不能自定义属性和变量的。下面通过关联对象实现给分类添加属性。关联对象Runtime提供了下面几个接口：123456//关联对象void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)//获取关联的对象id objc_getAssociatedObject(id object, const void *key)//移除关联的对象void objc_removeAssociatedObjects(id object) 参数解释1234id object：被关联的对象const void *key：关联的key，要求唯一id value：关联的对象objc_AssociationPolicy policy：内存管理的策略 这里插一下内存管理的策略相关知识，防懵逼 😳1234567891011typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN = 0, /**&lt; Specifies a weak reference to the associated object. */ OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. * The association is not made atomically. */ OBJC_ASSOCIATION_COPY_NONATOMIC = 3, /**&lt; Specifies that the associated object is copied. * The association is not made atomically. */ OBJC_ASSOCIATION_RETAIN = 01401, /**&lt; Specifies a strong reference to the associated object. * The association is made atomically. */ OBJC_ASSOCIATION_COPY = 01403 /**&lt; Specifies that the associated object is copied. * The association is made atomically. */&#125;; 我们看看内存测量对于的属性修饰 下面实现一个UIView的Category添加自定义属性defaultColor12345678910111213141516171819202122232425262728293031323334#import \"ViewController.h\"#import \"objc/runtime.h\"@interface UIView (DefaultColor)@property (nonatomic, strong) UIColor *defaultColor;@end@implementation UIView (DefaultColor)@dynamic defaultColor;static char kDefaultColorKey;- (void)setDefaultColor:(UIColor *)defaultColor &#123; objc_setAssociatedObject(self, &amp;kDefaultColorKey, defaultColor, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (id)defaultColor &#123; return objc_getAssociatedObject(self, &amp;kDefaultColorKey);&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UIView *test = [UIView new]; test.defaultColor = [UIColor blackColor]; NSLog(@\"%@\", test.defaultColor);&#125;@end 打印结果： 2018-04-01 15:41:44.977732+0800 ocram[2053:63739] UIExtendedGrayColorSpace 0 1 打印结果来看，我们成功在分类上添加了一个属性，实现了它的setter和getter方法。 通过关联对象实现的属性的内存管理也是有ARC管理的，所以我们只需要给定适当的内存策略就行了，不需要操心对象的释放。 2）方法魔法(Method Swizzling)：方法添加和替换和KVO实现 方法添加 实际上添加方法刚才在讲消息转发的时候，动态方法解析的时候就提到了。 12//class_addMethod(Class _Nullable __unsafe_unretained cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)class_addMethod([self class], sel, (IMP)fooMethod, \"v@:\"); cls 被添加方法的类 name 添加的方法的名称的SEL imp 方法的实现。该函数必须至少要有两个参数，self,_cmd 类型编码 方法替换 下面实现一个替换ViewController的viewDidLoad方法的例子。 123456789101112131415161718192021222324252627282930@implementation ViewController+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; SEL originalSelector = @selector(viewDidLoad); SEL swizzledSelector = @selector(jkviewDidLoad); Method originalMethod = class_getInstanceMethod(class,originalSelector); Method swizzledMethod = class_getInstanceMethod(class,swizzledSelector); //judge the method named swizzledMethod is already existed. BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); // if swizzledMethod is already existed. if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;- (void)jkviewDidLoad &#123; NSLog(@\"替换的方法\"); [self jkviewDidLoad];&#125;- (void)viewDidLoad &#123; NSLog(@\"自带的方法\"); [super viewDidLoad];&#125;@end swizzling应该只在+load中完成。 在 Objective-C 的运行时中，每个类有两个方法都会自动调用。+load 是在一个类被初始装载时调用，+initialize 是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。 swizzling应该只在dispatch_once 中完成,由于swizzling 改变了全局的状态，所以我们需要确保每个预防措施在运行时都是可用的。原子操作就是这样一个用于确保代码只会被执行一次的预防措施，就算是在不同的线程中也能确保代码只执行一次。Grand Central Dispatch 的 dispatch_once满足了所需要的需求，并且应该被当做使用swizzling 的初始化单例方法的标准。 实现图解如下图 从图中可以看出，我们通过swizzling特性，将selectorC的方法实现IMPc与selectorN的方法实现IMPn交换了，当我们调用selectorC，也就是给对象发送selectorC消息时，所查找到的对应的方法实现就是IMPn而不是IMPc了。 KVO 实现 全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。再MVC大行其道的Cocoa中，KVO机制很适合实现model和controller类之间的通讯。 KVO的实现依赖于 Objective-C 强大的 Runtime，当观察某对象 A 时，KVO 机制动态创建一个对象A当前类的子类，并为这个新的子类重写了被观察属性 keyPath 的 setter 方法。setter 方法随后负责通知观察对象属性的改变状况。 Apple 使用了 isa-swizzling 来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为：NSKVONotifying_A的新类，该类继承自对象A的本类，且 KVO 为 NSKVONotifying_A 重写观察属性的 setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。 NSKVONotifying_A 类剖析 12NSLog(@\"self-&gt;isa:%@\",self-&gt;isa); NSLog(@\"self class:%@\",[self class]); 在建立KVO监听前，打印结果为： 12self-&gt;isa:Aself class:A 在建立KVO监听之后，打印结果为： 12self-&gt;isa:NSKVONotifying_Aself class:A 在这个过程，被观察对象的 isa 指针从指向原来的 A 类，被KVO 机制修改为指向系统新创建的子类NSKVONotifying_A 类，来实现当前类属性值改变的监听；所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对 KVO 的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类，就会发现系统运行到注册 KVO 的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为 NSKVONotifying_A 的中间类，并指向这个中间类了。 子类setter方法剖析 KVO 的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangeValueForKey: ，在存取数值的前后分别调用 2 个方法： 被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath 的属性值即将变更 当改变发生后， didChangeValueForKey: 被调用，通知系统该keyPath 的属性值已经变更 之后， observeValueForKey:ofObject:change:context:也会被调用。且重写观察属性的setter 方法这种继承方式的注入是在运行时而不是编译时实现的。 KVO 为子类的观察者属性重写调用存取方法的工作原理在代码中相当于： 12345- (void)setName:(NSString *)newName &#123; [self willChangeValueForKey:@\"name\"]; //KVO 在调用存取方法之前总调用 [super setValue:newName forKey:@\"name\"]; //调用父类的存取方法 [self didChangeValueForKey:@\"name\"]; //KVO 在调用存取方法之后总调用&#125; 3）消息转发(热更新)：解决Bug(JSPatch) JSPatch 是一个 iOS 动态更新框架，只需在项目中引入极小的引擎，就可以使用 JavaScript 调用任何 Objective-C 原生接口，获得脚本语言的优势：为项目动态添加模块，或替换项目原生代码动态修复 bug。 关于消息转发，前面已经讲到过了，消息转发分为三级，我们可以在每级实现替换功能，实现消息转发，从而不会造成崩溃。JSPatch不仅能够实现消息转发，还可以实现方法添加、替换能一系列功能。 4）实现NSCoding的自动归档和自动解档 原理描述：用runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。 核心方法：在Model的基类中重写方法： 123456789101112131415161718192021- (id)initWithCoder:(NSCoder *)aDecoder &#123; if (self = [super init]) &#123; unsigned int outCount; Ivar * ivars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar ivar = ivars[i]; NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)]; [self setValue:[aDecoder decodeObjectForKey:key] forKey:key]; &#125; &#125; return self;&#125;- (void)encodeWithCoder:(NSCoder *)aCoder &#123; unsigned int outCount; Ivar * ivars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar ivar = ivars[i]; NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)]; [aCoder encodeObject:[self valueForKey:key] forKey:key]; &#125;&#125; 5）实现字典和模型的自动转换(MJExtension) 原理描述：用runtime提供的函数遍历Model自身所有属性，如果属性在json中有对应的值，则将其赋值。 核心方法：在NSObject的分类中添加方法 1234567891011121314151617181920212223242526272829303132- (instancetype)initWithDict:(NSDictionary *)dict &#123; if (self = [self init]) &#123; //(1)获取类的属性及属性对应的类型 NSMutableArray * keys = [NSMutableArray array]; NSMutableArray * attributes = [NSMutableArray array]; /* * 例子 * name = value3 attribute = T@\"NSString\",C,N,V_value3 * name = value4 attribute = T^i,N,V_value4 */ unsigned int outCount; objc_property_t * properties = class_copyPropertyList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; objc_property_t property = properties[i]; //通过property_getName函数获得属性的名字 NSString * propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding]; [keys addObject:propertyName]; //通过property_getAttributes函数可以获得属性的名字和@encode编码 NSString * propertyAttribute = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding]; [attributes addObject:propertyAttribute]; &#125; //立即释放properties指向的内存 free(properties); //(2)根据类型给属性赋值 for (NSString * key in keys) &#123; if ([dict valueForKey:key] == nil) continue; [self setValue:[dict valueForKey:key] forKey:key]; &#125; &#125; return self;&#125; 以上就是 Runtime 的底层原理，Runtime 也可以说是很多 iOS 特性的动效支撑。 以上文章整理自：https://juejin.im/post/5ac0a6116fb9a028de44d717","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS Principle：NamedTypes","slug":"iOS Principle NamedTypes","date":"2018-06-04T13:56:27.000Z","updated":"2018-11-16T13:10:20.545Z","comments":true,"path":"2018/06/04/iOS Principle NamedTypes/","link":"","permalink":"https://reversescale.github.io/2018/06/04/iOS Principle NamedTypes/","excerpt":"在开发过程中常常需要用到系统提供的基础类型之外的的类型，Swift 作为一款成长中的语言，自然敏锐的注意到这一点，所以 Swift 允许我们根据自己的需要构建属于自己的类型系统，以便于更加灵活和方便的开发程序并其称之为named types~","text":"在开发过程中常常需要用到系统提供的基础类型之外的的类型，Swift 作为一款成长中的语言，自然敏锐的注意到这一点，所以 Swift 允许我们根据自己的需要构建属于自己的类型系统，以便于更加灵活和方便的开发程序并其称之为named types~ 👨🏻‍💻 Github Demo 方便记忆 Named types 的四种类型：enum、struct、class、protocol enum：值类型，一组有限种可能性的相关值提供的通用类型 struct：值类型，一系列具有相同类型或不同类型的数据构成的数据集合 class：引用类型，类可继承，允许类型转换，有引用计数，析构方法释放资源 protocol：引用类型，协议中没有属性和方法的实现，可以当做类型来使用 Named types 的四种类型 enum struct class protocol 相比于 Objective-C 中的这三者，Swift 将 enum 和 struct 变得更加灵活且强大，并且赋予了他们很多和class 相似的属性实现更加丰富多彩的功能。 本文重点介绍在 Swift 中 enum 和 struct 的定义和新特性以及两者与 class 之间的异同。 枚举（enum）Swift 中的枚举的定义与C家族有些许不同，Swift 中枚举定义是“为一组有限种可能性的相关值提供的通用类型”，而在 C/C++/C# 中，“枚举是一个被命名的整型常数的集合”。 使用枚举可以类型安全并且有提示性地操作这些值。与结构体、类相似，使用关键词enum来定义枚举，并在一对大括号内定义具体内容包括使用case关键字列举成员。 就像下面一样： 12345enum StudentType &#123; case pupils case middleSchoolStudent case collegeStudent&#125; 上面的代码可以读作：如果存在一个StudentType的实例，他要么是pupils （小学生）、要么是middleSchoolStudent（中学生）、要么是collegeStudent（大学生）。 和C、objective-c中枚举的不同，Swift 中的枚举成员在被创建时不会分配一个默认的整数值。而且不强制要求给枚举中的每一个成员都提供值。 如果一个值（所谓“原始值”）要被提供给每一个枚举成员，那么这个值可以是字符串、字符、任意的整数值，或者是浮点类型。 Swift中定义的枚举只需要帮助我们表明不同的情况就够了，他的成员可以没有值，也可以有其他类型的值，不像 OC 中枚举值只局限于整数类型，缺点就是你再回去写 OC 时可能会不习惯。 枚举中有两个很容易混淆的概念：原始值(raw value)、关联值(associated value)，两个词听起来比较模糊，下面简单介绍一下： 枚举的原始值(raw value) 枚举成员可以用相同类型的默认值预先填充，这样的值我们称为原始值(raw value)。 123456//枚举的原始值(raw value)enum StudentType: Int&#123; case pupil = 10 case middleSchoolStudent = 15 case collegeStudents = 20&#125; 上面的StudentType中三个成员分别被Int类型的10 、15、 20填充表示不同阶段学生的年龄。 注意：Int修饰的是StudentType成员原始值的类型而不是StudentType的类型，StudentType类型从定义开始就是一个全新的枚举类型。 12345678910111213// 常量student1值是 10let student1 = StudentType.pupils.rawValueprint(\"student1:\\(student1)\")// 变量student2值是 15let student2 = StudentType.middleSchoolStudent.rawValueprint(\"student2:\\(student2)\")// 使用成员rawValue属性创建一个`StudentType`枚举的新实例let student3 = StudentType.init(rawValue: 15)// student3的值是 Optional&lt;senson&gt;.Typeprint(\"student3:\\(type(of: student3))\")// student4的值是nil，因为并不能通过整数30得到一个StudentType实例的值let student4 = StudentType.init(rawValue: 30)print(\"student4:\\(student4)\") 使用原始值初始化器这种方式初始化创建得到StudentType的实例student4是一个StudentType的可选类型，因为并不是给定一个年龄就能找到对应的学生类型，比如在StudentType中给定年龄为30就找不到对应的学生类型（很可能30岁的人已经是博士了） 总之，原始值是为枚举的成员们绑定了一组类型必须相同值不同的固定的值（可能是整型，浮点型，字符类型等等）。这样很好解释为什么提供原始值的时候用的是等号。 枚举的关联值(associated value) 关联值和原始值不同，关联值更像是为枚举的成员们绑定了一组类型，不同的成员可以是不同的类型(提供关联值时用的是括号)。例如下面的代码： 1234567//枚举的关联值(associated value)//定义一个表示学生类型的枚举类型 StudentType，他有三个成员分别是pupils、middleSchoolStudent、collegeStudentsenum StudentTypeAssociated &#123; case pupils(String) case middleSchoolStudent(Int, String) case collegeStudents(Int, String)&#125; 这里我们并没有为StudentType的成员提供具体的值，而是为他们绑定了不同的类型，分别是pupil绑定String类型、middleSchoolStudent和collegeStudents绑定（Int， String）元祖类型。接下来就可以创建不同StudentType枚举实例并为对应的成员赋值了。 123456789//student1 是一个StudentType类型的常量，其值为pupil（小学生），特征是\"have fun\"（总是在玩耍）let student1 = StudentTypeAssociated.pupils(\"have fun\")print(\"student1:\\(student1)\")//student2 是一个StudentType类型的常量，其值为middleSchoolStudent（中学生），特征是 7, \"always study\"（一周7天总是在学习）let student2 = StudentTypeAssociated.middleSchoolStudent(7, \"always study\")print(\"student2:\\(student2)\")//student3 是一个StudentType类型的常量，其值为collegeStudent（大学生），特征是 7, \"always LOL\"（一周7天总是在撸啊撸）let student3 = StudentTypeAssociated.middleSchoolStudent(7, \"always LOL\")print(\"student3:\\(student3)\") 这个时候如果需要判断某个StudentType实例的具体的值就需要这样做了： 12345678switch student3 &#123; case .pupils(let things): print(\"is a pupil and \\(things)\") case .middleSchoolStudent(let day, let things): print(\"is a middleSchoolStudent and \\(day) days \\(things)\") case .collegeStudents(let day, let things): print(\"is a collegeStudent and \\(day) days \\(things)\")&#125; 控制台输出：is a collegeStudent and 7 days always LOL，看到这你可能会想，是否可以为一个枚举成员提供原始值并且绑定类型呢，答案是不能的！因为首先给成员提供了固定的原始值，那他以后就不能改变了；而为成员提供关联值(绑定类型)就是为了创建枚举实例的时候赋值。 递归枚举 递归枚举是拥有另一个枚举作为枚举成员关联值的枚举。 关于递归枚举我们可以拆封成两个概念来看：递归 + 枚举。递归是指在程序运行中函数（或方法）直接或间接调用自己的这样一种方式，其特点为重复有限个步骤、格式较为简单。 下面是一个经典的通过递归算法求解n!（阶乘）的函数。 123456789func factorial(n: Int)-&gt;Int &#123; if n &gt; 0 &#123; return n * factorial(n: n - 1) &#125; else &#123; return 1 &#125;&#125; //1 * 2 * 3 * 4 * 5 * 6 = 720 let sum = factorial(n: 6) 函数factorial (n: int)-&gt; Int在执行过程中很明显的调用了自身。结合枚举的概念我们这里可以简单的理解为递归枚举类似上面将枚举值本身传入给成员去判断的情况。 可以看出Swift中枚举变得更加灵活和复杂，有递归枚举的概念，还有很多和类类似的特性，比如：计算属性用来提供关于枚举当前值的额外信息；实例方法提供与枚举表示值相关的功能；定义初始化器来初始化成员值；而且能够遵循协议来提供标准功能等等。 结构体（struct）结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。结构体是一种值类型的数据结构，在Swift中常常使用结构体封装一些属性甚至是方法来组成新的复杂类型，目的是简化运算。 定义好的结构体存在一个自动生成的成员初始化器，使用它来初始化结构体实例的成员属性。 12345struct Student &#123; var chinese: Int var math: Int var english: Int&#125; 看到木有，定义结构体类型时其成员可以没有初始值，要是类那个坑货早报错了…(提醒这个类没有被初始化) 结构体实例的创建 创建结构体和类的实例的语法非常相似，结构体和类两者都能使用初始化器语法来生成新的实例。 最简单的语法是在类或结构体名字后面接一个空的圆括号，例如: 1let student1 = Student() 这样就创建了一个新的类或者结构体的实例，任何成员都被初始化为它们的默认值（前提是成员均有默认值）。 但是如果定义结构体时没有设置初始值，像上面直接()的写法编译器会报错（出来混迟早是要给初始值的） 12//使用Student类型的结构体创建Student类型的实例（变量或常量）并初始化三个成员（这个学生的成绩会不会太好了点）let student2 = Student(chinese: 90, math: 80, english: 70) 所有的结构体都有一个自动生成的成员初始化器，你可以使用它来初始化新结构体实例的成员就像上面一样（前提是没有自定义的初始化器）。如果我们在定义Student时为他的成员赋上初值，那么下面的代码是编译通过的： 1234567struct Students &#123; var chinese: Int = 50 var math: Int = 50 var english: Int = 50&#125;let student3 = Students()print(\"student3:\\(student3)\") 总之，定义结构体类型时其成员可以没有初始值，但是创建结构体实例时该实例的成员必须有初值。 自定义的初始化器 当我们想要使用自己的方式去初始化创建一个Student类型的实例时，系统提供的成员初始化器可能就不够用了。例如，我们希望通过如下方式创建实例时，就需要自定义初始化方法了： 1let student5 = Student(stringScore: \"70,80,90\") 自定义初始化方法 1234567891011121314151617181920struct Student &#123; var chinese: Int = 50 var math: Int = 50 var english: Int = 50 init() &#123;&#125; init(chinese: Int, math: Int, english: Int) &#123; self.chinese = chinese self.math = math self.english = english &#125; init(stringScore: String) &#123; let cme = stringScore.characters.split(separator: \",\") chinese = Int(atoi(String(cme.first!))) math = Int(atoi(String(cme[1]))) english = Int(atoi(String(cme.last!))) &#125;&#125;let student6 = Student()let student7 = Student(chinese: 90, math: 80, english: 70)let student8 = Student(stringScore: \"70,80,90\") 一旦我们自定义了初始化器，系统自动的初始化器就不起作用了，如果还需要使用到系统提供的初始化器，在我们自定义初始化器后就必须显式的定义出来。 定义其他方法 如果此时需要修改某个学生某科的成绩，该如何实现呢？可以定义下面的方法： 12345//更改某个学生某门学科的成绩func changeChinese(num: Int, student: inout Student)&#123; student.chinese += num&#125;changeChinese(num: 20, student: &amp;student7) 此时student7的语文成绩就由原来的70被修改到了90 但是此方法有两个明显的弊端： 1.学生的语文成绩chinese是Student结构体的内部成员，一个学生的某科成绩无需被Student的使用者了解。即我们只关心学生的语文成绩更改了多少，而不是关心学生语文成绩本身是多少。 2.更改一个学生的语文成绩本身就是和Student结构体内部成员计算相关的事情，我们更希望达到如下形如： 1student7.changeChinese(num: 10) 因为只有学生本身清楚自己需要将语文成绩更改多少（更像是面向对象封装的思想）。很明显此时changeChinese(num:)方法是Student结构体内部的方法而不是外部的方法，所以我定义了一个修改某个学生数学成绩的内部方法用于和之前修改语文成绩的外部方法对比： 123456789101112struct Studentes &#123; var chinese: Int = 50 var math: Int = 50 var english: Int = 50 //修改数学成绩 mutating func changeMath(num: Int) &#123; self.math += num &#125;&#125;var student7 = Studentes(chinese: 20, math: 30, english: 40)student7.changeMath(num: 10)print(\"student7:\\(student7)\") 运行结果： 尽管两者都能达到同样的效果，但是把修改结构体成员的方法定义在结构体内部显得更加合理同时满足面向对象封装的特点。以上两点就是我们为Student结构体内部添加changeMath(num:)的原因，他让我们把类型相关的计算表现的更加自然和统一，即自己的事情应该用自己的方法实现不应该被别人关心。 值得一提的是在结构体内部方法中如果修改了结构体的成员，那么该方法之前应该加入：mutating关键字。由于结构体是值类型，Swift规定不能直接在结构体的方法（初始化器除外）中修改成员。原因很简单，结构体作为值的一种表现类型怎么能提供改变自己值的方法呢，但是使用mutating我们便可以办到这点，当然这也是和类的不同点。 常见的结构体 Swift中很多的基础数据类型都是结构体类型，下面列举的是一些常用的结构体类型： 12345678//表示数值类型的结构体：Int，Float，Double，CGFloat...//表示字符和字符串类型的结构体Character，String...//位置和尺寸的结构体CGPoint，CGSize...//集合类型结构体Array，Set，Dictionary... 很多时候你不细心观察的话可能不会想到自己信手拈来的代码中居然藏了这么多结构体。另外有时候在使用类和结构体的时候会出现下面的情况 类方法：123456789// Person 类class Person &#123; var name: String = \"jack\" let life: Int = 1&#125;var s1 = Person()var s2 = s1s2.name = \"mike\"s1 结构体方法：123456789// People 结构体数据结构struct People &#123; var name: String = \"jack\" let life: Int = 1&#125;var p1 = People()var p2 = p1p2.name = \"mike\"p1 细心的同学可能已经发现了其中的诡异。变量s1、s2是Person类的实例，修改了s2的name属性，s1的name也会改变；而p1、p2作为People结构体的实例，修改了p1的name属性，p2的name并不会发生改变。这是为什么呢？ 类能够改变是因为，类是引用类型，内部做浅拷贝处理，本质是指向同一个对象，自然可以改name；结构体之前已经说过是值类型，内部做深拷贝处理，会重新生成一个对象，在复制时修改一个实例的数据并不影响副本的数据。 性能对比其实本质是对比值类型和引用类型的性能，因此擂台上的选手就是结构体（struct）和类（class）。 测试1: 循环创建类和结构体a.执行1亿次类创建 12345678910111213// 定义类class StudentC&#123; var name:String init(name:String) &#123; self.name = name &#125;&#125;// 统计时间let date = Date()for i in 0...100_000_000&#123; let s = StudentC(name: \"酷走天涯\")&#125;print(Date().timeIntervalSince(date)) 运行三次结果: 19.392848014831520.991949281292120.7549253872943 b.执行10亿次结构体创建 123456789101112// 定义结构体struct StudentS&#123; var name:String init( name:String) &#123; self.name = name &#125;&#125;let date = Date()for i in 0...1000_000_000&#123; let s = StudentS(name: \"酷走天涯\")&#125;print(Date().timeIntervalSince(date)) 运行三次结果: 9.9922145421245510.928164827391710.7281881727434 我们上面的属性为基本数据类型,我们将属性改为对象测试一下速度 c.创建10_000_000个对象 123456class StudentC&#123; var date = NSDate()&#125;for i in 0...10_000_000&#123; let s = StudentS()&#125; 测试结果: 6.385093986988076.436492025852226.39519000053406 d.创建10_000_000个结构体实例 123456struct StudentS&#123; var date = NSDate()&#125;for i in 0...10_000_000&#123; let s = StudentS()&#125; 测试结果: 4.385093986988074.436492025852224.39519000053406 结论：创建结构体要比创建对象速度快 测试2:创建1000_000 个对象或者结构体放在数组中,查看内存占用率a.循环创建1000_000个对象 123456789101112class StudentC&#123; var name:String init( name:String) &#123; self.name = name &#125;&#125;var students:[StudentC] = []// 创建for i in 0...1000_000&#123;let s = StudentC(name: \"酷走天涯\")students.append(s)&#125; 运行结果: 内存占用61.8MB b.循环创建1000_000个结构体 1234567891011struct StudentS&#123; var name:String init( name:String) &#123; self.name = name &#125;&#125;var students:[StudentS] = []for i in 0...1000_000&#123;let s = StudentS(name: \"酷走天涯\")students.append(s)&#125; 运行结果: 内存占用32.6MB 照样,我们将基本属性改为对象继续测试 c.10_000_000 个对象添加到数组中 12345678class StudentC&#123; var date = NSDate()&#125;var students:[StudentC] = []for i in 0...10_000_000&#123; let s = StudentC() students.append(s)&#125; 测试结果: 占内存538.7MB d.10_000_000 个结构体添加到数组中 1234567struct StudentS&#123; var date = NSDate()&#125;for i in 0...10_000_000&#123; let s = StudentS() students.append(s)&#125; 测试结构: 占用225.7MB 结论：创建相同属性的结构体比类更加节省内存 测试3:对1_000_000个结构体实体和对象进行排序,测消耗时间a.对1_000_000个结构体实体进行排序 12345let date = Date()students.sort &#123; (stu1, stu2) -&gt; Bool in return stu1.name &gt; stu2.name&#125;print(Date().timeIntervalSince(date)) 运行结果: 13.378394961357113.6793909668922 b.对1_000_000个对象进行排序 12345let date = Date()students.sort &#123; (stu1, stu2) -&gt; Bool in return stu1.name &gt; stu2.name&#125;print(Date().timeIntervalSince(date)) 运行结果: 6.708819985389716.60394102334976 结论: 在数据量比较大的排序中,结构体排序的速度比较慢,因为结构体是值类型,排序的时候,需要大量的赋值运算。而对象只需要交换地址即可。 对比总结枚举、结构体、类的共同点： 定义属性和方法； 下标语法访问值； 初始化器； 支持扩展增加功能； 可以遵循协议； 结构体、类的不同点： 类可以继承,结构体不能继承； 类能够在运行时检查和解释类实例的类型； Deinitializers使一个类的实例来释放任何资源分配； 类有引用计数,允许对象被多次引用； 类特有的功能： 继承； 允许类型转换； 析构方法释放资源； 引用计数； 如何选择使用：当你使用Cocoa框架的时候，很多API都要通过NSObject的子类使用，所以这时候必须要用到引用类型class。在其他情况下，有下面几个准则： 1.什么时候该用值类型： 要用==运算符来比较实例的数据时 你希望那个实例的拷贝能保持独立的状态时 数据会被多个线程使用时 2.什么时候该用引用类型（class）： 要用==运算符来比较实例身份的时候 你希望有创建一个共享的、可变对象的时候 3.类和结构体在效率上的差异： 结构体创建速度,内存占用更小,如果需要使用复杂的运算,这个时候,就需要综合考虑两者的有缺点了。 以上文章整理自：https://www.jianshu.com/p/51f99a352838，http://www.cocoachina.com/swift/20161221/18377.html","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS Principle：Category","slug":"iOS Principle Category","date":"2018-06-03T13:56:27.000Z","updated":"2018-11-16T13:08:51.519Z","comments":true,"path":"2018/06/03/iOS Principle Category/","link":"","permalink":"https://reversescale.github.io/2018/06/03/iOS Principle Category/","excerpt":"分类就是对一个类的功能进行扩展,让这个类能够适应不不同情况的需求.在一般的实际开发中,我们都会对系统的一些常用类进行扩展,比如,NSString,Button,Label等等,简单来说类别是一种为现有的类添加新方法的方式~","text":"分类就是对一个类的功能进行扩展,让这个类能够适应不不同情况的需求.在一般的实际开发中,我们都会对系统的一些常用类进行扩展,比如,NSString,Button,Label等等,简单来说类别是一种为现有的类添加新方法的方式~ 👨🏻‍💻 Github Demo 方便记忆 调用顺序：先调用类的load方法，再调用分类的load方法 为分类添加属性： 实现：RunTime 为 Category 动态关联对象，objc_setAssociatedObject方法，内部调用_object_set_associative_reference函数 原理：关联对象并不是放在了原来的对象里面，而是自己维护了一个全局的map用来存放每一个对象及其对应关联属性表格 目录结构 我们之前讲到过实例对象的isa指针指向类对象，类对象的isa指针指向元类对象，当p调用run方法时，类对象的isa指针找到类对象的isa指针，然后在类对象中查找对象方法，如果没有找到，就通过类对象的superclass指针找到父类对象，接着去寻找run方法。 Category 的底层实现将Preson+Test.m文件转化为c++文件，查看其中的编译过程 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc Person+Test.m 在分类转化为c++文件中可以看出_category_t结构体中，存放着类名，对象方法列表，类方法列表，协议列表，以及属性列表 12345678struct _category_t &#123; const char *name; struct _class_t *cls; const struct _method_list_t *instance_methods; const struct _method_list_t *class_methods; const struct _protocol_list_t *protocols; const struct _prop_list_t *properties;&#125;; 紧接着，我们可以看到_method_list_t类型的结构体 1234567891011static struct /*_method_list_t*/ &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[3];&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_objc_method), 3, &#123;&#123;(struct objc_selector *)\"test\", \"v16@0:8\", (void *)_I_Person_Test_test&#125;, &#123;(struct objc_selector *)\"setAge:\", \"v20@0:8i16\", (void *)_I_Person_Test_setAge_&#125;, &#123;(struct objc_selector *)\"age\", \"i16@0:8\", (void *)_I_Person_Test_age&#125;&#125;&#125;; 从中我们发现这个结构体_OBJC_CATEGORY_INSTANCE_METHODS_Preson_Test从名称可以看出是INSTANCE_METHODS对象方法，并且一一对应为上面结构体内赋值。我们可以看到结构体中存储了方法占用的内存，方法数量，以及方法列表。并且找到分类中我们实现对应的对象方法，test , setAge, age三个方法 123456789static struct /*_method_list_t*/ &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[1];&#125; _OBJC_$_CATEGORY_CLASS_METHODS_Person_$_Test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_objc_method), 1, &#123;&#123;(struct objc_selector *)\"abc\", \"v16@0:8\", (void *)_C_Person_Test_abc&#125;&#125;&#125;; 同上面对象方法列表一样，这个我们可以看出是类方法列表结构体 _OBJC_CATEGORY_CLASS_METHODS_Preson_Test，同对象方法结构体相同，同样可以看到我们实现的类方法，abc 接下来是协议方法列表 1234567891011121314151617181920212223242526272829303132static struct /*_method_list_t*/ &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[1];&#125; _OBJC_PROTOCOL_INSTANCE_METHODS_NSCopying __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_objc_method), 1, &#123;&#123;(struct objc_selector *)\"copyWithZone:\", \"@24@0:8^&#123;_NSZone=&#125;16\", 0&#125;&#125;&#125;;struct _protocol_t _OBJC_PROTOCOL_NSCopying __attribute__ ((used)) = &#123; 0, \"NSCopying\", 0, (const struct method_list_t *)&amp;_OBJC_PROTOCOL_INSTANCE_METHODS_NSCopying, 0, 0, 0, 0, sizeof(_protocol_t), 0, (const char **)&amp;_OBJC_PROTOCOL_METHOD_TYPES_NSCopying&#125;;struct _protocol_t *_OBJC_LABEL_PROTOCOL_$_NSCopying = &amp;_OBJC_PROTOCOL_NSCopying;static struct /*_protocol_list_t*/ &#123; long protocol_count; // Note, this is 32/64 bit struct _protocol_t *super_protocols[1];&#125; _OBJC_CATEGORY_PROTOCOLS_$_Person_$_Test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; 1, &amp;_OBJC_PROTOCOL_NSCopying&#125;; 通过上述源码可以看到先将协议方法通过_method_list_t结构体存储，之后通过_protocol_t结构体存储在_OBJC_CATEGORY_PROTOCOLS_Preson_Test中同_protocol_list_t结构体一一对应，分别为protocol_count 协议数量以及存储了协议方法的_protocol_t结构体 最后我们可以看到属性列表 123456789static struct /*_prop_list_t*/ &#123; unsigned int entsize; // sizeof(struct _prop_t) unsigned int count_of_properties; struct _prop_t prop_list[1];&#125; _OBJC_$_PROP_LIST_Person_$_Test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_prop_t), 1, &#123;&#123;\"age\",\"Ti,N\"&#125;&#125;&#125;; 属性列表结构体_OBJC_PROP_LIST_Preson_Test同_prop_list_t结构体对应，存储属性的占用空间，属性属性数量，以及属性列表，可以看到我们自己写的age属性。 最后我们可以看到定义了_OBJC_CATEGORY_Preson_Test结构体，并且将我们上面着重分析的结构体一一赋值，我们通过两张图片对照一下。 上下两张图一一对应，并且我们看到定义_class_t类型的OBJC_CLASS_Preson结构体，最后将_OBJC_CATEGORY_Preson_Test的cls指针指向OBJC_CLASS_Preson结构体地址。我们这里可以看出，cls指针指向的应该是分类的主类类对象的地址。 通过以上分析我们发现。分类源码中确实是将我们定义的对象方法，类方法，属性等都存放在catagory_t结构体中。通过 runtime 源码查看catagory_t存储的方法，属性，协议等我们得知，分类的实现原理是将category中的方法，属性，协议数据放在category_t结构体中，然后将结构体内的方法列表拷贝到类对象的方法列表中。 Category可以添加属性，但是并不会自动生成成员变量及set/get方法。因为category_t结构体中并不存在成员变量。通过之前对对象的分析我们知道成员变量是存放在实例对象中的，并且编译的那一刻就已经决定好了。而分类是在运行时才去加载的。那么我们就无法再程序运行时将分类的成员变量中添加到实例对象的结构体中。因此分类中不可以添加成员变量。 load 和 initializeload方法会在程序启动就会调用，当装载类信息的时候就会调用。 调用顺序看一下源代码。 通过源码我们发现是优先调用类的load方法，之后调用分类的load方法 我们通过代码验证一下： 我们添加Student继承Presen类，并添加Student+Test分类，分别重写只+load方法，其他什么都不做通过打印发现 确实是优先调用类的load方法之后调用分类的load方法，不过调用类的load方法之前会保证其父类已经调用过load方法。之后我们为Preson、Student 、Student+Test 添加initialize方法。 我们知道当类第一次接收到消息时，就会调用initialize，相当于第一次使用类的时候就会调用initialize方法。调用子类的initialize之前，会先保证调用父类的initialize方法。如果之前已经调用过initialize，就不会再调用initialize方法了。当分类重写initialize方法时会先调用分类的方法。但是load方法并不会被覆盖，首先我们来看一下initialize的源码。 上图中我们发现，initialize是通过消息发送机制调用的，消息发送机制通过isa指针找到对应的方法与实现，因此先找到分类方法中的实现，会优先调用分类方法中的实现 我们再来看一下load方法的调用源码 我们看到load方法中直接拿到load方法的内存地址直接调用方法，不在是通过消息发送机制调用 我们可以看到分类中也是通过直接拿到load方法的地址进行调用。因此正如我们之前试验的一样，分类中重写load方法，并不会优先调用分类的load方法，而不调用本类中的load方法了。 RunTime 为 Category 动态关联对象使用RunTime给系统的类添加属性，首先需要了解对象与属性的关系。我们通过之前的学习知道，对象一开始初始化的时候其属性为nil，给属性赋值其实就是让属性指向一块存储内容的内存，使这个对象的属性跟这块内存产生一种关联。 那么如果想动态的添加属性，其实就是动态的产生某种关联就好了。而想要给系统的类添加属性，只能通过分类。 这里给NSObject添加name属性，创建NSObject的分类 我们可以使用@property给分类添加属性 1@property(nonatomic,strong)NSString *name; 通过探寻Category的本质我们知道，虽然在分类中可以写@property添加属性，但是不会自动生成私有属性，也不会生成set,get方法的实现，只会生成set,get的声明，需要我们自己去实现。 方法一：我们可以通过使用静态全局变量给分类添加属性 1234567static NSString *_name;- (void)setName:(NSString *)name &#123; _name = name;&#125;- (NSString *)name &#123; return _name;&#125; 但是这样_name静态全局变量与类并没有关联，无论对象创建与销毁，只要程序在运行_name变量就存在，并不是真正意义上的属性。 方法二：使用RunTime动态添加属性RunTime提供了动态添加属性和获得属性的方法。 123456-(void)setName:(NSString *)name &#123; objc_setAssociatedObject(self, @\"name\",name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;-(NSString *)name &#123; return objc_getAssociatedObject(self, @\"name\"); &#125; 1.动态添加属性 objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy); 参数一：id object : 给哪个对象添加属性，这里要给自己添加属性，用self。 参数二：void * == id key : 属性名，根据key获取关联对象的属性的值，在**objc_getAssociatedObject中通过次key获得属性的值并返回。 参数三：id value** : 关联的值，也就是set方法传入的值给属性去保存。 参数四：objc_AssociationPolicy policy : 策略，属性以什么形式保存。 有以下几种1234567typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN = 0, // 指定一个弱引用相关联的对象 OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, // 指定相关对象的强引用，非原子性 OBJC_ASSOCIATION_COPY_NONATOMIC = 3, // 指定相关的对象被复制，非原子性 OBJC_ASSOCIATION_RETAIN = 01401, // 指定相关对象的强引用，原子性 OBJC_ASSOCIATION_COPY = 01403 // 指定相关的对象被复制，原子性 &#125;; key值只要是一个指针即可，我们可以传入@selector(name) 2.获得属性1objc_getAssociatedObject(id object, const void *key); 参数一：id object : 获取哪个对象里面的关联的属性。 参数二：void * == id key : 什么属性，与objc_setAssociatedObject中的key相对应，即通过key值取出value。 3.移除所有关联对象 1234- (void)removeAssociatedObjects &#123; // 移除所有关联对象 objc_removeAssociatedObjects(self);&#125; 此时已经成功给NSObject添加name属性，并且NSObject对象可以通过点语法为属性赋值。 123NSObject *objc = [[NSObject alloc]init];objc.name = @\"xx_cc\";NSLog(@\"%@\",objc.name); 可以看出关联对象的使用非常简单，接下来我们来探寻关联对象的底层原理 objc_setAssociatedObject函数 来到runtime源码，首先找到objc_setAssociatedObject函数，看一下其实现 我们看到其实内部调用的是_object_set_associative_reference函数，我们来到_object_set_associative_reference函数中 _object_set_associative_reference函数 _object_set_associative_reference函数内部我们可以全部找到我们上面说过的实现关联对象技术的核心对象。接下来我们来一个一个看其内部实现原理探寻他们之间的关系。 AssociationsManager 通过AssociationsManager内部源码发现，AssociationsManager内部有一个AssociationsHashMap对象。 AssociationsHashMap 我们来看一下AssociationsHashMap内部的源码。 通过AssociationsHashMap内部源码我们发现AssociationsHashMap继承自unordered_map首先来看一下unordered_map内的源码 从unordered_map源码中我们可以看出_Key和_Tp也就是前两个参数对应着map中的Key和Value，那么对照上面AssociationsHashMap内源码发现_Key中传入的是disguised_ptr_t，_Tp中传入的值则为ObjectAssociationMap*。 紧接着我们来到ObjectAssociationMap中，上图中ObjectAssociationMap已经标记出，我们发现ObjectAssociationMap中同样以key、Value的方式存储着ObjcAssociation。 接着我们来到ObjcAssociation中 我们发现ObjcAssociation存储着_policy、_value，而这两个值我们可以发现正是我们调用objc_setAssociatedObject函数传入的值，也就是说我们在调用objc_setAssociatedObject函数中传入的value和policy这两个值最终是存储在ObjcAssociation中的。 现在我们已经对AssociationsManager、 AssociationsHashMap、 ObjectAssociationMap、ObjcAssociation四个对象之间的关系有了简单的认识，那么接下来我们来细读源码，看一下objc_setAssociatedObject函数中传入的四个参数分别放在哪个对象中充当什么作用。 重新回到_object_set_associative_reference函数实现中 细读上述源码我们可以发现，首先根据我们传入的value经过acquireValue函数处理获取new_value。acquireValue函数内部其实是通过对策略的判断返回不同的值 之后创建 AssociationsManager manager 以及拿到manager内部的AssociationsHashMap即associations。之后我们看到了我们传入的第一个参数object，object经过DISGUISE函数被转化为了disguised_ptr_t类型的disguised_object。 DISGUISE函数其实仅仅对object做了位运算 之后我们看到被处理成new_value的value，同policy被存入了ObjcAssociation中。 而ObjcAssociation对应我们传入的key被存入了ObjectAssociationMap中。 disguised_object和ObjectAssociationMap则以key-value的形式对应存储在associations中也就是AssociationsHashMap中。 如果我们value设置为nil的话那么会执行下面的代码 从上述代码中可以看出，如果我们设置value为nil时，就会将关联对象从ObjectAssociationMap中移除。 最后我们通过一张图可以很清晰的理清楚其中的关系 通过上图我们可以总结为：一个实例对象就对应一个ObjectAssociationMap，而ObjectAssociationMap中存储着多个此实例对象的关联对象的key以及ObjcAssociation，为ObjcAssociation中存储着关联对象的value和policy策略。 由此我们可以知道关联对象并不是放在了原来的对象里面，而是自己维护了一个全局的map用来存放每一个对象及其对应关联属性表格。 objc_getAssociatedObject函数 objc_getAssociatedObject内部调用的是_object_get_associative_reference _object_get_associative_reference函数 从_object_get_associative_reference函数内部可以看出，向set方法中那样，反向将value一层一层取出最后return出去。 objc_removeAssociatedObjects函数 objc_removeAssociatedObjects用来删除所有的关联对象，objc_removeAssociatedObjects函数内部调用的是_object_remove_assocations函数 _object_remove_assocations函数 上述源码可以看出_object_remove_assocations函数将object对象向对应的所有关联对象全部删除。 关联对象并不是存储在被关联对象本身内存中，而是存储在全局的统一的一个AssociationsManager中，如果设置关联对象为nil，就相当于是移除关联对象。 此时我们我们在回过头来看objc_AssociationPolicy policy 参数: 属性以什么形式保存的策略。 1234567typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN = 0, // 指定一个弱引用相关联的对象 OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, // 指定相关对象的强引用，非原子性 OBJC_ASSOCIATION_COPY_NONATOMIC = 3, // 指定相关的对象被复制，非原子性 OBJC_ASSOCIATION_RETAIN = 01401, // 指定相关对象的强引用，原子性 OBJC_ASSOCIATION_COPY = 01403 // 指定相关的对象被复制，原子性 &#125;; 我们会发现其中只有RETAIN和COPY而为什么没有weak呢？总过上面对源码的分析我们知道，object经过DISGUISE函数被转化为了disguised_ptr_t类型的disguised_object。 1disguised_ptr_t disguised_object = DISGUISE(object); 而同时我们知道，weak修饰的属性，当没有拥有对象之后就会被销毁，并且指针置位nil，那么在对象销毁之后，虽然在map中既然存在值object对应的AssociationsHashMap，但是因为object地址已经被置位nil，会造成坏地址访问而无法根据object对象的地址转化为disguised_object了。 相关问题问：Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？ 答：Category中有load方法，load方法在程序启动装载类信息的时候就会调用。load方法可以继承。调用子类的load方法之前，会先调用父类的load方法 问：load、initialize的区别，以及它们在category重写的时候的调用的次序。 答：区别在于调用方式和调用时刻 调用方式：load是根据函数地址直接调用，initialize是通过objc_msgSend调用 调用时刻：load是runtime加载类、分类的时候调用（只会调用1次），initialize是类第一次接收到消息的时候调用，每一个类只会initialize一次（父类的initialize方法可能会被调用多次） 调用顺序：先调用类的load方法，先编译那个类，就先调用load。在调用load之前会先调用父类的load方法。分类中load方法不会覆盖本类的load方法，先编译的分类优先调用load方法。initialize先初始化父类，之后再初始化子类。如果子类没有实现+initialize，会调用父类的+initialize（所以父类的+initialize可能会被调用多次），如果分类实现了+initialize，就覆盖类本身的+initialize调用。 以上文章整理自：https://juejin.im/post/5aef0a3b518825670f7bc0f3、https://juejin.im/post/5af86b276fb9a07aa34a59e6","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS Principle：ClassAndObjective","slug":"iOS Principle ClassAndObjective","date":"2018-06-02T13:56:27.000Z","updated":"2018-11-16T13:06:02.391Z","comments":true,"path":"2018/06/02/iOS Principle ClassAndObjective/","link":"","permalink":"https://reversescale.github.io/2018/06/02/iOS Principle ClassAndObjective/","excerpt":"面向对象(Object Oriented,OO)是软件开发方法。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域~","text":"面向对象(Object Oriented,OO)是软件开发方法。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域~ 👨🏻‍💻 Github Demo 方便记忆 OC 三种对象：instance实例对象、class类对象、meta-class元类对象 instance实例对象：NSObject转化为c语言其实就是一个结构体，系统分配内存空间，存放一个成员isa指针表示对象的地址（结构体的地址）64bit占用8个字节，32bit占用4个字节 class类对象：类对象内存存储的信息：isa和superclass指针、类的属性信息和成员变量、对象方法和协议信息 meta-class元类对象：元类对象和class对象的内存结构一样，isa指针指向基类对象，基类的元类对象的isa指针指向自己 OC 三种对象原理：objc_class结构体的指针 关于OC对象的底层实现寻OC对象的本质，我们平时编写的Objective-C代码，底层实现其实都是C\\C++代码。 OC的对象结构都是通过基础C\\C++的结构体实现的。 我们通过创建OC文件及对象，并将OC文件转化为C++文件来探寻OC对象的本质 OC如下代码 12345678#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSObject *objc = [[NSObject alloc] init]; NSLog(@\"Hello, World!\"); &#125; return 0;&#125; 我们通过命令行将OC的mian.m文件转化为c++文件 1clang -rewrite-objc main.m -o main.cpp // 这种方式没有指定架构例如arm64架构 我们可以指定架构模式的命令行，使用xcode工具 xcrun 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp // 生成 main-arm64.cpp main-arm64.cpp 文件中搜索NSObjcet，可以找到 NSObjcet_IMPL（IMPL代表 implementation 实现） 我们看一下NSObject_IMPL内部 123456struct NSObject_IMPL &#123; Class isa;&#125;;// 查看Class本质typedef struct objc_class *Class;// 我们发现Class其实就是一个指针，对象底层实现其实就是这个样子。 思考： 一个OC对象在内存中是如何布局的? NSObjcet的底层实现，点击NSObjcet进入发现NSObject的内部实现 1234567@interface NSObject &lt;NSObject&gt; &#123; #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wobjc-interface-ivars\" Class isa OBJC_ISA_AVAILABILITY; #pragma clang diagnostic pop&#125;@end 转化为c语言其实就是一个结构体 123struct NSObject_IMPL &#123; Class isa;&#125;; 那么这个结构体占多大的内存空间呢，我们发现这个结构体只有一个成员，isa指针，而指针在64位架构中占8个字节。也就是说一个NSObjec对象所占用的内存是8个字节。 为了探寻OC对象在内存中如何体现，我们来看下面一段代码 1NSObject *objc = [[NSObject alloc] init]; 上面一段代码在内存中如何体现的呢？上述一段代码中系统为NSObject对象分配8个字节的内存空间，用来存放一个成员isa指针。那么isa指针这个变量的地址就是结构体的地址，也就是NSObjcet对象的地址。 假设isa的地址为0x100400110，那么上述代码分配存储空间给NSObject对象，然后将存储空间的地址赋值给objc指针。objc存储的就是isa的地址。objc指向内存中NSObject对象地址，即指向内存中的结构体，也就是isa的位置。 自定义类的内部实现1234567891011121314151617@interface Student : NSObject&#123; @public int _no; int _age;&#125;@end@implementation Studentint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Student *stu = [[Student alloc] init]; stu -&gt; _no = 4; stu -&gt; _age = 5; NSLog(@\"%@\",stu); &#125; return 0;&#125;@end 按照上述步骤同样生成c++文件。并查找Student，我们发现Student_IMPL 12345struct Student_IMPL &#123; struct NSObject_IMPL NSObject_IVARS; int _no; int _age;&#125;; 发现第一个是 NSObject_IMPL的实现。而通过上面的实验我们知道NSObject_IMPL内部其实就是Class isa 那么我们假设 struct NSObject_IMPL NSObject_IVARS; 12345struct Student_IMPL &#123; Class *isa; int _no; int _age;&#125;; 因此此结构体占用多少存储空间，对象就占用多少存储空间。因此结构体占用的存储空间为，isa指针8个字节空间+int类型_no4个字节空间+int类型_age4个字节空间共16个字节空间 123Student *stu = [[Student alloc] init];stu -&gt; _no = 4;stu -&gt; _age = 5; 那么上述代码实际上在内存中的体现为，创建Student对象首先会分配16个字节，存储3个东西，isa指针8个字节，4个字节的_no ,4个字节的_age sutdent对象的3个变量分别有自己的地址。而stu指向isa指针的地址。因此stu的地址为0x100400110，stu对象在内存中占用16个字节的空间。并且经过赋值，_no里面存储着4 ，_age里面存储着5 验证Student在内存中模样 1234567891011121314151617181920struct Student_IMPL &#123; Class isa; int _no; int _age;&#125;;@interface Student : NSObject &#123; @public int _no; int _age;&#125;@end@implementation Studentint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // 强制转化 struct Student_IMPL *stuImpl = (__bridge struct Student_IMPL *)stu; NSLog(@\"_no = %d, _age = %d\", stuImpl-&gt;_no, stuImpl-&gt;_age); // 打印出 _no = 4, _age = 5 &#125; return 0;&#125; 上述代码将oc对象强转成Student_IMPL的结构体。也就是说把一个指向oc对象的指针，指向这种结构体。由于我们之前猜想，对象在内存中的布局与结构体在内存中的布局相同，那么如果可以转化成功，说明我们的猜想正确。由此说明stu这个对象指向的内存确实是一个结构体。 实际上想要获取对象占用内存的大小，可以通过更便捷的运行时方法来获取。 123class_getInstanceSize([Student class])NSLog(@\"%zd,%zd\", class_getInstanceSize([NSObject class]) ,class_getInstanceSize([Student class]));// 打印信息 8和16 窥探内存结构实时查看内存数据 方式一：通过打断点。 Debug Workflow -&gt; viewMemory address中输入stu的地址 从上图中，我们可以发现读取数据从高位数据开始读，查看前16位字节，每四个字节读出的数据为16进制 0x0000004(4字节) 0x0000005(4字节) isa的地址为 00D1081000001119(8字节) 方式二：通过lldb指令xcode自带的调试器 12345678910memory read 0x10074c450// 简写 x 0x10074c450// 增加读取条件// memory read/数量格式字节数 内存地址// 简写 x/数量格式字节数 内存地址// 格式 x是16进制，f是浮点，d是10进制// 字节大小 b：byte 1字节，h：half word 2字节，w：word 4字节，g：giant word 8字节示例：x/4xw // /后面表示如何读取数据 w表示4个字节4个字节读取，x表示以16进制的方式读取数据，4则表示读取4次 同时也可以通过lldb修改内存中的值 12memory write 0x100400c68 6将_no的值改为了6 那么一个NSObject对象占用多少内存？ NSObjcet实际上是只有一个名为isa的指针的结构体，因此占用一个指针变量所占用的内存空间大小，如果64bit占用8个字节，如果32bit占用4个字节。 更复杂的继承关系在64bit环境下， 下面代码的输出内容？1234567891011121314151617181920212223/* Person */@interface Person: NSObject &#123; int _age;&#125;@end@implementation Person@end/* Student */@interface Student: Person &#123; int _no;&#125;@end@implementation Student@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSLog(@\"%zd %zd\", class_getInstanceSize([Person class]), class_getInstanceSize([Student class]) ); &#125; return 0;&#125; 我们依据上面的分析与发现，类对象实质上是以结构体的形式存储在内存中，画出真正的内存图例 我们发现只要是继承自NSObject的对象，那么底层结构体内一定有一个isa指针。 那么他们所占的内存空间是多少呢？单纯的将指针和成员变量所占的内存相加即可吗？上述代码实际打印的内容是16 16，也就是说，person对象和student对象所占用的内存空间都为16个字节。 其实实际上person对象确实只使用了12个字节。但是因为内存对齐的原因。使person对象也占用16个字节。 我们可以总结内存对齐为两个原则： 原则 1. 前面的地址必须是后面的地址正数倍,不是就补齐。 原则 2. 整个Struct的地址必须是最大字节的整数倍。 通过上述内存对齐的原则我们来看，person对象的第一个地址要存放isa指针需要8个字节，第二个地址要存放_age成员变量需要4个字节，根据原则一，8是4的整数倍，符合原则一，不需要补齐。然后检查原则2，目前person对象共占据12个字节的内存，不是最大字节数8个字节的整数倍，所以需要补齐4个字节，因此person对象就占用16个字节空间。 而对于student对象，我们知道student对象中，包含person对象的结构体实现，和一个int类型的_no成员变量，同样isa指针8个字节，_age成员变量4个字节，_no成员变量4个字节，刚好满足原则1和原则2，所以student对象占据的内存空间也是16个字节。 OC的类信息存放在哪里OC对象主要可以分为三种 instance对象（实例对象） class对象（类对象） meta-class对象（元类对象） instance对象就是通过类alloc出来的对象，每次调用alloc都会产生新的instance对象12NSObjcet *object1 = [[NSObjcet alloc] init];NSObjcet *object2 = [[NSObjcet alloc] init]; object1和object2都是NSObject的instace对象（实例对象），但他们是不同的两个对象，并且分别占据着两块不同的内存。instance对象在内存中存储的信息包括 isa指针 其他成员变量 衍生问题：在上图实例对象中根本没有看到方法，那么实例对象的方法的代码放在什么地方呢？那么类的方法的信息，协议的信息，属性的信息都存放在什么地方呢？ class对象 我们通过class方法或runtime方法得到一个class对象。class对象也就是类对象 1234567Class objectClass1 = [object1 class];Class objectClass2 = [object2 class];Class objectClass3 = [NSObject class];// runtimeClass objectClass4 = object_getClass(object1);Class objectClass5 = object_getClass(object2);NSLog(@\"%p %p %p %p %p\", objectClass1, objectClass2, objectClass3, objectClass4, objectClass5); 每一个类在内存中有且只有一个class对象 可以通过打印内存地址证明，class对象在内存中存储的信息主要包括 1.isa指针 2.superclass指针 3.类的属性信息（@property），类的成员变量信息（ivar） 4.类的对象方法信息（instance method），类的协议信息（protocol） 成员变量的值时存储在实例对象中的，因为只有当我们创建实例对象的时候才为成员变赋值。但是成员变量叫什么名字，是什么类型，只需要有一份就可以了。 类方法放在那里？ 元类对象 meta-class 1234567//runtime中传入类对象此时得到的就是元类对象Class objectMetaClass = object_getClass([NSObject class]);// 而调用类对象的class方法时得到还是类对象，无论调用多少次都是类对象Class cls = [[NSObject class] class];Class objectClass3 = [NSObject class];class_isMetaClass(objectMetaClass) // 判断该对象是否为元类对象NSLog(@\"%p %p %p\", objectMetaClass, objectClass3, cls); // 后面两个地址相同，说明多次调用class得到的还是类对象 每个类在内存中有且只有一个meta-class对象。 meta-class对象和class对象的内存结构是一样的，但是用途不一样，在内存中存储的信息主要包括 1.isa指针 2.superclass指针 3.类的类方法的信息（class method） meta-class对象和class对象的内存结构是一样的，所以meta-class中也有类的属性信息，类的对象方法信息等成员变量，但是其中的值可能是空的。 对象的isa指针指向哪里? 1.当对象调用实例方法的时候，我们上面讲到，实例方法信息是存储在class类对象中的，那么要想找到实例方法，就必须找到class类对象，那么此时isa的作用就来了。 1[stu studentMethod]; instance的isa指向class，当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用。 2.当类对象调用类方法的时候，同上，类方法是存储在meta-class元类对象中的。那么要找到类方法，就需要找到meta-class元类对象，而class类对象的isa指针就指向元类对象 1[Student studentClassMethod]; class 的 isa 指向 meta-class 当调用类方法时，通过 class 的 isa 找到 meta-class，最后找到类方法的实现进行调用 3.当对象调用其父类对象方法的时候，又是怎么找到父类对象方法的呢？，此时就需要使用到class类对象superclass指针。 12[stu personMethod];[stu init]; 当Student的instance对象要调用Person的对象方法时，会先通过isa找到Student的class，然后通过superclass找到Person的class，最后找到对象方法的实现进行调用，同样如果Person发现自己没有响应的对象方法，又会通过Person的superclass指针找到NSObject的class对象，去寻找响应的方法 当类对象调用父类的类方法时，就需要先通过isa指针找到meta-class，然后通过superclass去寻找响应的方法 12[Student personClassMethod];[Student load]; 当Student的class要调用Person的类方法时，会先通过isa找到Student的meta-class，然后通过superclass找到Person的meta-class，最后找到类方法的实现进行调用 最后又是这张静定的isa指向图，经过上面的分析我们在来看这张图，就显得清晰明了很多。 对isa、superclass总结 1.instance的isa指向class 2.class的isa指向meta-class 3.meta-class的isa指向基类的meta-class，基类的isa指向自己 4.class的superclass指向父类的class，如果没有父类，superclass指针为nil 5.meta-class的superclass指向父类的meta-class，基类的meta-class的superclass指向基类的class 6.instance调用对象方法的轨迹，isa找到class，方法不存在，就通过superclass找父类 7.class调用类方法的轨迹，isa找meta-class，方法不存在，就通过superclass找父类 如何证明isa指针的指向真的如上面所说？我们通过如下代码证明：1234NSObject *object = [[NSObject alloc] init];Class objectClass = [NSObject class];Class objectMetaClass = object_getClass([NSObject class]);NSLog(@\"%p %p %p\", object, objectClass, objectMetaClass); 打断点并通过控制台打印相应对象的isa指针 我们发现object-&gt;isa与objectClass的地址不同，这是因为从64bit开始，isa需要进行一次位运算，才能计算出真实地址。而位运算的值我们可以通过下载objc源代码找到。 我们通过位运算进行验证。 我们发现，object-isa指针地址0x001dffff96537141经过同0x00007ffffffffff8位运算，得出objectClass的地址0x00007fff96537140 接着我们来验证class对象的isa指针是否同样需要位运算计算出meta-class对象的地址。当我们以同样的方式打印objectClass-&gt;isa指针时，发现无法打印 同时也发现左边objectClass对象中并没有isa指针。我们来到Class内部看一下 12345678910111213141516typedef struct objc_class *Class;struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ 相信了解过isa指针的同学对objc_class结构体内的内容很熟悉了，今天这里不深入研究，我们只看第一个对象是一个isa指针，为了拿到isa指针的地址，我们自己创建一个同样的结构体并通过强制转化拿到isa指针。 12345struct xx_cc_objc_class&#123;Class isa;&#125;;Class objectClass = [NSObject class];struct xx_cc_objc_class *objectClass2 = (__bridge struct xx_cc_objc_class *)(objectClass); 此时我们重新验证一下 确实，objectClass2的isa指针经过位运算之后的地址是meta-class的地址。 关于OC Class 的底层实现Class的本质我们知道不管是类对象还是元类对象，类型都是Class，class和mete-class的底层都是objc_class结构体的指针，内存中就是结构体，本章来探寻Class的本质。 12Class objectClass = [NSObject class]; Class objectMetaClass = object_getClass([NSObject class]); 点击Class来到内部，我们可以发现 1typedef struct objc_class *Class; Class对象其实是一个指向objc_class结构体的指针。因此我们可以说类对象或元类对象在内存中其实就是objc_class结构体。 我们来到objc_class内部，可以看到这段在底层原理中经常出现的代码。 123456789101112131415struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ 这部分代码相信在文章中很常见，但是OBJC2_UNAVAILABLE;说明这些代码已经不在使用了。那么目前objc_class的结构是什么样的呢？我们通过objc源码中去查找objc_class结构体的内容 我们发现这个结构体继承 objc_object 并且结构体内有一些函数，因为这是c++结构体，在c上做了扩展，因此结构体中可以包含函数。我们来到objc_object内，截取部分代码 我们发现objc_object中有一个isa指针，那么objc_class继承objc_object，也就同样拥有一个isa指针 那么我们之前了解到的，类中存储的类的成员变量信息，实例方法，属性名等这些信息在哪里呢。我们来到class_rw_t中，截取部分代码，我们发现class_rw_t中存储着方法列表，属性列表，协议列表等内容。 而class_rw_t是通过bits调用data方法得来的，我们来到data方法内部实现。我们可以看到，data函数内部仅仅对bits进行&amp;FAST_DATA_MASK操作 而成员变量信息则是存储在class_ro_t内部中的，我们来到class_ro_t内查看 最后总结通过一张图进行总结 我们可以自定义一个结构体，如果我们自己写的结构和objc_class真实结构是一样的，那么当我们强制转化的时候，就会一一对应的赋值。此时我们就可以拿到结构体内部的信息。 下列代码是我们仿照objc_class结构体，提取其中需要使用到的信息，自定义的一个结构体。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#import &lt;Foundation/Foundation.h&gt;#ifndef XXClassInfo_h#define XXClassInfo_h# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# endif#if __LP64__ typedef uint32_t mask_t;#else typedef uint16_t mask_t;#endif typedef uintptr_t cache_key_t;struct bucket_t &#123; cache_key_t _key; IMP _imp;&#125;;struct cache_t &#123; bucket_t *_buckets; mask_t _mask; mask_t _occupied;&#125;;struct entsize_list_tt &#123; uint32_t entsizeAndFlags; uint32_t count;&#125;;struct method_t &#123; SEL name; const char *types; IMP imp;&#125;;struct method_list_t : entsize_list_tt &#123; method_t first;&#125;;struct ivar_t &#123; int32_t *offset; const char *name; const char *type; uint32_t alignment_raw; uint32_t size;&#125;;struct ivar_list_t : entsize_list_tt &#123; ivar_t first;&#125;;struct property_t &#123; const char *name; const char *attributes;&#125;;struct property_list_t : entsize_list_tt &#123; property_t first;&#125;;struct chained_property_list &#123; chained_property_list *next; uint32_t count; property_t list[0];&#125;;typedef uintptr_t protocol_ref_t; struct protocol_list_t &#123; uintptr_t count; protocol_ref_t list[0];&#125;;struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; // instance对象占用的内存空间#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; // 类名 method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; // 成员变量列表 const uint8_t * weakIvarLayout; property_list_t *baseProperties;&#125;;struct class_rw_t &#123; uint32_t flags; uint32_t version; const class_ro_t *ro; method_list_t * methods; // 方法列表 property_list_t *properties; // 属性列表 const protocol_list_t * protocols; // 协议列表 Class firstSubclass; Class nextSiblingClass; char *demangledName;&#125;;#define FAST_DATA_MASK 0x00007ffffffffff8ULstruct class_data_bits_t &#123; uintptr_t bits; public: class_rw_t* data() &#123; // 提供data()方法进行 &amp; FAST_DATA_MASK 操作 return (class_rw_t *)(bits &amp; FAST_DATA_MASK); &#125;&#125;;/* OC对象 */struct xx_objc_object &#123; void *isa;&#125;;/* 类对象 */struct xx_objc_class : xx_objc_object &#123; Class superclass; cache_t cache; class_data_bits_t bits; public: class_rw_t* data() &#123; return bits.data(); &#125; xx_objc_class* metaClass() &#123; // 提供metaClass函数，获取元类对象 // 上一篇我们讲解过，isa指针需要经过一次 &amp; ISA_MASK操作之后才得到真正的地址 return (xx_objc_class *)((long long)isa &amp; ISA_MASK); &#125;&#125;;#endif /* XXClassInfo_h */ 接下来我们将自己定义的类强制转化为我们自定义的精简的class结构体类型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;#import \"XXClassInfo.h\"/* Person */@interface Person : NSObject &lt;NSCopying&gt; &#123; @public int _age;&#125;@property (nonatomic, assign) int height;- (void)personMethod;+ (void)personClassMethod;@end@implementation Person- (void)personMethod &#123;&#125;+ (void)personClassMethod &#123;&#125;@end/* Student */@interface Student : Person &lt;NSCoding&gt; &#123; @public int _no;&#125;@property (nonatomic, assign) int score;- (void)studentMethod;+ (void)studentClassMethod;@end@implementation Student- (void)studentMethod &#123;&#125;+ (void)studentClassMethod &#123;&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSObject *object = [[NSObject alloc] init]; Person *person = [[Person alloc] init]; Student *student = [[Student alloc] init]; xx_objc_class *objectClass = (__bridge xx_objc_class *)[object class]; xx_objc_class *personClass = (__bridge xx_objc_class *)[person class]; xx_objc_class *studentClass = (__bridge xx_objc_class *)[student class]; xx_objc_class *objectMetaClass = objectClass-&gt;metaClass(); xx_objc_class *personMetaClass = personClass-&gt;metaClass(); xx_objc_class *studentMetaClass = studentClass-&gt;metaClass(); class_rw_t *objectClassData = objectClass-&gt;data(); class_rw_t *personClassData = personClass-&gt;data(); class_rw_t *studentClassData = studentClass-&gt;data(); class_rw_t *objectMetaClassData = objectMetaClass-&gt;data(); class_rw_t *personMetaClassData = personMetaClass-&gt;data(); class_rw_t *studentMetaClassData = studentMetaClass-&gt;data(); // 0x00007ffffffffff8 NSLog(@\"%p %p %p %p %p %p\", objectClassData, personClassData, studentClassData, objectMetaClassData, personMetaClassData, studentMetaClassData); return 0;&#125; 通过打断点，我们可以看到class内部信息。 至此，我们再次拿出那张经典的图，挨个分析图中isa指针和superclass指针的指向 instance对象首先我们来看instance对象，我们通过上一篇文章知道，instance对象中存储着isa指针和其他成员变量，并且instance对象的isa指针是指向其类对象地址的。我们首先分析上述代码中我们创建的object，person，student三个instance对象与其相对应的类对象objectClass，personClass，studentClass。 从上图中我们可以发现instance对象中确实存储了isa指针和其成员变量，同时将instance对象的isa指针经过&amp;运算之后计算出的地址确实是其相应类对象的内存地址。由此我们证明isa，superclass指向图中的1，2，3号线。 class对象接着我们来看class对象，同样通过上一篇文章，我们明确class对象中存储着isa指针，superclass指针，以及类的属性信息，类的成员变量信息，类的对象方法，和类的协议信息，而通过上面对object源码的分析，我们知道这些信息存储在class对象的class_rw_t中，我们通过强制转化来窥探其中的内容。如下图 上图中我们通过模拟对person类对象调用.data函数，即对bits进行&amp;FAST_DATA_MASK(0x00007ffffffffff8UL)运算，并转化为class_rw_t。即上图中的personClassData。其中我们发现成员变量信息，对象方法，属性等信息只显示first第一个，如果想要拿到更多的需要通过代码将指针后移获取。 而上图中的instaceSize = 16也同person对象中isa指针8个字节+_age4个字节+_height4个字节相对应起来。这里不在展开对objectClassData及studentClassData进行分析，基本内容同personClassData相同。 那么类对象中的isa指针和superclass指针的指向是否如那张经典的图示呢？我们来验证一下。 通过上图中的内存地址的分析，由此我们证明isa，superclass指向图中，isa指针的4，5，6号线，以及superclass指针的10，11，12号线。 meta-class对象最后我们来看meta-class元类对象，上文提到meta-class中存储着isa指针，superclass指针，以及类的类方法信息。同时我们知道meta-class元类对象与class类对象，具有相同的结构，只不过存储的信息不同，并且元类对象的isa指针指向基类的元类对象，基类的元类对象的isa指针指向自己。元类对象的superclass指针指向其父类的元类对象，基类的元类对象的superclass指针指向其类对象。 与class对象相同，我们同样通过模拟对person元类对象调用.data函数，即对bits进行&amp;FAST_DATA_MASK(0x00007ffffffffff8UL)运算，并转化为class_rw_t。 首先我们可以看到结构同personClassData相同，并且成员变量及属性列表等信息为空，而methods中存储着类方法personClassMethod。 接着来验证isa及superclass指针的指向是否同上图序号标注一样。 上图中通过地址证明meta-class的isa指向基类的meta-class，基类的isa指针也指向自己。 上图中通过地址证明meta-class的superclass指向父类的meta-class，基类的meta-class的superclass指向基类的class类。 以上文章整理自：https://juejin.im/post/5ac81c75518825556534c0af、https://juejin.im/post/5ad210636fb9a028da7cf90c","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS Principle：LLVMAndClang","slug":"iOS Principle LLVMAndClang","date":"2018-05-29T13:56:27.000Z","updated":"2018-11-16T13:24:49.138Z","comments":true,"path":"2018/05/29/iOS Principle LLVMAndClang/","link":"","permalink":"https://reversescale.github.io/2018/05/29/iOS Principle LLVMAndClang/","excerpt":"LLVM 是 Low Level Virtual Machine 的简称，这个库提供了与编译器相关的支持，能够进行程序语言的编译期优化、链接优化、在线编译优化、代码生成。简而言之，可以作为多种语言编译器的后台来使用~","text":"LLVM 是 Low Level Virtual Machine 的简称，这个库提供了与编译器相关的支持，能够进行程序语言的编译期优化、链接优化、在线编译优化、代码生成。简而言之，可以作为多种语言编译器的后台来使用~ 👨🏻‍💻 Github Demo 方便记忆 编译语言：OC 和 Swift 基于 Clang 和 LLVM 来编译（Clang 前端、LLVM 后端） 特点：Clang 更快、内存占用小、兼容GCC、设计简单、模块化库（GCC 支持JAVA等和更多平台） 编译工作：Clang 语法分析，语义分析，生成中间代码；LLVM 机器无关的代码优化，生成机器语言 编译完成：生成 dSYM 文件存放函数地址映射，Fabric、友盟等崩溃解析 编译插入：预处理——宏、插入脚本——cocoapod 编译时间优化： 代码层—优化@class代替#import、打包库、头文件进行预编译； 编译器层—debug模式不生成dsym和开启Build Active Architecture并且关闭编译器优化Only 整理学习 iOS Principle 一系列的文章，每篇开头归结知识点，帮助记忆 相关概念历史原因2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的 Chris Lattner（他的 twitter @clattner_llvm ） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器，JIT编译器，汇编器，调试器，静态分析工具等一系列跟编程语言相关的工作，于是就把简称 LLVM 这个简称作为了正式的名字。Chris Lattner 后来又开发了 Clang，使得 LLVM 直接挑战 GCC 的地位。2012年，LLVM 获得美国计算机学会 ACM 的软件系统大奖，和 UNIX，WWW，TCP/IP，Tex，JAVA 等齐名。 Chris Lattner 生于 1978 年，2005年加入苹果，将苹果使用的 GCC 全面转为 LLVM。2010年开始主导开发 Swift 语言。 iOS 开发中 Objective-C 是 Clang / LLVM 来编译的。 Swift 是 Swift / LLVM，其中 Swift 前端会多出 SIL optimizer，它会把 .swift 生成为中间代码 .sil 属于 High-Level IR， 因为 Swift 在编译时就完成了方法绑定，直接通过地址调用属于强类型语言，方法调用不再是像OC那样的消息发送，这样编译就可以获得更多的信息用在后面的后端优化上。 LLVM是一个模块化和可重用的编译器和工具链技术的集合，Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，目的是提供惊人的快速编译，比 GCC 快3倍，其中的 clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。LLVM 核心库提供一个优化器，对流行的 CPU 做代码生成支持。lld 是 Clang / LLVM 的内置链接器，clang 必须调用链接器来产生可执行文件。 这里是 Clang 官方详细文档： Welcome to Clang’s documentation! — Clang 4.0 documentation 这篇是对 LLVM 架构的一个概述： The Architecture of Open Source Applications 将编译器之前对于编译的前世今生也是需要了解的，比如回答下这个问题，编译器程序是用什么编译的？看看 《linkers and loaders》这本书就知道了。 LLVM 与 Clang 介绍LLVM 是 Low Level Virtual Machine 的简称，这个库提供了与编译器相关的支持，能够进行程序语言的编译期优化、链接优化、在线编译优化、代码生成。简而言之，可以作为多种语言编译器的后台来使用。如果这样还比较抽象的话，介绍下 Clang 就知道了：Clang 是一个 C++ 编写、基于 LLVM、发布于 LLVM BSD 许可证下的 C/C++/Objective C/Objective C++ 编译器，其目标（之一）就是超越 GCC。 Clang 开发事出有因，Wiki 介绍如下： Apple 使用 LLVM 在不支持全部 OpenGL 特性的 GPU (Intel 低端显卡) 上生成代码 (JIT)，令程序仍然能够正常运行。之后 LLVM 与 GCC 的集成过程引发了一些不快，GCC 系统庞大而笨重，而 Apple 大量使用的 Objective-C 在 GCC 中优先级很低。此外 GCC 作为一个纯粹的编译系统，与 IDE 配合很差。加之许可证方面的要求，Apple 无法使用修改版的 GCC 而闭源。于是 Apple 决定从零开始写 C family 的前端，也就是基于 LLVM 的 Clang 了。 Clang 的特性： 快：通过编译 OS X 上几乎包含了所有 C 头文件的 carbon.h 的测试，包括预处理 (Preprocess)，语法 (lex)，解析 (parse)，语义分析 (Semantic Analysis)，抽象语法树生成 (Abstract Syntax Tree) 的时间，Clang 是 Apple GCC 4.0 的 2.5x 快。(2007-7-25) 内存占用小：Clang 内存占用是源码的 130%，Apple GCC 则超过 10x。 诊断信息可读性强：我不会排版，推荐去网站观看。其中错误的语法不但有源码提示，还会在错误的调用和相关上下文的下方有~和^的提示，相比之下 GCC 的提示很天书。 GCC 兼容性。 设计清晰简单，容易理解，易于扩展增强。与代码基础古老的 GCC 相比，学习曲线平缓。 基于库的模块化设计，易于 IDE 集成及其他用途的重用。由于历史原因，GCC 是一个单一的可执行程序编译器，其内部完成了从预处理到最后代码生成的全部过程，中间诸多信息都无法被其他程序重用。Clang 将编译过程分成彼此分离的几个阶段，AST 信息可序列化。通过库的支持，程序能够获取到 AST 级别的信息，将大大增强对于代码的操控能力。对于 IDE 而言，代码补全、重构是重要的功能，然而如果没有底层的支持，只使用 tags 分析或是正则表达式匹配是很难达成的。 当然，GCC 也有其优势： 支持 JAVA/ADA/FORTRAN 当前的 Clang 的 C++ 支持落后于 GCC，参见。（近日 Clang 已经可以自编译，见） GCC 支持更多平台 GCC 更流行，广泛使用，支持完备 GCC 基于 C，不需要 C++ 编译器即可编译 iOS 开发中用途 一般可以将编程语言分为两种，编译语言和直译式语言。 编译语言:像C++,Objective C都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码，机器码可以直接在CPU上执行，所以执行效率较高。 直译式语言:像JavaScript,Python都是直译式语言。直译式语言不需要经过编译的过程，而是在执行的时候通过一个中间的解释器将代码解释为CPU可以执行的代码。所以，较编译语言来说，直译式语言效率低一些，但是编写的更灵活，也就是为啥JS大法好。 iOS开发目前的常用语言是：Objective和Swift。二者都是编译语言，换句话说都是需要编译才能执行的。二者的编译都是依赖于Clang + LLVM. iOS编译不管是OC还是Swift，都是采用Clang作为编译器前端，LLVM(Low level vritual machine)作为编译器后端。所以简单的编译过程如图 编译器前端编译器前端的任务是进行：语法分析，语义分析，生成中间代码(intermediate representation )。在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行。 编译器后端编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化。iOS的编译过程，后端的处理如下 LVVM优化器会进行BitCode的生成，链接期优化等等。 LLVM机器码生成器会针对不同的架构，比如arm64等生成不同的机器码。 执行一次 XCode build 的流程当你在XCode中，选择build的时候(快捷键command+B)，会执行如下过程 编译信息写入辅助文件，创建编译后的文件架构(name.app) 处理文件打包信息，例如在debug环境下 12345Entitlements:&#123; &quot;application-identifier&quot; = &quot;app的bundleid&quot;; &quot;aps-environment&quot; = development;&#125; 执行CocoaPod编译前脚本(例如对于使用CocoaPod的工程会执行CheckPods Manifest.lock) 编译各个.m文件，使用CompileC和clang命令。 1234CompileC ClassName.o ClassName.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compilerexport LANG=en_US.US-ASCIIexport PATH=&quot;...&quot;clang -x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc... -Wno-missing-field-initializers ... -DDEBUG=1 ... -isysroot iPhoneSimulator10.1.sdk -fasm-blocks ... -I 上文提到的文件 -F 所需要的Framework -iquote 所需要的Framework ... -c ClassName.c -o ClassName.o 通过这个编译的命令，我们可以看到 clang是实际的编译命令 x objective-c 指定了编译的语言 arch x86_64制定了编译的架构，类似还有arm7等 fobjc-arc 一些列-f开头的，指定了采用arc等信息。这个也就是为什么你可以对单独的一个.m文件采用非ARC编程。 Wno-missing-field-initializers 一系列以-W开头的，指的是编译的警告选项，通过这些你可以定制化编译选项 DDEBUG=1 一些列-D开头的，指的是预编译宏，通过这些宏可以实现条件编译 iPhoneSimulator10.1.sdk 制定了编译采用的iOS SDK版本 I 把编译信息写入指定的辅助文件 F 链接所需要的Framework c ClassName.c 编译文件 o ClassName.o 编译产物 工作流程 链接需要的Framework，例如Foundation.framework,AFNetworking.framework,ALiPay.fframework 编译xib文件 拷贝xib，图片等资源文件到结果目录 编译ImageAssets 处理info.plist 执行CocoaPod脚本 拷贝Swift标准库 创建.app文件和对其签名 dSYM 文件我们在每次编译过后，都会生成一个dsym文件。dsym文件中，存储了16进制的函数地址映射。 在App实际执行的二进制文件中，是通过地址来调用方法的。在App crash的时候，第三方工具(Fabric,友盟等)会帮我们抓到崩溃的调用栈，调用栈里会包含crash地址的调用信息。然后，通过dSYM文件，我们就可以由地址映射到具体的函数位置。 XCode中，选择Window -&gt; Organizer可以看到我们生成的archier文件 iOS 如何调试第三方统计到的崩溃报告 (http://blog.csdn.net/hello_hwc/article/details/50036323) attribute或多或少，你都会在第三方库或者iOS的头文件中，见到过attribute。 比如 1__attribute__ ((warn_unused_result)) //如果没有使用返回值，编译的时候给出警告 attribtue 是一个高级的的编译器指令，它允许开发者指定更更多的编译检查和一些高级的编译期优化。 分为三种： 函数属性 (Function Attribute) 类型属性 (Variable Attribute ) 变量属性 (Type Attribute ) 语法结构 attribute 语法格式为：attribute ((attribute-list)) 放在声明分号“;”前面。 比如，在三方库中最常见的，声明一个属性或者方法在当前版本弃用了 1@property (strong,nonatomic)CLASSNAME * property __deprecated; 这样的好处是：给开发者一个过渡的版本，让开发者知道这个属性被弃用了，应当使用最新的API，但是被__deprecated的属性仍然可以正常使用。如果直接弃用，会导致开发者在更新Pod的时候，代码无法运行了。 attribtue的使用场景很多，本文只列举iOS开发中常用的几个： 1234567891011121314151617181920//弃用API，用作API更新#define __deprecated __attribute__((deprecated))//带描述信息的弃用#define __deprecated_msg(_msg) __attribute__((deprecated(_msg)))//遇到__unavailable的变量/方法，编译器直接抛出Error#define __unavailable __attribute__((unavailable))//告诉编译器，即使这个变量/方法 没被使用，也不要抛出警告#define __unused __attribute__((unused))//和__unused相反#define __used __attribute__((used))//如果不使用方法的返回值，进行警告#define __result_use_check __attribute__((__warn_unused_result__))//OC方法在Swift中不可用#define __swift_unavailable(_msg) __attribute__((__availability__(swift, unavailable, message=_msg))) Clang警告处理你一定还见过如下代码： 1234#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;///代码#pragma clang diagnostic pop 这段代码的作用是 对当前编译环境进行压栈 忽略-Wundeclared-selector(未声明的)Selector警告 编译代码 对编译环境进行出栈 通过clang diagnostic push/pop,你可以灵活的控制代码块的编译选项。 iOS 合理利用Clang警告来提高代码质量 (http://blog.csdn.net/Hello_Hwc/article/details/46425503) 预处理所谓预处理，就是在编译之前的处理。预处理能够让你定义编译器变量，实现条件编译。 比如，这样的代码很常见 12345#ifdef DEBUG//...#else//...#endif 同样，我们同样也可以定义其他预处理变量,在XCode-选中Target-build settings中，搜索proprecess。然后点击图中蓝色的加号，可以分别为debug和release两种模式设置预处理宏。 比如我们加上：TestServer，表示在这个宏中的代码运行在测试服务器 然后，配合多个Target(右键Target，选择Duplicate)，单独一个Target负责测试服务器。这样我们就不用每次切换测试服务器都要修改代码了。 12345#ifdef TESTMODE//测试服务器相关的代码#else//生产服务器相关代码#endif 插入脚本通常，如果你使用CocoaPod来管理三方库，那么你的Build Phase是这样子的： 其中：[CP]开头的，就是CocoaPod插入的脚本。 Check Pods Manifest.lock，用来检查cocoapod管理的三方库是否需要更新 Embed Pods Framework，运行脚本来链接三方库的静态/动态库 Copy Pods Resources，运行脚本来拷贝三方库的资源文件 而这些配置信息都存储在这个文件(.xcodeprog)里 到这里，CocoaPod的原理也就大致搞清楚了，通过修改xcodeproject，然后配置编译期脚本，来保证三方库能够正确的编译连接。 同样，我们也可以插入自己的脚本，来做一些额外的事情。比如，每次进行archive的时候，我们都必须手动调整target的build版本，如果一不小心，就会忘记。这个过程，我们可以通过插入脚本自动化。 123buildNumber=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; &quot;$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;&quot;)buildNumber=$(($buildNumber + 1))/usr/libexec/PlistBuddy -c &quot;Set :CFBundleVersion $buildNumber&quot; &quot;$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;&quot; 这段脚本其实很简单，读取当前pist的build版本号,然后对其加一，重新写入。 使用起来也很简单： Xcode – 选中Target – 选中build phase 选择添加Run Script Phase 然后把这段脚本拷贝进去，并且勾选Run Script Only When installing，保证只有我们在安装到设备上的时候，才会执行这段脚本。重命名脚本的名字为Auto Increase build number 然后，拖动这个脚本的到Link Binary With Libraries下面 脚本编译打包脚本化编译打包对于CI(持续集成)来说，十分有用。iOS开发中，编译打包必备的两个命令是： 1234567//编译成.appxcodebuild -workspace $projectName.xcworkspace -scheme $projectName -configuration $buildConfig clean build SYMROOT=$buildAppToDir//打包xcrun -sdk iphoneos PackageApplication -v $appDir/$projectName.app -o $appDir/$ipaName.ipa通过info命令，可以查看到详细的文档info xcodebuild 之前写的一套基于 Python 的编译打包脚本 (https://github.com/ReverseScale/AutoBuildScript/blob/master/autobuild.py) 提高项目编译速度通常，当项目很大，源代码和三方库引入很多的时候，我们会发现编译的速度很慢。在了解了XCode的编译过程后，我们可以从以下角度来优化编译速度： 查看编译时间我们需要一个途径，能够看到编译的时间，这样才能有个对比，知道我们的优化究竟有没有效果。 对于XCode 8，关闭XCode，终端输入以下指令 1defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES 然后，重启XCode，然后编译，你会在这里看到编译时间。 代码层面的优化2.1)forward declaration 所谓forward declaration，就是@class CLASSNAME，而不是#import CLASSNAME.h。这样，编译器能大大提高#import的替换速度。 2.2)对常用的工具类进行打包(Framework/.a) 打包成Framework或者静态库，这样编译的时候这部分代码就不需要重新编译了。 2.3)常用头文件放到预编译文件里 XCode的pch文件是预编译文件，这里的内容在执行XCode build之前就已经被预编译，并且引入到每一个.m文件里了。 编译器选项优化3.1)Debug模式下，不生成dsym文件 上文提到了，dysm文件里存储了调试信息，在Debug模式下，我们可以借助XCode和LLDB进行调试。所以，不需要生成额外的dsym文件来降低编译速度。 3.2)Debug开启Build Active Architecture Only 在XCode -&gt; Build Settings -&gt; Build Active Architecture Only 改为YES。这样做，可以只编译当前的版本，比如arm7/arm64等等，记得只开启Debug模式。这个选项在高版本的XCode中自动开启了。 3.3)Debug模式下，关闭编译器优化 编译器优化 更多深入学习关于 iOS 编译 Clang LLVM 相关的知识整理参见：深入剖析 iOS 编译 Clang LLVM 版权声明此系列文章内容多为网上资料整理，文章结尾会列出参照链接，如有纰漏欢迎讨论🤗 以上文章整理自：https://my.oschina.net/u/2345393/blog/820141，https://linuxtoy.org/archives/llvm-and-clang.html，https://blog.csdn.net/hello_hwc/article/details/53557308，https://github.com/ming1016/study/wiki/深入剖析-iOS-编译-Clang---LLVM","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"走在技术前沿的 iOS 架构实现","slug":"iOS Architecture","date":"2018-05-01T13:56:27.000Z","updated":"2018-11-16T12:08:39.132Z","comments":true,"path":"2018/05/01/iOS Architecture/","link":"","permalink":"https://reversescale.github.io/2018/05/01/iOS Architecture/","excerpt":"我理解的框架，就好比计算机的主板，房屋的建筑骨架，道路的基础设施配套，框架搭的好，能直接影响开发者的开发心情，更能让项目健壮性和扩展性大大增强~","text":"我理解的框架，就好比计算机的主板，房屋的建筑骨架，道路的基础设施配套，框架搭的好，能直接影响开发者的开发心情，更能让项目健壮性和扩展性大大增强~ 基于 Objective-C 实现的框架设计，YTKNetwork网络层 + AOP替代基类 + MVVM + ReactiveObjC + JLRoutes路由 👨🏻‍💻 Github Demo 🤖 要求 iOS 8.0+ Xcode 8.0+ Objective-C 🎨 测试 UI 什么样子？ 1.展示页 2.展示页 3.展示页 4.说明页 登录视图 示例展示 跳转页面 介绍页面 🎯 安装方法安装在 iOS, 你需要在 Podfile 中添加.123456789101112131415161718source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;9.0&apos;use_frameworks! # 提示组件框架 pod &apos;SVProgressHUD&apos;, &apos;~&gt; 2.2.2&apos; # 网络请求框架 pod &apos;YTKNetwork&apos;, &apos;~&gt; 2.0.3&apos; # AOP面向切面 pod &apos;Aspects&apos;, &apos;~&gt; 1.4.1&apos; # 响应函数式框架 pod &apos;ReactiveObjC&apos;, &apos;~&gt; 3.0.0&apos; # 路由组件化解耦 pod &apos;JLRoutes&apos;, &apos;~&gt; 2.0.5&apos; # 提示组件框架 pod &apos;SVProgressHUD&apos;, &apos;~&gt; 2.2.2&apos; # 自动布局 pod &apos;Masonry&apos;, &apos;~&gt; 1.0.2&apos; 🛠 框架介绍AOP 模式（Aspects-RunTime 代替基类）+ Category 方法交换采用AOP思想，使用 Aspects 来完成替换 Controller ，View，ViewModel基类，和基类说拜拜 Casa反革命工程师 iOS应用架构谈 view层的组织和调用方案 博客中提到一个疑问是否有必要让业务方统一派生ViewController Casa大神回答是NO，原因如下 使用派生比不使用派生更容易增加业务方的使用成本 不使用派生手段一样也能达到统一设置的目的对于第一点，从 集成成本 ，上手成本 ，架构维护成本等因素入手，大神博客中也已经很详细。 框架不需要通过继承即能够对ViewController进行统一配置。业务即使脱离环境，也能够跑完代码，ViewController一旦放入框架环境，不需要添加额外的或者只需添加少量代码，框架也能够起到相应的作用 对于本人来说 ，具备这点的吸引力，已经足够让我有尝试一番的心思了。 对于OC来说，方法拦截很容易就想到自带的黑魔法方法调配 Method Swizzling， 至于为ViewController做动态配置，自然非Category莫属了Method Swizzling 业界已经有非常成熟的三方库 Aspects, 所以Demo代码采用 Aspects 做方法拦截。 12345678910111213141516171819202122+ (void)load &#123; [super load]; [FKViewControllerIntercepter sharedInstance];&#125;// .... 单例初始化代码- (instancetype)init &#123; self = [super init]; if (self) &#123; /* 方法拦截 */ // 拦截 viewDidLoad 方法 [UIViewController aspect_hookSelector:@selector(viewDidLoad) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt;aspectInfo)&#123; [self _viewDidLoad:aspectInfo.instance]; &#125; error:nil]; // 拦截 viewWillAppear: [UIViewController aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, BOOL animated)&#123; [self _viewWillAppear:animated controller:aspectInfo.instance]; &#125; error:NULL]; &#125; return self;&#125; 至于 Category 已经非常熟悉了 12345678910111213141516171819202122232425262728@interface UIViewController (NonBase)/** 去Model&amp;&amp;表征化参数列表 */@property (nonatomic, strong) NSDictionary *params;/** ViewModel 属性 */@property (nonatomic, strong) id &lt;FKViewControllerProtocol&gt; viewModel;#pragma mark - 通用类/** 返回Controller的当前bounds @param hasNav 是否有导航栏 @param hasTabBar 是否有tabbar @return 坐标 */- (CGRect)fk_visibleBoundsShowNav:(BOOL)hasNav showTabBar:(BOOL)hasTabBar;/** 隐藏键盘 */- (void)fk_hideKeyBoard;@end 至此，我们已经实现了不继承基类来实现对ViewController的配置，项目中的 View ViewModel 去基类原理如出一辙。 View层采用 MVVM 设计模式，使用 ReactiveObjC 进行数据绑定-MVC- 作为老牌思想MVC，大家早已耳熟能详，MVC素有 Massive VC之称，随着业务增加，Controller将会越来越复杂，最终Controller会变成一个”神类”, 即有网络请求等代码，又充斥着大量业务逻辑，所以为Controller减负，在某些情况下变得势在必行 -MVVM- MVVM是基于胖Model的架构思路建立的，然后在胖Model中拆出两部分：Model和ViewModel (注：胖Model 是指包含了一些弱业务逻辑的Model)胖Model实际上是为了减负 Controller 而存在的，而 MVVM 是为了拆分胖Model , 最终目的都是为了减负Controller。 我们知道，苹果MVC并没有专门为网络层代码分专门的层级，按照以往习惯，大家都写在了Controller 中，这也是Controller 变Massive得元凶之一，现在我们可以将网络请求等诸如此类的代码放到ViewModel中了 （文章后半部分将会描述ViewModel中的网络请求） -数据流向- 正常的网络请求获取数据，然后更新View自然不必多说，那么如果View产生了数据要怎么把数据给到Model，由于View不直接持有ViewModel，所以我们需要有个桥梁 ReactiveCocoa, 通过 Signal 来和 ViewModel 通信，这个过程我们使用 通知 或者 Target-Action也可以实现相同的效果，只不过没有 ReactiveCocoa 如此方便罢了 123456789101112131415161718/* View -&gt; ViewModel 传递数据示例 */#pragma mark - Bind ViewModel- (void)bindViewModel:(id&lt;FKViewModelProtocol&gt;)viewModel withParams:(NSDictionary *)params &#123; if ([viewModel isKindOfClass:[FKLoginViewModel class]])&#123; FKLoginViewModel *_viewModel = (FKLoginViewModel *)viewModel; // 绑定账号 View -&gt; ViewModel 传递数据 @weakify(self); RAC(_viewModel, userAccount) = [[self.inputTextFiled.rac_textSignal takeUntil:self.rac_prepareForReuseSignal] map:^id _Nullable(NSString * _Nullable account) &#123; @strongify(self); // 限制账号长度 if (account.length &gt; 25) &#123; self.inputTextFiled.text = [account substringToIndex:25]; &#125; return self.inputTextFiled.text; &#125;]; &#125;&#125; 上面代码给出了 View -&gt; ViewModel 绑定的一个例子 具体一些详情，可以直接看DemoMVVM一些总结： View C ViewModel Model 实际上应该称之为MVCVM Controller 将不再直接和 Model 进行绑定，而通过桥梁ViewModel 最终 Controller 的作用变成一些UI的处理逻辑，和进行View和ViewModel的绑定 MVVM 和 MVC 兼容 由于多了一层 ViewModel, 会需要写一些胶水代码，所以代码量会增加 网络层使用 YTKNetwork 配合 ReactiveCocoa 封装网络请求，解决如何交付数据，交付什么样的数据（去Model化)等问题YTKNetwork 是猿题库 iOS 研发团队基于 AFNetworking 封装的 iOS 网络库，其实现了一套 High Level 的 API，提供了更高层次的网络访问抽象。 笔者对 YTKNetwork 进行了一些封装，结合 ReactiveCocoa，并提供 reFormatter 接口对服务器响应数据重新处理，灵活交付给业务层。接下来，本文会回答两个问题 以什么方式将数据交付给业务层？ 交付什么样的数据 ?对于第一个问题 以什么方式将数据交付给业务层？ 虽然 iOS应用架构谈 网络层设计方案 中 Casa大神写到 尽量不要用block，应该使用代理的确，Block难以追踪和定位错误，容易内存泄漏， YTKNetwork 也提供代理方式回调 1234567891011121314@protocol YTKRequestDelegate &lt;NSObject&gt;@optional/// Tell the delegate that the request has finished successfully.////// @param request The corresponding request.- (void)requestFinished:(__kindof YTKBaseRequest *)request;/// Tell the delegate that the request has failed.////// @param request The corresponding request.- (void)requestFailed:(__kindof YTKBaseRequest *)request;@end 前文有说过，MVVM 并不等于 ReactiveCocoa , 但是想要体验最纯正的 ReactiveCocoa 还是Block较为酸爽，Demo中笔者两者都给出了代码, 大家可以自行选择和斟酌哈我们看一下 YTKNetwork 和 ReactiveCocoa 结合的代码 123456789101112131415161718192021222324252627- (RACSignal *)rac_requestSignal &#123; [self stop]; RACSignal *signal = [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; // 请求起飞 [self startWithCompletionBlockWithSuccess:^(__kindof YTKBaseRequest * _Nonnull request) &#123; // 成功回调 [subscriber sendNext:[request responseJSONObject]]; [subscriber sendCompleted]; &#125; failure:^(__kindof YTKBaseRequest * _Nonnull request) &#123; // 错误回调 [subscriber sendError:[request error]]; &#125;]; return [RACDisposable disposableWithBlock:^&#123; // Signal销毁 停止请求 [self stop]; &#125;]; &#125;] takeUntil:[self rac_willDeallocSignal]]; //设置名称 便于调试 if (DEBUG) &#123; [signal setNameWithFormat:@\"%@ -rac_xzwRequest\", RACDescription(self)]; &#125; return signal;&#125; 写了一个简单的 Category FKBaseRequest+Rac.hViewModel 中使用 RACCommand 封装调用：1234567891011- (RACCommand *)loginCommand &#123; if (!_loginCommand) &#123; @weakify(self); _loginCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id _Nullable input) &#123; @strongify(self); return [[[FKLoginRequest alloc] initWithUsr:self.userAccount pwd:self.password] rac_requestSignal]; &#125;]; &#125; return _loginCommand;&#125; Block方式交付业务1234567FKLoginRequest *loginRequest = [[FKLoginRequest alloc] initWithUsr:self.userAccount pwd:self.password];return [[[loginRequest rac_requestSignal] doNext:^(id _Nullable x) &#123; // 解析数据 [[NSUserDefaults standardUserDefaults] setObject:@(YES) forKey:@\"isLogin\"]; &#125;] materialize]; Delegate方式交付业务12345678910FKLoginRequest *loginRequest = [[FKLoginRequest alloc] initWithUsr:self.userAccount pwd:self.password];// 数据请求响应代理 通过代理回调loginRequest.delegate = self;return [loginRequest rac_requestSignal];#pragma mark - YTKRequestDelegate- (void)requestFinished:(__kindof YTKBaseRequest *)request &#123; // 解析数据 [[NSUserDefaults standardUserDefaults] setObject:@(YES) forKey:@\"isLogin\"];&#125; 交付什么样的数据 ? 现在诸如 JSONModel ，YYModel 之类的Json转Model的库也非常多，大多数Json对象，网络请求成功直接就被转成Model了然而 iOS应用架构谈 网络层设计方案 中给出了两种有意思的交付思路 使用 reformer 对数据进行清洗 去特定对象表征 （去Model） Casa文章中好处已经写得很详细了，通过不同的 reformer 来重塑和交付不同的业务数据，可以说是非常灵活了 使用 reformer 对数据进行清洗 在网络层封装 FKBaseRequest.h 中 给出了 FKBaseRequestFeformDelegate 接口来重塑数据1234567891011121314151617181920@protocol FKBaseRequestFeformDelegate &lt;NSObject&gt;/** 自定义解析器解析响应参数 @param request 当前请求 @param jsonResponse 响应数据 @return 自定reformat数据 */- (id)request:(FKBaseRequest *)request reformJSONResponse:(id)jsonResponse;@end然后在对应的 reformer 对数据进行重塑#pragma mark - FKBaseRequestFeformDelegate- (id)request:(FKBaseRequest *)request reformJSONResponse:(id)jsonResponse &#123; if([request isKindOfClass:FKLoginRequest.class])&#123; // 在这里对json数据进行重新格式化 &#125; return jsonResponse;&#125; 也可以直接在子类的 RequestManager 中覆盖父类方法达到一样的效果12345/* FKLoginRequest.m */// 可以在这里对response 数据进行重新格式化， 也可以使用delegate 设置 reformattor- (id)reformJSONResponse:(id)jsonResponse &#123;&#125; 去特定对象表征 （去Model） 这思路可以说是业界的泥石流了去Model也就是说，使用NSDictionary形式交付数据，对于网络层而言，只需要保持住原始数据即可，不需要主动转化成数据原型但是会存在一些小问题 去Model如何保持可读性？ 复杂和多样的数据结构如何解析？ Casa大神 提出了 使用EXTERN + Const 字符串形式，并建议字符串跟着reformer走，个人觉得很多时候API只需要一种解析格式，所以Demo跟着 APIManager 走，其他情况下常量字符串建议听从 Casa大神 的建议，常量定义： 123456/* FKBaseRequest.h */// 登录token keyFOUNDATION_EXTERN NSString *FKLoginAccessTokenKey;/* FKBaseRequest.m */NSString *FKLoginAccessTokenKey = @\"accessToken\"; 在 .h 和 .m 文件中要同时写太多代码，我们也可以使用局部常量的形式，只要在 .h 文件中定义即可 12345678910111213// 也可以写成 局部常量形式static const NSString *FKLoginAccessTokenKey2 = @\"accessToken\";最终那么我们的reformer可能会变成这样子- (id)request:(FKBaseRequest *)request reformJSONResponse:(id)jsonResponse &#123; if([request isKindOfClass:FKLoginRequest.class])&#123; // 在这里对json数据进行重新格式化 return @&#123; FKLoginAccessTokenKey : jsonResponse[@\"token\"], &#125;; &#125; return jsonResponse;&#125; 复杂和多样的数据结构如何解析？有时候，reformer 交付过来的数据，我们需要解析的可能是字符串类型，也可能是NSNumber类型，也有可能是数组为此，笔者提供了一系列 Encode Decode方法，来降低解析的复杂度和安全性1234567891011121314151617181920212223242526#pragma mark - Encode Decode 方法// NSDictionary -&gt; NSStringFK_EXTERN NSString* DecodeObjectFromDic(NSDictionary *dic, NSString *key);// NSArray + index -&gt; idFK_EXTERN id DecodeSafeObjectAtIndex(NSArray *arr, NSInteger index);// NSDictionary -&gt; NSStringFK_EXTERN NSString * DecodeStringFromDic(NSDictionary *dic, NSString *key);// NSDictionary -&gt; NSString ？ NSString ： defaultStrFK_EXTERN NSString* DecodeDefaultStrFromDic(NSDictionary *dic, NSString *key,NSString * defaultStr);// NSDictionary -&gt; NSNumberFK_EXTERN NSNumber * DecodeNumberFromDic(NSDictionary *dic, NSString *key);// NSDictionary -&gt; NSDictionaryFK_EXTERN NSDictionary *DecodeDicFromDic(NSDictionary *dic, NSString *key);// NSDictionary -&gt; NSArrayFK_EXTERN NSArray *DecodeArrayFromDic(NSDictionary *dic, NSString *key);FK_EXTERN NSArray *DecodeArrayFromDicUsingParseBlock(NSDictionary *dic, NSString *key, id(^parseBlock)(NSDictionary *innerDic));#pragma mark - Encode Decode 方法// (nonull Key: nonull NSString) -&gt; NSMutableDictionaryFK_EXTERN void EncodeUnEmptyStrObjctToDic(NSMutableDictionary *dic,NSString *object, NSString *key);// nonull objec -&gt; NSMutableArrayFK_EXTERN void EncodeUnEmptyObjctToArray(NSMutableArray *arr,id object);// (nonull (Key ? key : defaultStr) : nonull Value) -&gt; NSMutableDictionaryFK_EXTERN void EncodeDefaultStrObjctToDic(NSMutableDictionary *dic,NSString *object, NSString *key,NSString * defaultStr);// (nonull Key: nonull object) -&gt; NSMutableDictionaryFK_EXTERN void EncodeUnEmptyObjctToDic(NSMutableDictionary *dic,NSObject *object, NSString *key); 我们的reformer可以写成这样子1234567891011#pragma mark - FKBaseRequestFeformDelegate- (id)request:(FKBaseRequest *)request reformJSONResponse:(id)jsonResponse &#123; if([request isKindOfClass:FKLoginRequest.class])&#123; // 在这里对json数据进行重新格式化 return @&#123; FKLoginAccessTokenKey : DecodeStringFromDic(jsonResponse, @\"token\") &#125;; &#125; return jsonResponse;&#125; 解析有可能是这样子1NSString *token = DecodeStringFromDic(jsonResponse, FKLoginAccessTokenKey) 好了，至此我们解决了两个问题 以什么方式将数据交付给业务层答：delegate 最佳，block为次 交付什么样的数据答：纯字典，去Model 采用 JLRoutes 路由对应用进行组件化解耦 带着问题思考如何才能设计出最好的组件化路由： 1）3D-Touch功能或者点击推送消息，要求外部跳转到App内部一个很深层次的一个界面。 2）自家的一系列App之间如何相互跳转？ 3）如何解除App组件之间和App页面之间的耦合性？ 4）如何能统一iOS和Android两端的页面跳转逻辑？甚至如何能统一三端的请求资源的方式？ 5）如果使用了动态下发配置文件来配置App的跳转逻辑，那么如果做到iOS和Android两边只要共用一套配置文件？ 6）如果App出现bug了，如何不用JSPatch，就能做到简单的热修复功能？ 7）如何在每个组件间调用和页面跳转时都进行埋点统计？每个跳转的地方都手写代码埋点？利用Runtime AOP ？ 8）如何在每个组件间调用的过程中，加入调用的逻辑检查，令牌机制，配合灰度进行风控逻辑？ 9）如何在App任何界面都可以调用同一个界面或者同一个组件？只能在AppDelegate里面注册单例来实现？ iOS应用架构谈 组件化方案 一文中 Casa 针对 蘑菇街组件化 提出了质疑，质疑点主要在这几方面 App启动时组件需要注册URL URL调用组件方式不太好传递类似 UIImage 等非常规对象 URL需要添加额外参数可读性差，所以没必要使用URL 对于 App启动时组件需要注册URL 顾虑主要在于，注册的URL需要在应用生存周期内常驻内存，如果是注册Class还好些，如果注册的是实例，消耗的内存就非常可观了 12345#pragma mark - 路由表NSString *const FKNavPushRoute = @\"/com_madao_navPush/:viewController\";NSString *const FKNavPresentRoute = @\"/com_madao_navPresent/:viewController\";NSString *const FKNavStoryBoardPushRoute = @\"/com_madao_navStoryboardPush/:viewController\";NSString *const FKComponentsCallBackRoute = @\"/com_madao_callBack/*\"; 而且JLRoutes 还支持 * 来进行通配，路由表如何编写大家可以自由发挥对应的路由事件 handler 12345678910111213141516171819202122232425262728293031323334353637// push// 路由 /com_madao_navPush/:viewController[[JLRoutes globalRoutes] addRoute:FKNavPushRoute handler:^BOOL(NSDictionary&lt;NSString *,id&gt; * _Nonnull parameters) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [self _handlerSceneWithPresent:NO parameters:parameters]; &#125;); return YES;&#125;];// present// 路由 /com_madao_navPresent/:viewController[[JLRoutes globalRoutes] addRoute:FKNavPresentRoute handler:^BOOL(NSDictionary&lt;NSString *,id&gt; * _Nonnull parameters) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [self _handlerSceneWithPresent:YES parameters:parameters]; &#125;); return YES;&#125;];#pragma mark - Private/// 处理跳转事件- (void)_handlerSceneWithPresent:(BOOL)isPresent parameters:(NSDictionary *)parameters &#123; // 当前控制器 NSString *controllerName = [parameters objectForKey:FKControllerNameRouteParam]; UIViewController *currentVC = [self _currentViewController]; UIViewController *toVC = [[NSClassFromString(controllerName) alloc] init]; toVC.params = parameters; if (currentVC &amp;&amp; currentVC.navigationController) &#123; if (isPresent) &#123; [currentVC.navigationController presentViewController:toVC animated:YES completion:nil]; &#125;else &#123; [currentVC.navigationController pushViewController:toVC animated:YES]; &#125; &#125;&#125; 通过URL中传入的组件名动态注册，处理相应跳转事件，并不需要每个组件一一注册使用URL路由，必然URL会散落到代码各个地方 1234NSString *key = @\"key\";NSString *value = @\"value\";NSString *url = [NSString stringWithFormat:@\"/com_madao_navPush/%@?%@=%@\", NSStringFromClass(ViewController.class), key, value];[[UIApplication sharedApplication] openURL:[NSURL URLWithString:url]]; 诸如此类丑陋的代码，散落在各个地方的话简直会让人头皮发麻, 所以笔者在 JLRoutes+GenerateURL.h 写了一些 Helper方法1234567891011121314151617181920212223242526272829303132333435/** 避免 URL 散落各处， 集中生成URL @param pattern 匹配模式 @param parameters 附带参数 @return URL字符串 */+ (NSString *)fk_generateURLWithPattern:(NSString *)pattern parameters:(NSArray *)parameters;/** 避免 URL 散落各处， 集中生成URL 额外参数将被 ?key=value&amp;key2=value2 样式给出 @param pattern 匹配模式 @param parameters 附加参数 @param extraParameters 额外参数 @return URL字符串 */+ (NSString *)fk_generateURLWithPattern:(NSString *)pattern parameters:(NSArray *)parameters extraParameters:(NSDictionary *)extraParameters;/** 解析NSURL对象中的请求参数http://madao?param1=value1¶m2=value2 解析成 @&#123;param1:value1, param2:value2&#125; @param URL NSURL对象 @return URL字符串 */+ (NSDictionary *)fk_parseParamsWithURL:(NSURL *)URL;/** 将参数对象进行url编码 将@&#123;param1:value1, param2:value2&#125; 转换成 ?param1=value1&amp;param2=value2 @param dic 参数对象 @return URL字符串 */+ (NSString *)fk_mapDictionaryToURLQueryString:(NSDictionary *)dic; 宏定义Helper12345678910#undef JLRGenRoute#define JLRGenRoute(Schema, path) \\([NSString stringWithFormat: @\"%@:/%@\", \\Schema, \\path])#undef JLRGenRouteURL#define JLRGenRouteURL(Schema, path) \\([NSURL URLWithString: \\JLRGenRoute(Schema, path)]) 最终我们的调用可以变成12NSString *router = [JLRoutes fk_generateURLWithPattern:FKNavPushRoute parameters:@[NSStringFromClass(ViewController.class)] extraParameters:nil];[[UIApplication sharedApplication] openURL:JLRGenRouteURL(FKDefaultRouteSchema, router)]; 📝 整理制作Casa Taloyum：https://casatwy.com/modulization_in_action.html 简书博客：http://www.jianshu.com/p/921dd65e79cb 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"ReactNative 开发常用命令行（持续更新）","slug":"ReactNative command","date":"2018-03-29T14:56:27.000Z","updated":"2018-11-16T12:13:47.540Z","comments":true,"path":"2018/03/29/ReactNative command/","link":"","permalink":"https://reversescale.github.io/2018/03/29/ReactNative command/","excerpt":"记录一些 ReactNative 常用的命令行，包括了例如安装、启动服务、插件管理、热更新等一些日常经常使用的命令，会随着使用的深入不断的补充 ~","text":"记录一些 ReactNative 常用的命令行，包括了例如安装、启动服务、插件管理、热更新等一些日常经常使用的命令，会随着使用的深入不断的补充 ~ Node 相关查看所有安装的node版本信息：1nvm list 查看更新了的node的版本(可能需要翻墙)：1nvm ls-remote 安装node：1nvm install v7.4.0 设置默认的node版本(这里设置成了7.4.0)，解决有些版本有些兼容性的问题：1nvm alias default v7.4.0 React 相关卸载命令：1npm uninstall -g react-native-cli 安装命令：1npm install -g react-native-cli 查看某个模块最新发布版本信息(这里查看react-native发布的版本信息)：1npm info react-native 升级或者降级react-native的版本并且更新package.json，需要用在react-native项目目录下：1npm install --save react-native@0.41.1 新建 react-native 项目并指定版本：1react-native init demo --version 0.40.0 开启服务：1react-native start 运行Android：1react-native run-android 运行iOS：1react-native run-ios 版本查看：1react-native --version 项目版本查看：1react-native -v 查看react-native的帮助信息：1react-native --help 使用 Cocoapods 管理 ReactNativePodfile 文件格式：1234567891011pod &apos;React&apos;, :path =&gt; &apos;./node_modules/react-native&apos;, :subspecs =&gt; [ &apos;Core&apos;, &apos;RCTText&apos;, &apos;RCTImage&apos;, &apos;RCTActionSheet&apos;, &apos;RCTGeolocation&apos;, &apos;RCTNetwork&apos;, &apos;RCTSettings&apos;, &apos;RCTVibration&apos;, &apos;RCTWebSocket&apos;, ] ReactNative 0.42.0 以上版本需在 Podfile 配置 yoga：12# 如果你的RN版本 &gt;= 0.42.0，请加入下面这行pod &quot;yoga&quot;, :path =&gt; &quot;./node_modules/react-native/ReactCommon/yoga&quot; 开源组件库：安装最新版本：1npm install react-native-tab-navigator --save 安装指定版本：1npm install --save react-native-tab-navigator@0.4.0 react-native 集成组件绑定(ReactNative 0.27以后，自集成RNPM)：1react-native link react-native-splash-screen 常用开源库：12345678npm install --save react-native-tab-navigator@0.4.0npm install --save react-native-scrollable-tab-view@0.7.0npm install --save react-native-check-box@1.0.4npm install --react-native-easy-toast@1.0.9npm install --save GitHubTrending@2.0.0npm install --save react-native-htmlview@0.5.0npm install --save react-native-popover@0.5.0npm install --react-native-splash-screen@2.0.0 Code-Push 常用命令Code-Push 推包命令：1code-push release-react &lt;appName&gt; &lt;platform&gt; [options] 示例： 1code-push release-react RNAPPGithub ios --t 1.0.2 --dev false --d Staging --des &quot;1.热更新相关设置&quot; --m true Code-Push 线上查看更新：1code-push deployment ls RNAPPGithub Code-Push 查看项目Key：1code-push deployment ls RNAPPGithub -k Code-Push iOS更新打包方法：1react-native bundle --platform ios --entry-file index.js --bundle-output release_ios/main.jsbundle --assets-dest release_ios/ --dev fasle IDE 技巧《使用VS Code调试React-Native程序》（https://jingyan.baidu.com/article/ad310e80fb13fc1849f49ed1.html）","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"https://reversescale.github.io/tags/ReactNative/"}]},{"title":"ReactNative 学习成果总结","slug":"ReactNative APP","date":"2018-03-29T11:56:27.000Z","updated":"2018-11-16T12:13:55.027Z","comments":true,"path":"2018/03/29/ReactNative APP/","link":"","permalink":"https://reversescale.github.io/2018/03/29/ReactNative APP/","excerpt":"ReactNative 这几年风生水起，当然除了 React 社区生态圈的加持和 Facebook 的大力推广以外，另外一个最主要的原因就是其在开发效率和应用性能方面取得了一个比较好的平衡~","text":"ReactNative 这几年风生水起，当然除了 React 社区生态圈的加持和 Facebook 的大力推广以外，另外一个最主要的原因就是其在开发效率和应用性能方面取得了一个比较好的平衡~ 学习课程：《双平台真实开发GitHub App React Native技术全面掌握》399 大洋，含着泪吃了一个月泡面.. 👨🏻‍💻 Github Demo 知识点： 1.整理 ReactNative 网络封装及常用的三方模块 2.ReactNative 的 AsyncStorage数据库技术、离线缓存 3.ReactNative 的数据 DAO 层设计技巧，数据状态实时更新 4.ReactNative 的代码提取技巧，组合模式应用技巧，数据异步刷新与动态添加 5.ReactNative 的版本升级、数据统计、社会化分享、第三方登录，热更新等 6.ReactNative 项目发布前的优化、打包与上线 目录结构： 生命周期及使用场景 项目介绍 组件化 集成与管理 布局约束 组件封装 本地持久化 网络请求封装 功能调试 双平台适配 开源组件库的使用 热更新 生命周期及使用场景常用方法： constructor: componentWillMount: render: componentDidMount: componentWillReceiveProps: shouldComponentUpdate: componentWillUpdate: componentDidUpdate componentWillUnmount: constructor:在组件创建的时候调用一次,这个方法进行this.state初始化状态机。123456constructor(props) &#123; super(props); // 初始状态 this.state = &#123; isShow:true &#125;;&#125; componentWillMount:在组件生命周期中只会被执行一次,在初始渲染(render函数)前被执行。注意: 如果这个函数通过setState函数修改状态机变量,RN框架不会额外执行渲染(界面刷新) 如果子组件也有componentWillMount函数使用,会在父组件之后调用 需要从本地存储中读取数据用于显示,常用这个函数 render:该函数组件必有的，通过返回JSX或其他组件来构成DOM，换言之，就是组件的核心渲染过程。 componentDidMount:在React Native组件的生命周期中,这个函数只会被执行一次，它在初始渲染完成后会马上被调用。在这之后开发者可以通过子组件的引用来访问，操作任何子组件。如果RN组件的子组件也有componentDidMount函数，并会在父组件的componentDidMount函数之前被调用。 常用来网络请求数据 componentWillReceiveProps:在React Native组件的初始渲染完成后，props改变时，这个函数被调用，参数是个新的props。 shouldComponentUpdate:React Native组件的初始渲染执行完成后, RN组件接收到新的state或者props时这个函数会调用。 通过这个函数阻止无必要的重新渲染，是提高React Native应用程序性能的一大技巧。 componentWillUpdate:初始渲染完成后,重新渲染前会调用这个函数。 这个函数不能通过this.setState再次改变状态机变量的值。 组件更新时调用。 componentDidUpdateRN组件初始渲染完成后，RN框架在重新渲染RN组件完成后调用。参数是渲染前的props和state。 组件更新完毕时调用。 componentWillUnmount:ReactNative 组件被卸载前会调用，通常做一些清理内容。 项目介绍双平台效果预览： React Native是React在移动端的跨平台方案。如果想更快地理解和掌握React Native开发，就必须先了解React。 React是FaceBook开源的一个前端框架，它起源于 Facebook 的内部项目，并于 2013 年 5 月开源。因为React 拥有较高的性能，代码逻辑非常简单，所以越来越多的人已开始关注和使用它，目前该框架在Github上已经有7万+star。 ReactNative 技术导图： 组件化React采用组件化的方式开发，通过将view构建成组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。有一句话说的很形象：在React中，构建应用就像搭积木一样。 组件化特征React认为一个组件应该具有如下特征： 可组合（Composeable）：一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部。如果一个组件内部创建了另一个组件，那么说父组件拥有它创建的子组件，通过这个特性，一个复杂的UI可以拆分成多个简单的UI组件； 可重用（Reusable）：每个组件都是具有独立功能的，它可以被使用在多个UI场景； 可维护（Maintainable）：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护； 封装好的导航栏就可以被称之为一个组件，它符合上述三个特点： 可组合：可以将导航栏组件放在页面组件中作为页面组件的子组件。而且在导航栏组件的内部，也有按钮组件等子组件。 可重用：如果封装好了该组件，就可以放在任意需要导航栏的页面（组件）使用，也可以放在其他项目中使用。 可维护：因为具有独立的功能和展示逻辑，所以便于定位和修改。 组件的属性与状态在React Native（React.js）里，组件所持有的数据分为两种： 属性（props）：组件的props是不可变的，它只能从其他的组件（例如父组件）传递过来。 状态（state）：组件的state是可变的，它负责处理与用户的交互。在通过用户点击事件等操作以后，如果使得当前组件的某个state发生了改变，那么当前组件就会触发render()方法刷新自己。 我们可以看到这个页面有两个子页面，一个是‘最热’页面（组件），另一个是‘趋势‘页面（组件）。那么这两个组件都有什么props和state呢？ 1.props：由于props是从其父组件传递过来的，那么可想而知，props的声明应该是在当前组件的父组件里来做。在React Native中，通常props的声明是和当前组件的声明放在一起的： 1234//最热子页面&lt;FavoriteTabPage &#123;...this.props&#125; tabLabel='最热' flag=&#123;FlAG_STORAGE.flag_popular&#125;/&gt;//趋势子页面&lt;FavoriteTabPage &#123;...this.props&#125; tabLabel='趋势' flag=&#123;FlAG_STORAGE.flag_trending&#125;/&gt; 在这里，收藏页面是父组件，而最热页面和趋势页面是其子组件。在收藏页面组件里声明了最热页面和趋势页面的组件。 而且我们也可以看到，最热页面和趋势页面组件都用的是同一个组件：FavoriteTabPage，而这两个页面的不同点只在于传入的两个props的不同：tabLabel和flag。 而在FavoriteTabPage组件内部，如果想调用flag这个props，可以使用this.props.flag来调用。 2.state: 下面是最热和趋势页面的组件： 12345678class FavoriteTabPage extends Component&#123;//组件的构造方法constructor(props)&#123; super(props); this.state=&#123; dataSource:new ListView.DataSource(&#123;rowHasChanged:(r1,r2)=&gt;r1!==r2&#125;),isLoading:false, &#125;&#125; 这里面定义了两个state: dataSource:列表的数据源 isLoading:是否正在刷新 这两个state都是将来可能经常变化的。比如在网络请求以后，列表的数据源会被替换掉，这个时候就要调用: 1234this.setState(&#123; //把新的值newDataArr对象传给dataSource dataSource:newDataArr&#125;) 3.DOMDOM 是前端的一个概念，暂时可以粗略理解为一个页面的树形结构。React 生命周期的三大阶段 Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM 在每个阶段都有相应的状态和与之对应的回调函数，具体可以看下图： 上图来自：贾鹏辉的技术博客：React Native之React速学教程(中) 集成与管理1.指定版本初始化在终端输入react-native demo –version 0.40.0命令以后，就会初始化一个React Native版本为0.40.0的项目。这个最初项目里面直接就包含了iOS和Android的工程文件夹，可以用对应的IDE打开后编译运行。 在新建一个React Native项目之后的根目录结构是这样的： 2.使用 Cocoapods 管理 ReactNativePodfile 文件格式：1234567891011pod &apos;React&apos;, :path =&gt; &apos;./node_modules/react-native&apos;, :subspecs =&gt; [ &apos;Core&apos;, &apos;RCTText&apos;, &apos;RCTImage&apos;, &apos;RCTActionSheet&apos;, &apos;RCTGeolocation&apos;, &apos;RCTNetwork&apos;, &apos;RCTSettings&apos;, &apos;RCTVibration&apos;, &apos;RCTWebSocket&apos;, ] ReactNative 0.42.0 以上版本需在 Podfile 配置 yoga：12# 如果你的RN版本 &gt;= 0.42.0，请加入下面这行pod &quot;yoga&quot;, :path =&gt; &quot;./node_modules/react-native/ReactCommon/yoga&quot; 输入react-native run-ios或者react-native run-android指令， 就会自动打开模拟器运行项目(前提是安装了相应的开发环境)。 但是一个比较完整的项目仅仅有这些类别的文件是不够的，还需要一些工具类，模型类，资源等文件。为了很好地区分它们，使项目结构一目了然，需要组织好项目文件夹以及类的命名，下面是我将教程里的文件夹命名和结构稍加修改后的一个方案，可供大家参考： 布局约束采用Flex布局的元素，被称为Flex container，其所有子元素被称为Flex item；容器默认存在两个轴，分别是主轴（main axis）和垂直的交叉轴（cross axis）,主轴开始的位置叫做main start，结束的位置叫main end；交叉轴的开始位置叫做cross start，结束的位置叫做cross end；单个item占据的主轴空间叫做main size，占据的交叉轴控件叫做cross size。 如下图所示： 组件化驱动下，搜索结果页中展示的 Cell 与之前的列表页 Cell 可以重用： 我们把该组件定名为：RespositoryCell，结合代码来看一下具体的实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960export default class RepositoryCell extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; isFavorite: this.props.projectModel.isFavorite, favoriteIcon: this.props.projectModel.isFavorite ? require('../../res/images/ic_star.png') : require('../../res/images/ic_unstar_transparent.png'), &#125;; &#125; componentWillReceiveProps(nextProps) &#123; this.setFavoriteState(nextProps.projectModel.isFavorite) &#125; setFavoriteState(isFavorite) &#123; this.props.projectModel.isFavorite = isFavorite; this.setState(&#123; isFavorite: isFavorite, favoriteIcon: isFavorite ? require('../../res/images/ic_star.png') : require('../../res/images/ic_unstar_transparent.png') &#125;) &#125; onPressFavorite() &#123; this.setFavoriteState(!this.state.isFavorite) this.props.onFavorite(this.props.projectModel.item, !this.state.isFavorite) &#125; render() &#123; let item = this.props.projectModel.item? this.props.projectModel.item:this.props.projectModel; let favoriteButton=this.props.projectModel.item? &lt;TouchableOpacity style=&#123;&#123;padding:6&#125;&#125; onPress=&#123;()=&gt;this.onPressFavorite()&#125; underlayColor='transparent'&gt; &lt;Image ref='favoriteIcon' style=&#123;[&#123;width: 22, height: 22,&#125;,this.props.theme.styles.tabBarSelectedIcon]&#125; source=&#123;this.state.favoriteIcon&#125;/&gt; &lt;/TouchableOpacity&gt;:null; return ( &lt;TouchableOpacity onPress=&#123;this.props.onSelect&#125; style=&#123;styles.container&#125; &gt; &lt;View style=&#123;styles.cell_container&#125;&gt; &lt;Text style=&#123;styles.title&#125;&gt;&#123;item.full_name&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.description&#125;&gt;&#123;item.description&#125;&lt;/Text&gt; &lt;View style=&#123;styles.row&#125;&gt; &lt;View style=&#123;styles.row&#125;&gt; &lt;Text&gt;Author:&lt;/Text&gt; &lt;Image style=&#123;&#123;height: 22, width: 22&#125;&#125; source=&#123;&#123;uri: item.owner.avatar_url&#125;&#125; /&gt; &lt;/View&gt; &lt;View style=&#123;&#123;justifyContent: 'space-between', flexDirection: 'row'&#125;&#125;&gt; &lt;Text&gt;Star:&lt;/Text&gt; &lt;Text&gt;&#123;item.stargazers_count&#125;&lt;/Text&gt; &lt;/View&gt; &#123;favoriteButton&#125; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) &#125;&#125; 这里声明了RespositoryCell组件，它继承于Component，也就是组件类，即是说，声明组件的时候必须都要继承与这个类。 集中看一下该组件的render方法，它返回的是该组件的实际布局：在语法上使用JSX，类似于HTML的标签式语法，很清楚地将cell的层级展现了出来： 最外层被一个View组件包裹着，里面第一层有三个子组件：两个Text组件和一个作为底部背景的View组件。 底部背景的View组件又有三个子组件：View组件（显示作者信息），View组件（显示star信息）,收藏按钮。 结构分解图： 组件封装 我的页面 个人中心 对于“我的页面”和“个人中心”这类结构相似的页面，建议进行组件封装，封装后的 AboutPage 实现代码简洁如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768export default class AboutPage extends Component&#123; constructor(props) &#123; super(props); this.aboutCommon=new AboutCommon(props,(dic)=&gt;this.updateState(dic),FLAG_ABOUT.flag_about,config); this.state = &#123; projectModels: [], author:config.author &#125; &#125; componentDidMount() &#123; this.aboutCommon.componentDidMount(); &#125; componentWillUnmount() &#123; this.aboutCommon.componentWillUnmount(); &#125; updateState(dic)&#123; this.setState(dic); &#125; onClick(tab) &#123; let TargetComponent, params = &#123;...this.props,menuType:tab&#125;; switch (tab) &#123; case MORE_MENU.About_Author: TargetComponent = AboutMePage; break; case MORE_MENU.Website: TargetComponent = WebViewPage; params.title='GitHubPopular'; var url='https://reversescale.github.io'; params.url=url; break; case MORE_MENU.Feedback: var url='mailto://reversescale@icloud.com'; Linking.canOpenURL(url).then(supported =&gt; &#123; if (!supported) &#123; console.log('Can\\'t handle url: ' + url); &#125; else &#123; return Linking.openURL(url); &#125; &#125;).catch(err =&gt; console.error('An error occurred', err)); break; case MORE_MENU.Share: break; &#125; if (TargetComponent) &#123; this.props.navigator.push(&#123; component: TargetComponent, params: params, &#125;); &#125; &#125; render() &#123; let content=&lt;View&gt; &#123;this.aboutCommon.renderRepository(this.state.projectModels)&#125; &#123;ViewUtils.getSettingItem(()=&gt;this.onClick(MORE_MENU.Website), require('../../../res/images/ic_computer.png'), MORE_MENU.Website, this.props.theme.styles.tabBarSelectedIcon)&#125; &lt;View style=&#123;GlobalStyles.line&#125;/&gt; &#123;ViewUtils.getSettingItem(()=&gt;this.onClick(MORE_MENU.About_Author), require('../my/img/ic_insert_emoticon.png'), MORE_MENU.About_Author, this.props.theme.styles.tabBarSelectedIcon)&#125; &lt;View style=&#123;GlobalStyles.line&#125;/&gt; &#123;ViewUtils.getSettingItem(()=&gt;this.onClick(MORE_MENU.Feedback), require('../../../res/images/ic_feedback.png'), MORE_MENU.Feedback, this.props.theme.styles.tabBarSelectedIcon)&#125; &lt;/View&gt; return this.aboutCommon.render(content, &#123; 'name': 'GitHub Popular', 'description': '这是一个用来查看GitHub最受欢迎与最热项目的App,它基于React Native支持Android和iOS双平台。', \"avatar\": \"http://og1yl0w9z.bkt.clouddn.com/18-3-28/61685877.jpg\", \"backgroundImg\": \"http://og1yl0w9z.bkt.clouddn.com/18-3-28/37407402.jpg\", &#125;); &#125;&#125; 本地持久化 主题选择界面 切换主题后界面 在涉及如主题变更等操作时，需要将状态信息保存，这时就需要用到类似于iOS 中的NSUserDefault， AsyncStorage 是React Native中的 Key-Value 存储系统，可以做本地持久化。 首先看它主要的几个接口： 根据键来获取值，获取的结果会放在回调函数中：1static getItem(key: string, callback:(error, result)) 根据键来设置值：1static setItem(key: string, value: string, callback:(error)) 根据键来移除项：1static removeItem(key: string, callback:(error)) 获取所有的键：1static getAllKeys(callback:(error, keys)) 设置多项，其中 keyValuePairs 是字符串的二维数组，比如：[[‘k1’, ‘val1’], [‘k2’, ‘val2’]]：1static multiSet(keyValuePairs, callback:(errors)) 获取多项，其中 keys 是字符串数组，比如：[‘k1’, ‘k2’]：1static multiGet(keys, callback:(errors, result)) 删除多项，其中 keys 是字符串数组，比如：[‘k1’, ‘k2’]：1static multiRemove(keys, callback:(errors)) 清除所有的项目：1static clear(callback:(error)) 网络请求封装在React Native中，经常使用Fetch函数来实现网络请求，它支持GET和POST请求并返回一个Promise对象，这个对象包含一个正确的结果和一个错误的结果。 来看一下用Fetch发起的POST请求封装： 12345678910111213141516171819static post(url,data)&#123; return new Promise((resolve,reject)=&gt;&#123; fetch(url,&#123; method:'POST', header:&#123; 'Accept':'application/json', 'Content-Type':'application/json' &#125;, body:JSON.stringify(data) &#125;) .then(response=&gt;response.json()) .then(result=&gt;&#123; resolve(result); &#125;) .catch(error=&gt;&#123; reject(error); &#125;) &#125;) &#125; 从上面的代码中，我们可以大致看到：Fetch函数中，第一个参数是请求url，第二个参数是一个字典，包括方法，请求头，请求体等信息。 随后的then和catch分别捕捉了fetch函数的返回值：一个Promise对象的正确结果和错误结果。注意，这里面有两个then，其中第二个then把第一个then的结果拿了过来。而第一个then做的事情是把网络请求的结果转化为JSON对象。 那么什么是Promise对象呢？ Promise 是异步编程的一种解决方案，Promise对象可以获取某个异步操作的消息。它里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 它分为三种状态： Pending（进行中）、Resolved（已成功）和Rejected（已失败） 它的构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject： resolve函数的作用：将Promise对象的状态从“未完成”变成“成功”(即从Pending变为Resolved)，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject函数的作用：将Promise对象的状态从“未完成”变成“成功”(即从Pending变为Rejected)，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 GET 请求封装：123456789101112static get(url)&#123; return new Promise((resolve,reject)=&gt;&#123; fetch(url) .then(response=&gt;response.json()) .then(result=&gt;&#123; resolve(result); &#125;) .catch(error=&gt;&#123; reject(error); &#125;) &#125;) &#125; 因为只是GET请求，所以不需要配置请求体，而且因为这个fetch函数返回值是一个Promise对象， 所以我们可以用.then和.catch来捕捉正确和错误的结果。 功能调试我们可以使用浏览器的开发者工具来调试React Native项目，可以通过打断点的方式来看数据信息以及方法的调用： 首先在iOS模拟器中点击command + D，然后再弹出菜单里点击Debug JS Remotely。随后就打开了浏览器进入了调试。 浏览器一般会展示下面的页面，然后点击command + option + J进入真生的调试界面。 双平台适配因为React Native讲求的是一份代码跑在两个平台上，而客观上这两个平台又有一些不一样的地方，所以就需要在别要的时候做一下两个平台的适配。 例如导航栏：在iOS设备中是存在导航栏的，而安卓设备上是没有的。所以在定制导航栏的时候，在不同平台下给导航栏设置不同的高度： 12345678910const NAV_BAR_HEIGHT_IOS = 54;const NAV_BAR_HEIGHT_ANDROID = 50;// css navBar: &#123; flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', height: Platform.OS === 'ios' ? NAV_BAR_HEIGHT_IOS : NAV_BAR_HEIGHT_ANDROID, &#125;, 上面的Platform是React Native内置的用于区分平台的库，可以在引入后直接使用。 建议在调试程序的时候，同时打开iOS和Android的模拟器进行调试，因为有些地方可能在某个平台上是没问题的，但是另一个平台上有问题，这就需要使用Platform来区分平台。 开源组件库的使用ReactNative 的组件与原生的组件有许多共同之处，如下拉刷新，同样的 Github 中开源组件已经相当完善。 开源组件库方法如下，安装最新版本：1npm install react-native-tab-navigator --save 安装指定版本：1npm install --save react-native-tab-navigator@0.4.0 react-native 集成组件绑定(ReactNative 0.27以后，自集成RNPM)：1react-native link react-native-splash-screen 常用开源库：12345678npm install --save react-native-tab-navigator@0.4.0npm install --save react-native-scrollable-tab-view@0.7.0npm install --save react-native-check-box@1.0.4npm install --react-native-easy-toast@1.0.9npm install --save GitHubTrending@2.0.0npm install --save react-native-htmlview@0.5.0npm install --save react-native-popover@0.5.0npm install --react-native-splash-screen@2.0.0 下图为使用 react-native-splash-screen 后的效果演示： 热更新CodePush 是微软提供的一套用于热更新 React Native 和 Cordova 应用的服务。 CodePush 是提供给 React Native 和 Cordova 开发者直接部署移动应用更新给用户设备的云服务。CodePush 作为一个中央仓库，开发者可以推送更新 (JS, HTML, CSS and images)，应用可以从客户端 SDK 里面查询更新。 Code-Push 推包命令：1code-push release-react &lt;appName&gt; &lt;platform&gt; [options] 示例：1code-push release-react RNAPPGithub ios --t 1.0.0 --dev false --d Staging --des &quot;1.热更新我的页面背景色&quot; --m true 1code-push release-react RNAPPGithub ios --t 1.0.1 --dev false --d Staging --des &quot;1.热更新相关设置&quot; --m true Code-Push 线上查看更新：1code-push deployment ls RNAPPGithub Code-Push 查看项目Key：1code-push deployment ls RNAPPGithub -k Code-Push iOS更新打包方法：1react-native bundle --platform ios --entry-file index.ios.js --bundle-output release_ios/main.jsbundle --assets-dest release_ios/ --dev fasle 总结之前也有零零散散的调研这门技术，但是经过系统的 15 个下午的坚持学习，深感跨平台技术的独到之处，特别是在与原生交互的编写上简直让人欲生欲死，还好在 Github 上已经有各路大神开源的各种方便开发的组件库可以供我们使用。 分享链接《React Native 开发常用命令行（持续更新）》(https://juejin.im/post/5abc54c86fb9a028da7c998c) 《ReactNative 开发常用的三方模块》(https://www.jianshu.com/p/53ff78168acc) 《使用VS Code调试React-Native程序》（https://jingyan.baidu.com/article/ad310e80fb13fc1849f49ed1.html） 参考资料 React Native中文网 贾鹏辉的技术博客 从一个实战项目来看一下React Native开发的几个关键技术点 Marno:给所有开发者的React Native详细入门指南 大漠:一个完整的Flexbox指南 阮一峰:Flex 布局教程：语法篇 八段代码彻底掌握 Promise 阮一峰：Promise对象 asce1885:React Native 高质量学习资料汇总 世锋日上:ReactNative 学习资源大汇集","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"https://reversescale.github.io/tags/ReactNative/"}]},{"title":"基于 Aspects 深入了解 AOP","slug":"Library Aspects","date":"2018-03-23T13:56:27.000Z","updated":"2018-11-16T13:22:46.436Z","comments":true,"path":"2018/03/23/Library Aspects/","link":"","permalink":"https://reversescale.github.io/2018/03/23/Library Aspects/","excerpt":"AOP(Aspect-Oriented-Programming)，翻译过来就是「面向切面编程」，使用场景很多，如统计埋点、方法替换等~","text":"AOP(Aspect-Oriented-Programming)，翻译过来就是「面向切面编程」，使用场景很多，如统计埋点、方法替换等~ 👨🏻‍💻 Github Demo 🎨 测试 UI 什么样子？ 1.展示页 2.展示页 3.展示页 展示列表 拦截系统事件 自定义拦截 🎯 安装方法安装在 iOS, 你需要在 Podfile 中添加.12345source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;9.0&apos;use_frameworks!pod &quot;Aspects&quot; 🛠 配置系统级拦截拦截系统级级事件，如 viewWillAppear 等 1234567891011121314#import &lt;Aspects.h&gt;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. [UIViewController aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, BOOL animated) &#123; NSLog(@&quot;View Controller %@ will appear animated: %tu&quot;, aspectInfo.instance, animated); &#125; error:NULL];&#125;- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; NSLog(@&quot;System View Controller will appear&quot;);&#125; 自定义拦截拦截自定义事件，如对类的操作 12345678910111213141516171819202122232425262728// Cat.h 类@interface Cat: NSObject+ (void)classFee;@end// Cat.m 类@implementation Cat+ (void)classFee &#123; NSLog(@&quot;Miao~&quot;);&#125;@end// 实现方法#import &quot;Cat.h&quot;#import &lt;Aspects.h&gt;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. Class catMetal = objc_getMetaClass(NSStringFromClass(Cat.class).UTF8String); [catMetal aspect_hookSelector:@selector(classFee) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123; NSLog(@&quot;Miao~,I am angry~&quot;); &#125; error:NULL]; [Cat classFee];&#125; 📝 深入学习索引： AOP 简介 Aspects 简介 Aspects 结构剖析 Aspects 核心代码剖析 优秀 AOP 库应该具备的特质 总结 AOP 简介在 Objective-C 的实现结构中 Runtime 的动态派发机制保证了这么语言的灵活性，而在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是AOP(面向切面编程)。 AOP 是一种编程范式或者编程思想，它解决了 OOP (Object-oriented programming) 的延伸问题 什么时候需要使用 AOP假设随着我们所在的公司逐步发展，之前第三方的用户页面统计已经不能满足需求了，公司要求实现一个我们自己的用户页面统计。 在传统的 OOP 思想下，可能会如下操作： 一个熟悉 OOP 思想的程序猿会理所应当的想到要把用户页面统计这一任务放到 ViewController 中； 考虑到一个个的手动添加统计代码要死人（而且还会漏，以后新增 ViewController 也要手动加），于是想到了 OOP 思想中的继承； 不巧由于项目久远，所有的 ViewController 都是直接继承自系统类 UIViewController（笑），此时选择抽一个项目 RootViewController，替换所有 ViewController 继承 RootViewController； 然后在 RootViewController 的 viewWillAppear: 和 viewWillDisappear: 方法加入时间统计代码，记录 ViewController 以及 Router 传参。 其实 OOP 也有其特殊的定位，也能够实现上述的需求。 而 AOP 则更适合在给多个 App 写通用组件并以通用的形式实现统计的情况下。 一个简单的思路：Hook 方法交换的方法，在原方法执行之后记录需要统计的信息并上报。 单通过 Method Swizzling 来 Hook 的方法在处理不当的情况下容易出现安全隐患 Aspects 简介 Aspects 是一个使用起来简单愉快的 AOP 库，使用 Objective-C 编写，适用于 iOS 与 Mac OS X。 Aspects 简单易用，作者通过在 NSObject (Aspects) 分类中暴露出的两个接口分别提供了对实例和 Class 的 Hook 实现： 12345678910@interface NSObject (Aspects)+ (id)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;- (id)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;@end Aspects 支持实例 Hook，相较其他 Objective-C AOP 库而言可操作粒度更小，适合的场景更加多样化。作为使用者无需进行更多的操作即可 Hook 指定实例或者 Class 的指定 SEL，AspectOptions 参数可以指定 Hook 的点，以及是否执行一次之后就撤销 Hook。 Aspects 结构剖析 尽管 Aspects 只有不到千行的源码，但是其内部实现考虑到了很多 Hook 相关的安全问题和其他细节，对比其他 Objective-C AOP 开源项目来说 Aspects 更为健全。 Aspects 内部结构Aspects 内部定义了两个协议： AspectToken - 用于注销 Hook AspectInfo - 嵌入 Hook 中的 Block 首位参数 此外 Aspects 内部还定义了 4 个类： AspectInfo - 切面信息，遵循 AspectInfo 协议 AspectIdentifier - 切面 ID，应该遵循 AspectToken 协议（作者漏掉了，已提 PR） AspectsContainer - 切面容器 AspectTracker - 切面跟踪器 以及一个结构体： AspectBlockRef - 即 _AspectBlock，充当内部 Block如果你扒一遍源码，还会发现两个内部静态全局变量： static NSMutableDictionary *swizzledClassesDict; static NSMutableSet *swizzledClasses; Aspects 协议AspectToken AspectToken 协议旨在让使用者可以灵活的注销之前添加过的 Hook，内部规定遵守此协议的对象须实现 remove 方法。 12345/// 不透明的 Aspect Token，用于注销 Hook@protocol AspectToken /// 注销一个 aspect./// 返回 YES 表示注销成功，否则返回 NO- (BOOL)remove;@end AspectInfo AspectInfo 协议旨在规范对一个切面，即 aspect 的 Hook 内部信息的纰漏，我们在 Hook 时添加切面的 Block 第一个参数就遵守此协议。 12345678/// AspectInfo 协议是我们块语法的第一个参数。@protocol AspectInfo /// 当前被 Hook 的实例- (id)instance;/// 被 Hook 方法的原始 invocation- (NSInvocation *)originalInvocation;/// 所有方法参数（装箱之后的）惰性执行- (NSArray *)arguments;@end 装箱是一个开销昂贵操作，所以用到再去执行 Aspects 内部类接着协议，我们下面详细介绍一下 Aspects 的内部类。 AspectInfo AspectInfo 在这里是一个 Class，其遵守上文中讲到的 AspectInfo 协议，不要混淆。 123456@interface AspectInfo : NSObject - (id)initWithInstance:(__unsafe_unretained id)instance invocation:(NSInvocation *)invocation;@property (nonatomic, unsafe_unretained, readonly) id instance;@property (nonatomic, strong, readonly) NSArray *arguments;@property (nonatomic, strong, readonly) NSInvocation *originalInvocation;@end AspectInfo 比较简单，参考 ReactiveCocoa 团队提供的 NSInvocation 参数通用方法可将参数装箱为 NSValue，简单来说 AspectInfo 扮演了一个提供 Hook 信息的角色。 AspectIdentifier AspectIdentifier 类定义： 123456789@interface AspectIdentifier : NSObject+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;- (BOOL)invokeWithInfo:(id)info;@property (nonatomic, assign) SEL selector;@property (nonatomic, strong) id block;@property (nonatomic, strong) NSMethodSignature *blockSignature;@property (nonatomic, weak) id object;@property (nonatomic, assign) AspectOptions options;@end AspectIdentifier 实际上是添加切面的 Block 的第一个参数，其应该遵循 AspectToken 协议，事实上也的确如此，其提供了 remove 方法的实现。 AspectIdentifier 内部需要注意的是由于使用 Block 来写 Hook 中我们加的料，这里生成了 blockSignature，在 AspectIdentifier 初始化的过程中会去判断 blockSignature 与入参 object 的 selector 得到的 methodSignature 的兼容性，兼容性判断成功才会顺利初始化。 AspectsContainer AspectsContainer 作为切面的容器类，关联指定对象的指定方法，内部有三个切面队列，分别容纳关联指定对象的指定方法中相对应 AspectOption 的 Hook： NSArray *beforeAspects; - AspectPositionBefore NSArray *insteadAspects; - AspectPositionInstead NSArray *afterAspects; - AspectPositionAfter AspectsContainer 在 NSObject 分类中通过 AssociatedObject 方法与当前要 Hook 的目标关联在一起的。 12345678@interface AspectsContainer : NSObject- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;- (BOOL)removeAspect:(id)aspect;- (BOOL)hasAspects;@property (atomic, copy) NSArray *beforeAspects;@property (atomic, copy) NSArray *insteadAspects;@property (atomic, copy) NSArray *afterAspects;@end 关联目标是 Hook 之后的 Selector，即 aliasSelector（原始 SEL 名称加 aspects_ 前缀对应的 SEL） AspectTracker AspectTracker 类定义： 123456@interface AspectTracker : NSObject- (id)initWithTrackedClass:(Class)trackedClass parent:(AspectTracker *)parent;@property (nonatomic, strong) Class trackedClass;@property (nonatomic, strong) NSMutableSet *selectorNames;@property (nonatomic, weak) AspectTracker *parentEntry;@end AspectTracker 作为切面追踪器，原理大致如下： 12345678910111213// Add the selector as being modified.currentClass = klass;AspectTracker *parentTracker = nil;do &#123; AspectTracker *tracker = swizzledClassesDict[currentClass]; if (!tracker) &#123; tracker = [[AspectTracker alloc] initWithTrackedClass:currentClass parent:parentTracker]; swizzledClassesDict[(id)currentClass] = tracker; &#125; [tracker.selectorNames addObject:selectorName]; // All superclasses get marked as having a subclass that is modified. parentTracker = tracker;&#125;while ((currentClass = class_getSuperclass(currentClass))); 全局变量 swizzledClassesDict 中的 value 对应着 AspectTracker 指针。 AspectTracker 是从下而上追踪，最底层的 parentEntry 为 nil，父类的 parentEntry 为子类的 tracker。 Aspects 静态全局变量 1）static NSMutableDictionary *swizzledClassesDict; static NSMutableDictionary *swizzledClassesDict; 在 Aspects 中扮演着已混写类字典的角色，Aspects 内部提供了专门访问这个全局字典的方法： 12345678static NSMutableDictionary *aspect_getSwizzledClassesDict() &#123; static NSMutableDictionary *swizzledClassesDict; static dispatch_once_t pred; dispatch_once(&amp;pred, ^&#123; swizzledClassesDict = [NSMutableDictionary new]; &#125;); return swizzledClassesDict;&#125; 这个全局变量可以简单理解为记录整个 Hook 影响的 Class 包含其 SuperClass 的追踪记录的全局字典。 2）static NSMutableSet *swizzledClasses; static NSMutableSet *swizzledClasses; 在 Aspects 中担当记录已混写类的角色，Aspects 内部提供一个用于修改这个全局变量内容的方法： 12345678910static void _aspect_modifySwizzledClasses(void (^block)(NSMutableSet *swizzledClasses)) &#123; static NSMutableSet *swizzledClasses; static dispatch_once_t pred; dispatch_once(&amp;pred, ^&#123; swizzledClasses = [NSMutableSet new]; &#125;); @synchronized(swizzledClasses) &#123; block(swizzledClasses); &#125;&#125; Aspects 核心代码剖析Hook Class &amp;&amp; Hook InstanceAspects 不光支持 Hook Class 还支持 Hook Instance，这提供了更小粒度的控制，配合 Hook 的撤销功能可以更加灵活精准的实现功能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static Class aspect_hookClass(NSObject *self, NSError **error) &#123; // 断言 self NSCParameterAssert(self); // classClass statedClass = self.class;// isaClass baseClass = object_getClass(self);NSString *className = NSStringFromClass(baseClass); // 已经子类化过了if ([className hasSuffix:AspectsSubclassSuffix]) &#123;return baseClass; // 我们混写了一个 class 对象，而非一个单独的 object&#125;else if (class_isMetaClass(baseClass)) &#123; // baseClass 是元类，则 self 是 Class 或 MetaClass，混写 self return aspect_swizzleClassInPlace((Class)self); // 可能是一个 KVO'ed class。混写就位。也要混写 meta classes。 &#125;else if (statedClass != baseClass) &#123; // 当 .class 和 isa 指向不同的情况，混写 baseClass return aspect_swizzleClassInPlace(baseClass); &#125; // 默认情况下，动态创建子类 // 拼接子类后缀 AspectsSubclassSuffixconst char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;// 尝试用拼接后缀的名称获取 isaClass subclass = objc_getClass(subclassName); // 找不到 isa，代表还没有动态创建过这个子类if (subclass == nil) &#123; // 创建一个 class pair，baseClass 作为新类的 superClass，类名为 subclassNamesubclass = objc_allocateClassPair(baseClass, subclassName, 0);if (subclass == nil) &#123; // 返回 nil，即创建失败 NSString *errrorDesc = [NSString stringWithFormat:@\"objc_allocateClassPair failed to allocate class %s.\", subclassName]; AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc); return nil; &#125; // 混写 forwardInvocation:aspect_swizzleForwardInvocation(subclass);// subClass.class = statedClassaspect_hookedGetClass(subclass, statedClass);// subClass.isa.class = statedClassaspect_hookedGetClass(object_getClass(subclass), statedClass);// 注册新类objc_registerClassPair(subclass);&#125; // 覆盖 isaobject_setClass(self, subclass);return subclass;&#125; 难点就在于对 .class 和 object_getClass 的区分。 .class 当 target 是 Instance 则返回 Class，当 target 是 Class 则返回自身 object_getClass 返回 isa 指针的指向 动态创建一个 Class 的完整步骤也是我们应该注意的。 objc_allocateClassPair class_addMethod class_addIvar objc_registerClassPair Hook 的实现在上面 aspect_hookClass 方法中，不仅仅是返回一个要 Hook 的 Class，期间还做了一些细节操作，不论是 Class 还是 Instance，都会调用 aspect_swizzleForwardInvocation 方法，这个方法没什么难点，简单贴一下代码让大家有个印象： 123456789101112static void aspect_swizzleForwardInvocation(Class klass) &#123; // 断言 klass NSCParameterAssert(klass); // 如果没有 method，replace 实际上会像是 class_addMethod 一样 IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, \"v@:@\"); // 拿到 originalImplementation 证明是 replace 而不是 add，情况少见 if (originalImplementation) &#123; // 添加 AspectsForwardInvocationSelectorName 的方法，IMP 为原生 forwardInvocation: class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, \"v@:@\"); &#125; AspectLog(@\"Aspects: %@ is now aspect aware.\", NSStringFromClass(klass));&#125; 上面的方法就是把要 Hook 的目标 Class 的 forwardInvocation: 混写了，混写之后 forwardInvocation: 的具体实现在 ASPECTS_ARE_BEING_CALLED 中，里面能看到 invoke 标识位的不同是如何实现的，还有一些其他的实现细节： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 宏定义，以便于我们有一个更明晰的 stack trace#define aspect_invoke(aspects, info) \\for (AspectIdentifier *aspect in aspects) &#123;\\ [aspect invokeWithInfo:info];\\ if (aspect.options &amp; AspectOptionAutomaticRemoval) &#123; \\ aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \\ &#125; \\&#125;static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) &#123; // __unsafe_unretained NSObject *self 不解释了 // 断言 self, invocation NSCParameterAssert(self); NSCParameterAssert(invocation); // 从 invocation 可以拿到很多东西，比如 originalSelector SEL originalSelector = invocation.selector; // originalSelector 加前缀得到 aliasSelectorSEL aliasSelector = aspect_aliasForSelector(invocation.selector);// 用 aliasSelector 替换 invocation.selector invocation.selector = aliasSelector; // Instance 的容器 AspectsContainer *objectContainer = objc_getAssociatedObject(self, aliasSelector); // Class 的容器 AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(self), aliasSelector); AspectInfo *info = [[AspectInfo alloc] initWithInstance:self invocation:invocation]; NSArray *aspectsToRemove = nil; // Before hooks. aspect_invoke(classContainer.beforeAspects, info); aspect_invoke(objectContainer.beforeAspects, info); // Instead hooks. BOOL respondsToAlias = YES; if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123; // 如果有任何 insteadAspects 就直接替换了 aspect_invoke(classContainer.insteadAspects, info); aspect_invoke(objectContainer.insteadAspects, info); &#125;else &#123; // 否则正常执行 // 遍历 invocation.target 及其 superClass 找到实例可以响应 aliasSelector 的点 invoke Class klass = object_getClass(invocation.target); do &#123; if ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) &#123; [invocation invoke]; break; &#125; &#125;while (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass))); &#125; // After hooks. aspect_invoke(classContainer.afterAspects, info); aspect_invoke(objectContainer.afterAspects, info); // 如果没有 hook，则执行原始实现（通常会抛出异常） if (!respondsToAlias) &#123; invocation.selector = originalSelector; SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName); // 如果可以响应 originalForwardInvocationSEL，表示之前是 replace method 而非 add method if ([self respondsToSelector:originalForwardInvocationSEL]) &#123; ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation); &#125;else &#123; [self doesNotRecognizeSelector:invocation.selector]; &#125; &#125; // 移除 aspectsToRemove 队列中的 AspectIdentifier，执行 remove [aspectsToRemove makeObjectsPerformSelector:@selector(remove)];&#125;#undef aspect_invoke aspect_invoke 宏定义的作用域 代码实现对应了 Hook 的 AspectOptions 参数的 Before，Instead 和 After。 aspect_invoke 中 aspectsToRemove 是一个 NSArray，里面容纳着需要被销户的 Hook，即 AspectIdentifier（之后会调用 remove 移除）。 遍历 invocation.target 及其 superClass 找到实例可以响应 aliasSelector 的点 invoke 实现代码。 Block Hook Aspects 让我们在指定 Class 或 Instance 的特定 Selector 执行时，根据 AspectOptions 插入我们自己的 Block 做 Hook，而这个 Block 内部有我们想要的有关于当前 Target 和 Selector 的信息，我们来看一下 Aspects 是怎么办到的： 1234567891011121314151617181920212223242526272829303132333435363738- (BOOL)invokeWithInfo:(id)info &#123; NSInvocation *blockInvocation = [NSInvocation invocationWithMethodSignature:self.blockSignature]; NSInvocation *originalInvocation = info.originalInvocation; NSUInteger numberOfArguments = self.blockSignature.numberOfArguments; // 偏执。我们已经在 hook 注册的时候检查过了，（不过这里我们还要检查）。 if (numberOfArguments &gt; originalInvocation.methodSignature.numberOfArguments) &#123; AspectLogError(@\"Block has too many arguments. Not calling %@\", info); return NO; &#125; // block 的 `self` 将会是 AspectInfo。可选的。 if (numberOfArguments &gt; 1) &#123; [blockInvocation setArgument:&amp;info atIndex:1]; &#125; // 简历参数分配内存 argBuf 然后从 originalInvocation 取 argument 赋值给 blockInvocationvoid *argBuf = NULL; for (NSUInteger idx = 2; idx &lt; numberOfArguments; idx++) &#123; const char *type = [originalInvocation.methodSignature getArgumentTypeAtIndex:idx];NSUInteger argSize;NSGetSizeAndAlignment(type, &amp;argSize, NULL); // reallocf 优点，如果创建内存失败会自动释放之前的内存，讲究if (!(argBuf = reallocf(argBuf, argSize))) &#123; AspectLogError(@\"Failed to allocate memory for block invocation.\");return NO;&#125; [originalInvocation getArgument:argBuf atIndex:idx];[blockInvocation setArgument:argBuf atIndex:idx]; &#125; // 执行 [blockInvocation invokeWithTarget:self.block]; // 释放 argBuf if (argBuf != NULL) &#123; free(argBuf); &#125; return YES;&#125; 考虑两个问题： [blockInvocation setArgument:&amp;info atIndex:1]; 为什么要在索引 1 处插入呢？ for (NSUInteger idx = 2; idx &lt; numberOfArguments; idx++) 为什么要从索引 2 开始遍历参数呢？ 优秀 AOP 库应该具备的特质 良好的使用体验 可控粒度小 使用 Block 做 Hook 支持撤销 Hook 安全性 良好的使用体验Aspects 使用 NSObject + Categroy 的方式提供接口，非常巧妙的涵盖了 Instance 和 Class。 Aspects 提供的接口保持高度一致（本着易用，简单，方便的原则设计接口和整个框架的实现会让你的开源项目更容易被人们接纳和使用）： 12345678+ (id)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;- (id)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error; 可控粒度小Aspects 不仅支持大部分 AOP 框架应该做到的对于 Class 的 Hook，还支持粒度更小的 Instance Hook，而其在内部实现中为了支持 Instance Hook 所做的代码也非常值得我们参考和学习（已在上文 Aspects 核心代码剖析处单独分析）。 为使用者提供更为自由的 Hook 方式以达到更加精准的控制是每个使用者乐于见到的事。 使用 Block 做 HookAspects 使用 Block 来做 Hook 应该考虑到了很多东西，支持使用者通过在 Block 中获取到相关的信息，书写自己额外的操作就可以实现 Hook 需求。 支持撤销 HookAspects 还支持撤销之前做的 Hook 以及已混写的 Method，为了实现这个功能 Aspects 设计了全局容器，把 Hook 和混写用全局容器做记录，让一切都可以复原，这不正是我们想要的吗？ 安全性在学习 Runtime 的时候，就应该看到过不少文章讲解 Method Swizzling 要注意的安全性问题，由于用到了大量 Runtime 方法，加上 AOP 是面向整个切面的，所以一单发现问题就会比较严重，设计的面会比较广，而且难以调试。 不能因为容易造成问题就可以回避 Method Swizzling，就好比大学老师讲到递归时强调容易引起循环调用，很多人就在内心回避使用递归，甚至于非常适合使用递归来写的算法题（这里指递归来写会易读写、易维护）只会用复杂的方式来思考。 总结 文章简单介绍了 AOP 的概念，希望能给各位读者对 AOP 思想的理解提供微薄的帮助。 文章系统的剖析了 Aspects 开源库的内部结构，希望能让大家在浏览 Aspects 源码时快速定位代码位置，找到核心内容。 文章重点分析了 Aspects 的核心代码，提炼了一些笔者认为值得注意的点，但愿可以在大家扒源码时提供一些指引。 文章结尾总结了 Aspects 作为一个比较优秀的 AOP 开源库所具有的特质，不过毕竟是很久之前的代码了，如果有哪位想要造一个关于 AOP 的轮子，希望这篇文章能够产生些许帮助。 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"Swift 4.0 中对 Dictionary 的改进","slug":"Swift 4 Dictionary","date":"2018-03-13T13:56:27.000Z","updated":"2018-11-16T12:47:15.150Z","comments":true,"path":"2018/03/13/Swift 4 Dictionary/","link":"","permalink":"https://reversescale.github.io/2018/03/13/Swift 4 Dictionary/","excerpt":"Swift 4 发布已经有一段时间了，不知道大家有没有切换到 4.0 版本。 这次 4.0 更新给我最大的感受就是没有了前几次升级的跳跃式变化。 不用为了更新语言版本，完全推翻已有的项目，这也是 Swift 慢慢趋向于稳定的标志~","text":"Swift 4 发布已经有一段时间了，不知道大家有没有切换到 4.0 版本。 这次 4.0 更新给我最大的感受就是没有了前几次升级的跳跃式变化。 不用为了更新语言版本，完全推翻已有的项目，这也是 Swift 慢慢趋向于稳定的标志~ 咱们这次说说 Swift 4.0 对 Dictionary 这个经常会用到的类的改进。 自动根据 key 分组Dictionary 新增了一个构造方法，可以将给定的一个数组，根据指定的条件进行分组。 来看一个例子: 123456789struct Person &#123; var name: String var gender: Gender var age: Int enum Gender &#123; case male case female &#125;&#125; 这里有一个 Person 结构, 然后我们初始化一个数组： 12345let p1 = Person(name: \"aa\", gender: .female, age: 22)let p2 = Person(name: \"bb\", gender: .male, age: 24)let p3 = Person(name: \"cc\", gender: .male, age: 21)let persons = [p1, p2, p3] 现在用新的 Dictionary 构造方法，可以立即将这组 Person 实例根据他们的 gender 属性进行分组： 123let groupedDict = Dictionary(grouping: persons) &#123; p in return p.gender&#125; 这个构造方法，第一个参数 grouping 接收的是 persons 数组， 第二个参数是一个闭包，用于返回根据进行分组的依据，我们这里返回的是 p.gender。结果一目了然： 123456789[ .male: [ Person(name: \"bb\", gender: .male, age: 24), Person(name: \"cc\", gender: .male, age: 21) ], .female: [ Person(name: \"aa\", gender: .female, age: 22) ]] 以往要实现这样的功能，就需要手动遍历整个数组，取出 key， 然后生成字典， 现在方便很多。 value 无缝转换另外一个比较有用的特性是，Dictionary 提供的 mapValues 方法。 还以我们刚才生成的 groupedDict 为例，可以进行这样的操作： 123let count = groupedDict.mapValues &#123; persons in persons.count&#125; 先看一下输出，大家可能就猜到这个方法的用途是什么了： 1234[ .male: 2, .female: 1] 上面的输出可以看到， mapValues 会遍历每一个 key 对应的 values， 然后传递给闭包进行自定义转换。 我们例子中的闭包返回的就是每个 key 对应的 Person 集合的数量，最生成了一个新的 Dictionary，里面的 key 和之前一样，只是对应的值变成了我们闭包中自定义的了。 mapValues 方法同样是一个帮助我们解决繁杂操作的工具方法。 从键值对元组中直接构建假如我们有这样一个数组: 1let personsTuples = [(\"group 1\", [p1, p2]), (\"group 2\", [p3])] 然后可以调用 uniqueKeysWithValues 构造方法直接初始化字典： 1let dict = Dictionary(uniqueKeysWithValues: personsTuples) personsTuples 数组中，每一个元素都是一个元组(Tuple)， 这个构造方法把元组中的第一项当做 key， 第二项当做 value， 生成一个新的 Dictionary，如下所示： 123456789[ \"group 1\": [ Person(name: \"aa\", gender: .female, age: 22), Person(name: \"bb\", gender: .male, age: 24) ], \"group 2\": [ Person(name: \"cc\", gender: .male, age: 21) ]] 使用 uniqueKeysWithValues 构造方法时候需要注意，就是传入的数组中，不能有重复的 key， 否则会报运行时错误，比如这个数组就会报错： 1let personsTuples = [(\"group 1\", [p1, p2]), (\"group 2\", [p3]), (\"group 2\", [p4])] 上面数组中 group 2 出现了两次。 如果用它来初始化的话，就会出错。 所以 Swift 4.0 还提供了另外一个初始化方法， 对于上面这个数组，可以调用： 123let dict = Dictionary(personsTuples) &#123; old, new in return new&#125; 第二个闭包参数，会在遇到重复的 key 时候调用。 它提供两个参数，一个是同样这个 key 的上一个值 old， 还有当前的值 new。 我们这里直接返回 new，意思就是 每次遇到重复的 key， 就用新的值代替老的值。 这样初始化后，生成的 Dictionary 结构如下： 123456789[ \"group 1\": [ p1, p2 ], \"group 2\": [ p4 ]] group 2 中的值， 是第二次 key 所对应的 p4。 提供默认值如果我们访问了一个字典中不存在的 key， 会返回 nil： 1dict[\"group 3\"] 因为上面字典中，不存在 group 3 这个 key， 所以它返回了 nil。 Swift 4 中新增了指定默认值的能力： 1dict[\"group 3\", default: []] 这样调用，如果 group 3 这个 key 不存在的话， 就会返回我们指定的默认值空数组， 而不是 nil 了。 这个特性在我们处理 JSON 数据解析这类的问题上很实用。 过滤器过滤器对于集合类来说是比较常用的功能。 Swift 4 中对 Dictionary 类型也提供了过滤器的支持： 123let filteredDict = dict.filter &#123; key, val in return val.count &gt;= 2&#125; filter 方法接收一个闭包，它会遍历 Dictionary 中所有的元素，并且作为闭包的参数传入。 我们需要通过闭包的返回值确定这个元素是否被保留。 上面的例子中，比如我们 dict 中的元素是 ： 123456789[ \"group 1\": [ p1, p2 ], \"group 2\": [ p4 ]] 调用 filter 后，我们只保留数量大于 2 的集合： 123456[ \"group 1\": [ p1, p2 ]] 总结以上就是 Swift 4.0 对于 Dictionary 的主要改进。 这些新增的工具方法对于提高我们开发效率和代码质量都有帮助，希望这里的介绍对你有帮助。 关于 Dictionary 更完整的信息，大家还可以参考苹果官方的文档，还有 Swift Blog 中的介绍。 参考文献Dictionary 官方文档：https://developer.apple.com/documentation/swift/dictionarySwift Blog: https://swift.org/blog/dictionary-and-set-improvements/","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://reversescale.github.io/tags/Swift/"}]},{"title":"Swift 4.0 新特征汇总及演示","slug":"Swift 4 New feature","date":"2018-03-09T13:16:27.000Z","updated":"2018-11-16T12:16:08.813Z","comments":true,"path":"2018/03/09/Swift 4 New feature/","link":"","permalink":"https://reversescale.github.io/2018/03/09/Swift 4 New feature/","excerpt":"Swift 在不断的版本迭代中，由于其 ABI 尚不稳定，所以给开发者带来许多的挑战，但也正因为如此，这门语言才有无限可能~","text":"Swift 在不断的版本迭代中，由于其 ABI 尚不稳定，所以给开发者带来许多的挑战，但也正因为如此，这门语言才有无限可能~ 👨🏻‍💻 Github Demo Key Paths 新语法key-path 通常是用在键值编码（KVC）与键值观察（KVO）上的，KVC、KVO 相关内容可以参考我之前写的这篇文章：Swift - 反射（Reflection）的介绍与使用样例（附KVC介绍） 1.Swift 3 之前使用的是 String 类型的 key-Path1234567891011121314151617//用户类class User: NSObject&#123; @objc var name:String = &quot;&quot; //姓名 @objc var age:Int = 0 //年龄&#125; //创建一个User实例对象let user1 = User()user1.name = &quot;hangge&quot;user1.age = 100 //使用KVC取值let name = user1.value(forKey: &quot;name&quot;)print(name) //使用KVC赋值user1.setValue(&quot;hangge.com&quot;, forKey: &quot;name&quot;) 具体显示如下： 2.到了 Swift 3 新增了 #keyPath() 写法使用 #keyPath() 写法，可以避免我们因为拼写错误而引发问题。1234567891011121314151617//用户类class User: NSObject&#123; @objc var name:String = &quot;&quot; //姓名 @objc var age:Int = 0 //年龄&#125; //创建一个User实例对象let user1 = User()user1.name = &quot;hangge&quot;user1.age = 100 //使用KVC取值let name = user1.value(forKeyPath: #keyPath(User.name))print(name) //使用KVC赋值user1.setValue(&quot;hangge.com&quot;, forKeyPath: #keyPath(User.name)) 3.Swift 4 中直接用 \\ 作为开头创建 KeyPath新的方式不仅使用更加简单，而且有如下优点： 类型可以定义为 class、struct 定义类型时无需加上 @objc 等关键字 性能更好 类型安全和类型推断，例如：user1.value(forKeyPath: #keyPath(User.name)) 返回的类型是 Any，user1[keyPath: \\User.name] 直接返回 String 类型 可以在所有值类型上使用（1）比如上面的样例在 Swift4 中可以这么写：1234567891011121314151617//用户类class User: NSObject&#123; var name:String = &quot;&quot; //姓名 var age:Int = 0 //年龄&#125; //创建一个User实例对象let user1 = User()user1.name = &quot;hangge&quot;user1.age = 100 //使用KVC取值let name = user1[keyPath: \\User.name]print(name) //使用KVC赋值user1[keyPath: \\User.name] = &quot;hangge.com&quot; （2）keyPath 定义在外面也是可以的：123456let keyPath = \\User.name let name = user1[keyPath: keyPath]print(name) user1[keyPath: keyPath] = &quot;hangge.com&quot; （3）可以使用 appending 方法向已定义的 Key Path 基础上填加新的 Key Path。12let keyPath1 = \\User.phonelet keyPath2 = keyPath1.appending(path: \\.number) 类与协议的组合类型在 Swift 4 中，可以把类（Class）和协议（Protocol）用 &amp; 组合在一起作为一个类型使用。 使用样例1：12345678910111213protocol MyProtocol &#123; &#125; class View &#123; &#125; class ViewSubclass: View, MyProtocol &#123; &#125; class MyClass &#123; var delegate: (View &amp; MyProtocol)?&#125; let myClass = MyClass()myClass.delegate = ViewSubclass() //这个编译正常myClass.delegate = View() //这个编译报错: 具体错误信息如下： 使用样例2：123456789101112131415161718192021protocol Shakeable &#123; func shake()&#125; extension UIButton: Shakeable &#123; func shake() &#123; /* ... */ &#125;&#125; extension UISlider: Shakeable &#123; func shake() &#123; /* ... */ &#125;&#125; func shakeEm(controls: [UIControl &amp; Shakeable]) &#123; for control in controls where control.isEnabled &#123; control.shake() &#125;&#125; 下标支持泛型1.下标的返回类型支持泛型有时候我们会写一些数据容器，Swift 支持通过下标来读写容器中的数据。但是如果容器类中的数据类型定义为泛型，过去下标语法就只能返回 Any，在取出值后需要用 as? 来转换类型。现在 Swift 4 定义下标也可以使用泛型了。12345678910111213141516171819202122struct GenericDictionary&lt;Key: Hashable, Value&gt; &#123; private var data: [Key: Value] init(data: [Key: Value]) &#123; self.data = data &#125; subscript&lt;T&gt;(key: Key) -&gt; T? &#123; return data[key] as? T &#125;&#125; //字典类型: [String: Any]let earthData = GenericDictionary(data: [&quot;name&quot;: &quot;Earth&quot;, &quot;population&quot;: 7500000000, &quot;moons&quot;: 1]) //自动转换类型，不需要在写 &quot;as? String&quot;let name: String? = earthData[&quot;name&quot;]print(name) //自动转换类型，不需要在写 &quot;as? Int&quot;let population: Int? = earthData[&quot;population&quot;]print(population) 2.下标类型同样支持泛型12345678910111213141516extension GenericDictionary &#123; subscript&lt;Keys: Sequence&gt;(keys: Keys) -&gt; [Value] where Keys.Iterator.Element == Key &#123; var values: [Value] = [] for key in keys &#123; if let value = data[key] &#123; values.append(value) &#125; &#125; return values &#125;&#125; // Array下标let nameAndMoons = earthData[[&quot;moons&quot;, &quot;name&quot;]] // [1, &quot;Earth&quot;]// Set下标let nameAndMoons2 = earthData[Set([&quot;moons&quot;, &quot;name&quot;])] // [1, &quot;Earth&quot;] Codable 序列化如果要将一个对象持久化，需要把这个对象序列化。过去的做法是实现 NSCoding 协议，但实现 NSCoding 协议的代码写起来很繁琐，尤其是当属性非常多的时候。Swift 4 中引入了 Codable 协议，可以大大减轻了我们的工作量。我们只需要让需要序列化的对象符合 Codable 协议即可，不用再写任何其他的代码。1234struct Language: Codable &#123; var name: String var version: Int&#125; 1.Encode 操作我们可以直接把符合了 Codable 协议的对象 encode 成 JSON 或者 PropertyList。12345678let swift = Language(name: &quot;Swift&quot;, version: 4) //encoded对象let encodedData = try JSONEncoder().encode(swift) //从encoded对象获取Stringlet jsonString = String(data: encodedData, encoding: .utf8)print(jsonString) 2.Decode 操作12let decodedData = try JSONDecoder().decode(Language.self, from: encodedData)print(decodedData.name, decodedData.version) SubtringSwift 4 中有一个很大的变化就是 String 可以当做 Collection 来用，并不是因为 String 实现了 Collection 协议，而是 String 本身增加了很多 Collection 协议中的方法，使得 String 在使用时看上去就是个 Collection。1234567let str = &quot;hangge.com&quot; print(str.prefix(5)) // &quot;hangg&quot;print(str.suffix(5)) // &quot;e.com&quot; print(str.dropFirst()) // &quot;angge.com&quot;print(str.dropLast()) // &quot;hangge.co&quot; 比如上面的样例，我们使用一些 Collection 协议的方法对字符串进行截取，只不过它们的返回结果不是 String 类型，而是 Swift 4 新增的 Substring 类型。 1.为何要引入 Substring？既然我们想要的到的就是字符串，那么直接返回 String 就好了，为什么还要多此一举返回 Substring。原因只有一个：性能。具体可以参考下图：当我们用一些 Collection 的方式得到 String 里的一部分时，创建的都是 Substring。Substring 与原 String 是共享一个 Storage。这意味我们在操作这个部分的时候，是不需要频繁的去创建内存，从而使得 Swift 4 的 String 相关操作可以获取比较高的性能。而当我们显式地将 Substring 转成 String 的时候，才会 Copy 一份 String 到新的内存空间来，这时新的 String 和之前的 String 就没有关系了。 2.使用 Substring 的注意事项由于 Substring 与原 String 是共享存储空间的，只要我们使用了 Substring，原 String 就会存在内存空间中。只有 Substring 被释放以后，整个 String 才会被释放。而且 Substring 类型无法直接赋值给需要 String 类型的地方，我们必须用 String() 包一层。当然这时系统就会通过复制创建出一个新的字符串对象，之后原字符串就会被释放。 3.使用样例这里对 String 进行扩展，新增一个 subString 方法。直接可以根据起始位置（Int 类型）和需要的长度（Int 类型），来截取出子字符串。123456789101112extension String &#123; //根据开始位置和长度截取字符串 func subString(start:Int, length:Int = -1) -&gt; String &#123; var len = length if len == -1 &#123; len = self.count - start &#125; let st = self.index(startIndex, offsetBy:start) let en = self.index(st, offsetBy:len) return String(self[st ..&lt; en]) &#125;&#125; 使用样例：1234let str1 = &quot;欢迎访问hangge.com&quot;let str2 = str1.subString(start: 4, length: 6)print(&quot;原字符串：\\(str1)&quot;)print(&quot;截取出的字符串：\\(str2)&quot;) 运行结果如下： 注意：这个方法最后我们会将 Substring 显式地转成 String 再返回。 废除 swap 方法（1）过去我们会使用 swap(_:_:) 来将两个变量的值进行交换：1234var a = 1var b = 2swap(&amp;a, &amp;b)print(a, b) （2）后面 swap() 方法将会被废弃，建议使用 tuple（元组）特性来实现值交换，也只需要一句话就能实现：1234var a = 1var b = 2(b, a) = (a, b)print(a, b) 使用 tuple 方式的好处是，多个变量值也可以一起进行交换：12345var a = 1var b = 2var c = 3(a, b, c) = (b, c, a)print(a, b, c) （3）补充一下：现在数组增加了个 swapAt 方法可以实现两个元素的位置交换。1234var fruits = [&quot;apple&quot;, &quot;pear&quot;, &quot;grape&quot;, &quot;banana&quot;]//交换元素位置（第2个和第3个元素位置进行交换）fruits.swapAt(1, 2)print(fruits) 减少隐式 @objc 自动推断1.过去的情况（Swift 3）（1）在项目中如果想把 Swift 写的 API 暴露给 Objective-C 调用，需要增加 @objc。在 Swift 3 中，编译器会在很多地方为我们隐式的加上 @objc。（2）比如当一个类继承于 NSObject，那么这个类的所有方法都会被隐式的加上 @objc。1234class MyClass: NSObject &#123; func print() &#123; &#125; // 包含隐式的 @objc func show() &#123; &#125; // 包含隐式的 @objc&#125; （3）但这样做很多并不需要暴露给 Objective-C 也被加上了 @objc。而大量 @objc 会导致二进制文件大小的增加。 2.现在的情况（Swift 4）（1）在 Swift 4 中隐式 @objc 自动推断只会发生在下面这种必须要使用 @objc 的情况： 覆盖父类的 Objective-C 方法 符合一个 Objective-C 的协议 （2）大多数地方必须手工显示地加上 @objc。1234class MyClass: NSObject &#123; @objc func print() &#123; &#125; //显示的加上 @objc @objc func show() &#123; &#125; //显示的加上 @objc&#125; （3）如果在类前加上 @objcMembers，那么它、它的子类、扩展里的方法都会隐式的加上 @objc。123456789@objcMembersclass MyClass: NSObject &#123; func print() &#123; &#125; //包含隐式的 @objc func show() &#123; &#125; //包含隐式的 @objc&#125; extension MyClass &#123; func baz() &#123; &#125; //包含隐式的 @objc&#125; （4）如果在扩展（extension）前加上 @objc，那么该扩展里的方法都会隐式的加上 @objc。123456class SwiftClass &#123; &#125; @objc extension SwiftClass &#123; func foo() &#123; &#125; //包含隐式的 @objc func bar() &#123; &#125; //包含隐式的 @objc&#125; （5）如果在扩展（extension）前加上 @nonobjc，那么该扩展里的方法都不会隐式的加上 @objc。12345678@objcMembersclass MyClass : NSObject &#123; func wibble() &#123; &#125; //包含隐式的 @objc&#125; @nonobjc extension MyClass &#123; func wobble() &#123; &#125; //不会包含隐式的 @objc&#125;","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://reversescale.github.io/tags/Swift/"}]},{"title":"移动端 iOS 年终工作总结 - 纯干货请自备酒水","slug":"iOS 2017","date":"2018-02-26T15:56:27.000Z","updated":"2018-11-16T12:08:25.843Z","comments":true,"path":"2018/02/26/iOS 2017/","link":"","permalink":"https://reversescale.github.io/2018/02/26/iOS 2017/","excerpt":"时间匆匆，一转眼 2017 年已经过去了，这一年依旧在不断学习，厚积而薄发~","text":"时间匆匆，一转眼 2017 年已经过去了，这一年依旧在不断学习，厚积而薄发~ 主题：发展 内容大纲观点： Swift 发展观 ReactNative 发展观 进阶： 模块化 Pods 依赖库及组件化 环境自动切换 + 自动化打包测试 + 线上质量监控 管理： 团队核心组成架构 硬件设备投入 例会和文档化 组织 CodeReview 工具： Gitlab 及 Git 相关规范 Sketch 设计工具 + Zeplin 标注工具 成果： Github 原创开源项目 90+，共计 400+ 贡献力 参与维护开源项目 fastlane 20.5k（至2018.02.08） 完成 Swifter 功能展示应用研发 观点Swift 发展观Apple 在 WWDC 2017 大会上发布 Swift 4，Swift 4 带来了更快、更容易使用的 String 实现，可以保持 Unicode 的正确性，并增加对创建、使用广告管理子串的支持，它提高了开发者创建、使用和管理集合类型的能力，它支持结构化枚举类型的归档并允许对外部格式进行类型安全的序列化，包括 JSON 和 plist。 既然提到了 WWDC（https://developer.apple.com/wwdc/），相信 Swift 的发展观就没有太多争议了，近几年所有的官方演示视频都是基于 Swift 来演示的，作为 iOS 的开发人员可能会继续使用 Objective-C，但是如果对 Swift 是持抗拒心理的，那无疑对自身发展是不负责任的。 Apple 于 2017 年宣布 Swift 5 后会锁定 ABI，也就标志着这门语言会正式作为 iOS、macOS 的主流语言。同年 12 月，Apple 宣布会着手计划 iOS 和 macOS 的应用层面合并。配合 Apple 一直以来的对 Swift 幼儿教育以及在 AI、AR 等领域的推进，不难看出这门语言未来的发展潜力。 ReactNative 发展观提到 ReactNative 就不得不说 FaceBook，其实现在主流的移动端开发规范就是这家公司设计的。当然除了 React 社区生态圈的加持和 Facebook 的大力推广以外，另外一个最主要的原因就是其在开发效率和应用性能方面取得了一个比较好的平衡： 开发效率通过 JS 工程实践，逻辑跨平台复用得到极大提升 性能则通过全 Native 的 UI 层得到满足 跨平台这一特性对于小公司的吸引力则更体现在节约用人成本上，对简单的需求能做到一端多用，随时变更线上内容。 对于已经正在运营的项目，完全切 ReactNative 总是不太现实，其实大多数厂商的方法是对运营引流有影响的关键性页面（如：首页）进行 ReactNative 改版，这里可能就会引入一个 模块化 的概念，后面会有讲到。 对于想要入门的朋友，慕课网上一个入门级 ReactNative 教学还不错。 教学视频：http://coding.imooc.com/class/89.html 源码：https://github.com/crazycodeboy/GitHubPopular/ 进阶模块化模块化、组件化我后半年一直在调研的课题，对这些的研究也给我带来了从量变到质变的提升。 什么是模块化？ 那么什么是模块化呢？《 Java 应用架构设计：模块化模式与 OSGi 》一书中对它的定义是：模块化是一种处理复杂系统分解为更好的可管理模块的方式。 我们可以把软件看做是一辆汽车，开发一款软件的过程就是生产一辆汽车的过程。一辆汽车由车架、发动机、变数箱、车轮等一系列模块组成；同样，一款大型商业软件也是由各个不同的模块组成的。 汽车的这些模块是由不同的工厂生产的，一辆 BMW 的发动机可能是由位于德国的工厂生产的，它的自动变数箱可能是 Jatco（世界三大变速箱厂商之一）位于日本的工厂生产的，车轮可能是中国的工厂生产的，最后交给华晨宝马的工厂统一组装成一辆完整的汽车。这就类似于我们在软件工程领域里说的多团队并行开发，最后将各个团队开发的模块统一打包成我们可使用的 App 。 一款发动机、一款变数箱都不可能只应用于一个车型，比如同一款 Jatco 的 6AT 自动变速箱既可能被安装在 BMW 的车型上，也可能被安装在 Mazda 的车型上。这就如同软件开发领域里的模块重用。 到了冬天，特别是在北方我们可能需要开着车走雪路，为了安全起见往往我们会将汽车的公路胎升级为雪地胎；轮胎可以很轻易的更换，这就是我们在软件开发领域谈到的低耦合。一个模块的升级替换不会影响到其它模块，也不会受其它模块的限制；同时这也类似于我们在软件开发领域提到的可插拔。 20180906 更新 再谈模块化、组件化、插件化定义 模块化：一个可实现的单元，核心是内聚和分离，如登录模块的抽离 组件化：也称构件，最理想情况下是与业务无关，强调复用，如可复用 Library 插件化：与组件化不同，组件化在编译时合并模块，插件化在运行时合并模块，如可实现远程替换功能 模块化分层设计 上面的类比很清晰的说明的模块化带来的好处： 多团队并行开发测试； 模块间解耦、重用； 可单独编译打包某一模块，提升开发效率。 在《安居客 Android 项目架构演进》这篇文章中，作者介绍了安居客 Android 端的模块化设计方案，这里作者还是拿它来举例。但首先要对本文中的组件和模块做个区别定义： 组件：指的是单一的功能组件，如地图组件（MapSDK）、支付组件（AnjukePay）、路由组件（Router）等等； 模块：指的是独立的业务模块，如新房模块（NewHouseModule）、二手房模块（SecondHouseModule）、即时通讯模块（InstantMessagingModule）等等；模块相对于组件来说粒度更大。 针对模块化作者的团队也定义了一些自己的游戏规则: 对于 Business Module Layer，各业务模块之间不允许存在相互依赖关系，它们之间的跳转通讯采用路由框架 Router 来实现（后面会介绍 Router 框架的实现）; 对于 Business Component Layer，单一业务组件只能对应某一项具体的业务，个性化需求对外部提供接口让调用方定制; 合理控制各组件和各业务模块的拆分粒度，太小的公有模块不足以构成单独组件或者模块的，作者先放到类似于 CommonBusiness 的组件中，在后期不断的重构迭代中视情况进行进一步的拆分; 上层的公有业务或者功能模块可以逐步下放到下层，合理把握好度就好； 各 Layer 间严禁反向依赖，横向依赖关系由各业务 Leader 和技术小组商讨决定。 自从 Oasis Feng 在去年的 MDCC2016 上分享了模块化的经验后，模块化在 Android 社区越来越多的被提起。作者自然也不落俗的去做了一些研究和探索。安居客现在面临很多问题：例如全量编译时间太长（我这台13款的 MacBook Pro 上打一次包得花十多分钟）；例如新房、二手房、租房等等模块间耦合严重，不利于多团队并行开发测试；另外在17年初安居客重新将租房 App 捡起推广，单独让人来开发维护一个三年前的项目并不划算，所以作者希望能直接从现在的安居客用户端中拆分出租房模块作为一个单独的 App 发布上线。这样看来模块化似乎是一个不错的选择。 所以作者做模块化的目的大致是这样的： 业务模块间解耦 单个业务模块单独编译打包，加快编译速度 多团队间并行开发、测试 解决好租App需要单独维护的问题，降低研发成本 关于模块化组件化的生动解读来自安居客 Android 组组长张磊的博客 http://baronzhang.com Pods 依赖库及组件化组件化与模块化安居客的 Android 团队内部成立了技术小组，基础组件的开发是技术小组很重要的一部分工作；模块化更多的是现有的方案受到来自业务上的挑战以及受到了 Oasis Feng 在 MDCC 上的分享和整个大环境的启发，现在正处于设计规划和 Demo 开发的阶段。 组件化组件化不是个新概念，通俗的讲组件化就是基于可重用的目的，将一个大的软件系统拆分成一个个独立组件。 组件化的带来的好处不言而喻： 避免重复造轮子，节省开发维护成本； 降低项目复杂性，提升开发效率； 多个团队公用同一个组件，在一定层度上确保了技术方案的统一性。 现在的安居客有是三个业务团队：安居客用户 App、经纪人 App、集客家 App。为了避免各个业务团队重复造轮子，团队中也需要有一定的技术沉淀，因此组件化是必须的。现在我们需要提供更多的、职能单一、性能更优的组件供业务团队使用。根据业务相关性，我们将这些组件分为：基础组件和业务组件。 阿里架构组同样是组件化的先驱者，以下是阿里架构组 Evans 对组件化的观点： 首先，我的理解分块化应该是有四种，组件化+模块化+插件化+解耦 第一，组件和组件其实是没有什么鬼明确的约束 ，因为组件一般都是单独开发、单独测试，不能直接放到主项目中开发，测试也是单独针对性的测试 （里面涉及到短链+组件的生命周期+….） 第二，模块化我的理解是，怎么做好project的模块化的拆分，我们内部一直在说越底层的模块，应该越稳定，越抽象，越具有高复用度，但是其实有一个壁垒就是怎么去提升模块的复用度，怎么去快速具备复用性高于代码复用性，这我们就要做好每个模块只做好一件事情，模块化结构要更加清晰，每个模块都只做一件事情，具有良好的延展性和拓展性，但愿不要出现下层模块依赖上层模块的现象，业务模块之间也尽量不要耦合。好处是同样的功能模块，可以在多个app中复用，业务隔离了跨团队开发代码控制和版本风险都变小了。 第三，解耦其实理解很简单就是在基于模块设计原则上, 让模块之间没有循环依赖, 让业务模块之间解除依赖，不相互调用。 概况的理解就是 组件化：单独开发、测试、维护的开发模式 模块化：对 Project 进行拆分，根据业务、功能进行分类 解耦：模块设计原则上, 让模块之间没有非必要依赖 而组件化现在主流的做法是通过 CocoaPods 对要包装的内容进行打包，提交到公司的私有库（开源项目是公有库），进行日常维护及开发。 环境自动切换 + 自动化打包测试 + 线上质量监控环境自动切换 Debug 和 Release 仅仅是编译选项的不同，那么为什么要区分 Debug 和 Release 版本呢？ Debug 和 Release，主要是针对其面向的目标不同的而进行区分的。 Debug 通常称为调试版本，通过一系列编译选项的配合，编译的结果通常包含调试信息，而且不做任何优化，为开发人员提供强大的应用程序调试能力。 而 Release 通常称为发布版本，是为用户使用的，一般客户不允许在发布版本上进行调试。所以不保存调试信息，同时，它往往进行了各种优化，以期达到代码最小和速度最优。为用户的使用提供便利。 对于一些企业版应用或者有内部测试的需求其实还可以新增 Beta 版，收集核心用户的建议或者测试新开发的功能模块，对反馈做出迅速反应，灵活控制。 由于之前引入了组件化开发模式，所有我又加入了 UnitTest（单元测试）模式，只要用于对组件的分离化测试，快速定位问题。 切换环境的同时会对应切换应用的图标，能有效避免测试环节中的环境混淆和降低辨别成本。 自动化打包测试 关于自动化打包就不得不说在创业公司的经历，那时开发任务重，提测前常常加班到晚上 12 点，就算 bug 修完，也要等半个小时看着 Xcode 不慌不忙的打包完成上传测试平台发邮件才能安心回家。 鉴于这种惨痛经历，利用闲暇时间就搞了个自动打包脚本，后期又整理一遍并适配 Xcode 8.2 之后的版本。 做的了三步配置，杜绝污染，一行命令自动上传。 也是鉴于 Xcode 版本升级后的苦逼适配经历，最终选择了开源的 fastlane 包，从此搭上了组织的小火车，配合 Testflight 终于可以放心的玩耍了… FastLane 是一种配置 iOS 和 Android 自动化 Beta 部署和发布的最简单的方法之一。它可以简化一些乏味、单调、重复的工作，像截图、代码签名以及发布 App。也能无缝衔接蒲公英、Fir等测试平台，这酸爽… 省时：每次将新版本推送到商店或Beta测试服务时，都可节省时间。 集成：集成当前开发环境中所有存在的工具和服务。 开源：100%基于MIT许可开源。 简单：简单的设置助手，几分钟配置即可使用。 运行：基于你的app和数据，运行在本地机器上。 CI：集成几乎所有CI系统。 支持：支持iOS、Mac以及Android 应用。 自定义：根据自身需要扩展和定制fastlane，不依赖任何人。 命令行：不需要记住除fastlane以外的任何命令。 配置：可以在任何电脑上配置，包括CI服务器。 对于 Testflight，就像没故事的卓同学所说的。 Testflight 有个较大的使用门槛，需要收集用户的邮箱，之后在 Testflight 里输入苹果发出的邀请码才能开始测试。很多用户嫌麻烦就退出了，运营认为这样会给测试带来很大的不便。但是冷静了心态后其实事情并没有那么糟糕。真正对这个产品有兴趣的用户不会因为要填个邮箱就放弃了。那些流失的只是普通的用户。用户使用了 Testflight 后，后续的测试包的发布也会收到更新。不会像企业版那样，只能手动的告诉用户我们有新的测试包。当 beta 测试活跃用户超过 100 个会有一个质变。这些都是积极的重度用户，一群重度用户使用你的新版本几天，至少可以保证核心业务逻辑是没有纰漏的。 这里推荐配合测试的 SDK 质量监控服务——Bugtags，Bugtags 可以通过悬浮窗或者摇一摇的方式进行截图，并将捕获的 bug 图片上传到测试平台，其自身也包括 Crash 的自动上传。 线上质量监控Crashlytics 成立于2011年，是专门为移动应用开者发提供的保存和分析应用崩溃信息的工具。 Crashlytics 不会漏掉任何应用崩溃信息。在发生崩溃后，用户再次进入 APP 并联网情况下，日志自动上传。 Crashlytics 可以象 Bug 管理工具那样，管理这些崩溃日志。例如：Crashlytics 会根据每种类型的 Crash 的出现频率以及影响的用户量来自动设置优先级。对于每种类型的 Crash，Crashlytics 除了会像一般的工具提供 Call Stack 外，还会显示更多相关的有助于诊断的信息，例如：设备是否越狱，当时的内存量，当时的 iOS 版本等。对于修复掉的 Crash 日志，可以在 Crashlytics 的后台将其关掉。 Crashlytics 可以每天和每周将崩溃信息汇总发到你的邮箱。 提供在线的报告，解释崩溃原因，甚至能给出是哪一行代码导致的崩溃。 Crashlytics 有配套的 macOS 应用 Fabric 用户体验值得国内 SDK 服务商学习。 2013 年 Twitter 对 Crashlytics 进行人才和服务的多重收购，一年后 Google 收购 Firebase，从此 Fabric 和 Firebase 这对好基友就成为了应用崩溃报告的黄金搭档。 管理团队核心组成架构关于团队的观点，我基本和没故事的卓同学看法一致，除了技术的硬指标，在早期团队还有一个工程团队文化的问题。一个几十个人的项目，里面某个特定的人的积极性对于项目其实是不太重要的。他只要完成应该完成的工作。甚至和其他人不说话也影响不大。一个大的项目也不能因为任何一个人不在了就运行不下去。 我之前思考过团队文化是什么，怎么形容团队文化。后来看到一个说法感觉挺贴切。文化是空气，无处不在。公司没有规定下班后社交平台上看到用户反馈需要你去回应，也不会规定你发现其他部门的产品有问题是不当回事还是应该去和其他部门的人沟通，又或者看到一个更好的建议是不是要和公司提出来。这些行为背后的支撑就是团队文化。在团队里的人决定了价值观。 技术团队做事就像古代的八抬大轿，公司业务就像轿子里的小娘子，团队文化就像抬轿子时喊的号子，团队里的每个人就像是抬轿子的车夫。抬轿子的大多数人走的快，每个人的步子齐，那轿子里的小娘子就坐得很舒服，如果哪个环节出现问题都会对坐轿子的人有影响。 所以，车夫水平要挑好，号子要响亮提气，每个人的步伐要协调，轿子就能平稳上路，可是如果想快点赶路，那可能就要尝试不同的抬轿姿势，换更响亮的号子，排练更协调步子，甚至换个更轻的轿子、换个轮子… 硬件设备投入接着上面的“花轿”说，硬件投入的重要性就不言而喻了，别人已经换上了带轮子的马车了，当然跑的飞快。 拿 Swift 的编译速度讲，MacBook Air 和 MacBook Pro 的处理器芯片和内存容量决定了两种电脑的编译耗时可能相差1倍左右，而一块外接显示屏能节省的频繁操作更是以少积多。 如果把一个工程师的薪资换算成时薪，配合硬件设备浪费掉的时间，将是一笔不那么明智的开销，当然如果你的工程师每天只是喝凉水看新闻，那请配给他一个保温杯和老花镜~ 例会和文档化有哪些会？ 当我打算写这个主题时，反思了下过去都参加过哪些会议，发现有时会莫名其妙的就参加了一些完全无意义的会议。下面我们先看看一般程序员都会碰到哪些会议。 需求会 这类会议一般是产品或项目经理召集，组织参与项目的程序员一起讨论需求并确定排期。这类会议容易出的问题是，程序员到了会上才第一次知道需求，并陷入到需求细节的无休止讨论中。更好的方式是提前让程序员详细了解需求，会上只需敲定排期并让互相有协作依赖的程序员之间达成一致和形成承诺。 讨论会 这类会议的场景比较广泛，比如：项目进行过程中同组程序员之间就设计或实现的讨论，或与其他组项目合作人之间的讨论等等。这类会议容易出现的问题是临时把一堆人拉到会上，然后陷入混乱的自由讨论，失去焦点。 还有一类讨论会叫头脑风暴会，也是容易把一堆人拉到会上，开动头脑风暴。如今遗憾的领悟到这是最没效率也没效果的方式。头脑风暴会需要就待解决的问题让参与人员提前准备，搜集或阅读材料，不同人从不同角度各自提出自己的观点或方案，然后到了会上将所有观点和方案列出来，再开动头脑，碰撞连接一下，看看能不能风暴出一些新的观点或方案去有效解决问题。 周例会 一般来说一个部门或小组都会每周开个例会，例会容易被当作日常的例行工作而不被重视。例会应该有固定的时间和议程，而且例会是一群经常一起工作并熟悉的人开会。虽然开例会的人都在同一个部门，但并不意味着他们都会相互合作完成同一个项目或事情。所以，例会是通过了解各自工作来完成了解整个部门或小组工作进展的机会，而不是每周固定的休闲时光。当然我们也可以在每周的例会留出一段自由讨论时间，可以畅所欲言，增加工作之外交流。 除了周例会，有些实施敏捷方法的团队也会开每日站立会，每日站立会的一般内容是： 昨天干了什么 今天计划干什么 遇到了什么障碍 每日站立会议的主要目的是让团队成员互相交流互通工作情况，而不是为了让经理们了解情况而召开的会议。每日站立会不是一个团队的人站一圈各自说下工作情况，因为曾经发现彼此并不关心对方工作内容的人站一圈开这个站立会，其意义何在？ 分享会 部门内、公司内或行业内都会有各类不同规模分享会，想清楚你为什么要去参加一个分享会？一般来说我只有两个原因，我对分享的内容感兴趣，这应该是大部分人参会的原因。另一个，即使分享内容我已经很熟悉，那么参会的原因一般就是对分享人感兴趣，想要去通过这个分享了解分享人。 还有一种情况可能是碍于面子参加一些完全没兴趣的分享会，恩，这种还是尽量规避吧。 临时会 总会碰到这种情况，突然有个人过来叫你临时去参加个会，然后你就一脸懵逼的去了。这种会似乎属于身不由己，不好规避，这类会议多是非计划性的任务驱动型会议。英特尔前 CEO 安迪·格鲁夫说过： 在现实中，有 20% 的情况还得靠任务导向会议来解决。但如果经理人将超过 25% 的时间用在应急的任务导向会议上，这个组织就一定有了毛病。这种类型的会议随时召开，而且会针对具体情况产生决策，若这种临时紧急的任务驱动会议太多了，那问题肯定出在平时的工作中。 总结会 可能是项目上线或产品发布后的总结会，也可能是线上故障后的经验教训总结会。我以前开过的很多总结会都变成了领导的总结会，关于这类会大家有什么好想法吗？ 对于以上这些千奇百怪的会议，于是有人制作了这幅漫画： 其实呢，凡事都有两面性，最难把控的永远是人，作为有效的讨论活动，会议本事没有问题，精耕细作也会在一定程度上保证质量。重要的是会议的气氛、主题以及控场力。 高效会议的三个要诀：1.提前通知议题并发给参会人相关资料，不要求可参加可不参加的人2.会议必须有主持人，引导大家时刻盯住会议主题3.要有会议纪要，会后对会议结论、行动计划、负责人、进度表和考核目标的提炼总结 我之前遇到一个项目领导就很有特色，由于采取封闭式敏捷开发模式，需要每天确定工作内容，调节各部门间工作进展，所以需要每天做午会，但是当时并不枯燥而且团队协作融洽，因为在例会过后有组织抽签买饮料、零食和惩罚倒霉鬼的活动，如今想来，他确实是一个优秀的组织者。 以上这些会议内容来自博客园的 mindwind，让我们同情他一刻钟~ 文档化文档化和例会一样是充满争议的举措，本质上是为了让一切有据可查，方便后期查阅和减少交接工作负担。但也不乏反对者，认为是在浪费时间，形势主义。 还是一样的道理，稳定的方法不会错，难把握的是个人。把每一个账号密码整理保存也是文档化。保持会议记录、工作聊天日志也能在必要时不接受飞来的横“锅”~ 组织 CodeReview还是引用没故事的卓同学的话，Code review 是一件神奇的事情。所有有素养的工程师都觉得 code review 好，据我们所知国外很多优秀的 IT 企业都很注重 code review，但是在国内却很少看到有团队执行 code review。或者中小团队里很少看到 code review。 作为一个 leader，在 review 的时候帮助成员成长，和只是看下代码是不是能完成功能最后会引向不同的结果。看过一句很有触动的话，现在很多 leader 知道自己的工作里需要管理其他人，但是却忽略了还需要 lead 。老实说推进 code review 确实遇到很多阻力。有团队里的也有团队外的。团队外的看法是 code review 拖慢了项目进度。我作为一个核心的开发成员，每天超过 20% 的时间是没有可见的工作产出的。有时别人写的有问题被我打回去改，一个已经完成的功能又多花了几个小时。团队内遇到的问题是，很多成员不理解这项工作背后的价值。 同样的感触来自上面提到的那家公司，负责我们的小组组长是一名有着 6 年移动端开发经验的优秀工程师，在一套严格的代码规范要求和 code review 的锻炼下，我的成长几乎是肉眼可见的（对比回看之前的代码），他对我们的指导也是无私且专业的，以至于我现在依然在感谢着他。 CodeReview 的方式 开 Code Review 会议 团队内部会整理 Check List 团队内部成员交换代码 找出可优化方案 多问问题，例如：“这块儿是怎么工作的？”、“如果有XXX 情况，你这个怎么处理？” 区分重点，优先抓住设计，可读性，健壮性等重点问题 整理好的编码实践，用来作为 Code Review 的参考 CodeReview 的内容 [1]架构/设计/常规1.单一职责原则这是经常被违背的原则。一个类只能干一个事情，一个方法最好也只干一件事情。比较常见的违背是一个类既干UI的事情，又干逻辑的事情，这个在低质量的客户端代码里很常见2.行为是否统一，例如：1)缓存是否统一2)错误处理是否统一3)错误提示是否统一4)弹出框是否统一5)……3.代码污染代码有没有对其他模块强耦合4.重复代码–&gt;应该抽取5.开闭原则6.面向接口编程7.健壮性1)是否考虑线程安全2)数据访问是否一致性3)边界处理是否完整4)逻辑是否健壮5)是否有内存泄漏6)有没有循环依赖7)有没有野指针8)是否检查了数组的“越界“错误9)……8.错误处理9.改动是不是对代码的提升新的改动是打补丁，让代码质量继续恶化，还是对代码质量做了修复10.效率/性能1)关键算法的时间复杂度多少？有没有可能有潜在的性能瓶颈2)客户端程序对频繁消息和较大数据等耗时操作是否处理得当 [2]代码风格1.可读性衡量可读性的可以有很好实践的标准，就是 Reviewer 能否非常容易的理解这个代码。如果不是，那意味着代码的可读性要进行改进2.命名1)命名对可读性非常重要2)是否跟系统属性命名造成冲突3)英语用词尽量准确一点，必要时可以查字典3.函数长度/类长度1)函数太长的不好阅读2)类太长了，检查是否违反的 单一职责 原则4.注释恰到好处的注释,不是注释越多越好5.参数个数不要太多，一般不要超过 3 个 工具Gitlab 及 Git 相关规范Gitlab对于代码仓库开源首选 GitHub，不开源现在也有许多服务商，如：Gitee 等，如果有钱任性 GitHub 普通的团队套餐每个月每人 9 刀，但我相信大多数中小企业会选择 Gitlab。 还有就是服务端如果要自己配置 CI 服务不太方便。如果部署在自己的服务器上，其他一些服务脚本也部署在一起，会有很大的自主权。综合之后选择了主流的 Gitlab。 第三方仓库都可能遇到父爱如山般的维护时期。 Git 相关规范Git 相比 SVN 能避免大多数非人为问题，这点相信已经不需要论证了。但是那些人为的问题怎么办，那当然需要规范了。 首先，做好分工，特别是 Storyboard 和 XIB 多种，尽量避免出现多人修改同一个文件。 每个人的所有开发工作都只在自己的分支开发。例如小明开发，你就在本地切换到自己的 xiaoming_gittutorial 分支然后进行开发。 每个人只允许在自己的分支直接push远程分支。 合并的时候必须遵循以下条件： 首先，本地切换到develop分支。pull```123* 例如你是小明，那么在 pull 到远程的 develop 最新的内容之后。```git merge xiaoming_gittutorial 如果出现 conflict 那么清除 conflict 之后，commit 然后把本地 develop push 到远程的 develop。 每完成一个功能就提交一次，不要累计代码。 保证主分支代码永远可运行，版本完整（用于脚本自动化发测试包）。 这样的流程有什么好处呢？ 几乎不会出现 conflict。 你永远也不会污染 develop 分支。 每次都是在本地 merge 完清除了 conflict 之后再 push 会远端，那么别人更新本地 develop 分支，再合并的时候，就算出现 conflict 也只会是自己最新代码产生的 conflict。 Sketch 设计工具 + Zeplin 标注工具移动端也属于前端，是做直接和用户打交道的事情，当然也包括设计狮，设计狮是一种很厉害的猫科动物，他们有着令人恐惧的像素眼和血统中的强迫症。（以上我喝多了说的，不要当真哈~） Sketch 作为一款移动时代设计师新宠，自然有其存在的道理。 自动保存和版本管理 矢量编辑和完美像素 智能参考线 自由编辑元素 布尔运算 单图层多重混合模式 四舍五入像素数值取整 共享样式和组件 优秀的输出 分配间距 移动设备模版 自带格栅 出色的文字渲染 丰富的插件（标注、内容填充） 多种软件高度配合 旋转复制 手机实时预览 Zeplin 面向的用户是设计师和前端（Web、Mobile）工程师，相当于做的是中间桥梁这一块，核心功能为标注、Style Guide、备注文档与简单的团队协作。 sketch支持多画板，便于同时预览，占用内存较ps小很多 sketch支持导出flinto，便于制作交互动效原型 zeplin解放设计师的双手，从此告别切图和标注 zeplin降低工程师的沟通成本，提高设计还原度 Abstract 就是一个借助 Git 对 Sketch 文件进行版本控制的软件。 详情参见《Git 与 Sketch 的神奇邂逅：Abstract》（https://sspai.com/post/40595） 成果年终总结 Github 原创开源项目 90+，共计 400+ 贡献力 参与维护开源项目 fastlane 20.5k（至2018.02.08） 完成 Swifter 功能展示应用研发 Swifter 是一款基于 Swift 开发的，采用 MVVM 模式、RxSwift 函数式响应编程、组件化和 ReactNative 等技术的技术示例应用。","categories":[{"name":"Summary","slug":"Summary","permalink":"https://reversescale.github.io/categories/Summary/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"让 Async 帮你解决线程问题","slug":"Library Async","date":"2018-02-23T03:56:27.000Z","updated":"2018-11-16T12:09:19.724Z","comments":true,"path":"2018/02/23/Library Async/","link":"","permalink":"https://reversescale.github.io/2018/02/23/Library Async/","excerpt":"线程这种东西一般封装比较深，很微观，也很考察计算机基础知识，虽然系统为我们封装的 GCD、NSOperation 已经很好用了，但是我发现了个更好用的~","text":"线程这种东西一般封装比较深，很微观，也很考察计算机基础知识，虽然系统为我们封装的 GCD、NSOperation 已经很好用了，但是我发现了个更好用的~ 👨🏻‍💻 Github Demo 🤖 要求 iOS 9.0+ Xcode 9.0+ Swift 4 🎨 测试 UI 什么样子？ 1.展示页 2.展示页 3.展示页 常见场景列表 耗时操作场景示例 黑科技操作场景示例 🎯 安装方法在 iOS, 你需要在 Podfile 中添加.12345source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;9.0&apos;use_frameworks!pod &apos;AsyncSwift&apos; 🛠 配置耗时操作这是应用最广泛的场景，为了避免阻塞主线程，将耗时操作放在子线程处理，然后在主线程使用处理结果。比如读取沙盒中的一些数据，然后将读取的数据展示在 UI，这个场景还有几个细分：1.1 执行一个耗时操作后回调主线程123456Async.background &#123;print(\"A: This is run on the \\(qos_class_self().description) (expected \\(QOS_CLASS_BACKGROUND.description))\") sleep(2)&#125;.main &#123; print(\"B: This is run on the \\(qos_class_self().description) (expected \\(qos_class_main().description)), after the previous block\")&#125; 1.2 串行耗时操作 每一段子任务依赖上一个任务完成，全部完成后回调主线程：1234567891011let backgroundBlock = Async.background &#123; print(\"This is run on the first\\(qos_class_self().description) (expected \\(QOS_CLASS_BACKGROUND.description))\") sleep(2) print(\"This is run on the second \\(qos_class_self().description) (expected \\(QOS_CLASS_BACKGROUND.description))\") sleep(2)&#125;// Run other code here...backgroundBlock.main &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(qos_class_main().description)), after the previous block\")&#125; 1.3 并发耗时操作 每一段子任务独立，所有子任务完成后回调主线程：12345678910111213141516Async.main &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(qos_class_main().description))\") // Prints: \"This is run on the Main (expected Main) count: 1 (expected 1)\" &#125;.userInteractive &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(QOS_CLASS_USER_INTERACTIVE.description))\") // Prints: \"This is run on the Main (expected Main) count: 2 (expected 2)\" &#125;.userInitiated &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(QOS_CLASS_USER_INITIATED.description)) \") // Prints: \"This is run on the User Initiated (expected User Initiated) count: 3 (expected 3)\" &#125;.utility &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(QOS_CLASS_UTILITY.description)) \") // Prints: \"This is run on the Utility (expected Utility) count: 4 (expected 4)\" &#125;.background &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(QOS_CLASS_BACKGROUND.description)) \") // Prints: \"This is run on the User Interactive (expected User Interactive) count: 5 (expected 5)\"&#125; 延时执行延时一段时间后执行代码，一般见于打开 App 一段时间后，弹出求好评对话框。123456let seconds = 3.0Async.main(after: seconds) &#123; print(\"Is called after 3 seconds\")&#125;.background(after: 6.0) &#123; print(\"At least 3.0 seconds after previous block, and 6.0 after Async code is called\")&#125; 其他用法请见 Demo。 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"门罗币(Monero XMR)给你最轻巧的矿工生活(包教包会)","slug":"Monero XMR","date":"2018-02-08T18:56:27.000Z","updated":"2018-11-16T12:10:01.852Z","comments":true,"path":"2018/02/09/Monero XMR/","link":"","permalink":"https://reversescale.github.io/2018/02/09/Monero XMR/","excerpt":"你向往躺着赚钱吗？你想不努力工作就实现财务自由吗？你想什么都不做就有数不完的钱吗？洗洗睡吧~","text":"你向往躺着赚钱吗？你想不努力工作就实现财务自由吗？你想什么都不做就有数不完的钱吗？洗洗睡吧~ 从2017年8月21日开始，XMR一路走高，从$55左右，一路上涨，到本文写作时，已经达到$269（≈￥1,699）。数据来源：Crypto coins mining profit calculator compared to Ethereum 门罗币（Monero，代号XMR）是一个创建于2014年4月开源加密货币，它着重于隐私、分权和可扩展性。与自比特币衍生的许多加密货币不同，Monero基于CryptoNote协议，并在区块链模糊化方面有显著的算法差异。Monero的模块化代码结构得到了比特币核心维护者之一的Wladimir J. van der Laan的赞赏。Monero致力于成为可代替的不可追踪的电子货币。相比比特币及其分叉，Monero具有更高程度的匿名性。 Monero于2014年4月18日发布。 高涨的币价使得在国内一直默默无闻的XMR瞬间成为焦点，现在已经变成挖矿收益最高的币种之一。以1060 3G为例，在不超频的情况下，挖掘XMR的速度在430H/s左右，不计电费，单卡日收益达到$1.62，超过了之前收益之王ETH。 如何挖矿？ 作为矿工，大家最关心的应该还是怎么挖矿了，下面就向大家介绍一下挖矿的最轻巧姿势。 获得一个钱包地址（推荐）使用在线钱包：https://mymonero.com/特点：使用方便，安全性差 或者在XMR的官方网站下载钱包 App：Monero: Downloads(https://getmonero.org/downloads/)特点：相对安全，方便性差 参与挖矿在网上，你可能看到过许许多多硬件驱动的挖矿方式，组合多少显卡的矿池，但是这里的主题是“最轻巧”，所以我们只做帮工好了。 Coinhive是一个提供恶意JS脚本的网站平台（https://coinhive.com），允许攻击者将脚本挂在到自己的或入侵的网站上，所有访问该网站的用户都可能成为门罗币的挖掘矿工。该工具在网络犯罪分子中间迅速扩散，俨然已经成为了互联网的“Martin Shkreli”。 Coinhive工具其实是一个Java库，用户访问加载该JS的网站后，Coinhive的JS代码库在用户的浏览器上运行，开始为网站所有者挖掘门罗币，消耗的是用户自己的CPU资源。 不得不说，这个想法相当地有创意！Coinhive于9月14日推出，作者向站长们推广Coinhive时声称，站长们加载了Coinhive JS就可以实现盈利：它仅耗费访问用户的少部分CPU，就可以为网站所有者赚取利润，用于支持他们的业务，再也不用添加各种烦人的广告了。 这一想法获得了某些人的支持，在The Pirate Bay（全球知名的BT下载网站）试运行了两天后，由于用户的负面反馈，最后放弃了。 未开情况下 CPU 占用： 理论上你可以使用闲置的那 54.08% 进行挖矿，实测对 CPU 的负荷还是很大的下图是开通100 Threads 下处理器占用情况： 矿工分成之前已经介绍过这种机制的原理了，轻量也注定着收益不会太高，但是简单的使用却可以为你省下大把时间，相信你的时间才是最宝贵的。 上面那些对于刚刚接触的你可能不是很受用，那来看看下面这些 以为这样以后每天的早餐钱就有了？😆那你最好仔细读读下面的东西…","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://reversescale.github.io/tags/Blockchain/"}]},{"title":"iOS 模块化路由之 JLRoute","slug":"Library JLRoute","date":"2018-02-01T13:56:27.000Z","updated":"2018-11-16T12:09:27.900Z","comments":true,"path":"2018/02/01/Library JLRoute/","link":"","permalink":"https://reversescale.github.io/2018/02/01/Library JLRoute/","excerpt":"基于 JLRoute 实现的模块化路由，支持自动注册映射表、Url 跳转原生页面、WebView 页面和 ReactNative 页面、跳转传参及回调等~","text":"基于 JLRoute 实现的模块化路由，支持自动注册映射表、Url 跳转原生页面、WebView 页面和 ReactNative 页面、跳转传参及回调等~ 模块化已经成为调剂庞大项目结构的一剂良药，对项目的开发、维护和后续的扩展的好处已经不言而喻。 👨🏻‍💻 Github Demo 🤖 要求 iOS 8.0+ Xcode 7.0+ 🎯 安装方法安装在 iOS, 你需要在 Podfile 中添加.1234567891011121314151617source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;9.0&apos;use_frameworks!pod &apos;JLRoutes&apos;, &apos;~&gt; 2.0.1&apos;# &apos;node_modules&apos;目录一般位于根目录中# 但是如果你的结构不同，那你就要根据实际路径修改下面的`:path`pod &apos;React&apos;, :path =&gt; &apos;./node_modules/react-native&apos;, :subspecs =&gt; [ &apos;Core&apos;, &apos;RCTText&apos;, &apos;RCTNetwork&apos;, &apos;RCTWebSocket&apos;, # 这个模块是用于调试功能的 # 在这里继续添加你所需要的模块]# 如果你的RN版本 &gt;= 0.42.0，请加入下面这行pod &quot;Yoga&quot;, :path =&gt; &quot;./node_modules/react-native/ReactCommon/yoga&quot; 启动 ReactNative 环境1.修改项目ModuleARNPageViewController.m IP 跳转地址 2.进入项目所在目录，运行(首次运行需要 npm install) 1npm start 🛠 JLRoutes的工作流程和原理单一的Scheme注册过程： 1.调用注册方法（用户注册routePattern，默认优先级0） 1- (void)addRoute:(NSString *)routePattern handler:(BOOL (^__nullable)(NSDictionary&lt;NSString *, id&gt; *parameters))handlerBlock; 2.路由解析（这些解析跟我们设置路由的规则有直接关系） (1)判断接口URL是否设置可选性URL并将对应的URL封装成JLRRouteDefinition对象 (2)将JLRRouteDefinition对象装载进一个可变数组，内存保留了所有的对象！！ （JLRRouteDefinition对象包括有路径，参数解析，block等信息） 单一的Scheme调用过程：1.调用URL 1+ (BOOL)routeURL:(NSURL *)URL 2.解析URL，将参数，路由信息封装成JLRRouteRequest对象 1- (instancetype)initWithURL:(NSURL *)URL alwaysTreatsHostAsPathComponent:(BOOL)alwaysTreatsHostAsPathComponent 3.给JLrouteRequest对象和路由数组里的JLRRouteDefinition对象作比对，并且返回JLRRouteResponse 对象抽出参数和URL在数组里 1JLRRouteResponse *response = [route routeResponseForRequest:request decodePlusSymbols:shouldDecodePlusSymbols]; 4.调用JLRRouteResponse 对象里面的回调方法 1[route callHandlerBlockWithParameters:finalParameters]; JLRoutes的URL注册规则： 1.普通注册 123456JLRoutes *routes = [JLRoutes globalRoutes];[routes addRoute:@&quot;/user/view/:userID&quot; handler:^BOOL(NSDictionary *parameters) &#123;NSString *userID = parameters[@&quot;userID&quot;]; // defined in the route by specifying &quot;:userID&quot;// present UI for viewing user with ID &apos;userID&apos;return YES; // return YES to say we have handled the route&#125;]; URL里，分号表示这个是参数 另外一种注册方式，下标注册法 123JLRoutes.globalRoutes[@&quot;/route/:param&quot;] = ^BOOL(NSDictionary *parameters) &#123;// ...&#125;; 如何按照以上的方式注册，在任何时刻（包括在其它的APP）你都可以调用这个URL。 12NSURL *viewUserURL = [NSURL URLWithString:@&quot;myapp://user/view/joeldev&quot;];[[UIApplication sharedApplication] openURL:viewUserURL]; 在这个例子中，在parmameters字典里面的userID会传给block，它是一个键值对。”userID”: “joeldev”。给UI层或者任何需要它的地方用的。 字典参数： 字典参数总包括至少一下3个键： 12345&#123;&quot;JLRouteURL&quot;: &quot;(the NSURL that caused this block to be fired)&quot;,&quot;JLRoutePattern&quot;: &quot;(the actual route pattern string)&quot;,&quot;JLRouteScheme&quot;: &quot;(the route scheme, defaults to JLRoutesGlobalRoutesScheme)&quot;&#125; 处理Block 你会发现，每个注册的block都会返回一个YES。这个值，如果你返回NO，JLRoutes会跳过这个匹配，然后继续去匹配其它的。 如果你的block设置成nil，它会默认返回YES。 2.复杂注册 1234567[[JLRoutes globalRoutes] addRoute:@&quot;/:object/:action/:primaryKey&quot; handler:^BOOL(NSDictionary *parameters) &#123;NSString *object = parameters[@&quot;object&quot;];NSString *action = parameters[@&quot;action&quot;];NSString *primaryKey = parameters[@&quot;primaryKey&quot;];// stuffreturn YES;&#125;]; 这个地址会被匹配很多URL，如/user/view/joeldev or /post/edit/123。这些URL上的是参数。 12NSURL *editPost = [NSURL URLWithString:@&quot;myapp://post/edit/123?debug=true&amp;foo=bar&quot;];[[UIApplication sharedApplication] openURL:editPost]; 这时，pramater字典就会是以下这样的（传参） 12345678910&#123;&quot;object&quot;: &quot;post&quot;,&quot;action&quot;: &quot;edit&quot;,&quot;primaryKey&quot;: &quot;123&quot;,&quot;debug&quot;: &quot;true&quot;,&quot;foo&quot;: &quot;bar&quot;,&quot;JLRouteURL&quot;: &quot;myapp://post/edit/123?debug=true&amp;foo=bar&quot;,&quot;JLRoutePattern&quot;: &quot;/:object/:action/:primaryKey&quot;,&quot;JLRouteScheme&quot;: &quot;JLRoutesGlobalRoutesScheme&quot;&#125; 3.Scheme（有没有多态的感觉） JLRoutes支持用指定的URL scheme来创建路由。相同的scheme才能被匹配。默认地，所有的URL会设置进global scheme。 123456789101112[[JLRoutes globalRoutes] addRoute:@&quot;/foo&quot; handler:^BOOL(NSDictionary *parameters) &#123;// This block is called if the scheme is not &apos;thing&apos; or &apos;stuff&apos; (see below)return YES;&#125;];[[JLRoutes routesForScheme:@&quot;thing&quot;] addRoute:@&quot;/foo&quot; handler:^BOOL(NSDictionary *parameters) &#123;// This block is called for thing://fooreturn YES;&#125;];[[JLRoutes routesForScheme:@&quot;stuff&quot;] addRoute:@&quot;/foo&quot; handler:^BOOL(NSDictionary *parameters) &#123;// This block is called for stuff://fooreturn YES;&#125;]; 如果你调用的使用，是这样调用的 123[[JLRoutes globalRoutes] addRoute:@&quot;/global&quot; handler:^BOOL(NSDictionary *parameters) &#123;return YES;&#125;]; 它只会调用global scheme的对应的URL。不会调用ting scheme里面对应的URL。 当然，你可以设置，如果指定的scheme没有这个URL，去查询global scheme 有没有。你需要设置一个属性。 1[JLRoutes routesForScheme:@&quot;thing&quot;].shouldFallbackToGlobalRoutes = YES; 3.通配符的设置URL的方式 通配符为：* 通配符符后面所有的URL上的参数都会以一个数组保存在parameters字典里面的JLRouteWildcardComponentsKey对应的value里。 例如，如果你注册URL如下: 123456789[[JLRoutes globalRoutes] addRoute:@&quot;/wildcard/*&quot; handler:^BOOL(NSDictionary *parameters) &#123;NSArray *pathComponents = parameters[JLRouteWildcardComponentsKey];if ([pathComponents count] &gt; 0 &amp;&amp; [pathComponents[0] isEqualToString:@&quot;joker&quot;]) &#123;// the route matched; do stuffreturn YES;&#125;// not interested unless the joker&apos;s in itreturn NO;&#125;]; 如果调用的URL开始是／wildcard，这个路由就可能被触发！！如果第一个参数是joker，就被触发，如果不是，就被拒绝触发。。。 4.选择性路由 如果路由地址设置样式有括号，如：/the(/foo/:a)(/bar/:b)，其实它代表的URL有如下： 1234/the/foo/:a/bar/:b/the/foo/:a/the/bar/:b/the 5.查询Routes 下面的方式，你可以查看Routes里所有注册的URL Routes。 1234/// All registered routes, keyed by scheme+ (NSDictionary &lt;NSString *, NSArray &lt;JLRRouteDefinition *&gt; *&gt; *)allRoutes;/// Return all registered routes in the receiving scheme namespace.- (NSArray &lt;JLRRouteDefinition *&gt; *)routes; 自定义路由解析如果你想自己定制一个路由编辑，你可以继承JLRouteDefinition并且用 addRoute：方法去添加你自定义类的对象。 📝 调研来源JLRoutes：https://github.com/joeldev/JLRoutes JLRoutes资料博客：https://www.varsiri.com/archives/305 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iPhone X + iOS 11 适配指南","slug":"iPhone X iOS 11","date":"2017-09-30T09:56:27.000Z","updated":"2018-11-16T12:08:45.619Z","comments":true,"path":"2017/09/30/iPhone X iOS 11/","link":"","permalink":"https://reversescale.github.io/2017/09/30/iPhone X iOS 11/","excerpt":"北京时间今天凌晨1点，苹果再一次让全世界沸腾。iPhone X 带给我们的最大改变：全屏 Super Retina显示屏。它提供了更多的内容显示空间，同时也营造了更加深入的沉浸感。作为 iOS 开发者，在为强大的 Face ID 和全面屏欣喜的同时，我更担忧“齐刘海”的适配！ 下面结合官方的人机交互指南，来了解下如何设计 App 才能在iPhone X 和其他所有 iOS 设备上都看起来很棒~","text":"北京时间今天凌晨1点，苹果再一次让全世界沸腾。iPhone X 带给我们的最大改变：全屏 Super Retina显示屏。它提供了更多的内容显示空间，同时也营造了更加深入的沉浸感。作为 iOS 开发者，在为强大的 Face ID 和全面屏欣喜的同时，我更担忧“齐刘海”的适配！ 下面结合官方的人机交互指南，来了解下如何设计 App 才能在iPhone X 和其他所有 iOS 设备上都看起来很棒~ 前言北京时间今天凌晨1点，苹果再一次让全世界沸腾。iPhone X 带给我们的最大改变：全屏 Super Retina显示屏。它提供了更多的内容显示空间，同时也营造了更加深入的沉浸感。作为 iOS 开发者，在为强大的 Face ID 和全面屏欣喜的同时，我更担忧“齐刘海”的适配！ 下面结合官方的人机交互指南，来了解下如何设计 App 才能在iPhone X 和其他所有 iOS 设备上都看起来很棒。 理论部分屏幕尺寸 在竖屏下，iPhone X 上的显示的宽度与 iPhone 6，iPhone 7和 iPhone 8的4.7英寸显示屏的宽度保持一致。然而，iPhone X 比4.7英寸显示屏高了145个点，这导致增加了大约20％的垂直高度内容。 大家在为设计师悲伤的同时也不要忘记添加启动图（LaunchImage or LaunchScreen.storyboard）呦~ 安全区 在 iPhone X 布局中，最关键的是：必须确保布局填满屏幕，同时又不会被设备的圆角，传感器外壳或用于访问主屏幕的指示灯所遮盖，苹果为称此区域为“安全区”。 可喜的是，大多数标准的系统提供的UI元素和控件（如 navigation bars，tables 和 collections）都已经为新外形做了很好的适配。 背景已经延伸到显示器的边缘，并且UI元件被很恰当地插入和定位在安全区域。 因此，对于具有自定义布局的 App，支持iPhone X 也应该比较容易，特别是如果使用了 AutoLayout 并遵守安全区域(safe area)和边距布局(margin layout)指南。这些在上文都已经有过较详细的阐述。 下面说几点需要特别注意的： 在 iPhone X 上预览 App: 在拿到新机之前，也可以先使用 Simulator 来预览和检查下布局问题。 但是一些依赖硬件的功能，如图像效果和交互体验，最好还是在真机上预览。 始终保持全屏体验: 确保背景延伸到显示区域的边缘，以及垂直可滚动的布局（如 tables 和 collections）一直延续到底部。 防止边缘内容被裁剪: 一般来说，内容应该是居中对称的，这样它在任何方向看起来都会很棒，不会被边角角或设备外壳夹住，或被主屏幕的指示器遮挡。 为了获得最佳效果，请使用标准的系统界面元素和 AutoLayout 构建界面。 所有 App 都应遵循 UIKit 定义的安全区域和布局边距，因为这些区域可以根据设备和上下文进行适当的填充。 安全区域还可以防止内容覆盖status bar, navigation bar, toolbar, 以及 tab bar. 注意 status bar 的高度: status bar 在iPhone X 上比在其他 iPhone上更高。 如果假定你固定 status bar 的高度用于将内容定位在 status bar 的下方，那么现在必须更新你的的 App，才能根据用户的设备动态定位内容。 特别需要注意，当后台任务（如录音和位置跟踪）处于活动状态时，iPhone X上的状态栏不会改变高度。 重新考虑隐藏 status bar: iPhone X 较之显示高度为4.7“iPhone 的显示屏提供了更多的内容垂直空间，status bar 占据的只是扩展出来的屏幕区域。况且 status bar 更直观的显示用户有用的信息，如果非要隐藏状态栏，那最好用与这些信息同等重要的内容替代。 注意长宽比差异: iPhone X 具有不同于4.7“iPhone 的长宽比。因此，全屏4.7英寸iPhone 图形在iPhone X 上全屏显示时出现裁剪或 letterboxing 。同样，全屏iPhone X 图形全屏显示在4.7“iPhone 上时也会被裁剪或 pillarboxing ，因此要确保重要的视觉内容适配这两种尺寸。 避免交互式控件出现在屏幕底部和角落: iPhone X 提供了显示屏底部的滑动手势来访问主屏幕和应用程序切换器的新交互方式，这些手势可能会取消在此区域中实现的自定义手势。 况且屏幕的两个角落过多复杂的交互也不是最佳体验的良好实践。 不要遮挡或者特别修饰显示特性来引起用户注意: 请勿尝试隐藏设备的圆角、传感器外壳，或者通过在屏幕顶部和底部放置控件来访问主屏幕的引导。也要特别注意不要试图使用像括号，边框或各种符号等视觉修饰这些特殊区域。 为了轻松访问主屏幕允许自动隐藏指示器: 当开启自动隐藏时，如果用户离开屏幕几秒钟，指示器将消失。 当用户再次触摸屏幕时，它会重新出现。 这种行为应该只能用于提升观看体验，如播放视频或照片幻灯片。 色彩iPhone X 的显示器支持 P3 色彩空间，它可以产生比 sRGB 更丰富，更饱和的颜色。 可以使用 wide color 来增强视觉体验。 它可以让照片和视频更加逼真生动。 更多内容可以参考官网Color management（https://developer.apple.com/ios/human-interface-guidelines/visual-design/color/#color-management） 手势想必大家都在发布会上看到了，iPhone X 上的显示屏可以使用屏幕边缘手势来访问主屏幕，应用程序切换器，通知中心和控制中心。适应这个新变化的同时，对于开发者要特别注意： 避免干扰系统范围的屏幕边缘手势:用户依赖这些手势在每个 App 中操作，所以在极少数情况下，比如游戏这种强调沉浸式体验的 App 可能需要自定义的屏幕边缘手势，优先级高于系统的手势。 这种行为（称为边缘保护）应该谨慎使用，因为它使得用户难以访问系统级的操作。 更多内容参考官网Gestures （https://developer.apple.com/ios/human-interface-guidelines/user-interaction/gestures/） 补充的注意事项 认证方法准确:iPhone X 支持 Face ID进行身份验证。 如果你的 App 集成了 Apple Pay 或其他系统身份验证功能，请务必注意不要在 iPhone X 上引用 Touch ID。同样地，也请确保不要在支持Touch ID 的设备上引用 Face ID。 更详细的内容请参考Authentication(https://developer.apple.com/ios/human-interface-guidelines/user-interaction/authentication/) 不要重复增加系统提供的键盘功能:在 iPhone X上，即使使用自定义键盘，Emoji / Globe 按钮和 Dictation 按钮也自动显示在键盘的下方。 你的 App 不能影响这些按钮，因此避免在键盘中重复增加这些按钮造成混乱。 由于 iPhone X的屏幕比例发生变化，对于长期靠“等比缩放”完成适配的H5活动页而言也有不小的影响，需要对页面结构进行适当微调。 更详细内容请参阅Custom-keyboards(https://developer.apple.com/ios/human-interface-guidelines/extensions/custom-keyboards/) 判断 iPhone X 机型 (Swift)如何判断当前的设备是 iPhone X 呢？有好几种办法，可以考虑取得「iPhone 10,1」这样的 Module Name 来判断，也可以用屏幕分辨率的形式来判断。我觉得要用屏幕分辨率的方式来做，因为这是目前为止最简单也最不容易出错的。因为 iPhone X 只有一种分辨率，那就是 812pt x 375pt (@3x），且没有任何其他设备用了一样的分辨率，特别是高度。 于是写了一个基于 UIDevice 的扩展（或者其他任意方法也行）： 12345678extension UIDevice &#123; public func isX() -&gt; Bool &#123; if UIScreen.main.bounds.height == 812 &#123; return true &#125; return false &#125;&#125; 在代码中，就可以用 UIDevice.current.isX() 来判断是不是跑在 iPhone X 机型上，然后做一些或不做一些特殊的 Hack 了。 当然如果你习惯用三方库，也可以尝试“DeviceKit” 1234567let device = Device()print(device) // prints, for example, \"iPhone X\"if device == .iPhoneX &#123; // Do something&#125; else &#123; // Do something else&#125; 代码适配部分当我们能够判断出设备型号就可以配合系统版本进行适配了 适配 UITableView 组件12345678if (@available(iOS 11.0, *)) &#123; self.contentInsetAdjustmentBehavior = .never self.estimatedRowHeight = 0 self.estimatedSectionHeaderHeight = 0 self.estimatedSectionFooterHeight = 0&#125; else &#123; // Fallback on earlier versions&#125; 适配 UIScrollView 组件12345if (@available(iOS 11.0, *)) &#123; scrollView?.contentInsetAdjustmentBehavior = .never&#125; else &#123; // Fallback on earlier versions&#125; UITableView中的sectionHeader或者Footer显示不正常还有的发现某些界面tableView的sectionHeader、sectionFooter高度与设置不符的问题，在iOS11中如果不实现-tableView: viewForHeaderInSection:和-tableView: viewForFooterInSection:，则-tableView: heightForHeaderInSection:和- tableView: heightForFooterInSection:不会被调用，导致它们都变成了默认高度，这是因为tableView在iOS11默认使用Self-Sizing，tableView的estimatedRowHeight、estimatedSectionHeaderHeight、estimatedSectionFooterHeight三个高度估算属性由默认的0变成了UITableViewAutomaticDimension，解决办法简单粗暴，就是实现对应方法或把这三个属性设为0。 1234567if #available(iOS 11.0, *) &#123; tableView.estimatedRowHeight = 0; tableView.estimatedSectionHeaderHeight = 0; tableView.estimatedSectionFooterHeight = 0;&#125; else &#123; automaticallyAdjustsScrollViewInsets = false;&#125;; 适配网页加载不全下面有白边1234if #available(iOS 11.0, *) &#123; webView.scrollView.contentInsetAdjustmentBehavior = .never&#125; else &#123;&#125;; 适配iPhoneX不能铺满屏的问题给Brand Assets添加一张1125*2436大小的图片 打开Assets.xcassets文件夹，找到Brand Assets 右键Show in Finder 添加一张1125*2436大小的图片 修改Contents.json文件,添加如下内容 123456789&#123;&quot;extent&quot; : &quot;full-screen&quot;,&quot;idiom&quot; : &quot;iphone&quot;,&quot;subtype&quot; : &quot;2436h&quot;,&quot;filename&quot; : &quot;1125_2436.png”,&quot;minimum-system-version&quot; : &quot;11.0&quot;,&quot;orientation&quot; : &quot;portrait&quot;,&quot;scale&quot; : &quot;3x&quot;&#125; 使用 LaunchScreen.storyboard 设置启动图 使用 LaunchScreen.storyboard 文件将简单视图约束定位，实现各种尺寸的自适应。 适配iPhoneX12345//适配iPhoneXlet LL_iPhoneX = (kScreenW == Double(375.0) &amp;&amp; kScreenH == Double(812.0) ?true:false)let kNavibarH = LL_iPhoneX ? Double(88.0) : Double(64.0)let kTabbarH = LL_iPhoneX ? Double(49.0+34.0) : Double(49.0)let kStatusbarH = LL_iPhoneX ? Double(44.0) : Double(20.0) Xcode9 打包注意事项Xcode9 打包版本只能是8.2及以下版本,或者9.0及更高版本 Xcode9 不支持8.3和8.4版本 Xcode9 新打包要在构建版本的时候加入1024*1024 AppSore icon Xcode9 沿用了之前的分包设计，可以配置打出多种设备的包文件，用户安装时根据设备不同分别安装不同的API包，减小安装包大小。 iOS 11 相册权限变更iOS11以前： NSPhotoLibraryUsageDescription：访问相册和存储照片到相册（读写），会出现用户授权。 iOS11之后： NSPhotoLibraryUsageDescription：无需添加。默认开启访问相册权限（读），无需用户授权。 NSPhotoLibraryAddUsageDescription： 添加内容到相册。（写），会出现用户授权。","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS RAC 的使用总结","slug":"Reactive Cocoa","date":"2017-07-16T14:56:27.000Z","updated":"2018-11-16T13:27:23.887Z","comments":true,"path":"2017/07/16/Reactive Cocoa/","link":"","permalink":"https://reversescale.github.io/2017/07/16/Reactive Cocoa/","excerpt":"Reactive Cocoa(简称RAC),是 GitHub 上开源的一个应用于 iOS 和 OS X 开发的一个新框架，RAC具有函数式编程和响应者编程的特性~","text":"Reactive Cocoa(简称RAC),是 GitHub 上开源的一个应用于 iOS 和 OS X 开发的一个新框架，RAC具有函数式编程和响应者编程的特性~ ReactiveCocoa解决的问题: 1.传统iOS开发过程中,状态以及状态之间依赖过多的问题 2.传统MVC架构的问题:Controller比较复杂,可测试性差 3.提供统一的消息传递机制 键值观察–监听 TF 的值发生变化123456789101112- (void)demo1&#123; @weakify(self); [self.tF.rac_textSignal subscribeNext:^(NSString *value) &#123; @strongify(self); self.value = value; &#125;]; //当self.value的值变化时调用Block，这是用KVO的机制，RAC封装了KVO [RACObserve(self, value) subscribeNext:^(NSString *value) &#123; NSLog(@&quot;%@&quot;,value); &#125;];&#125; map 的使用1234567891011121314151617- (void)demo2&#123; //创建一个信号 RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; //这个信号里面有一个Next事件的玻璃球和一个complete事件的玻璃球 [subscriber sendNext:@&quot;唱歌&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //对信号进行改进,当信号里面流的是唱歌.就改进为&apos;跳舞&apos;返还给self.value RAC(self, tF.text) = [signalA map:^id(NSString *value) &#123; if ([value isEqualToString:@&quot;唱歌&quot;]) &#123; return @&quot;跳舞&quot;; &#125; return @&quot;&quot;; &#125;]; &#125; filter 使用,你向西，他就向东，他向左，你就向右1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void)demo3&#123; //创建两个通道,一个从A流出的通道A,和一个从B流出的通道B RACChannelTerminal *channelA = RACChannelTo(self, value); RACChannelTerminal *channelB = RACChannelTo(self, value2); //改造通道A,使通过通道A的值,如果等于&apos;西&apos;,就改为&apos;东&apos; [[channelA map:^id(NSString *value) &#123; if ([value isEqualToString:@&quot;西&quot;]) &#123; NSLog(@&quot;东&quot;); return @&quot;东&quot;; &#125; NSLog(@&quot;====== %@&quot;,value); return value; &#125;] subscribe:channelB];//通道A流向B //改造通道B,使通过通道B的值,如果等于&apos;左&apos;,就改为&apos;右&apos;传出去 [[channelB map:^id(id value) &#123; if ([value isEqualToString:@&quot;左&quot;]) &#123; NSLog(@&quot;右&quot;); return @&quot;右&quot;; &#125; NSLog(@&quot;====== %@&quot;,value); return value; &#125;] subscribe:channelA];//通道B流向通道A //KVO监听valueA的值的变化,过滤valueA的值,返回Yes表示通过 //只有value有值,才可通过 [[RACObserve(self, value) filter:^BOOL(id value) &#123; return value ? YES : NO; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;你向%@&quot;,x); &#125;]; //KVO监听value2的变化 [[RACObserve(self, value2) filter:^BOOL(id value) &#123; return value ? YES: NO; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;他向%@&quot;,x); &#125;]; //下面使value的值和value2的值发生改变 self.value = @&quot;西&quot;; self.value2 = @&quot;左&quot;; &#125; 代理1)代理的第一种写法 .m文件123- (void)demo4&#123; [self.delegate makeAnApp:@&quot;12345上山打老虎&quot; String:@&quot;老虎不在家,怎么办&quot;];&#125; .h文件12345- (void)makeAnApp:(NSString *)string String:(NSString *)string;@end@interface Base5Controller : UIViewController@property (nonatomic, assign)id&lt;ProgrammerDelegate&gt; delegate; 第一个控制器的.h123456789101112131415161718192021222324Base5Controller *base = [[Base5Controller alloc] init]; // base.delegate = self; [self demo4]; // 这里是个坑,必须将代理最后设置,否则信号是无法订阅到的 // 雷纯峰大大是这样子解释的:在设置代理的时候，系统会缓存这个代理对象实现了哪些代码方法 // 如果将代理放在订阅信号前设置,那么当控制器成为代理时是无法缓存这个代理对象实现了哪些代码方法的 base.delegate = self; [self.navigationController pushViewController:base animated:YES]; &#125; else &#123; [self.navigationController pushViewController:[cl new] animated:YES]; &#125;&#125;#pragma mark---demo4//使用RAC代替代理时,rac_signalForSelector: fromProtocol:这个代替代理的方法使用时,切记要将self设为代理这句话放在订阅代理信号的后面写,否则会无法执行- (void)demo4&#123; //为self添加一个信号,表示代理ProgrammerDelegate的makeAnApp; //RACTuple 相当于swift中的元祖 [[self rac_signalForSelector:@selector(makeAnApp:String:) fromProtocol:@protocol(ProgrammerDelegate)] subscribeNext:^(RACTuple *x) &#123; //这里可以立即为makeAnApp的方法要执行的代码 NSLog(@&quot;%@ &quot;,x.first); NSLog(@&quot;%@&quot;,x.second); &#125;];&#125; 2)方法2 使用RACSubject替代代理123456789101112131415161718192021/*** RACSubject:信号提供者,自己可以充当信号,又能发送信号创建方法:1.创建RACSubject2.订阅信号3.发送信号工作流程:1.订阅信号,内部保存了订阅者,和订阅者相应block2.当发送信号的,遍历订阅者,调用订阅者的nextBolck注:如果订阅信号,必须在发送信号之前订阅信号,不然收不到信号,有利用区别RACReplaySubject*/-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; RacSubjectController *racsub = [[RacSubjectController alloc] init]; racsub.subject = [RACSubject subject]; [racsub.subject subscribeNext:^(id x) &#123; NSLog(@&quot;被通知了%@&quot;,x); &#125;]; [self.navigationController pushViewController:racsub animated:YES];&#125; 在RacSubjectController.h里面声明属性1@property (nonatomic, strong) RACSubject *subject; .m里面进行数据的传递12345-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; if (self.subject) &#123; [self.subject sendNext:@1]; &#125;&#125; 广播12345678910111213141516//发送通知- (void)demo5&#123; NSNotificationCenter *center = [NSNotificationCenter defaultCenter]; //发送广播通知 [center postNotificationName:@&quot;妇女之友&quot; object:nil userInfo:@&#123;@&quot;技巧&quot;:@&quot;用心听&quot;&#125;];&#125;//接收通知NSNotificationCenter *center = [NSNotificationCenter defaultCenter];//RAC的通知不需要我们手动移除//注册广播通知RACSignal *siganl = [center rac_addObserverForName:@&quot;妇女之友&quot; object:nil];//设置接收通知的回调处理[siganl subscribeNext:^(NSNotification *x) &#123; NSLog(@&quot;技巧: %@&quot;,x.userInfo[@&quot;技巧&quot;]);&#125;]; 两个信号串联,两个管串联,一个管处理完自己的东西,下一个管才开始处理自己的东西12345678910111213141516171819202122- (void)demo6&#123; //创建一个信号管A RACSignal *siganlA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;吃饭&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //创建一个信号管B RACSignal *siganlB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;吃的饱饱的,才可以睡觉的&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //串联管A和管B RACSignal *concatSiganl = [siganlA concat:siganlB]; //串联后的接收端处理 ,两个事件,走两次,第一个打印siggnalA的结果,第二次打印siganlB的结果 [concatSiganl subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125; 并联,只要有一个管有东西,就可以打印123456789101112131415161718192021- (void)demo7&#123; //创建信号A RACSignal *siganlA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;纸厂污水&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //创建信号B RACSignal *siganlB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;电镀厂污水&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //并联两个信号,根上面一样,分两次打印 RACSignal *mergeSiganl = [RACSignal merge:@[siganlA,siganlB]]; [mergeSiganl subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125; 组合,只有两个信号都有值,才可以组合1234567891011121314151617181920- (void)demo8&#123; //定义2个自定义信号 RACSubject *letters = [RACSubject subject]; RACSubject *numbers = [RACSubject subject]; //组合信号 [[RACSignal combineLatest:@[letters,numbers] reduce:^(NSString *letter, NSString *number)&#123; return [letter stringByAppendingString:number]; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;]; //自己控制发生信号值 [letters sendNext:@&quot;A&quot;]; [letters sendNext:@&quot;B&quot;]; [numbers sendNext:@&quot;1&quot;]; //打印B1 [letters sendNext:@&quot;C&quot;];//打印C1 [numbers sendNext:@&quot;2&quot;];//打印C2&#125; 合流压缩12345678910111213141516171819202122- (void)demo9&#123; //创建信号A RACSignal *siganlA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;红&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //创建信号B RACSignal *siganlB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;白&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //合流后处理的是压缩包,需要解压后才能取到里面的值 [[siganlA zipWith:siganlB] subscribeNext:^(id x) &#123; //解压缩 RACTupleUnpack(NSString *stringA, NSString *stringB) = x; NSLog(@&quot;%@ %@&quot;,stringA, stringB); &#125;];&#125; 映射,我可以点石成金12345678910111213141516171819- (void)demo10&#123; RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:nil]; [subscriber sendCompleted]; return nil; &#125;]; //对信号进行改造,改&quot;石&quot;成&quot;金&quot; siganl = [siganl map:^id(NSString *value) &#123; if ([value isEqualToString:@&quot;石&quot;]) &#123; return @&quot;金&quot;; &#125; return value; &#125;]; //打印,不论信号发送的是什么,这一步都会走的 [siganl subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125; 过滤,未满18岁,禁止入内12345678910111213141516171819- (void)demo11&#123; RACSignal *singal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@(15)]; [subscriber sendNext:@(17)]; [subscriber sendNext:@(21)]; [subscriber sendNext:@(14)]; [subscriber sendNext:@(30)]; [subscriber sendCompleted]; return nil; &#125;]; //过滤信号,打印 [[singal filter:^BOOL(NSNumber *value) &#123; //大于18岁的,才可以通过 return value.integerValue &gt;= 18;//return为yes可以通过 &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125; 秩序(flattenMap 方法也可以换成 then 方法,效果一样)123456789101112131415161718192021222324252627282930313233-(void)demo12&#123; RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;打蛋液&quot;); [subscriber sendNext:@&quot;蛋液&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //对信号进行秩序秩序的第一步 siganl = [siganl flattenMap:^RACStream *(NSString *value) &#123; //处理上一步的RACSiganl的信号value.这里的value=@&quot;蛋液&quot; NSLog(@&quot;把%@倒进锅里面煎&quot;,value); return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;煎蛋&quot;]; [subscriber sendCompleted]; return nil; &#125;]; &#125;]; //对信号进行第二步处理 siganl = [siganl flattenMap:^RACStream *(id value) &#123; NSLog(@&quot;把%@装载盘里&quot;,value); return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;上菜&quot;]; [subscriber sendCompleted]; return nil; &#125;]; &#125;]; //最后打印 最后带有===上菜 [siganl subscribeNext:^(id x) &#123; NSLog(@&quot;====%@&quot;,x); &#125;];&#125; 命令12345678910111213-(void)demo13&#123; RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; //打印：今天我投降了 //命令执行代理 NSLog(@&quot;%@我投降了&quot;,input); //返回一个RACSignal信号 return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; return nil; &#125;]; &#125;]; //执行命令 [command execute:@&quot;今天&quot;];&#125; 延迟12345678910111213- (void)demo14&#123; RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;等等我,我还有10s就到了&quot;); [subscriber sendNext:@&quot;北极&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //延迟10s接受next的玻璃球 [[siganl delay:10] subscribeNext:^(id x) &#123; NSLog(@&quot;我到了%@&quot;,x); &#125;];&#125; 重放123456789101112131415161718- (void)demo15&#123; RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;电影&quot;); [subscriber sendNext:@&quot;电影&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //创建该普通信号的重复信号 RACSignal *replaySiganl = [siganl replay]; //重复接受信号 [replaySiganl subscribeNext:^(NSString *x) &#123; NSLog(@&quot;小米%@&quot;,x); &#125;]; [replaySiganl subscribeNext:^(NSString *x) &#123; NSLog(@&quot;小红%@&quot;,x); &#125;];&#125; 定时—每隔 8 小时服用一次药12345678- (void)demo16&#123; //创建定时器信号.定时8小时 RACSignal *siganl = [RACSignal interval:60 * 60 * 8 onScheduler:[RACScheduler mainThreadScheduler]]; //定时器执行代码 [siganl subscribeNext:^(id x) &#123; NSLog(@&quot;吃药&quot;); &#125;];&#125; 超时12345678910111213141516171819202122- (void)demo17&#123; RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;我快到了&quot;); RACSignal *sendSiganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:nil]; [subscriber sendCompleted]; return nil; &#125;]; //发生信号要1个小时10分钟才到 [[sendSiganl delay:60 * 70] subscribeNext:^(id x) &#123; //这里才发送next玻璃球到siganl [subscriber sendNext:@&quot;我到了&quot;]; [subscriber sendCompleted]; &#125;]; return nil; &#125;]; [[siganl timeout:60 * 60 onScheduler:[RACScheduler mainThreadScheduler]] subscribeNext:^(id x) &#123; NSLog(@&quot;等了你一个小时,你一直没来,我走了&quot;); &#125;];&#125; 重试12345678910111213141516171819202122- (void)demo18&#123; __block int failedCount = 0; //创建信号 RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; if (failedCount &lt; 100) &#123; failedCount ++; NSLog(@&quot;我失败了&quot;); [subscriber sendError:nil]; &#125;else&#123; NSLog(@&quot;经历了数百次后,我成功了&quot;); [subscriber sendNext:nil]; &#125; return nil; &#125;]; //重试 RACSignal *retrySiganl = [siganl retry]; //直到发生next的玻璃球 [retrySiganl subscribeNext:^(id x) &#123; NSLog(@&quot;重要成功了&quot;); &#125;];&#125; 节流,不好意思,这里每一秒只能通过一个人,如果 1s 内发生多个,只通过最后一个1234567891011121314151617181920212223242526272829- (void)demo19&#123; RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; //即使发送一个next的玻璃球 [subscriber sendNext:@&quot;A&quot;]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@&quot;B&quot;]; &#125;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@&quot;C&quot;]; [subscriber sendNext:@&quot;D&quot;]; [subscriber sendNext:@&quot;E&quot;]; &#125;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@&quot;F&quot;]; &#125;); return nil; &#125;]; //对信号进行节流,限制时间内一次只能通过一个玻璃球 [[signal throttle:1] subscribeNext:^(id x) &#123; NSLog(@&quot;%@通过了&quot;,x); &#125;]; /* [2015-08-16 22:08:45.677]旅客A [2015-08-16 22:08:46.737]旅客B [2015-08-16 22:08:47.822]旅客E [2015-08-16 22:08:48.920]旅客F */&#125; 条件(takeUntil 方法,当给定的 signal 完成前一直取值)1234567891011121314151617181920212223242526- (void)demo20&#123; RACSignal *takeSiganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; //创建一个定时器信号,每一秒触发一次 RACSignal *siganl = [RACSignal interval:1 onScheduler:[RACScheduler mainThreadScheduler]]; [siganl subscribeNext:^(id x) &#123; //在这里定时发送next玻璃球 [subscriber sendNext:@&quot;直到世界尽头&quot;]; &#125;]; return nil; &#125;]; //创建条件信号 RACSignal *conditionSiganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; //设置5s后发生complete玻璃球 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;世界的今天到了,请下车&quot;); [subscriber sendCompleted]; &#125;); return nil; &#125;]; //设置条件,takeSiganl信号在conditionSignal信号接收完成前,不断取值 [[takeSiganl takeUntil:conditionSiganl] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125; RACReplaySubject 使用12345678910111213141516171819202122232425/*** RACReplaySubject创建方法 1.创建RACSubject 2.订阅信号 3.发送信号 工作流程: 1.订阅信号,内部保存了订阅者,和订阅者相应的block 2.当发送信号的,遍历订阅者,调用订阅者的nextBlock 3.发送的信号会保存起来,当订阅者订阅信号的时候,会将之前保存的信号,一个个作用于新的订阅者,保存信号的容量由capacity决定,这也是有别于RACSubject的*/-(void)RACReplaySubject&#123; RACReplaySubject *replaySubject = [RACReplaySubject subject]; [replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot; 1 %@&quot;,x); &#125;]; [replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot;2 %@&quot;,x); &#125;]; [replaySubject sendNext:@7]; [replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot;3 %@&quot;,x); &#125;];&#125; rac_liftSelector:withSignals 使用12345678910111213141516171819//这里的rac_liftSelector:withSignals 就是干这件事的，它的意思是当signalA和signalB都至少sendNext过一次，接下来只要其中任意一个signal有了新的内容，doA:withB这个方法就会自动被触发-(void)test&#123; RACSignal *sigalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; double delayInSeconds = 2.0; dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds *NSEC_PER_SEC)); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(popTime * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@&quot;A&quot;]; &#125;); return nil; &#125;]; RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;B&quot;]; [subscriber sendNext:@&quot;Another B&quot;]; [subscriber sendCompleted]; return nil; &#125;]; [self rac_liftSelector:@selector(doA:withB:) withSignals:sigalA,signalB, nil];&#125; 来源：简书作者未魏雨辰 《iOS RAC的使用总结》","categories":[{"name":"Summary","slug":"Summary","permalink":"https://reversescale.github.io/categories/Summary/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"Jenkins + Fastlane 自动打包脚本","slug":"AutoBuildScript","date":"2017-06-20T13:55:38.000Z","updated":"2018-11-17T07:36:42.180Z","comments":true,"path":"2017/06/20/AutoBuildScript/","link":"","permalink":"https://reversescale.github.io/2017/06/20/AutoBuildScript/","excerpt":"使用 Jenkins 运行 Fastlane 命令，实现定时自动打包、修改版本号、上传 Fir 或者 TestFlight 等功能，从此再也不用被小伙伴追着要测试包。 三步配置，杜绝污染，一步操作自动上传~","text":"使用 Jenkins 运行 Fastlane 命令，实现定时自动打包、修改版本号、上传 Fir 或者 TestFlight 等功能，从此再也不用被小伙伴追着要测试包。 三步配置，杜绝污染，一步操作自动上传~ 👨🏻‍💻 Github Demo 📺 故事背景记得大约两年前，当时在创业公司，开发任务重，提测前常常加班到晚上 12 点，就算 bug 修完，也要看着 Xcode 不慌不忙的花半个多小时打包完成，再上传测试平台，发了邮件才能安心回家。鉴于这种惨痛经历，利用闲暇时间就搞一搞自动打包脚本，后期有配上 Jenkins，从此过上了没羞没臊的生活。（已适配 Xcode 8.2 之后版本） 🚀 框架的优势 1.市面上文件最少，使用最便捷的自动化打包脚本 2.冗余方法少，结构清晰，注释齐全 3.同时支持多平台上传，如：Dir、Fir、蒲公英、App Store等 4.具备较高自定义性 5.[自编脚本的时代] -&gt; [Fastlane 的时代] █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🚂 自编脚本的时代 [🚂 自编脚本的时代] 了解一下即可，有些准备工作提供参考，如环境已经配置好，请直接阅读 [🚄 Fastlane 的时代] 第一步 安装fir-cilfir-cli 使用 Ruby 构建, 无需编译, 只要安装相应 gem 即可. 12$ ruby -v # &gt; 1.9.3$ gem install fir-cli 常见的安装问题(1)使用系统自带的 Ruby 安装, 需确保 ruby-dev 已被正确的安装: 12$ xcode-select --install # OS X 系统$ sudo apt-get install ruby-dev # Linux 系统 (2)现 Permission denied 相关错误: 解决：在命令前加上 sudo (3)出现 Gem::RemoteFetcher::FetchError 相关错误: 解决：更换 Ruby 的淘宝源(由于国内网络原因, 你懂的), 并升级下系统自带的 gem12345678$ gem sources --remove https://rubygems.org/$ gem sources -a https://ruby.taobao.org/$ gem sources -l*** CURRENT SOURCES ***https://ruby.taobao.org# 请确保只有 ruby.taobao.org, 如果有其他的源, 请 remove 掉gem update --systemgem install fir-cli (4)Mac OS X 10.11 以后的版本, 由于10.11引入了 rootless, 无法直接安装 fir-cli, 有以下三种解决办法: 方法一： 使用 Homebrew 及 RVM 安装 Ruby, 再安装 fir-cli(推荐)12345# Install Homebrew:$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;# Install RVM:$ \\curl -sSL https://get.rvm.io | bash -s stable --ruby$ gem install fir-cli 方法二： 指定 fir-cli 中 bin 文件的 PATH1$ export PATH=/usr/local/bin:$PATH;gem install -n /usr/local/bin fir-cli 方法三： 重写 Ruby Gem 的 bindir12$ echo &apos;gem: --bindir /usr/local/bin&apos; &gt;&gt; ~/.gemrc$ gem install fir-cli 第二步 登录fir.im 先到 https://fir.im 创建项目，得到 API Token 并复制。 1fir login 命令用于使用 API token 登录 fir.im, 并使用发布应用等相关命令. 1fir me 命令用于查看当前登录用户信息. 显示信息如下：12345678$ fir login XXX_YOUR_API_TOKEN_XXXI, [2016-03-08T12:48:56.499435 #13043] INFO -- : Login succeed, previous user&apos;s email: xxx@fir.imI, [2016-03-08T12:48:56.507044 #13043] INFO -- : Login succeed, current user&apos;s email: xxx@fir.imI, [2016-03-08T12:48:56.507147 #13043] INFO -- :$ fir meI, [2016-03-08T12:48:14.175488 #12986] INFO -- : Login succeed, current user&apos;s email: xxx@fir.imI, [2016-03-08T12:48:14.175687 #12986] INFO -- : Login succeed, current user&apos;s name: xxxI, [2016-03-08T12:48:14.175765 #12986] INFO -- : 第三步 下载并配置 shell 脚本1.把文件夹导入工程目录根目录下 2.配置 shell 脚本 12345678# 需要改动的地方 (根据项目具体信息改动)PROJECT_NAME = &quot;***&quot; #项目名称VERSION = &quot;1.0.0&quot; #打包版本号 会根据不同的版本创建文件夹（与项目本身的版本号无关）TAGREAT_NAME = &quot;***&quot; #项目对应target的名称如 &quot;Meifabao_User&quot; &quot;Miefabao_stylist&quot;CONFIGURATION = &quot;Release&quot; #打包的环境设置 Release 环境 Debug 环境PROFILE = &quot;AdHoc&quot; #配置文件分为四种 AdHoc Dev AppStore Ent 分别对应四种配置文件OUTPUT = &quot;./Packge/%s&quot; %(CONFIGURATION) #打包导出ipa文件路径（请确保 “%s” 之前的文件夹正确并存在） 根据具体项目填写 3.控制台到项目所在目录下，启动脚本(必要时加管理员权限) 可以将 autobuild.py 拖拽到控制台，执行脚本 注：其他的功能脚本由于实用性不高（其实我懒得搞），暂时没有适配，有兴趣的朋友可以自行配置试用，包括：邮件发送、打包 App Store 等等。 当看到 时，打包好的项目已经躺在你的 Fir 测试平台中了。 █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🚄 Fastlane 的时代2018.08.20 更新：Jenkins + Fastlane + GitLab + fir (或者蒲公英) 第一步 安装 FastlaneFastlane 是一套使用Ruby写的自动化工具集，用于iOS和Android的自动化打包、发布等工作，可以节省大量的时间 1sudo gem install fastlane --verbose 第二步 移动脚本至项目目录下根据注释完善脚本配置信息 脚本说明： 支持版本号自增长 支持传入自定的宏，用于在代码里使用此预编译的宏来区分开发环境和发布环境 支持自动上传到 fir 和 testflight 上传成功后弹窗提示 第三步 上传上传到 fir 的用法：1./build.sh -m &quot;xxxx_app_test&quot; -t test 上传到 testflight 的用法：1./build.sh -m &quot;xxxx_app_pro&quot; -t pro 第四步 配置 Jenkins Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。 1）下载 Jenkins： 点击 http://mirrors.jenkins.io/war-stable/latest/jenkins.war 下载最新的Jenkins.war 2）运行服务器： 需要先安装 java sdk （http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html） 1java -jar jenkins.war 3）运行 Jenkins 1jenkins 4）配置 Jenkins： 浏览器打开 http://localhost:8080/ 输入安全密码，安全密码命令行输出的一个文件里面。 然后自动安装推荐的插件，并新建管理员账号密码。 5）安装插件 登录http://localhost:8080/ ，选择系统管理 - 管理插件。在可选插件中选择GitLab Plugin，Gitlab Hook Plugin，和 Cocoapod plugin 进行安装。 6）构建任务 点击新建，输入名称，构建一个自由风格的软件项目。 配置 Git 仓库地址，并添加 git 账号。 配置构建脚本 附录 执行脚本过程中遇到的问题和解决方案 1）fir: command not found 这个是因为没有安装fir-cil，导致找不到相应的命令行，只需要安装一下就行了，详情见上文写的如何安装fir-cil。 2）README: No such file or directory 那是因为你的脚本目录下没有README的文件，只需要建一个README的文件就行了，打开终端，cd到当前位置，然后执行下面的命令： 1touch README 3）ERROR – : Token can not be blank 这个原因是因为你没有登录fir导致的，你执行这个脚本之前应该先登录一下fir，详情请看上文写的登录fir.im。 4）ERROR – : Code=14 (没有试用的设备 Domain=IDEDistributionErrorDomain Code=14 “No applicable devices 原因：rvm ruby 配置错误 解决：控制台 rvm system █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 2018.08.20 更新：Jenkins 相关设置5）查看端口占用 端口占用 使用 lsof 会列举所有占用的端口列表： 1lsof 使用less可以用于分页展示，如： 1lsof | less 也可以使用 -i 查看某个端口是否被占用，如： 1lsof -i:3000 杀死进程 1kill PID（进程的PID，如2044） 6）Jenkins 改时区 http://your-jenkins/systemInfo，查看user.timezone变量的值 在jenkins的【系统管理】-【脚本命令行】里运行 1System.setProperty(&apos;org.apache.commons.jelly.tags.fmt.timeZone&apos;, &apos;Asia/Shanghai&apos;) 7）Jenkins 构建超时 jenkins的”build timeout plugin”插件可以帮我们完成该任务。我使用的是jenkins-2.7.1, 默认就已经安装了该插件，如果默认没有安装可在插件管理中搜索进行安装。 8）Jenkins 定时构建和Poll SCM的区别 Build periodically：周期进行项目构建（源码是否发生变化没有关系） Poll SCM：定时检查源码变更，如果有更新就checkout最新code下来，然后执行构建动作 12345678910111213每15分钟构建一次：H/15 * * * * 或 */5 * * * *每天8点构建一次：0 8 * * *每天8点~17点，两小时构建一次：0 8-17/2 * * *周一到周五，8点~17点，两小时构建一次：0 8-17/2 * * 1-5每月1号、15号各构建一次，除12月：H H 1,15 1-11 **/5 * * * * （每5分钟检查一次源码变化）0 2 * * * （每天2:00 必须build一次源码） █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🕹 agvtool 命令行2018.08.20 更新：管理版本号 常用命令行： 设置 版本号 为 1.1.01xcrun agvtool new-marketing-version 1.1.0 设置 build 号 自动加11xcrun agvtool next-version -all 简介agvtool 是一个命令行工具，允许你自动递增到下一个最高的数量或具体的数字这些数字。 修改Xcode的默认设置默认情况下，在不使用任何版本控制系统。设置版本系统苹果通用确保 Xcode 将包括在你的项目中生成的所有agvtool版本信息。 上图：设置当前项目的版本和版本控制系统的构建设置 设置你的版本号和 bulid 版本号agvtool 查询应用程序的 Info.plist 得到你的版本和 bulid 版本号。 所以确保 CFBundleVersion (Bundle version) 和 CFBundleShortVersionString (Bundle versions string, short）的 key 在你的 Info.plist 中。 上图：info.plist 命令行操作更新版本号退出Xcode，然后导航到包含项目的目录，运行下列命令在终端应用 agvtool 属性工作。 设置 版本号 为 1.1.01xcrun agvtool new-marketing-version 1.1.0 设置 build 号 自动加11xcrun agvtool next-version -all 设置 build 号为 311xcrun agvtool new-version -all 31 查看 Version Numbers1xcrun agvtool what-marketing-version 查看 Build Numbers1xcrun agvtool what-version 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Summary","slug":"Summary","permalink":"https://reversescale.github.io/categories/Summary/"}],"tags":[{"name":"Script","slug":"Script","permalink":"https://reversescale.github.io/tags/Script/"}]},{"title":"使用 CocoaPods 对公有库开源和私有库组件","slug":"Open source library","date":"2017-01-22T13:56:27.000Z","updated":"2018-11-16T13:29:52.512Z","comments":true,"path":"2017/01/22/Open source library/","link":"","permalink":"https://reversescale.github.io/2017/01/22/Open source library/","excerpt":"最近在研究使用 CocoaPods 对 iOS 工程组件化，创建公有 Pod 库和私有 Pod 库方法，为了方便整理和学习就整理了这篇文章~","text":"最近在研究使用 CocoaPods 对 iOS 工程组件化，创建公有 Pod 库和私有 Pod 库方法，为了方便整理和学习就整理了这篇文章~ 创建公有 Pod 库或者私有 Pod 库，实际上原理是一样的，都是基于 git 服务和 repo 协议，不一样的是，两者的版本索引查询方式不一样，公有库的 podspec 由 CocoaPods/Specs 管理，而内部私有使用的 pod 库需要自己建立一个仓库来管理 podspec。 实用：开源公有库例子: 我有封装过一个工具CollectionIndexTools，CollectionIndexTools 可以给 Collection 添加一个类似 TableView 右侧的索引条，我想通过 Podfile 中添加 pod ‘CollectionIndexToolsLib’ 即可使用. 注册 CocoaPods 账户信息想要创建一个开源 pod 库，首先我们需要注册 CocoaPods, 这里使用 trunk 方式，作为一个 iOS 开发人员你一定安装了 CocoaPods，那么只需要在终端执行： 1pod trunk register 邮箱地址 &apos;用户名&apos; --verbose 这里我们一般使用 Github 邮箱和用户名，然后在你的邮箱中会收到确认邮件，在浏览器中点击链接确认即注册成功，成功之后可以终端执行： 1pod trunk me 查看自己的注册信息，以后当你有了自己的开源Pod库，也可以用此方式随时查看自己发布过的Pods： 创建共享库文件并上传到公有仓库共享库需要三个必不可少的部分: 1.共享文件夹(文件夹存放着你要共享的内容, 也就是其他人pod得到的文件, .podspec文件中的source_files需要指定此文件路径及文件类型); 2.LICENSE文件(默认一般选择MIT); 3.库描述文件.podspec(本库的各项信息描述, 需要提交给CocoaPods, pod通过这个文件查找到你共享的库, .podspec文件的格式见第3点). 这一步分两种场景: 场景一：如果你已经有了现成的想要共享的文件,你只需要满足上面三个部分,即可上传到公有仓库即可继续其他的步骤; 场景二：你想要创建一个全新的工程去做自己的共享, 可以使用终端命令: 1pod lib create CollectionIndexToolsLib 需要输入一些模板参数： Cocoapods 会自动生成一个模板项目，目录结构： 123456789101112131415CollectionIndexToolsLib├── Example #demo APP│ ├── CollectionIndexToolsLib│ ├── CollectionIndexToolsLib.xcodeproj│ ├── CollectionIndexToolsLib.xcworkspace│ ├── Podfile #demo APP 的依赖描述文件│ ├── Podfile.lock│ ├── Pods #demo APP 的依赖文件│ └── Tests├── LICENSE #开源协议 默认MIT├── Pod #组件的目录│ ├── Assets #资源文件│ └── Classes #类文件├── PodCollectionIndexToolsLib.podspec #第三步要创建的podspec文件└── README.md #markdown格式的README 编辑.podspec文件以CollectionIndexToolsLib.podspec为例:123456789101112131415161718192021Pod::Spec.new do |s| s.name = 'CollectionIndexToolsLib' s.version = '0.1.0' s.summary = 'Custom IndexTools similar to TableViews index bar' s.description = &lt;&lt;-DESC I believe you must have thought about adding an index like Table View to Collection View. I will give you one today. DESC s.homepage = 'https://github.com/ReverseScale/CollectionIndexToolsLib' s.license = 'MIT' s.author = &#123; 'ReverseScale' =&gt; 'reversescale@icloud.com' &#125; s.source = &#123; :git =&gt; 'https://github.com/ReverseScale/CollectionIndexToolsLib.git', :tag =&gt; s.version.to_s &#125; s.ios.deployment_target = '8.0' s.source_files = 'CollectionIndexToolsLib/Classes/**/*' s.requires_arc = trueend 理论上前面的设置就可以通过验证，下面是注释参照：1234567891011121314151617181920212223242526272829Pod::Spec.new do |s| s.name = \"PodTestLibrary\" #名称 s.version = \"0.1.0\" #版本号 s.summary = \"Just Testing.\" #简短介绍，下面是详细介绍 s.description = &lt;&lt;-DESC Testing Private Podspec. * Markdown format. * Don't worry about the indent, we strip it! DESC s.homepage = \"https://coding.net/u/wtlucky/p/podTestLibrary\" #主页,这里要填写可以访问到的地址，不然验证不通过 # s.screenshots = \"www.example.com/screenshots_1\", \"www.example.com/screenshots_2\" #截图 s.license = 'MIT' #开源协议 s.author = &#123; \"wtlucky\" =&gt; \"wtlucky@foxmail.com\" &#125; #作者信息 s.source = &#123; :git =&gt; \"https://coding.net/wtlucky/podTestLibrary.git\", :tag =&gt; \"0.1.0\" &#125; #项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS # s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;' #多媒体介绍地址 s.platform = :ios, '7.0' #支持的平台及版本 s.requires_arc = true #是否使用ARC，如果指定具体文件，则具体的问题使用ARC s.source_files = 'Pod/Classes/**/*' #代码源文件地址，**/*表示Classes目录及其子目录下所有文件，如果有多个目录下则用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置 s.resource_bundles = &#123; 'PodTestLibrary' =&gt; ['Pod/Assets/*.png'] &#125; #资源文件地址 s.public_header_files = 'Pod/Classes/**/*.h' #公开头文件地址 s.frameworks = 'UIKit' #所需的framework，多个用逗号隔开 s.dependency 'AFNetworking', '~&gt; 2.3' #依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependencyend 编写完成后, 我们需要验证.podspec文件的合法性, 这里需要终端cd到.podspec文件所在文件夹, 执行:忽视警告：–allow-warnings 1pod lib lint CollectionIndexToolsLib.podspec 如有警告或者错误请重新检查你的编写正确性，如果没有问题会出现： 123-&gt; CollectionIndexToolsLib (0.1.0)CollectionIndexToolsLib passed validation. 打tag, 发布一个release版本一切准备就绪后, 我们需要在你的git仓库里面存在一个与.podspec文件中一致的version, 这里你可以在你的git仓库中的releases一项去手动发布, 也可以在当前文件夹下使用终端命令: 12git tag -m &apos;🔖:Releasing tags.&apos; &apos;0.1.0&apos;git push --tag #推送tag到远端仓库 成功之后即可在你的 releases 里面看到这个 tag 的版本. 发布自己的库描述文件podspec给cocoapods同样在这个文件夹下, 终端执行:忽视警告：–allow-warnings 1pod trunk push CollectionIndexToolsLib.podspec 将你的库文件.podspec文件提交到公有的specs上面, 这一步做的操作是验证你的podspec文件是否合法+提交到specs中(等同于fork;commit;push)+将上传的podspec文件转成json格式文件)，成功后会出现Congrats信息。 成功上传后等待片刻就可以用查找命令找到你的库： 1pod search CollectionIndexToolsLib 日后维护更新开源库如果有错误或者需要迭代版本,修改工程文件后推送到远端仓库后, 需要修改podspec中的版本号, 并重新打tag上传, 再进行新一轮的验证和发布.如果在开发过程中发现某基础组件存在 bug 需要更新 Pod，具体操作步骤如下： 修改 podspec 文件中的 s.version; 修复 bug 并对项目打 tag，tag 名称和 s.version 一直并 push 到远程仓库。 验证 podspec 文件的有效性； 推送 podspec 文件到远程仓库； 执行 pod search RRCache 验证结果； 实用：组件化私有库组件化的实用之处请参考《移动端 iOS 年终工作总结-纯干货请自备酒水》（https://juejin.im/post/5a934dfa6fb9a0634514d8a9） 私有Pod库和公有Pod库的创建方式没有什么区别, 不一样的是管理他们的 spec repo 不一样. 所以我们需要自己创建一个跟CocoaPods/Specs类似的仓库来管理内部创建的Pod库的podspec文件, 供内部人员更新和依赖使用内部Pod组件库. 私有repo的构建形式有两种, 一种是私有git服务器上面创建，一种是本机创建. 本机创建请参考官方文档:Private Pods, 这里介绍的是在公司内部搭建的git服务器上面创建整个服务的方式. 创建一个git仓库用来做内部私有库的Spec Repo在私有服务器一个仓库,一个用来存放所有共享库的podspec, 这里创建好之后的内部SSH协议地址是:https://gitee.com/WhatsXie/LibComponent.git, 花钱买git的私有仓库或者使用其他免费的第三方git服务(如Bitbucket等)创建的私有仓库给到的http/https地址也一样.终端输入命令:1pod repo add LibComponent https://gitee.com/WhatsXie/LibComponent.git 将LibComponent添加到本地repo, 添加成功后可以在/.cocoapods/repos/目录下可以看到官方的specs:master和刚刚加入的specs:LibComponent 如果有其他合作人员共同使用这个私有Spec Repo的话在他有对应Git仓库的权限的前提下执行相同的命令添加这个Spec Repo即可. 创建私有Pod组件库继续创建一个私有仓库,用来建立需要共享的内部组件, 以RSGuidePageLib为例:https://gitee.com/WhatsXie/RSGuidePageLib.git 可以创建示例工程, 像创建公有的库一样, 填写自己的podspec文件 1234567891011121314151617181920212223242526272829Pod::Spec.new do |s|s.name = 'RSGuidePageLib's.version = '0.3.0's.summary = 'Custom guide page package's.description = &lt;&lt;-DESCSwift implementation of the guide page package, support for multiple pictures and video guide pageDESCs.homepage = 'https://gitee.com/WhatsXie/RSGuidePageLib.git's.license = &#123; :type =&gt; 'MIT', :file =&gt; 'LICENSE' &#125;s.author = &#123; 'ReverseScale@icloud.com' =&gt; 'reversescale' &#125;s.source = &#123; :git =&gt; 'https://gitee.com/WhatsXie/RSGuidePageLib.git', :tag =&gt; s.version.to_s &#125;s.ios.deployment_target = '8.0's.swift_version = '3.2's.source_files = 'RSGuidePageLib/Classes/**/*'s.requires_arc = true 值得注意的是:podspec文件中的homepage和source不支持ssh协议地址,所以我们得放入http/https地址. 与公有库的创建方式一样, pod lib lint Category.podspec验证成功之后push到仓库, 然后打tag发布release版本. 然后将podspec加入私有Sepc repo中公有库使用trunk方式将.podspec文件发布到CocoaPods/Specs, 内部的pod组件库则是添加到我们第一步创建的私有Spec repo中去, 在终端执行:–allow-warnings 忽略警告–private 私有库 1pod repo push LibComponent RSGuidePageLib.podspec 添加成功之后LibComponent中会包含RSGuidePageLib库的podspec信息, 可以前往~/.cocoapods/repos下的LibComponent文件夹中查看, 同时git服务器中的远端也更新了. 移除私有Repo 1pod repo remove [name] 查找和使用内部组件库执行pod search Category就能查到刚刚创建好的Category库了, 然后在想要使用此组件的工程的Podfile中加入pod ‘Category’, ‘~&gt;1.0.1’即可使用内部组件啦！ 值得注意的是:必须在Podfile前面需要添加你的私有Spec repo的git地址source, pod install时, 才能在私有repo中查找到私有库, 像这样: 1234567891011# Uncomment the next line to define a global platform for your projectsource &apos;https://github.com/CocoaPods/Specs.git&apos;source &apos;https://gitee.com/WhatsXie/LibComponent.git&apos;# platform :ios, &apos;9.0&apos;target &apos;Demo&apos; dopod &apos;RSGuidePageLib&apos;, &apos;~&gt;0.3.0’end 经过测试, 这种方式可以把你的所有可以拆分出来的组件, 甚至是业务都来使用Pod管理, 这样达到了解耦和单项更新优化。某些组件不影响老版本的依赖使用, 出现问题修改Podfile中的依赖版本即可随时回滚, 给开发了带来极大的便利。 参考链接 CocoaPods创建公有和私有Pod库方法总结（https://www.aliyun.com/jiaocheng/376300.html） CocoaPods Guides(https://guides.cocoapods.org) Private Pods(https://guides.cocoapods.org/making/private-cocoapods.html) 手把手教你发布代码到CocoaPods(Trunk方式)(http://www.cnblogs.com/wengzilin/p/4742530.html) 使用Cocoapods创建私有podspec(http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/) COCOAPODS创建私有PODS(http://www.cnblogs.com/tufeibo/p/5654268.html) CocoaPods 组件化实践 - 私有Pod(https://www.jianshu.com/p/475d6b6d5600)","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"最简便的方式让你的应用接入 Emoji","slug":"Emoji Keyboard","date":"2016-11-20T03:56:27.000Z","updated":"2018-11-16T13:30:46.211Z","comments":true,"path":"2016/11/20/Emoji Keyboard/","link":"","permalink":"https://reversescale.github.io/2016/11/20/Emoji Keyboard/","excerpt":"不知道从什么时候开始，Emoji 表情无处不在。它们每天被数百万人使用，或喜或悲或猥琐，是一个无与伦比的表达工具~","text":"不知道从什么时候开始，Emoji 表情无处不在。它们每天被数百万人使用，或喜或悲或猥琐，是一个无与伦比的表达工具~ 我们相信，用户不应该被限制在 Unicode 库中，我们构建了这个键盘，以增加所有与我们合作的应用程序的参与度，保留率和收入。 👨🏻‍💻 Github Demo 🤖 要求 iOS 9.0+ &amp; Android Xcode 9.0+ Swift / Objective-C 🚀 准备开始Makemoji 应用内键盘是我们 SDK 的核心。 这是一个动态控制的表情符号键盘与紧密集成的文本输入，由我们的CMS和仪表板支持。 您可以创建自己的类别，上传 emoji / gifs 并沿着 unicode 表情符号跟踪其使用情况。 我们的文本输入的输出是一个简单的 HTML 消息，以及一个纯文本版本和我们所谓的“替代”版本，它使用一个简单的模板系统。 这个输出可以保存在您的设备上，后端或您选择的任何地方。 🎨 测试 UI 什么样子？ 展示页 展示页 展示页 输入前样式 文字键盘样式 表情键盘样式 🎯 安装方法安装在 iOS, 你需要在 Podfile 中添加.1pod &quot;Makemoji-SDK&quot; 如果你使用 Android, 添加在工程 build.gradle 目录下123456789dependencies &#123; compile &apos;com.makemoji:makemoji-sdk-android:0.9.777&apos;&#125; repositories &#123; jcenter() maven &#123; url &quot;https://dl.bintray.com/mm/maven/&quot; &#125;&#125; 设置你的 SDK Key要获得您的SDK密钥，请发送电子邮件至sdk@makemoji.com 要开始使用MakemojiSDK，您将首先设置您的SDK密钥。 iOS 在 AppDelegate 中:1#import &quot;MakemojiSDK.h&quot; 12345- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // setup your SDK key [MakemojiSDK setSDKKey:@&quot;YOUR-SDK-KEY&quot;]; return YES;&#125; Android 在 AndroidManifest.xml:123&lt;application android:name=&quot;com.makemoji.sbaar.mojilist.App&quot; ... 和 App.java12345public void onCreate()&#123; super.onCreate(); Moji.initialize(this,&quot;YOUR_KEY_HERE&quot;); //Moji.setUserId(&quot;Google ad id here if needed&quot;); // optional custom user id for analytics&#125; 🛠 配置设置假设您有一个应用程序的聊天区域，并且您希望使用我们的键盘来让用户在对话中共享独特的表情符号。 让我们开始设置我们的文本输入对象属性。 1234#import &quot;METextInputView.h&quot;@interface ViewController : UIViewController &lt;METextInputViewDelegate&gt;@property (nonatomic, retain) METextInputView * meTextInputView; METextInputView 是一个容器对象，它包含导航/趋势图栏以及文本输入。 这是为了解决苹果的InputAccessoryView的某些技术限制，尽管这种行为非常相似。 在 viewDidLoad 或 init 视图控制器中，初始化 METextInputView。12self.meTextInputView = [[METextInputView alloc] initWithFrame:CGRectZero];self.meTextInputView.delegate = self; 您需要将自己分配给委托，以侦听事件的回调，如点击发送或照相机按钮和键盘事件。 接下来，我们需要确定我们要在页面上使用什么类型的输入。 浮动输入如果你的应用程序需要一个浮动的 iMessage 类型的文本输入，你可以简单地将 METextInputView 添加到你的视图中。 1[self.view addSubview:self.meTextInputView]; 这个默认模式在键盘之后，随着一个摄像头/发送按钮，并且当用户输入一个长消息时，扩展到全屏。 METextInputView 遵循 ‘firstResponder` 模式来隐藏/显示键盘。 有很多方法可以定制这个输入和导航栏的外观和感觉。 我们将在 Customizations 中介绍 分离的输入如果您需要从键盘分离的文本输入，您将需要调用 detachTextInputView 方法，然后将 textInputContainerView 添加到您的视图。 12[self.meTextInputView detachTextInputView:YES];[self.view addSubview:self.meTextInputView.textInputContainerView]; 由于“发送按钮”和“摄像头”按钮在此模式下处于隐藏状态，因此您需要在 METextInputView 的 sendMessage 方法上附加一个按钮来触发捕获文本。 输入大小变化当使用我们的浮动输入时，您将希望在显示键盘时使用 didChangeFrame 委托回调来调整周围的视图。 123-(void)meTextInputView:(METextInputView *)inputView didChangeFrame:(CGRect)frame &#123; self.tableView.frame = CGRectMake(self.tableView.frame.origin.x, self.tableView.frame.origin.y, self.tableView.frame.size.width, self.meTextInputView.frame.origin.y);&#125; 发送消息Makemoji 消息由三部分组成：一个完全形成的HTML消息，一个ASCII兼容的明文消息和一个 substitute 消息。 你使用哪一个取决于你的消息存储是如何配置的。 替代文本允许您将带有Makemoji表情符号占位符的明文存储为文本的一部分。 这是一个示例消息。 12345&#123; html = &quot;&lt;p dir=\\&quot;auto\\&quot; style=\\&quot;margin-bottom:16px;font-family:&apos;.SF UI Text&apos;;font-size:16px;font-weight:bold;\\&quot;&gt;&lt;span style=\\&quot;color:#000000;\\&quot;&gt;Hey lets play &lt;/span&gt;&lt;img style=\\&quot;vertical-align:middle;width:20px;height:20px;\\&quot; src=\\&quot;https://d1tvcfe0bfyi6u.cloudfront.net/emoji/14-large@2x.png\\&quot; id=\\&quot;14\\&quot; link=\\&quot;\\&quot; name=\\&quot;Pacman\\&quot; /&gt;&lt;span style=\\&quot;color:#000000;\\&quot;&gt; at the &lt;/span&gt;&lt;img style=\\&quot;vertical-align:middle;width:20px;height:20px;\\&quot; src=\\&quot;https://d1tvcfe0bfyi6u.cloudfront.net/emoji/692-large@2x.png\\&quot; id=\\&quot;692\\&quot; name=\\&quot;Arcade\\&quot; link=\\&quot;\\&quot; /&gt;&lt;/p&gt;\\n&quot;; plaintext = &quot;Hey lets play at the \\n&quot;; substitute = &quot;Hey lets play [Pacman.E] at the [Arcade.BA]&quot;;&#125; 当用户点击 ‘sendButton时，didTapSend` 委托回调被触发，并返回一个包含html，plaintext和substitute消息的字符串的NSDictionary。 12345-(void)meTextInputView:(METextInputView *)inputView didTapSend:(NSDictionary *)message &#123; // send message to your backend here [self.messages addObject:message]; [self.tableView reloadData];&#125; 然后，您可以将选择的部分发送到后端以存储消息。 显示消息现在你已经有Makemoji消息了，我们需要设置一个显示它们的方法。 通常这将在 UITableViewCell 中，但您也可以使用任何自定义视图来显示消息。 我们已经包括一个优化的UITableViewCells用于显示HTML消息和一种方法来自动缓存你的表单元格高度。 这可以防止任何不必要的表情符号和文本布局，并提高性能。 这里是我们提供的信息显示的概述。 MESimpleTableViewCell这个单元格提供了一个基本的布局，默认情况下尝试使用整个单元格区域。 您将使用此单元格作为子类快速实现自定义表格单元格。 MEChatTableViewCell聊天单元提供一个iMessage，如聊天泡泡，间距，可设定的方向和颜色设置。 MECollectionViewCell简单表格单元格的集合视图版本。 MEMessageView单元的底层视图，消息的核心显示视图。 替代文字使用 substitute 类型的消息时，可以通过在 METextInputView 上使用下面的静态方法将其转换回HTML 1+(NSString *)convertSubstituedToHTML:(NSString *)substitute withFontName:(NSString *)fontName pointSize:(CGFloat)pointSize textColor:(UIColor *)color 高度缓存使用 cellHeightForHTML 方法获取消息的行高。 此方法缓存单元高度以提高性能。 123456789101112// determine row height with HTML- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; if (self.meTextInputView == nil) &#123; return 0; &#125; NSDictionary * message = [self.messages objectAtIndex:indexPath.row]; return [self.meTextInputView cellHeightForHTML:[message objectForKey:@&quot;html&quot;] atIndexPath:indexPath maxCellWidth:self.tableView.frame.size.width cellStyle:MECellStyleChat];&#125; 您可以通过重置 METextInputView 上的 cachedHeights 属性来手动重置 UITableViewCell 高度缓存。 表格单元格使用MEChatTableViewCell，您可以使用setCellDisplay在左侧或右侧显示聊天气泡。 这应该发生在为每个消息设置您的HTML之前。 12345678910111213141516171819202122- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; static NSString *CellIdentifier = @&quot;Cell&quot;; MEChatTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; if (cell == nil) &#123; cell = [[MEChatTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier]; &#125; // display chat cell on right side [cell setCellDisplay:MECellDisplayRight]; // display chat cell on left side if (indexPath.row % 2) &#123; [cell setCellDisplay:MECellDisplayLeft]; &#125; NSDictionary * message = [self.messages objectAtIndex:indexPath.row]; [cell setHTMLString:[message objectForKey:@&quot;html&quot;]]; return cell; &#125; Hypermoji - 带有URL的表情符号我们已经创建了一种新的方式来共享内容，浏览网页，观看视频或听音乐，而不用离开Hypermoji的应用程序。 要在Hypermoji（具有URL链接的表情符号）上点击时显示网页，请使用 didTapHypermoji 委托回调 1234// handle tapping of links (Hypermoji)-(void)meTextInputView:(METextInputView *)inputView didTapHypermoji:(NSString*)urlString &#123; // open webview here&#125; 相机按钮这是一个标准的UIButton，可以用图像或文本进行自定义。 要处理相机按钮的操作，请使用didTapCameraButton委托回调。 123-(void)meTextInputView:(METextInputView *)inputView didTapCameraButton:(UIButton*)cameraButton &#123; // Present image controller&#125; 自定义您可以通过在 METextInputView 上设置 displayCameraButton 属性来显示或隐藏内置摄像头 1self.meTextInputView.displayCameraButton = NO; 您可以通过在 METextInputView 上设置 displaySendButton 属性来显示或隐藏内置的发送按钮 1self.meTextInputView.displaySendButton = NO; 使用setFont你可以设置你的文本输入的默认字体。 1[self.meTextInputView setFont:[UIFont systemFontOfSize:20]]; 更改占位符文本的颜色 1self.meTextInputView.placeholderLabel.textColor = [UIColor darkGrayColor]; 控制锁定的类别您将需要侦听NSNotification MECategorySelectedLockedCategory 来确定什么时候锁定了一个类别。 要解锁一个类别，您需要调用 [MakemojiSDK unlockCategory：@“category”] 您可以收听 ‘MECategoryUnlockedSuccessNotification和MECategoryUnlockedFailedNotification` 以确定解锁呼叫是否成功。 📝 应用程序提交Makemoji SDK 使用IDFA跟踪ID来为您的应用程序中的视图，共享和点击进行归因。 将应用程序提交到 App Store 时，您需要检查“将此应用程序安装到以前投放的广告”选项。 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS 开发中常用的设计模式","slug":"Design patterns iOS","date":"2016-09-21T06:56:27.000Z","updated":"2018-11-16T13:25:33.846Z","comments":true,"path":"2016/09/21/Design patterns iOS/","link":"","permalink":"https://reversescale.github.io/2016/09/21/Design patterns iOS/","excerpt":"之前有朋友问到设计模式，便特意找了一篇文章，专门介绍在 iOS 开发中，对设计模式的具体应用，同时推荐一本书《Head First设计模式》~","text":"之前有朋友问到设计模式，便特意找了一篇文章，专门介绍在 iOS 开发中，对设计模式的具体应用，同时推荐一本书《Head First设计模式》~ （一）代理模式应用场景：当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。优势：解耦合敏捷原则：开放-封闭原则实例：tableview的 数据源delegate，通过和protocol的配合，完成委托诉求。列表row个数delegate自定义的delegate （二）观察者模式应用场景：一般为model层对，controller和view进行的通知方式，不关心谁去接收，只负责发布信息。优势：解耦合敏捷原则：接口隔离原则，开放-封闭原则实例：Notification通知中心，注册通知中心，任何位置可以发送消息，注册观察者的对象可以接收。kvo，键值对改变通知的观察者，平时基本没用过。 （三）MVC模式应用场景：是一中非常古老的设计模式，通过数据模型，控制器逻辑，视图展示将应用程序进行逻辑划分。优势：使系统，层次清晰，职责分明，易于维护敏捷原则：对扩展开放-对修改封闭实例：model-即数据模型，view-视图展示，controller进行UI展现和数据交互的逻辑控制。 （四）单例模式应用场景：确保程序运行期某个类，只有一份实例，用于进行资源共享控制。优势：使用简单，延时求值，易于跨模块敏捷原则：单一职责原则实例：[UIApplication sharedApplication]。注意事项：确保使用者只能通过 getInstance方法才能获得，单例类的唯一实例。java，C++中使其没有公有构造函数，私有化并覆盖其构造函数。object c中，重写allocWithZone方法，保证即使用户用 alloc方法直接创建单例类的实例，返回的也只是此单例类的唯一静态变量。 （五）策略模式应用场景：定义算法族，封装起来，使他们之间可以相互替换。优势：使算法的变化独立于使用算法的用户敏捷原则：接口隔离原则；多用组合，少用继承；针对接口编程，而非实现。实例：排序算法，NSArray的sortedArrayUsingSelector；经典的鸭子会叫，会飞案例。注意事项：1，剥离类中易于变化的行为，通过组合的方式嵌入抽象基类2，变化的行为抽象基类为，所有可变变化的父类3，用户类的最终实例，通过注入行为实例的方式，设定易变行为防止了继承行为方式，导致无关行为污染子类。完成了策略封装和可替换性。 （六）工厂模式应用场景：工厂方式创建类的实例，多与proxy模式配合，创建可替换代理类。优势：易于替换，面向抽象编程，application只与抽象工厂和易变类的共性抽象类发生调用关系。敏捷原则：DIP依赖倒置原则实例：项目部署环境中依赖多个不同类型的数据库时，需要使用工厂配合proxy完成易用性替换注意事项：项目初期，软件结构和需求都没有稳定下来时，不建议使用此模式，因为其劣势也很明显，增加了代码的复杂度，增加了调用层次，增加了内存负担。所以要注意防止模式的滥用。 设计模式六大原则1、开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle）为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle）原则是尽量使用合成/聚合的方式，而不是使用继承。 《Head First设计模式》http://pan.baidu.com/s/1nvTqSdj 验证码：DG58","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"https://reversescale.github.io/categories/Design-Patterns/"}],"tags":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/tags/Book/"}]},{"title":"GoF 设计模式 + 情景再现","slug":"Design patterns Gof","date":"2016-03-01T12:29:16.000Z","updated":"2018-11-16T13:25:39.532Z","comments":true,"path":"2016/03/01/Design patterns Gof/","link":"","permalink":"https://reversescale.github.io/2016/03/01/Design patterns Gof/","excerpt":"《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995），这几位作者常被称为”四人组（Gang of Four）”~","text":"《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995），这几位作者常被称为”四人组（Gang of Four）”~ 设计模式和情景再现创建型模式1、ABSTRACT FACTORY—追MM少不了请吃饭了，麦当劳的套餐和肯德基的套餐都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说“两个B套餐”就行了。麦当劳和肯德基就是B套餐的Abstract Factory, B套餐里含有汉堡, 鸡翅和饮料. 麦当劳或肯德基会根据B套餐的规格, 让汉堡Factory, 鸡翅Factory, 饮料Factory分别生产对应B套餐的材料。抽象工厂模式：客户类和工厂类分开。消费者任何时候需要某套产品集合时，只需向抽象工厂请求即可。抽象工厂会再向具体的工厂生产出符合产品集规格的产品。 2、BUILDER—MM最爱听的就是“我爱你”这句话了，见到不同地方的MM,要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出“我爱你”这句话了，国外的MM也可以轻松搞掂，这就是我的“我爱你”builder。（这一定比美军在伊拉克用的翻译机好卖）建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。 3、FACTORY METHOD—请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说“要一个汉堡”，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。 4、PROTOTYPE—跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype了。（100块钱一份，你要不要）原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。 5、SINGLETON—俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Singleton，她们只要说道“老公”，都是指的同一个人，那就是我。(刚才做了个梦啦，哪有这么好的事)单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。 结构型模式6、ADAPTER—在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的Adapter，让我和Sarah可以相互交谈了(也不知道他会不会耍我)适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。 7、BRIDGE—早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我“早上碰到MM新做了个发型怎么说”这种问题，自己用BRIDGE组合一下不就行了。桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。 8、COMPOSITE—Mary今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM都会用Composite模式了，你会了没有？合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。 9、DECORATOR—Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上“最好的的礼物，就是爱你的Fita”，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来……，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。 10、FACADE—我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。 11、FLYWEIGHT—每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。享元模式：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。 12、PROXY—跟MM在网上聊天，一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。 行为模式13、CHAIN OF RESPONSIBILITY—晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi,可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了，听说是个老处女呀，快跑!责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。 14、COMMAND—俺有一个MM家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送COMMAND，就数你最小气，才请我吃面。” :-(命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。 15、INTERPRETER—俺有一个《泡MM真经》，上面有各种泡MM的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟MM约会时，只要做一个Interpreter，照着上面的脚本执行就可以了。解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。 16、ITERATOR—我爱上了Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件”我：“什么条件我都答应，你说吧”Mary：“我看上了那个一克拉的钻石”我：“我买，我买，还有吗？”Mary：“我看上了湖边的那栋别墅”我：“我买，我买，还有吗？”……迭代子模式：迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。 17、MEDIATOR—四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。 18、MEMENTO—同时跟几个MM聊天时，一定要记清楚刚才跟MM说了些什么话，不然MM发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个MM说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。 19、OBSERVER—想知道咱们公司最新MM情报吗？加入公司的MM情报邮件组就行了，tom负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦观察者模式：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。 20、STATE—跟MM交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的MM就会说“有事情啦”，对你不讨厌但还没喜欢上的MM就会说“好啊，不过可以带上我同事么？”，已经喜欢上你的MM就会说“几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把MM的状态从不讨厌不喜欢变成喜欢哦。状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。 21、STRATEGY—跟不同类型的MM约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到MM的芳心，我的追MM锦囊中有好多Strategy哦。策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模式把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。 22、TEMPLATE METHOD——看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤(Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦(具体实现)；模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。 23、VISITOR—情人节到了，要给每个MM送一束鲜花和一张卡片，可是每个MM送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下Visitor，让花店老板根据MM的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。 设计模式之间的关系图： 设计模式的六大原则1、开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle）为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle）原则是尽量使用合成/聚合的方式，而不是使用继承。","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"https://reversescale.github.io/categories/Design-Patterns/"}],"tags":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/tags/Book/"}]}]}