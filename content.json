{"meta":{"title":"Technology","subtitle":"","description":"","author":"Tim's Blog","url":"https://reversescale.github.io"},"pages":[{"title":"Not found","date":"2018-11-15T12:15:47.151Z","updated":"2018-11-15T02:35:05.000Z","comments":true,"path":"404.html","permalink":"https://reversescale.github.io/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#fff;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#000;margin-top:260px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=5; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"About","date":"2015-08-16T06:58:08.000Z","updated":"2018-12-19T12:32:14.876Z","comments":false,"path":"about/index.html","permalink":"https://reversescale.github.io/about/index.html","excerpt":"","text":"Excellence is a continuous process and not an accident. Thanks for reading! ~ 👨🏻‍💻 职业：程序员劝退师📟 WeChat：WhatsXie🤪 不只生产 bug 更是 bug 的搬运工📮 邮件：ReverseScale@iCloud.com╰●●●●●●●●●●●●●●●●●●●●●●●●●●●●●●╯ Friends links友情链接 推荐 ☄️ Qtumist 量客：Qtumist(量子客)，为您解读量子科技的前沿技术动态，并致力于推动量子技术的普及与量子学习社区的建设。汇聚量子科学方面的研究者，并收录其精英人士们对该领域探索的经验； 🐍 CI_Knight Blog：资深 Python 工程师的葵花宝典，定期分享开发经验和学习心得，欢迎加入 PY Learning 微信群(2264380192)。 ⊙▂⊙ ⊙０⊙ ⊙︿⊙ ⊙﹏⊙ ⊙△⊙ ⊙▽⊙"},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2018-01-25T14:41:06.000Z","comments":true,"path":"archives/index.html","permalink":"https://reversescale.github.io/archives/index.html","excerpt":"","text":""},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2018-01-25T14:41:06.000Z","comments":false,"path":"categories/index.html","permalink":"https://reversescale.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2018-01-25T14:41:06.000Z","comments":true,"path":"tags/index.html","permalink":"https://reversescale.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"一位 70 后程序员的 24 个职场感悟（转）","slug":"Career planning","date":"2019-02-02T14:16:27.000Z","updated":"2019-02-02T14:37:22.892Z","comments":true,"path":"2019/02/02/Career planning/","link":"","permalink":"https://reversescale.github.io/2019/02/02/Career planning/","excerpt":"之所以搬运文章到自己的博客，可能是主人公的人生轨迹带来的感悟，与我一直坚守的价值观产生了强烈共鸣~","text":"之所以搬运文章到自己的博客，可能是主人公的人生轨迹带来的感悟，与我一直坚守的价值观产生了强烈共鸣~ 感悟 我的职场第一感悟：自学能力是竞争力之本。 我的职场第二感悟：自信能让你与众不同，尽管有时的自信有点莫名其妙。 我的职场第三感悟：兴趣是学习效率的催化剂，培养自己的职业兴趣。 我的职场第四感悟：学习应给自己设置虚拟的项目目标，以做项目的形式提升学习效果，只有这样学到的内容才会深入而实用，切忌无目标地学到哪算哪。 我的职场第五感悟：话语权首先来自能力，而不是职位权力。 我的职场第六感悟：难学的技能一旦掌握更具竞争优势。 我的职场第七感悟：用阶段性成果不断增强自己的自信，且最终支持自信的是能力，而不是自大。 我的职场第八感悟：做自己喜欢的事，如果那是自己的兴趣最好。 我的职场第九感悟：不论身处多么困难的环境，即使觉得前途渺茫，也不要放弃学习，否则就是“自断筋脉”。 我的职场第十感悟：长期安逸的工作意味着将来更大的风险。 我的职场第十一感悟：机遇很重要，但你得有能力才能抓住它。 我的职场第十二感悟：职场首先比拼的不是智商，而是坚持与好习惯。 我的职场第十三感悟：当短期利益与长远利益无法得兼时，选择长远利益。 我的职场第十四感悟：学历是很重要的敲门砖，即便你的能力很强；学历尽管很重要，但能力才是最终的通行证。我的职场第十五感悟：技术细节掌握得越深，解决问题时就越能游刃有余。 我的职场第十六感悟：技能的发展应采取深度先于广度且交替进行的方式，只有这样，面对大量的新知识才能更淡定。 我的职场第十七感悟：越难的技术问题，其所蕴藏的知识越丰富，也越具学习价值。 我的职场第十八感悟：每次积累的点滴知识，一定会在将来不知不觉地发挥效能。 我的职场第十九感悟：通过文档化的方式传承知识给后继者是你的基本责任，因为你作为后继者时也希望如此，这也是对自己负责的一种表现。 我职场第二十感悟：别人对你价值的认可，其实不是简单地根据你的自身能力，而是根据你对他人和团队的贡献。 我的职场第二十一感悟：英语的听说能力只要有合适的环境，并勇于张嘴练习的情况下能快速地提高，不必担心。我的职场第二十二感悟：在软件开发活动中，应设法通过有效的技术途径去解决工程困境。 我的职场第二十三感悟：不要用沉默的方式一味地迎合别人的要求，据理力争或许才是作为的表现。 我的职场第二十四感悟：流程、文档的作用，不只是引导我们做完事，更能规范我们的行为和帮助培养工作习惯。 █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 引子年龄是一个永恒的话题，不论是演员、运动员，或是身边的程序员。岁月带来了经验上的积累和虑事的周全，但也带走了年轻时候的体力和冲劲。 在上周末阿里巴巴中间件举办的APM深度交流技术沙龙上，出现一位白发高龄程序员，一个本子、一支笔、一台笔记本，正记录着台上80后和90后开发者分享的分布式系统下的压测、监控和可用性的话题，free talk期间，还和年轻程序员聊起了算法、架构和开发效率的话题。 技术变化太快，大龄程序员对新技术的兴趣、学习和接受能力可能不如以前，年龄成为大龄程序员走出舒适区最大的障碍之一。但我们身边总会有一些年龄虽长，依旧保持乐观、皮实、自省的前辈，不断的进行自我迭代，跳出舒适区，我想，这是否就是技术成长道路上最为关键的品质？本文整理自70后程序员至简于2012年底写的一篇博客，时间虽然有点久远，但文中内容从现在来看，似乎比6年前更为受用。 正文 时至今日的职场生涯中，每当我与同事分享自己的成长经历，总会有人为之振奋（希望你读这篇文章时也能感受到），或许以我的成长经历作为本文的写作主线是一个不错的选择！通过这篇文章，你可以看到一个1997年毕业的大专生（毕业于南昌水利水电高等专科学校，现更名为南昌工程学院）、一个在高二时英语还只考29分的人，是如何一步一步成为Motorola的软件架构师的。（至简目前就职于阿里巴巴中间件团队） 在继续读下去之前，读者应认识到一点：个人观点的独特性与自身的成长经历有很大的关系。因此，千万不要盲从，而应时刻保持一种批判接受的态度。或者说，你得有自己的观点，你（也只有你自己）得对自己的职业发展负责！另外，文章主线是自传形式，如果你对我的成长经历不感兴趣，可以快速地略读，只关注文中highlight的24点职场感悟。 学生时代故事的开始得从大学以前开始。从小受“学好数理化，走遍天下都不怕”观念的影响，我认为只要学好数理化就行了，所以偏科很严重，高二时英语还考过29分。那时也不爱读书，高三时，别的同学在复习，我却在看《晶体管技术》这类电子技术书。这种状态，直接的结果就是第一次高考落榜了。 落榜的那个暑假，父母为我的出路没少操心。在一天早晨刷牙时，当我妈对我说希望我去复读时，我当时脑海里想“能像表哥那样考上大学那该多好啊！”，在这个念头驱使下，我答应了去复读。从那天开始，我顿悟了，真正知道自己要什么了。在复读的一年里，我学到的一种重要能力是— 自学，这为以后大学乃至职场学习打下了很好的基础。正因如此，我想给出： 我的职场第一感悟：自学能力是竞争力之本。 经过复读，高考总成绩提高了100多分，但也只够专科线。最终，我被南昌水利水高等专科学校录取，专业是“供用电技术”。这个专业相信很多人不知其然，其实就是电力自动化的变种专业，其专业内容主要是电站、发电厂高电压的继电保护技术。 大学读书期间，我开始有与人在成绩上一争高下的念头了，加上复读一年所获得的自学能力，以及自己的努力，学习相当轻松，尤其是只要与电子技术沾边的课程，都能轻松地拔得头筹。三年共六个学期的学习，我拿了五个一等奖学金，一个二等奖学金。毕业时，我是系里唯一的一名优秀毕业生。期间通过了大学英语四级考试和计算机二级考试，获得了江西省电子技能比赛一等奖。需要提及的是，在大学期间所学的与计算机相关的课程只有：《电子技术基础》、《计算机组成原理》、《计算机软件基础》、《单片机技术》和《Basic编程语言》。 第一份工作 - 电气设计工程师在大学期间，我还完成了人生很重要的一件事 — 找好了现在的妻子。由于她是浙江人，所以毕业时工作地点毫不犹豫地选择了杭州。那时很多同学的工作还是包分配的，而我来到了杭州的人才市场进行双向选择，那时找一份工作还是相对轻松的（注：我们大学录取那年的招生人数是90多万），投出一份简历就找好了工作。第一个工作单位是一家不到100人、地处杭州花港观鱼对面（三台山）的电力设备制造民企。 尽管选择去这家民企后立马到公司去做了实地调查，但由于没有社会经验，加上被问的人没如实反应，所以进入这家民企后所了解的情况让人大跌眼镜。另外也了解到单位会通过一些不入流的做法控制我们的户口，不让我们跳槽（那会儿的户口还是相当重要的，结婚要户口证明，有同事就因为户口被控制而登记不了）。而我们在进入这家单位时签订了六年的劳动合同。在这样的小企业干上六年意味着什么？！当时与家人打电话告知这一状况时，我都哭出来了（就在现在杨公堤与虎跑路交叉的、现早已不存在的一个电话亭里，记忆犹新呀！）。 尽管前途是那样的渺茫，但带有“优秀毕业生光环”的我仍坚信自己能做得比别人更好，因为有我的： 我的职场第二感悟：自信能让你与众不同，尽管有时的自信有点莫名其妙。 在这个企业一开始的工作职责是电站设备的电气设计工程师，需要AutoCAD（到单位后学的）设计电气图纸，并指导工人最终完成电气设备装配及调试。期间，企业经营范围扩大，需要从事电子设备的生产，因此我开始有机会接触电子技术方面的设计工作。在兄弟单位一同事的帮助下，在一个星期内我掌握了如何用Tango（后来更名为Protel，现在的名称是Altium Designer）进行原理图和PCB线路板设计。而且，这一个星期的设计结果最终成为了电气产品的一个部件。对于一个毕业不到一年的我来说，这是不小的进步。那时知道了什么是网络表、过孔、焊盘等，掌握了很多电子原件的工作原理（有的还自己用面包板做实验），明白了做电路板的大致业务流程，还能动手焊接电路板，熟练运用示波器和万用表进行调试。那段时间，我对电子技术的兴趣帮上了大忙，学习起来远比别人快。当我精通电路原理，能自如运用示波器和万用表调试电子产品时，别人却还不明白我的调试动机。 我的职场第三感悟：兴趣是学习效率的催化剂，培养自己的职业兴趣。 第一次真正对编程感兴趣是从知道PLC（Programming Logic Controller）开始的。当时的电站设备采用了三菱的PLC，为了配合这一电气产品的需要，企业社招了一名懂PLC编程的工程师。由于老板担心我们相互学技术而“翅膀变硬”，所以明确提出工程师所掌握的技能不能互通有无。当时看到这位兄弟能通过“梯形图”改变PLC的行为，真是觉得他太神气了，仰慕不已。后来通过这位兄弟的私下帮助（哥们呀！），我晚上偷偷地在厂房里面学习PLC编程。为了获得良好的学习效果，我设定了对电气产品的PLC程序进行重写的目标，且最终达成了这一目标（当然，由于这个目标不能让老板知道，所以我的PLC程序不能用于商用）。 我的职场第四感悟：学习应给自己设置虚拟的项目目标，以做项目的形式提升学习效果，只有这样学到的内容才会深入而实用，切忌无目标地学到哪算哪。 从电气产品的技术负责人到软件工程师一年多的功夫，我成为了某电气产品的技术负责人，对整个产品的所有技术细节都了如指掌，我带领了其他几个工程师实现了该产品的“自主研发”。有趣的一件事是，老板当时并不知道我已经“翅膀硬了”，想抵赖答应过的8000元项目奖金，年轻气盛的我在与之拍完桌子之后对其他工程师下令：“没有我的允许，谁也不能将电气图纸和电路原理图用于生产”（因为年经，所以二！）。对抗的结果以老板兑现承诺而告终。这时我隐约地有了： 我的职场第五感悟：话语权首先来自能力，而不是职位权力。 我那时还学会了CRC算法并将之运用于PLC的串口通讯中，但对于计算机如何通过串口与PLC通讯获得采集数据存在很大的好奇心。于是想到了学习编程语言，并计划做一个能在计算机上实时显示PLC所采集数据的软件。在向PLC编程的兄弟表达了这一想法后，他给我的建议是：学习C语言比较难，Basic语言则更容易。于是，我毫不犹豫地选择了自学C语言，因为我深信： 我的职场第六感悟：难学的技能一旦掌握更具竞争优势。 也正是从那时开始，我真正开始了成为软件工程师的自学旅程。那时比较幸运的是，单位专为我配备了工作电脑，所以具备了自学的硬件条件。由于那时Internet还不普及，学习书籍都来自浙江大学的科海书店（后来眼见着它的店面越来越小，这也是进入电子商务时代的一个缩影），那时隔三叉五地到科海去找书，生活最大的花费就在于购书（那时这方面的书不少是质次价高）。当然，学习的过程或多或少还得瞒着老板。那段时间，别人午休我就编程，除了看书和做书后的习题，还一直朝实现自己的计算机监控软件这个目标迈进（参见我的职场第四感悟）。 终于有一天，我用Turbo C在DOS环境下实现了具有串口通讯功能的、基于图形界面的监控软件（如果你用现在的眼光看那个软件，一定会说“很土”）。当我乐此不疲地向他人演示时，你可以想象我那时有多高兴和自豪！这种小小的成功助长了我的信心，也让我感受到了： 我的职场第七感悟：用阶段性成果不断增强自己的自信，且最终支持自信的是能力，而不是自大。 尝到了成功甜头的我随后拓展了自己就软件开发方面的学习内容。那时的我已经下定决心要向软件开发方向发展，这种选择是因为： 我的职场第八感悟：做自己喜欢的事，如果那是自己的兴趣最好。 我的第一份专职软件工程师工作1999年的某月，在企业拖欠了一个月工资的情形下，“蓄谋”逃离企业束缚的我们（共19个工程师）经过几个月的劳动仲裁后，与企业解除了劳动合同。在离开这家民企的第二天，1999年11月的某天，我在浙江大立机电技术开发公司（即现在的大立科技。后面都简称为大立公司）找到了第一份专职的软件开发工作。我逃离束缚后能很快地找到新的支点，完全得感谢我的： 我的职场第九感悟：不论身处多么困难的环境，即使觉得前途渺茫，也不要放弃学习，否则就是“自断筋脉”。 在大立公司所参与的第一个软件项目，是使用Visual C++从事Windows某变电站图像监控桌面软件的开发。尽管我之前自学过C++语言，但那时并未完全掌握面向对象编程，尤其是其中的多态。我在该桌面软件中借鉴微软的示例软件DrawCli，独立地实现了电子地图功能。正是通过掌握这个示例软件的设计与实现，我真正领悟到了面向对象设计的好处。也通过该图像监控桌面软件的开发经历，掌握了Windows VxD驱动开发、Socket通讯、多线程编程、图像处理（锐化、伪彩处理、图像字符识别和图像对比等）、ODBC数据库编程（用的是SQL Server）等。 这里要插一个与我妻子相关的小故事。她是我大学的同班同学，毕业以后进了诸暨供电局从事农网预算工作。我在第一家民企工作时，时常往返于两地，有时觉得很是辛苦。另外，妻子在供电局安逸的工作环境下，时常会开玩笑说老了要是下岗了都不知能干什么。 在我进入大立公司不到一年的时间里，我向公司提出了可否让她到公司来从事软件开发工作。当时在我妻子没有任何面试和编程经验（她当时只自学了谭浩强老师的《C程序设计》和一本C++的书，忘记书名了）的情况下，公司让她过来了，我想这是缘于公司对我的器重（这里要谢谢庞总和章总两位老总！）。自然，我成了妻子学习编程的老师。我的岳父岳母当时对于妻子放弃供电局的工作尽管不舍，但还是尊重了我们的想法，谢谢他们的开明。支持我们做出这一决定，除了为了解决两地分居问题，还有： 我的职场第十感悟：长期安逸的工作意味着将来更大的风险。 我在大立公司的职业机遇在妻子进入大立公司不久，由我担纲了新版图像监控软件的重新开发，这是我第一次担任软件项目负责人。在这个项目上，我可以从技术层面尽情发挥，将我在老版本软件上所看到的设计不足完全克服。也正是通过这个软件项目，我的面向对象编程能力有了很大的提高，而且完整地做过了一个软件产品。用我现在的眼光来看：那时的开发工作除了引入了版本控制软件外，是不折不扣的作坊式软件开发；至于管理技能的提高，也可以说是微乎其微。 2000年底，大立公司因为业务拓展的需要，需开发嵌入式图像监控系统（系统中的前端产品是后来数字硬盘录象机的前身）。为此，公司社招了一位比我年长十岁的资深硬件开发工程师，他在进公司时已经有基于AMD的Elan SC520 x86嵌入式微控制器的硬件开发经验。他在进公司之初与章总交谈时指出：“做这类嵌入式产品，需要软件功底非常强的人”，章总的回答是：“你放心好了，我一定找一个最好的人与你搭档”（章总后来告诉我的）。是的，所找的那个人就是我！而其实那时我只有用Visual C++从事Windows桌面软件的开发经验，可见公司领导对我能力之信任！ 我的职场第十一感悟：机遇很重要，但你得有能力才能抓住它。 我当时所面临的技术挑战，读者可以想象。要知道，在2000年时基于x86微控制器的嵌入式系统的开发人员国内还很少。我的自学能力、电子爱好的兴趣在这种挑战面前又帮了大忙。其实，做嵌入式系统开发最主要的是参考各种资料以便掌握各类技术细节，这得通过大量地阅读芯片手册、用户手册，以及研究AMD在其官网上所提供的示例程序。在这个过程中，就技术困惑坚持探究和养成各种好的工作习惯（思考习惯、笔记习惯、总结习惯、阅读习惯）非常重要。 我的职场第十二感悟：职场首先比拼的不是智商，而是坚持与好习惯。 我独自完成了该嵌入式前端产品上的软件开发工作。其中包含的大致技术内容有：从编程的角度精通x86处理器架构； PCI、IDE硬盘、网卡、串口、闪存等总线或外设的驱动；实时操作系统内核的移植工作；MINUX操作系统的文件系统的移植； XINU操作系统的TCP/IP协议栈的移植工作。移植工作往往会碰到各种技术细节问题，等移植工作完成，对被移植模块的实现和背后的原理也已了如指掌。正应如此，这一时期的工作让我对操作系统的实现原理有了很深的理解。 除了软件方面的进步，我在大立公司时的硬件知识也得到了很强扩充。不仅能轻松地阅读数字电路原理图，还自学了VHDL语言，使得拿到逻辑器件CPLD的VHDL程序就能调试软件（通过VHDL程序，可以了解编程所需的译码端口、相关信号的操作时序等）。还学会了如何使用逻辑分析仪辅助软件调试工作。前面提到的这位兄长式硬件工程师调侃我说：“你让我看到了中国软件的希望！”，而我将这话当成了对自己的鼓励。另外，这期间还考入了浙江大学专升本的通讯工程专业，给自己充电（2001年入学，2004年毕业，获多学期“优秀学生”和“优秀毕业设计”）。 入职 UTSarcom由于大立公司是浙江省测试技术研究所的子公司，它或多或少带有事业单位的气息。加上公司的技术舞台有限，以及妻子也在同一家公司工作，我于2003年4月份左右离开了大立公司。在我离开之前，浙江省科委已批复了公司的申请，分配给我一套福利房。在我离开之时，房子仍在建，不少同事对于我的离职很是不解，也劝我拿到房再走。但我有： 我的职场第十三感悟：当短期利益与长远利益无法得兼时，选择长远利益。 在大立公司工作期间，很希望自己能入职UTStarcom这样的通讯企业（那时的UTStarcom是多么地辉煌！）。计划离开大立公司之际，我向UTStarcom提交了求职简历。这次求职开始好像很顺利，但到我真正入职UTStarcom的过程却很是曲折。 一开始当我收到UTStartcom的面试通知时，可能太希望能进入这个公司了，在没有很深入了解这个岗位的前提下，就去面试了，且马上拿到了Offer。但后来才了解到，我拿到的是生产部测试开发岗位，与实际研发部门是有区别的。 当时很纠结 — 这是我想进的公司，但却不是我想要的岗位。如果拒绝生产部的Offer，我很有可能与UTStarcom无缘。考虑再三，我还是选择了拒绝（参见我的职场第十三感悟）。并重新向研发部门投了简历。 经过度日如年的一个多月等待（那会儿刚好发生了SARS疫情），在觉得入职UTStarcom研发部门无望的情况下，我入职了另外一家小公司。令人意外的是，在入职那家公司的第二天，我收到了UTStarcom研发部门的面试通知。在HR面试的那一轮中，HR对我说，“你是我所面试的人中最有工作激情的”。那时的技术面试官中，其中一位是我日后入职后的上司 — 夏青，他是我的伯乐。由于我的学历问题，在技术面试通过后，别人只要一位VP面试通过就行，我却需要两位。 我的职场第十四感悟：学历是很重要的敲门砖，即便你的能力很强；学历尽管很重要，但能力才是最终的通行证。 2003年6月份左右，我正式入职UTStarcom研发部，从事小灵通基站控制器（后面简称为基站控制器）的软件开发工作，也从此踏入通讯行业。在入职之初，由于自认为对于操作系统的原理很精通，又完整地做过软件项目，有点飘飘然，觉得自己是个“小牛牛”。然而，入职后一接触工作就发现，内容没有想象的那么简单！ 首先，基站控制器的软件规模比我以前主导开发的项目要大很多，而且需要熟悉通讯行业的相关信令。其次，尽管我那时精通x86处理器，基站控制器用的却是PowerPC 8250，这意味着我得重新掌握它。再次，实时操作系统用的是前美国军方的、开源的RTEMS，那是我第一次接触。最后，UTStarcom的工作语言是英语，写文档和邮件都得用英语。尽管我那时能无障碍地阅读MSDN和各类芯片手册，但要着手写，却是一大挑战（口语不作要求，因为不需直接接触老外）。 一入职所分配的工作是网元网管部分告警抑制软件模块的开发。尽管PowerPC处理器和RTEMS操作系统技术细节的掌握与否并不影响日常开发工作，但我仍将掌握它们作为自己的努力目标，因为： 我的职场第十五感悟：技术细节掌握得越深，解决问题时就越能游刃有余。 那时工作时间应付日常开发工作，业余时间则先将精力集中放在熟读PowerPC 8250处理器相关的技术手册上（晚上还得上夜大）。加起来超过2000页的英文资料，我读了不少于3遍。随着时间的推移，当我对PowerPC 8250处理器很有感觉之后，我将工作重点转移到了熟悉RTEMS操作系统的实现细节上。先处理器后操作系统的学习安排，是基于我以往在x86处理器上的工作经验而得出的，也是因为： 我的职场第十六感悟：技能的发展应采取深度先于广度且交替进行的方式，只有这样，面对大量的新知识才能更淡定。 RTEMS是一个类UNIX的实时操作系统，也正因为接触这个操作系统我才意识到了自己在软件设计能力上存在很大的提升空间。尽管我对操作系统的实现原理胸有成竹，但却无力于构建一个象RTEMS那样优雅的操作系统，也真切地体会到了RTEMS的设计之美。那时基站控制器上运行的RTEMS操作系统是由美国的新泽西研发中心移植好的，杭州研发中心只需在之上做应用开发。为了就RTEMS操作系统获得更好的学习效果，我又一次运用了我的职场第四感悟，设定了自己完成RTEMS新版本移植这一目标。 RTEMS新版本的移植工作虽不在公司的日常工作范围内，但却得到了上司的支持。由于那时RTEMS还在开发新的功能，并不是很稳定，在移植过程中碰到各种奇怪的问题，有些问题还与GNU的binutils工具集有关（binutils中包括nm、ld、objdump等工具。RTEMS是用GCC编译的）。在无法确认是GNU工具集的问题之前，我甚至还向Wind River公司（其知名产品是VxWorks实时操作系统）寻求过帮助，因为那时用的是它的JTAG仿真器。移植工作虽曲折，但最终还是成功了（我所移植的版本并没有运用到产品中，后来的同事又做过了RTEMS4.6.0pre4的移植，且运用于产品中）。这一移植经历，让我对GNU的binutils、RTEMS操作系统的实现有了更为深入地掌握。 在UTStarcom工作的前期，我大多从事的是RTEMS操作系统相关的代码维护工作，工作内容除了OS内核，还包括FTP、Telnet等协议。直到中期转为做E-Box产品的互联网接入模块的开发工作。 E-Box是一个企业级电话交换产品，其中还存在一块基于ADSL的互联网接入数据板（与现在的ADSL猫功能一样），用于实现企业网对互联网的数据接入功能，这一数据板使用的是VxWorks5.5.0实时操作系统（PNE 2.0），处理器是Intel的XScale IXP425。那时VxWorks的IP协议栈还是基于BSD的，但Wind River对之做了一定增强。这段时期我的工作重点全在IP协议栈上（《TCP/IP详解》这套书帮上了大忙）。这一时期的开发经历，让我对PNE的Bridge、FastPath、MUX、PPPoE协议、Radix路由算法和VLAN协议很熟悉，也学会了用SmartBit仪器和Chariot软件做网络性能测试。总之，让我对IP（v4）协议栈方面的知识和软件实现有了长足的进步。 E-Box产品数据板上的开发工作进行了半年后，管理层决定放弃，于是我被调到了E-Box产品的软件平台组。那时平台组刚好面临一个比较麻烦的问题 — 在命令行上运行reboot命令后，有时会出现整个系统挂起，而不是期望的重启。平台组的同事花了一个多星期的时间仍没有解决这一问题。 进入平台组之际，同样是在没有任何人安排的情况下，我自己主动承担解决reboot命令功能异常的工作。在我的职业生涯中，我一直热衷于去解决别人难以解决的技术问题，因为： 我的职场第十七感悟：越难的技术问题，其所蕴藏的知识越丰富，也越具学习价值。 经过一天半的时间，问题被解决了。其根源在于，reboot之前没有禁用CPM协处理器。我能那么快地解决这一问题，完全是因为之前熟读过PowerPC 8250处理器的资料。 我在UTStarcom工作的后期，致力于ACE在E-Box产品中的一些应用，借助ACE的网络通信功能帮助实现在Windows平台上通过Visual Studio调试E-Box产品。我在《专业嵌入式软件开发》一书的《可开发性设计，一种高效且经济的开发模式》一章中所阐述的内容其实就是这一工作经历的总结与延伸。 另外，我还在E-Box产品上做过难度比较大的一个特性是，利用PowerPC 8250的MMU功能在VxWorks操作系统上实现了对任务栈的保护 — 当一个任务被调度而处于运行状态时，它的栈就处于可读写状态，而其他任务的栈全处于只读状态（VxWorks5.5.0内核中，还没有RealTime Process的概念，这一概念是从6.0开始有的，所以那时我所做的这一特性很具实用性）。通过这一特性，可以有效地防止任务栈被意外篡改（比如野指针操作），即便出现篡改也能尽早发现根源。这个功能的实现过程需要调试VxWorks内核，那时VxWorks的源码虽对公司提供，但Wind River公司对所提供的GNU的binutils做了特殊处理，使得无法为内核代码生成调试所需的信息，结果是无法对内核进行源码级程序调试。由于我之前的RTEMS操作系统移植经历让我对binutils非常熟悉，通过使用一定的方法（说来话长了）绕过了Wind River公司所设置的障碍，成功地实现了对VxWorks的源码级程序调试。 在职场中，我不时能成功解决复杂问题和克服技术障碍。 我的职场第十八感悟：每次积累的点滴知识，一定会在将来不知不觉地发挥效能。 短暂停留的杭州华数-雷科通2006年4月份左右，我离开了UTStarcom。在UTStarcom所学到的，不只是前面所介绍的那些技术知识，更让我知道了软件开发的“正规军”是怎样的，与小公司相比，UTStarcom的软件开发流程要正规得多；也经历了英文写作的“挤牙膏”时期过渡到轻松时期（好友周海东在我的英语学习中帮了不少忙）；看到了好友于善成如何通过大量阅读成为一个知识渊博的人（他的阅读量现在仍是我的学习榜样）；还有上司夏青的技术敏感度到现在仍让我为之称道，是我职场至今所见过的二位具有良好技术敏感度的技术管理者之一（另一位是我在Motorola工作期间认识的，后面会谈到他）；团队实力之强使得开发出的E-Box产品在我离开UTStarcom后不时能听到正面的评价。 对了，我在大立公司工作时期，就很注重软件设计文档的编写，而且在我离开之时，不仅完善了所有文档，还为后继同事做了全面的培训。我始终坚守： 我的职场第十九感悟：通过文档化的方式传承知识给后继者是你的基本责任，因为你作为后继者时也希望如此，这也是对自己负责的一种表现。 在UTStarcom工作期间，我进一步形成了将自己的技术想法写成文章与大家分享的习惯（那时同事贺旭东称我为“作家”，而我则称他为“点评家），也因为自己在嵌入式软件开发技术上的长期点滴积累，开始有了写书的想法。 离开UTStarcom后，我入职了杭州华数集团旗下的雷科通技术（杭州）有限公司。公司当时的意向是安排我负责某宽带接入产品的软件开发工作。在这个公司，尽管只有两个月的时间但也做了些事。除了一个月内完成了宽带接入产品以太网交换芯片在VxWorks操作系统上的驱动开发，并使得产品支持VLAN功能外，还解决了好几个影响整个产品系统稳定性的严重遗留缺陷。这两个月的工作不光让我在技术团队中很快地树立了自己的威望，也使得公司高层管理者真切地看到了我的能力而在我提出离开时极力地挽留。这短暂两个月的工作经历带给： 我职场第二十感悟：别人对你价值的认可，其实不是简单地根据你的自身能力，而是根据你对他人和团队的贡献。 加入 Motorola入职2006年初在杭州成立的Motorola研发中心的故事得从面试开始。在入职雷科通不久，我收到了猎头的电话，虽然那时并没有换工作的想法，但也没有拒绝猎头投简历。随后我收到了Motorola的面试电话。那次面试过程记得很清楚，因为那是我所经历的第一次英语口语技术面试。虽然工作中从没有锻炼过英语口语，好在对于自己做过的技术知识很熟悉，也经常需要查阅英文资料，所以对于所做过的内容还能用英语勉强解释清楚。在面试的最后，我对印裔技术面试官说，“现在我的英语口语不好，但我相信只要有合适的环境，能很快地提高”。印裔技术面试官最后将我领到HR那，说了一声“Yes” — 我的技术面试通过了！ 面试结束的第二天，收到了Motorola HR的电话，告知Offer的相关信息（我的入职级别是E09，E09及以上的人在整个Motorola杭州研发中心占比大约为10%）。那时由于并没有换工作的想法，所以拒绝了Offer。想法很简单，因为曾在UTStarcom这样的公司呆过了，所以对外企的工作并不是很向往，反而认为在雷科通这种小公司更能施展。在我拒绝了Motorola的Offer后，我将这件事告诉了身边的同事，他们的反馈几乎都是“你应当去Motorola”。 幸运的是，另一名HR再一次致电给我，试图说服我加入Motorola。她当时说“你一旦加入Motorola，以后离开时所看到的就是HP或IBM这样的大公司”，也正是这句话打动了我。之后的经历证明，加入Motorola是很正确的一个选择！ 2006年7月6日，我正式入职Motorola杭州研发中心。加入的初期是大量的内部培训，培训内容包括技术方面的、流程方面的和英语。Motorola有着成熟的企业文化，通过培训可以让工程师很快地融入企业，使人行事象是Motorolan（摩托罗拉人）。在经历了约半年的培训和学习后，2006年底，我开始参与WiMAX产品线上的CLA中间件软件项目。 尽管我在CLA项目上没有具体的工作（比如，没有缺陷修复工作会分配给我，也没有新的特性开发工作会挂在我的名下），但对整个团队所从事的技术工作都得负责。我的日常工作主要是设计方案评审、代码审查、帮助或带领团队解决技术难题等。 在CLA项目上工作了一个月左右，2007年春节之后，我被第一位派到Motorola的芝加哥研发中心做为期二个月的现场技术支持。之前尽管在公司有过英语培训，但要很好地听与说还是存在很大的障碍，加上芝加哥那边一起工作的是口音较重的印度人和巴基斯坦人，挑战可以想象。在芝加哥研发中心除了做现场技术支持，还得为后续人员的到来做铺垫。比如，租好房子、车子，准备好生活所需的一些家当（当时因为预算有限，我们住的是公寓，还得自己烧饭）。那段时间虽然因为语言的问题倍感压力，但在全英文的环境中，我的听说能力进步也明显。之后差不多每年一次的出国，见到以前认识的外国同事，总会有人对我说“Your English is getting better”。对于自认为英语听说能力不行的同仁，请记住： 我的职场第二十一感悟：英语的听说能力只要有合适的环境，并勇于张嘴练习的情况下能快速地提高，不必担心。 CLA软件在技术上属于运行于Linux操作系统上的一个中间件，它存在多个进程用于帮助通讯设备网元（包括WiMAX基站和接入网关）实现网管功能。由于软件架构的特点，使得CLA团队不时会碰到由于其他团队没有用好CLA而产生的技术问题，这类问题开始大多难以定位是属于CLA的、还是不属于CLA的，因而查错过程很低效。在CLA项目的后期，我希望通过引入新的软件设计方案帮助团队提高软件的查错能力，并改善软件质量。引入新设计需要增加很多代码，如何让管理层不担心由此而引入更多的缺陷是我着力这事时首先要考虑和解决的问题。 在这种背景下，我在CLA项目引入了单元测试，寄希望于通过单元测试提高新增代码的质量，以使管理层更具信心而获得他们强有力的支持。最终结果表明，在新增了近一万行代码的情况下，代码在最终发布后总共只发现了一个软件缺陷。这个项目上的工作经历让我第一次真正尝到了单元测试的甜头，在《专业嵌入式软件开发》一书中，就单元测试方面的内容很多源于我在这一项目上的成功经验。我在CLA上新增设计中的AED（Abnormal Exiting Detection）功能，在我离开CLA项目之后，还帮助团队发现了很隐蔽的多线程问题。当通过AED功能发现这一问题的同事高兴地跑过来对我说这个功能管用时，我的高兴劲写满了整张脸。这个项目的经历，也让我更加坚信： 我的职场第二十二感悟：在软件开发活动中，应设法通过有效的技术途径去解决工程困境。 软件开发架构师 - 帮助团队成长2009年初，Motorola杭州研发中心迎来了一个重量级项目 — WiMAX产品线的接入网关ASN-GW，我被安排到该项目，角色是软件开发架构师。初期我的架构师一职只是杭州研发中心单方面的角色安排，而非全球性的（当时该产品由美国、印度和中国三个研发中心共同参与）。 在ASN-GW项目上与我一同共事的经理，是曾在Motorola美国研发中心呆了近十年、后来临时转到国内来工作的华人李亮（后面简称亮，习惯了）。他之前在美国工作时做过架构师、软件发布经理（Release Manager）等职，是一个对技术很有敏感度的管理者（我前面提到过的两位有技术敏感度的管理者之一）。我在此之后的成长，完全离不开他的支持与信任，以及他为我所创造的职场发展环境，能与他共事让我倍感荣幸和感激。 我从亮身上学到的第一个内容是如何与美国管理层打交道。总体说来，Motorola在软件开发管理方面很是四平八稳，其管理存在两大特色，一是争夺项目的所有权（Ownership），另一个是质疑（Challenge）。前者使得各团队职责清晰，不容易出现突发问题或状况找不到负责人；后者使得团队在工作中有所作为，不至于让人浑水摸鱼。在面对美国团队的质疑时，我以前看到的大多管理者都很紧张，总想一味地达到美国方面的要求，但亮在这方面的表现却明显不同。他告诉我们（包括Team Lead），“如果美国提的要求不合理，直接与他们‘掰’”。后来我认识到，美国方面做事其实很讲逻辑，只要我们对于他们所质疑的问题能给出合理的解释，很多异常事件根本就没什么大不了。 我的职场第二十三感悟：不要用沉默的方式一味地迎合别人的要求，据理力争或许才是作为的表现。 参与ASN-GW的呼叫处理子系统的开发工作后，整个团队经历了大约半年的成长痛苦。痛苦的根源，一是对WiMAX无线接入技术相关的国际标准不熟悉，另外则是对ASN-GW产品的现有实现不了解，而且产品的复杂度的确很大（其中一个技术指标是：必须达到99.999%的容错能力）。在半年的痛苦期中，我很重要的一个工作职责是帮助团队成长，作为亮这类管理层与基层工程师间的桥梁。比如，为团队起草《开发者指南》和《测试指南》这样的文档，且要求和引导工程师通过文档化的形式沉淀经验与教训，以便提高工作效率（虽然文档化方法的实施过程需要我不断地提醒，但这一方法被证明在这种时期很有效）；我也会在例会上毫不留情地指出工程师的哪些行为影响了工作效率。 我的职场第二十四感悟：流程、文档的作用，不只是引导我们做完事，更能规范我们的行为和帮助培养工作习惯。 亮在项目进展的过程中，一直向美国方面主张杭州团队必须设置架构师一职，也正是由于亮的一再争取，美国方面最终努力地帮助我向这个方向发展，不断为我分派属于架构师工作的任务（如更新产品架构模型、参与需求管理、参与系统设计文档的评审、完成新特性开发工作评估等）。亮那时告诉我，我应是杭州研发中心第一个真正从事架构师工作的人。 刚接触架构师方面的工作时，其实还是不大自信的，尽管我那时掌握了软件架构师所需的基础技术技能（比如，我的软件设计能力很强、UML从1998年开始接触加上之后的持续学习所以功底也很好），但对于软件研发管理方面的内容，以及WiMAX无线接入技术知识的系统性认识还是相对单薄的。 那时与美国同事接触下来的感觉是，他们的综合能力都很强，似乎随便一个人都知道如何做架构师，不少人有做GSM、iDen和CDMA产品的经验，而且长期工作于无线接入技术领域。随着更多地参与架构师方面的工作，不仅逐渐建立了自信，对Motorola的软件研发管理也有了更为深入地认识与理解。所看到的不仅仅是产品技术本身的复杂度，更有开发活动运作管理方面的复杂度。最终，我成为了整个ASN-GW产品的架构师。 工作、学习和写作在2009年，我考入了浙江大学的MBA，同时还开始着手写自己的处女作《专业嵌入式软件开发》。在之后长达近两年的工作、学习和写作的三重压力下，我在时间管理上有很大的进步，抗压能力也得到了很好的锻炼，这时我的职场第十二感悟（指其中的坚持）又让我最终渡过了这段最为艰难的时期。 2010年中期，NSN宣布收购我所在的Motorola网络部门，收购活动直到2011年的4月份才结束。同时由于WiMAX市场的不景气，美国不少系统架构师转到了FDD-LTE产品线上，我也因为这一缘故担任了大约半年的系统架构师，主要负责WiMAX技术的移动性与网络安全方面的工作。 2012年7月份，因为WiMAX产品线裁员，我转到了NSN的WCDMA产品线。也从此开始离开了Motorola的研发管理环境，而真正步入了NSN的研发管理环境。 真感谢你花时间读到这！尽管我们常将“职业规划”挂在嘴边，实际上职场发展真的是一种“布朗运动”。你不知道下一站会是哪、也不知道后面将要从事什么工作、更不清楚后面会碰到怎样的老板。在众多不确定因素面前，或许参照我一路走来所总结出的职场感悟能让你不断地朝好的方向发展。 至简：阿里巴巴高级技术专家，是集团Service Mesh方向的重要参与者和推动者。曾出版《专业嵌入式软件开发——全面走向高质高效编程》一书，坚信和倡导软件设计是软件质量之根本，并对软件开发的复杂性本质有着深刻的认识，对如何高质高效实施软件开发有着自己独到的见解和方法。 原文发布于微信公众号 - 黑洞日志（heidcloud）原文发表时间：2018-12-25","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/tags/Book/"}]},{"title":"移动端自动化 CI Review 解决方案","slug":"AutoCI","date":"2019-01-26T04:55:38.000Z","updated":"2019-01-26T07:41:07.750Z","comments":true,"path":"2019/01/26/AutoCI/","link":"","permalink":"https://reversescale.github.io/2019/01/26/AutoCI/","excerpt":"介绍一下通过 CodeBeat 对移动端代码质量的自动化管理，顺带提及一下，第三方持续集成环境 Travis CI 的基本使用~","text":"介绍一下通过 CodeBeat 对移动端代码质量的自动化管理，顺带提及一下，第三方持续集成环境 Travis CI 的基本使用~ 之前一篇文章介绍如何通过 Jenkins + Fastlane 脚本自动打包发布测试包。 Jenkins + Fastlane 自动打包脚本 这次主要介绍通过 CodeBeat 对移动端代码质量的自动化管理，顺带提及一下，第三方持续集成环境 Travis CI 的基本使用。 █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🚠 第三方 CI 时代 [🚠 第三方 CI 时代] Travis CI 是一个专门为开源项目打造的持续集成环境（付费可以支持私有项目），目前已经支持绝大部分主流语言，它的配置文件采用 yaml 格式，简洁清新独树一帜。] 持续集成环境能做什么？ 持续集成是涵盖代码变更后对项目进行自动运行、测试及反馈运行结果的服务。通过自动化的监管，以最大程度确保代码变更符合开发预期。 不仅如此，一个完善的持续集成环境还能够清晰细化开发进度，优化迭代周期，提高项目质量。 但是搭建持续集成环境及配套服务通常需要涉及多方面知识，而且后期维护也需要时间成本。 Travis CI 服务 Travis CI 提供的是持续集成服务（Continuous Integration，简称 CI）。它绑定 Github 上面的项目，只要有新的代码，就会自动抓取。然后，提供一个运行环境，执行测试，完成构建，还能部署到服务器。 而且 Travis 能与 GitHub 的很好的结合起来，为我们提供友好的开发体验。 开始集成添加 Travis-CI 配置文件在项目根目录下新建 .travis.yml 文件，配置信息如下： 在 macOS 下，以 . 开头的文件默认为隐藏文件，在 Finder 中使用快捷键 Command + Shift + . 可以显示 / 隐藏对隐藏文件的显示。 123456789101112131415161718192021222324252627282930# Xcode 的大版本号，根据实际版本配置，如果是 Swift 项目要注意不同 Xcode 版本对 Swift 的支持osx_image: xcode10# 默认设置 objective-c 即可，Swift 项目可以设置 `swift`，但是并不影响运行language: objective-c# 环境变量 # XCODE_PROJECT：Xcode 工程文件路径 # SCHEME：需要执行的 Schemeenv: global: - LANG=en_US.UTF-8 - LC_ALL=en_US.UTF-8 - XCODE_PROJECT=CollectionIndexTools/CollectionIndexTools.xcodeproj matrix: - SCHEME=&quot;CollectionIndexTools&quot;# 在 before_install 步骤中，您可以安装项目所需的其他依赖项，如 Ubuntu 包或自定义服务before_install: - gem install xcpretty --no-rdoc --no-ri --no-document --quiet# 需要执行的构建脚本，使用 CocoaPods 进行库管理可以加一句 `pod install`，build 命令使用 `- xcodebuild -workspace &quot;$XCODE_PROJECT&quot; -scheme &quot;$SCHEME&quot; -configuration Debug -sdk iphonesimulator clean`script: - set -o pipefail - xcodebuild -project &quot;$XCODE_PROJECT&quot; -scheme &quot;$SCHEME&quot; -configuration Debug clean build CODE_SIGN_IDENTITY=&quot;&quot; CODE_SIGNING_REQUIRED=NO | xcpretty -c# 构建通过后的自定义命令 # sleep 3：延时 3 秒，规避 Travis-CI 的历史 Bugafter_success: - sleep 3 如果是 Swift 项目，需要额外新建 .swift-version 文件配置 Swift 版本号。 14.2 注册账户访问 Travis CI 官网 创建账户或者通过 Github 账户直接登录，Travis CI 对 Github 开源项目提供免费服务。 点击 + 进入 GitHub 项目同步设置列表，切换需要同步的项目。 默认情况下 Travis CI 会定时同步开通 Github 绑定的项目代码。 通过 Travis CI 控制面板可以获取到项目的运行结果、log 日志和配置文件。 设置完成后可以在 Github 对应项目的 Setting - Integrations &amp; services 中管理绑定状态。 运行流程从上面的 .travis.yml 配置可知，项目会分为 install、script 两个阶段。 install 阶段：安装依赖 script 阶段：运行脚本 1)install 字段用来指定安装脚本。 1install: ./install-dependencies.sh 如果有多个脚本，可以写成下面的形式。 123install: - command1 - command2 如果不需要安装，即跳过安装阶段，就直接设为true。 1install: true 在 install 阶段，如果 command1 失败了，整个构建就会停止退出进程。 2)script 字段用来指定构建或测试脚本。 1script: bundle exec thor build 如果有多个脚本，可以写成下面的形式。 123script: - command1 - command2 script 阶段，如果 command1 失败，command2 会继续执行。但是，整个构建阶段的状态是失败。 如果 command2 需要依赖 command1 成功后才能执行需要如下设置： 1script: command1 &amp;&amp; command2 运行状态Travis 每次运行返回的四种状态： passed：运行成功，退出码返回0 canceled：用户取消执行 errored：before_install、install、before_script 有非零退出码，运行会立即停止 failed ：script 有非零状态码，会继续运行 █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🤖 自动化 Review 时代 [🤖 自动化 Review 时代] CodeBeat 是一个免费为开源项目进行代码质量管理的工具（付费可以支持私有项目），无需对原有项目进行任何修改即可获取针对项目的完整质量分析，方便快捷。] Codebeat Codebeat 是一个开源的自动代码审查工具，支持Ruby、Go、Swift、Java 代码等开发语言。并且支持与Github，Bitbucket和slack的集成。 和 Travis CI 一样，Codebeat 会在代码仓库发生变更后，执行分析操作，对项目代码质量进行评分，并在完成后刷新项目评级 / 评分的状态或结果。 注册账户访问 CodeBeat 官网进行注册，具体和 Travis CI 一致，这里不多赘述。 CodeBeat 服务对开源项目是免费的，所以你的私有项目无法享受到免费的持续构建服务。 当然，每月支付 20 美刀成为付费用户后可以解锁无限数量私有库的功能。 登录好账号后点击 Add Repository 可以很方便的添加关联项目来开启代码质量管理。 同样关联成功会在 Github 设置页面的 Webhooks 中看到关联信息。 GPA 指数点击具体项目进入对应的评分结果页面，可以详细查看 Code Review 结果。 Codebeat 计算全局项目并给出一个 GPA 指数，范围0（最差）~ 4（最佳），大致映射到美国GPA量表。 GPA 指数的计算规则见官方文档 Review以我的 AutoAlignButton 项目为例，审查报告中给 LabelTagsViewController 评级为 D 😤。 点击进入报告详情，可以看到分为三个分组： Complexity 代码层级评估 Duplication 重复代码评估 Style 代码风格评估 可以看到我的项目中 LabelTagsViewController.m 和 CollectionTagsViewController.m 有一个 - (NSMutableArray *)dataArr 方法代码重复，虽然很 MMP，但是我们也是可以优化的。 对分析出的代码质量问题进行修改后直接提交，，Webhook 会通知 CodeBeat 进行刷新，以重新进行代码评分。 当然自动化的 Review 一定会出现对你高深代码架构的误解，这时候我们可以选择手动干预它的认知🤣。 来来来，让我们对报告结果进行 Mute、Report、Help 操作… 当然还有其他的报告指标等待您的发现🤪。 官方文档中关于功能级指标的解释 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Summary","slug":"Summary","permalink":"https://reversescale.github.io/categories/Summary/"}],"tags":[{"name":"Script","slug":"Script","permalink":"https://reversescale.github.io/tags/Script/"}]},{"title":"使用 Flutter 开发 macOS App","slug":"Flutter MacApp","date":"2018-12-18T01:29:16.000Z","updated":"2019-01-26T07:44:00.936Z","comments":true,"path":"2018/12/18/Flutter MacApp/","link":"","permalink":"https://reversescale.github.io/2018/12/18/Flutter MacApp/","excerpt":"Flutter 通过跨平台的 Skia 图形库来实现图形渲染，只依赖各个系统的图形绘制相关的 Api，可能是目前为止真正意义上的全平台 UI 框架~","text":"Flutter 通过跨平台的 Skia 图形库来实现图形渲染，只依赖各个系统的图形绘制相关的 Api，可能是目前为止真正意义上的全平台 UI 框架~ 👨🏻‍💻 Github Demo Flutter 框架Flutter 是 Google 开发的一套全新的跨平台、开源 UI 框架，支持 iOS、Android 系统开发，并且是未来新操作系统 Fuchsia 的默认开发套件。 借助 Feather 平台，我们可以在 MacOS 和 Windows 上运行我们的 Flutter 应用程序，也就是说您可以编写一个可以在所有主要桌面和移动设备上运行的应用程序。 Feather 平台 Feather 是一个在桌面上运行 Flutter 应用程序的平台。 在 Mac 和 Windows 上运行 Flutter 应用程序的编译器和库 一个应用商店，您可以使用它来发布和更新应用，并为用户提供最小的安装阻力 一组可选的扩展 Flutter UI 小部件，用于高级界面设计 目前处于 alpha 测试阶段 免费使用的商业执照 官网：https://feather-apps.com 配置环境进入官网，点击 Build an App Now 下载 Mac 端编译器。 下载完成后打开 Feature Workbench，这里就有了墙的存在，非精品网可能要自行处理一下。 Google 账户登录后，可以看到工程列表，如果你第一次做，当然是空的。 项目改造我们这里新建一个项目为例，教大家怎么把 Flutter 项目运行到 MacOS 上，非常简单哦。 1.打开终端，新建一个 Flutter 项目 1flutter create mac_app 2.打开 mac_app 项目中 main.dart 修改两处： 1）在代码顶部引入 foundation 架包 1import &apos;package:flutter/foundation.dart&apos;; 2）改造 void main() 函数，增加平台覆盖 1234void main() &#123; debugDefaultTargetPlatformOverride = TargetPlatform.iOS; runApp(MyApp());&#125; 保存代码，就可以了。 新建 Feather 项目点击 Feature Workbench 界面右下角的加号，进入新建页面，点击 BROWSE 找到 Flutter 项目工程。 设置应用名和图标就创建完成了。 点击 TEST 会打开 Xcode， command + r 运行就会看到 Flutter 的官方示例运行在 MacOS 上了。 Flutter 右上角的 DEBUG 是环境标记，不想看见它，切换生产环境它就不见了 发布和使用点击 PUBLISH 设置应用描述和截图，发布应用到 Feather 商店。 发布完成后再次进入项目列表，就可以看到 WEB 选项，点击就会进入 Feather 应用商店的网站。 任何 Mac 电脑都可以通过这个链接(https://feather-apps.com/alpha/app.html?id=app_gqcz24d6Vw80)来访问和安装这个应用。 更新和发布流程一样，只是需要注意修改版本号、应用描述和截图，最后上传应用即可。 效果演示上面使用的是 Flutter 官方的示例工程，有朋友表示看起来不过瘾，so 我从网上找了一个看起来很适合做跨平台服务的示例工程，经过改造后我将其运行到了 macOS 系统上。 朋友们满意了没🤪…","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://reversescale.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://reversescale.github.io/tags/Flutter/"}]},{"title":"Flutter 学习笔记","slug":"Flutter Start","date":"2018-12-15T12:29:16.000Z","updated":"2019-01-26T07:55:27.962Z","comments":true,"path":"2018/12/15/Flutter Start/","link":"","permalink":"https://reversescale.github.io/2018/12/15/Flutter Start/","excerpt":"Flutter 是谷歌的移动 UI 框架，可以快速在 iOS 和 Android 上构建高质量的原生用户界面。Flutter 可以与现有的代码一起工作。在全世界，Flutter 正在被越来越多的开发者和组织使用，并且 Flutter 是完全免费、开源的~","text":"Flutter 是谷歌的移动 UI 框架，可以快速在 iOS 和 Android 上构建高质量的原生用户界面。Flutter 可以与现有的代码一起工作。在全世界，Flutter 正在被越来越多的开发者和组织使用，并且 Flutter 是完全免费、开源的~ 👨🏻‍💻 Github Demo 📇 内容大纲： 项目介绍 配置开发环境 安装开发工具 Debug 技巧 三方库使用与发布 iOS 混编开发（Swift、OC） Demo 演示 🗞 项目介绍1）官方示例目前来看最好的 Flutter 示例工程，功能完善、代码结构清晰。 工程路径：1/flutter_gallery 项目演示首页 项目菜单页面 项目成品展示 项目通讯录页 项目控件介绍 项目提示控件 Flutter 通过跨平台的 Skia 图形库来实现图形渲染，只依赖各个系统的图形绘制相关的 Api，所以借助 Hummingbird 可以实现桌面端的渲染工作。 通过 Hummingbird 输出到 macOS 效果： 项目演示首页 项目菜单页面 项目成品展示 2）iOS 原生项目混编根据官方文档实现的原生 Flutter 混编示例，Demo 工程使用 Swift 实现，文档部分有 OC、Swift 分别实现方法。 工程路径：12345# Flutter 资源包/FlutterDemo/flutter_module # iOS 原生工程/FlutterDemo/FlutterIOS 运行前需要重新设定文件路径，否则 pod install 会报错。 3）Flutter 控件练习真正意义上的 Demo 工程，分别演示一些常用的功能控件使用和一些单页面（见底部效果图）。 工程路径：1/hello_flutter_app 4）Flutter 网络库使用使用 dio + rxdart 实现优雅的网络数据请求。 工程路径：1/network_app 5）Flutter 路由库使用使用 fluro 实现灵活的路由管理。 工程路径：1/router_fluro 6）Cupertino 风格示例鉴于目前设计师的出稿风格都是 Apple Design，这里新增 Cupertino 风格示例工程。 工程路径：1/veggieseasons █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🛠 配置开发环境下载 Flutter推荐去官网下载，速度并不慢，网址：https://flutter.io/setup-macos/ 或者也可以通过 git 将 Flutter 项目克隆到本地，其实和官网下载是一样滴。 1git clone -b alpha https://github.com/flutter/flutter.git 配置环境变量下载或者克隆完成后，到 flutter 所在目录，配置环境变量。 如果 bash_profile 文件不存在，就新建一下。 1source ~/.bash_profile 开始配置环境变量 1vim ~/.bash_profile 选择 edit，按键盘上的 “i” 键，进入可编辑状态，在文本中增加这三行（后面两行用于 flutter doctor 在天朝下载配置包）: 123export PATH=/flutter/bin:$PATHexport PUB_HOSTED_URL=https://pub.flutter-io.cnexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 编辑完，按 “esc” 退出编辑状态，输入 1:wq 保存一下，最后会出现 Welcom to Flutter!。 设置 flutter 为全局可执行 1export PATH=&quot;$PWD/flutter/bin:$PATH&quot; 使用 flutter doctor 命令进行安装检查运行 doctor 安装 Dart SDK 和工具包1flutter doctor 输出如下： 12345678910111213141516171819202122232425Downloading Dart SDK from Flutter engine e3687f70c7ece72000b32ee1b3c02755ba5361ac... % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 87.9M 100 87.9M 0 0 4247k 0 0:00:21 0:00:21 --:--:-- 4945kDownloading Material fonts... 0.6sDownloading package sky_engine... 0.3sDownloading common tools... 0.8sDownloading darwin-x64 tools... 3.4sDownloading android-arm-profile/darwin-x64 tools... 0.6sDownloading android-arm-release/darwin-x64 tools... 0.7sDownloading android-arm64-profile/darwin-x64 tools... 0.6sDownloading android-arm64-release/darwin-x64 tools... 0.6sDownloading android-x86 tools... 1.9sDownloading android-x64 tools... 2.4sDownloading android-arm tools... 1.2sDownloading android-arm-profile tools... 0.9sDownloading android-arm-release tools... 0.7sDownloading android-arm64 tools... 1.1sDownloading android-arm64-profile tools... 1.0sDownloading android-arm64-release tools... 0.8sDownloading ios tools... 4.3sDownloading ios-profile tools... 3.7sDownloading ios-release tools... 3.2sDownloading Gradle Wrapper... 0.1s 🔨 安装开发工具Android Studio官方地址：https://developer.android.com/studio/ 相关依赖配置可以在 AndroidDevtools 网站找，基本都有的。AndroidDevtools：http://www.androiddevtools.cn 解决 gradle sync 太慢的问题 就算是翻了墙，gradle sync 依然速度感人，而且国内访问jcenter太慢（甚至连接不上），就会报各种关于依赖更新失败的错误。 以前oschina（也就是开源中国）提供了jcenter的镜像地址，然而不幸的是因为各种原因，最近停止服务了开源中国 Maven 镜像库关闭访问 幸运的是阿里云提供了jcenter镜像 http://maven.aliyun.com/ 可以在工程gradle中如下修改，加速 gradle sync 123456789101112131415161718192021// Top-level build file where you can add configuration options common to all sub-projects/modules. buildscript &#123; repositories &#123; maven&#123; url &apos;http://maven.aliyun.com/nexus/content/groups/public&apos;&#125; //jcenter() &#125; dependencies &#123; classpath &apos;com.android.tools.build:gradle:2.2.2&apos; // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125; &#125; allprojects &#123; repositories &#123; maven&#123; url &apos;http://maven.aliyun.com/nexus/content/groups/public&apos;&#125; //jcenter() &#125; &#125; XcodeXcode 需要 macOS 系统的支持，如果用的是 MacBook，打开 App Store 直接下载就好了。 Visual Studio Code虽然 Android Studio 也可以用，但是 VS Code 更加轻量，所以推荐一下。 官网：https://code.visualstudio.com 安装 Flutter 包，就可以愉快的敲代码了.. 而且可以直接选择运行的虚拟机，从此不需要打开繁重的双端IDE。 🐛 Debug 技巧这里以 VSCode 做为 Dart 编辑工具为例，演示一下常用的 Debug 技巧。 断点调试和常用的 IDE 一样，在代码左侧点一下就会创建一个断点，在 VSCode 的 Debug 模式下点击 run 即可进行断点调试。 debugger 调试当使用 Dart Observatory 时，可以使用debugger() 语句插入编程式断点,首先需要添加 1import &apos;dart:developer&apos;; 然后在需要 debugger 的代码处添加方法即可。 1234void someFunction(double offset) &#123; debugger(when: offset &gt; 30.0, message: &apos;offset 大于 30 时，启动断点调试); // ...&#125; 除此之外，还可以通过 print debugPrint flutter logs 在系统控制台中打印信息辅助调试。 查看运行状态当我们从命令行运行 flutter run 运行程序时，控制台会给我们一个站内链接，以便我们查看运行状态。 使用 Chrome 浏览器打开上图的链接，就可以看到具体的运行状态信息了。 📦 三方库使用与发布使用三方库Flutter 项目中通过 pubspec.yaml 来管理第三方库，在 pubspec.yaml 中添加第三方库名称和版本号等信息。 以引入 dio 为例 12345678dependencies: flutter: sdk: flutter # The following adds the Cupertino Icons font to your application. # Use with the CupertinoIcons class for iOS style icons. cupertino_icons: ^0.1.2 dio: ^1.0.9 加入一行1dio: x.x.x #latest version 并执行flutter packages get即可将三方库拉入本地工程文件。 1flutter packages get 发布三方库上面通过 pubspec 管理的三方库大都也是开发者封装后打包发布的，接下来我们来试着发布一个自己的三方库。 package 分类： Dart packages：使用 Dart 语言编写，为 Flutter 做功能扩展的库。 plugin packages：在 Dart packages 基础上，包含 iOS 和 Android 功能调用的插件包。 1）创建 packages dart package:1flutter create --template=package test_dart_package plugin package:1flutter create --org com.rs.example --template=plugin -i swift -a kotlin test_flutter_package 参数说明： –org com.rs.example:包的组织名 -i swift:包使用 Swift -a kotlin:包使用 kotlin 支持 工程目录说明： lib/test_flutter_package.dart:插件包的Dart API. android/src/main/java/com/yourcompany/test_flutter_package/TestFlutterPackagePlugin.kt:插件包API的Android实现. ios/Classes/TestFlutterPackagePlugin.m:插件包API的ios实现. example/:一个依赖于该插件的Flutter应用程序，来说明如何使用它 2）发布 packages 运行 dry-run 命令以查看是否都准备OK了:1flutter packages pub publish --dry-run 运行发布命令:1flutter packages pub publish 更多请阅读 Flutter 中文网 📱 iOS 混编开发（Swift、OC）创建 module 包到 cd 到总目录 FlutterDemo 下，执行 Flutter 命令 flutter create -t module xxx： 1flutter create -t module flutter_module 运行过后，目录中就出现了 flutter_module 文件。 Cocoapods 引入后的目录结构如下： FlutterDemo: 总的父目录 FlutterIOS: iOS 已有的项目工程 flutter_module: Flutter 的库包 Pods 及脚本设置这里只介绍通过 cocoapods 绑定 module 包方法，手动导入请参考 Flutter Github wiki。 打开 Podfile 添加如下内容： 12flutter_application_path = &apos;/Users/whatsxie/Desktop/FlutterDemo/flutter_module/&apos; eval(File.read(File.join(flutter_application_path, &apos;.ios&apos;, &apos;Flutter&apos;, &apos;podhelper.rb&apos;)), binding) 注：上面的路径需要根据本地位置修改 运行 Demo 工程可能同时需要修改下图的路径： 执行 pod install 即可完成绑定。 接着打开 Xcode 至项目 TARGETS - 项目名 - BuildPhases 下，添加一个执行脚本。 12&quot;$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh&quot; build&quot;$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh&quot; embed 运行 ⌘B 绑定库就 OK 了。 Native 调用 Flutter 视图Demo 中是 Swift 实现，网上很多 OC 的实现，这里两种语言都提供参考。OC:AppDelegate.h12345#import &lt;UIKit/UIKit.h&gt;#import &lt;Flutter/Flutter.h&gt;@interface AppDelegate : FlutterAppDelegate@end AppDelegate.m1234567891011121314#import &lt;FlutterPluginRegistrant/GeneratedPluginRegistrant.h&gt; // Only if you have Flutter Plugins#include &quot;AppDelegate.h&quot;@implementation AppDelegate// This override can be omitted if you do not have any Flutter Plugins.- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [GeneratedPluginRegistrant registerWithRegistry:self]; return [super application:application didFinishLaunchingWithOptions:launchOptions];&#125;@end ViewController.m123456789101112131415161718192021#import &lt;Flutter/Flutter.h&gt;#import &quot;ViewController.h&quot;@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom]; [button addTarget:self action:@selector(handleButtonAction) forControlEvents:UIControlEventTouchUpInside]; [button setTitle:@&quot;Press me&quot; forState:UIControlStateNormal]; [button setBackgroundColor:[UIColor blueColor]]; button.frame = CGRectMake(80.0, 210.0, 160.0, 40.0); [self.view addSubview:button];&#125;- (void)handleButtonAction &#123; FlutterViewController* flutterViewController = [[FlutterViewController alloc] init]; [self presentViewController:flutterViewController animated:false completion:nil];&#125;@end Swift:AppDelegate.swift1234567891011121314import UIKitimport Flutterimport FlutterPluginRegistrant // Only if you have Flutter Plugins.@UIApplicationMainclass AppDelegate: FlutterAppDelegate &#123; // Only if you have Flutter plugins. override func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; GeneratedPluginRegistrant.register(with: self); return super.application(application, didFinishLaunchingWithOptions: launchOptions); &#125;&#125; ViewController.swift12345678910111213141516171819import UIKitimport Flutterclass ViewController: UIViewController &#123; override func viewDidLoad() &#123; super.viewDidLoad() let button = UIButton(type:UIButtonType.custom) button.addTarget(self, action: #selector(handleButtonAction), for: .touchUpInside) button.setTitle(&quot;Press me&quot;, for: UIControlState.normal) button.frame = CGRect(x: 80.0, y: 210.0, width: 160.0, height: 40.0) button.backgroundColor = UIColor.blue self.view.addSubview(button) &#125; @objc func handleButtonAction() &#123; let flutterViewController = FlutterViewController() self.present(flutterViewController, animated: false, completion: nil) &#125;&#125; 具体使用中的 Route 跳转方式 OC:1[flutterViewController setInitialRoute:@&quot;route1&quot;]; Swift:1flutterViewController.setInitialRoute(&quot;route1&quot;) 更多 iOS 与 Flutter 的相互调用，参考 Github Demo 中的 FlutterDemo。 🎞 Demo 演示1）Todolist UI 1cd FlutterDemo/hello_flutter_app/lib/TodoPage.dart 2）SQL数据库 通讯录 1cd FlutterDemo/hello_flutter_app/lib/DataApp.dart 3）旅游通信 12cd FlutterDemo/hello_flutter_app/lib/ComplexApp.dartcd FlutterDemo/hello_flutter_app/lib/ChatsApp.dart 📚 相关链接 Flutter 中国：https://flutter.io/community/china Flutter 中文社区：https://flutter-io.cn/ Flutter Github Wiki:https://github.com/flutter/flutter/wiki/Add-Flutter-to-existing-apps#experiment-integrate-flutterviewcontroller 😬 联系 WeChat : WhatsXie Email : ReverseScale@iCloud.com Blog : https://reversescale.github.io","categories":[{"name":"Flutter","slug":"Flutter","permalink":"https://reversescale.github.io/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"https://reversescale.github.io/tags/Flutter/"}]},{"title":"《经典算法大全》摘抄笔记整理","slug":"Book Algorithm","date":"2018-12-10T11:29:16.000Z","updated":"2018-12-10T11:59:42.898Z","comments":true,"path":"2018/12/10/Book Algorithm/","link":"","permalink":"https://reversescale.github.io/2018/12/10/Book Algorithm/","excerpt":"里面收录了51种常用算法，这里整理一些基础问题~","text":"里面收录了51种常用算法，这里整理一些基础问题~ 漏桶算法一、限流：每个API接口都是有访问上限的,当访问频率或者并发量超过其承受范围时候,我们就必须考虑限流来保证接口的可用性或者降级可用性.即接口也需要安装上保险丝,以防止非预期的请求对系统压力过大而引起的系统瘫痪. 通常的策略就是拒绝多余的访问,或者让多余的访问排队等待服务,或者引流.如果要准确的控制QPS,简单的做法是维护一个单位时间内的Counter,如判断单位时间已经过去,则将Counter重置零.此做法被认为没有很好的处理单位时间的边界,比如在前一秒的最后一毫秒里和下一秒的第一毫秒都触发了最大的请求数,将目光移动一下,就看到在两毫秒内发生了两倍的QPS. 二、限流算法：常用的更平滑的限流算法有两种:漏桶算法和令牌桶算法. 漏桶算法的漏出速率是固定的参数,所以,即使网络中不存在资源冲突(没有发生拥塞),漏桶算法也不能使流突发(burst)到端口速率.因此,漏桶算法对于存在突发特性的流量来说缺乏效率.漏桶可以看作是一个带有常量服务时间的单服务器队列，如果漏桶（包缓存）溢出，那么数据包会被丢弃。在网络中，漏桶算法可以控制端口的流量输出速率，平滑网络上的突发流量，实现流量整形，从而为网络提供一个稳定的流量。 令牌桶算法(Token Bucket)和 Leaky Bucket 效果一样但方向相反的算法,更加容易理解.随着时间流逝,系统会按恒定1/QPS时间间隔(如果QPS=100,则间隔是10ms)往桶里加入Token(想象和漏洞漏水相反,有个水龙头在不断的加水),如果桶已经满了就不再加了.新请求来临时,会各自拿走一个Token,如果没有Token可拿了就阻塞或者拒绝服务. 三、漏桶算法和令牌桶算法的区别漏桶算法与令牌桶算法在表面看起来类似，很容易将两者混淆。但事实上，这两者具有截然不同的特性，且为不同的目的而使用。漏桶算法与令牌桶算法的区别在于： 1）漏桶算法能够强行限制数据的传输速率。2）令牌桶算法能够在限制数据的平均传输速率的同时还允许某种程度的突发传输。 需要说明的是：在某些情况下，漏桶算法不能够有效地使用网络资源。因为漏桶的漏出速率是固定的，所以即使网络中没有发生拥塞，漏桶算法也不能使某一个单独的数据流达到端口速率。因此，漏桶算法对于存在突发特性的流量来说缺乏效率。而令牌桶算法则能够满足这些具有突发特性的流量。通常，漏桶算法与令牌桶算法结合起来为网络流量提供更高效的控制。 一般背包问题一般背包问题（背包问题）：如果物品是可以分割的，也就是允许将其中的一部分装入背包。 🌰：盗贼偷金粉算法：贪心算法（往一个杯子里放东西，先放石子，再放沙，最后水） 0/1背包问题0/1背包问题：如果每一件物品不能分割，只能作为整体或者装入背包，或者不装入 🌰：盗贼偷金锭算法：动态规划算法（当决定是否放入i时，我们需要考虑两种子问题。 一：如果放入，那我们考虑在物品数为i-1， 背包容量为j-weight[i]时的价值 二：如果不放入，物品数为i-1， 重量为j时的价值 哪一个大，选择哪一个。） 解决思路：对于这种问题，我们可以采用一个二维数组去解决：f[i][j]，其中i代表加入背包的是前i件物品，j表示背包的承重，f[i][j]表示当前状态下能放进背包里面的物品的最大总价值。那么，f[n][m]就是我们的最终结果了。 采用动态规划，必须要知道初始状态和状态转移方程。初始状态很容易就能知道，那么状态转移方程如何求呢？对于一件物品，我们有放进或者不放进背包两种选择：1)假如我们放进背包，f[i][j] = f[i - 1][j - weight[i]] + value[i]，这里的f[i - 1][j - weight[i]] + value[i]应该这么理解：在没放这件物品之前的状态值加上要放进去这件物品的价值。而对于f[i - 1][j - weight[i]]这部分，i - 1很容易理解，关键是 j - weight[i]这里，我们要明白：要把这件物品放进背包，就得在背包里面预留这一部分空间。2)假如我们不放进背包，f[i][j] = f[i - 1][j]，这个很容易理解。因此，我们的状态转移方程就是：f[i][j] = max(f[i][j] = f[i - 1][j] , f[i - 1][j - weight[i]] + value[i])当然，还有一种特殊的情况，就是背包放不下当前这一件物品，这种情况下f[i][j] = f[i - 1][j]。 最佳合并模式思路：若要使得带权外路径长度最小，可以将权值大的节点尽量靠近根节点，这样路径短一些；而权值小的节点可以适当远离根节点，因为权值小，外路径稍微长一点也没事。 伪代码：用一个优先权队列存储所有的初始节点；从队列中选出两个权值最小的节点，将它们的和作为它们的根节点，并放入队列中；循环这个过程，直到队列中只有一个节点为止，此时具有最小带权路径的扩充二叉树构造完毕！此时带权外路径长度即为最小的读写次数。 最小代价生成树🌰：n个村庄间架设通信线路，每个村庄间的距离不同，如何架设最节省开销？ 这个问题中，村庄可以抽象成节点，村庄之间的距离抽象成带权值的边，要求最节约的架设方案其实就是求如何使用最少的边、最小的权值和将图中所有的节点连接起来。这就是一个最小代价生成树的问题，可以用Prim算法或kruskal算法解决。 PS1：无向连通图的生成树是一个极小连通子图。PS2：生成树是图的一个子图，包括所有的顶点和最少的边（n-1条边）。PS3：最小代价生成树就是所有生成树中权值之和最小的那个。 算法的目标很明确，就是要在n个节点的图中，找出n-1个节点，并且节点之间连线的权值是最小的。 迪杰斯特拉算法一、描述：迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止 二、基本思想通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。 初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。 佛洛依德算法一、算法的特点：弗洛伊德算法是解决任意两点间的最短路径的一种算法，可以正确处理有向图或有向图或负权（但不可存在负权回路)的最短路径问题，同时也被用于计算有向图的传递闭包。 二、算法的思路通过Floyd计算图G=(V,E)中各个顶点的最短路径时，需要引入两个矩阵，矩阵S中的元素a[i][j]表示顶点i(第i个顶点)到顶点j(第j个顶点)的距离。矩阵P中的元素b[i][j]，表示顶点i到顶点j经过了b[i][j]记录的值所表示的顶点。 假设图G中顶点个数为N，则需要对矩阵D和矩阵P进行N次更新。初始时，矩阵D中顶点a[i][j]的距离为顶点i到顶点j的权值；如果i和j不相邻，则a[i][j]=∞，矩阵P的值为顶点b[i][j]的j的值。 接下来开始，对矩阵D进行N次更新。第1次更新时，如果”a[i][j]的距离” &gt; “a[i][0]+a[0][j]”(a[i][0]+a[0][j]表示”i与j之间经过第1个顶点的距离”)，则更新a[i][j]为”a[i][0]+a[0][j]”,更新b[i][j]=b[i][0]。 同理，第k次更新时，如果”a[i][j]的距离” &gt; “a[i][k-1]+a[k-1][j]”，则更新a[i][j]为”a[i][k-1]+a[k-1][j]”,b[i][j]=b[i][k-1]。更新N次之后，操作完成！ 进程调度算法需要进程调度的理由很简单，即充分利用计算机系统中的CPU资源，让计算机系统能够多快好省地完成我们让它做的各种任务。为此，可在内存中可存放数目远大于计算机系统内CPU个数的进程，让这些进程在操作系统的进程调度器的调度下，能够让进程高效（高的吞吐量–throughput）、及时（低延迟–latency）、公平（fairness）地使用CPU。 指标：1）CPU利用率：CPU是计算机系统中的稀缺资源，所以应在有具体任务的情况下尽可能使CPU保持忙，从而使得CPU资源利用率最高。2）吞吐量：CPU运行时的工作量大小是以每单位时间所完成的进程数目来描述的，即称为吞吐量。3）周转时间：指从进程创建到作进程结束所经过的时间，这期间包括了由于各种因素（比如等待I/O操作完成）导致的进程阻塞，处于就绪态并在就绪队列中排队，在处理机上运行所花时间的总和。4）等待时间：即进程在就绪队列中等待所花的时间总和。因此衡量一个调度算法的简单方法就是统计进程在就绪队列上的等待时间。5）响应时间：指从事件（比如产生了一次时钟中断事件）产生到进程或系统作出响应所经过的时间。在交互式桌面计算机系统中，用户希望响应时间越快越好，但这常常要以牺牲吞吐量为代价。 最长公共子序列一、区分最长公共子串（Longest Common Substirng）和最长公共子序列（Longest Common Subsequence，LCS）的区别为：子串是串的一个连续的部分，子序列则是从不改变序列的顺序，而从序列中去掉任意的元素而获得新的序列；也就是说，子串中字符的位置必须是连续的，子序列则可以不必连续。 二、应用最长公共子序列的问题常用于解决字符串的相似度，是一个非常实用的算法1）枚举法2）动态规划法 多段图问题多段图最短路径问题是应用动态规划的经典问题之一，许多优化问题都能转化为多段图最短路径问题进而求解。 问题求解：采用自底向上的动态规划算法进行求解，先求解源s到第2阶段所有节点的最短路径，然后求第3阶段所有节点的最短路径，以此类推，直到求到汇节点。 1.从前往后依次给所有结点编号；序号必须从0开始，依次递增，同一阶段的结点顺序可以随意；2.创建数组cost和d，分别记录每个结点的最短路径长度 和 每个结点最短路径的前驱结点；3.从最后一个结点开始，从后向前，依次计算每个结点的cost值和d值；4.直到将所有结点都计算完毕后，即可得到最短路径。 n皇后问题问题：N皇后问题是一个经典的问题，在一个N*N的棋盘上放置N个皇后，每行一个并使其不能互相攻击（同一行、同一列、同一斜线上的皇后都会自动攻击）。 广度优先搜索算法：这里使用的是一个改良版的广度优先搜索算法。在N×N的棋盘上，我们先在第一行的第一个位置放置下皇后，接着我们就不去管第一行了，因为第一行已经不能放置皇后了。我们在第二行找到所有的可以放置皇后的位置。同理我们现在可以不用去管前两行了。我们对于第二行的每一个可以放置皇后的位置，都在第三行继续寻找可以放置皇后的位置，如此往复，直到我们遍历到最后一行。这个时候我们就得到了一部分解，这些解是对于第一个皇后放置在第一行第一列的位置而言。接下来对于第一行第二列、第三列…所有列都进行这个步骤，就得到了所有的解。 回溯算法：回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。回溯算法的基本思想是：从一条路往前走，能进则进，不能进则退回来，换一条路再试。在现实中，有很多问题往往需要我们把其所有可能穷举出来，然后从中找出满足某种要求的可能或最优的情况，从而得到整个问题的解。回溯算法就是解决这种问题的“通用算法”，有“万能算法”之称。N皇后问题在N增大时就是这样一个解空间很大的问题，所以比较适合用这种方法求解。这也是N皇后问题的传统解法，很经典。 广度优先搜索（宽度优先搜索） BFS描述：属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。 广度优先搜索使用队列（queue）来实现，整个过程也可以看做一个倒立的树形：1、把根节点放到队列的末尾。2、每次从队列的头部取出一个元素，查看这个元素所有的下一级元素，把它们放到队列的末尾。并把这个元素记为它下一级元素的前驱。3、找到所要找的元素时结束程序。4、如果遍历整个树还没有找到，结束程序。 深度优先搜索 DFS描述：其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次. 深度优先搜索用栈（stack）来实现，整个过程可以想象成一个倒立的树形：1、把根节点压入栈中。2、每次从栈中弹出一个元素，搜索所有在它下一级的元素，把这些元素压入栈中。并把这个元素记为它下一级元素的前驱。3、找到所要找的元素时结束程序。4、如果遍历整个树还没有找到，结束程序。 应用：深度优先搜索是一种在开发爬虫早期使用较多的方法。它的目的是要达到被搜索结构的叶结点(即那些不包含任何超链的HTML文件) 。 递归和迭代递归：程序调用自身称为递归 优点：大问题转化为小问题，可以减少代码量，同时代码精简，可读性好； 缺点：就是递归调用浪费了空间，而且递归太深容易造成堆栈的溢出。 迭代：利用变量的原值推出新值称为迭代 优点：就是代码运行效率好，因为时间只因循环次数增加而增加，而且没有额外的空间开销； 缺点：就是代码不如递归简洁 缓存淘汰算法使用LRU(least-recently-used) 算法来淘汰（清理）使用频率较低的缓存。 缓存清理策略：使用三个维度来标记，分别是count（缓存数量），cost（开销），age（距上一次的访问时间）。YYMemoryCache提供了分别针对这三个维度的清理缓存的接口。用户可以根据不同的需求（策略）来清理在某一维度超标的缓存。","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://reversescale.github.io/categories/Algorithm/"}],"tags":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/tags/Book/"}]},{"title":"《计算机网络》摘抄笔记整理","slug":"Book Computer Networking","date":"2018-12-08T01:29:16.000Z","updated":"2018-12-08T01:38:51.734Z","comments":true,"path":"2018/12/08/Book Computer Networking/","link":"","permalink":"https://reversescale.github.io/2018/12/08/Book Computer Networking/","excerpt":"本书采用了独创的自顶向下方法，即从应用层开始沿协议栈向下讲解计算机网络的基本原理，强调应用层范例和应用编程接口，内容深入浅出，注重教学方法，理论与实践相结合~","text":"本书采用了独创的自顶向下方法，即从应用层开始沿协议栈向下讲解计算机网络的基本原理，强调应用层范例和应用编程接口，内容深入浅出，注重教学方法，理论与实践相结合~ 传输层传输层负责程序之间数据传输的效率以及可靠性，这些程序称为端点。 传输层完成传输连接的建立、维持和拆除 传输层有两种类型的协议：1)面向连接的协议TCP2)无连接协议UDP 传输层功能：1)传输层连接管理2)向会话层提供独立于通信子网的、可靠的、透明的数据传输服务 （封装性）3)多路复用 （提高效率）4)寻址（将报文传送给指定进程）5)差错控制 （重发纠错）6)流量控制 （端点流量） 复用：多个用户使用一个IO资源发送消息分用：多个用户使用一个IO资源接收消息 传输层位于网络层之上 场景虚构📽 东西海岸各12个表兄弟书信通信主机(也称为终端系统)=房子进程=堂兄妹应用程序消息=信封里的信网络层协议=邮递服务(包括邮递员)传输层协议=Ann和Bill(整理代发人) ━━●●━━━━━━━━━━━ UDPUDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以他在传输数据时非常快。 没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。UDP也是无法避免攻击的，比如：UDP flood攻击。 不可靠，不稳定，因为UDP没有TCP的那些可靠机制，在网络质量不好时很容易丢包。 – QQ语音– QQ视频– TFTP UDP协议分为首部字段和数据字段，其中首部字段只占用8个字节，分别是个占用两个字节的源端口、目的端口、长度和检验和。 ━━●●━━━━━━━━━━━ TCPTCP的可靠性体现在传输数据之前，三次握手建立连接（四次挥手释放连接），并且在数据传递时，有确认、窗口、重传、拥塞控制机制，数据传完之后，断开连接用来节省系统资源。 – 浏览器，用的HTTP– FlashFXP，用的FTP– Outlook，用的POP、SMTP– Putty，用的Telnet、SSH– QQ文件传输 TCP报头中的源端口号和目的端口号同IP数据报中的源IP与目的IP唯一确定一条TCP连接。 四次挥手1）第一次挥手：客户端发送一个FIN，用来关闭客户端到Server的数据传送，客户端进入FIN_WAIT_1状态。FIN：释放一个连接 2）第二次挥手：Server收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。 3）第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 4）第四次挥手：客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 场景虚构📽 TCP可靠传输是如何实现的 🍞 分割块：应用数据被分割成TCP认为最适合发送的数据块。 ⏰ 超时重传：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 👯‍ 编码排序：TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。 🗃 校验和：TCP将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。 🗑 自动丢弃：TCP的接收端会丢弃重复的数据。 ⏳ 流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的我数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。 🎢 拥塞控制：当网络拥塞时，减少数据的发送。 ━━●●━━━━━━━━━━━ 停止等待协议TCP协议是面向流的，而UDP是面向数据包的。 A发送一个数据包后就只等待，B接受一个数据后对数据包进行处理后发送一个“确认包”，这时候A才可以再发下一个数据包，如果在A等到超过了A所能接收的时间，那么A就重新发一个包。 优点：就是简单有效。 缺点：信道利用率低，发送端很多时间都花在等待上，接收端需要忙于对每个发送做确认。 ━━●●━━━━━━━━━━━ 滑动窗口协议滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。 体现了TCP面向字节流的设计思路。 一是提供TCP的可靠性，二是提供TCP的流控特性。 ━━●●━━━━━━━━━━━ TCP的流量控制一般来说，我们总是希望传输数据的更快一些，但假设发送方把数据发送的非常快。而接收方来不及接收，这就可能造成数据的丢失。流量控制就是让发送方的发送速率不要太快。让接收方来得及接收。 对于成块数据流，TCP利用滑动窗体机制来实现流量的控制，对于交互数据流，TCP利用捎带ACK和Nagle算法来实现流量的控制。 TCP采用大小可变的滑动窗口进行流量控制，窗口大小的单位是字节。 发送窗口在连接建立时由双方商定。但在通信的过程中，接收端可根据自己的资源情况，随时动态地调整对方的发送窗口上限值(可增大或减小)。 ━━●●━━━━━━━━━━━ TCP拥塞控制慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。 一、慢开始、拥塞避免：1）在主机刚刚开始发送报文段时可先将拥塞窗口 cwnd 设置为一个最大报文段 MSS 的数值。2）在每收到一个对新的报文段的确认后，将拥塞窗口增加至多一个 MSS 的数值。3）用这样的方法逐步增大发送端的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。 二、快重传、快恢复：如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。 快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。 ━━●●━━━━━━━━━━━ HTTP工作流程1、客户端连接到Web服务器一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，http://www.oakcms.cn。 2、发送HTTP请求通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。 3、服务器接受请求并返回HTTP响应Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。 4、释放连接TCP连接若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求; 5、客户端浏览器解析HTML内容客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。 HTTP 1.1 中的 8 种请求方式GET：请求指定的页面信息，并返回实体主体。HEAD：类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头POST：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。PUT：从客户端向服务器传送的数据取代指定的文档的内容。DELETE：请求服务器删除指定的页面。CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。OPTIONS：允许客户端查看服务器的性能。TRACE：回显服务器收到的请求，主要用于测试或诊断。 Request 包括以下格式（四部分）：1）请求行（request line）：GET、POST、..2）请求头部（header）：指出请求的目的地3）空行：空行是规范4）请求数据：主体 Response 包括以下格式（四部分）：1）状态行：（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）2）消息报头：说明客户端要使用的一些附加信息3）空行：空行是规范4）响应正文：响应正文，服务器返回给客户端的文本信息 HTTP常用状态码及其含义1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求 场景虚构📽 在浏览器地址栏键入URL，按下回车之后会经历以下流程：1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;2、解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;3、浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器;4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;5、释放 TCP连接;6、浏览器将该 html 文本并显示内容。 ━━●●━━━━━━━━━━━ HTTPSHTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。 HTTPS和HTTP的区别是什么1、HTTPS是加密传输协议，HTTP是名文传输协议; 2、HTTPS需要用到SSL证书，而HTTP不用; 3、HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO 【参考：（1）为保护用户隐私安全,谷歌优先索引HTTPS网页、（2）百度开放收录https站点，https全网化势不可挡】; 4、 HTTPS标准端口443，HTTP标准端口80; 5、 HTTPS基于传输层，HTTP基于应用层; 6、 HTTPS在浏览器显示绿色安全锁，HTTP没有显示。 场景虚构📽 HTTPS协议的工作流程step1:👨🏻‍💻 -&gt; 你好 -&gt; 🗄 step2:🗄 -&gt; 你好，我是服务器，这里是我的数字证书 -&gt; 👨🏻‍💻 step3:👨🏻‍💻 -&gt; 向我证明你就是服务器，这是一个随机字符串 -&gt; 🗄🗄 -&gt;{一个随机字符串}[私钥|RSA] -&gt; 👨🏻‍💻(🔑公钥解密做对比) step4:👨🏻‍💻 -&gt; [私钥|RSA] -&gt; 🗄🗄 -&gt;{OK，已经收到你发来的对称加密算法和密钥！有什么可以帮到你的？}[密钥|对称加密算法] -&gt; 👨🏻‍💻👨🏻‍💻 -&gt;{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法] -&gt; 🗄🗄 -&gt;{你好，你的余额是100元}[密钥|对称加密算法] -&gt; 👨🏻‍💻… … (其他通讯) ━━●●━━━━━━━━━━━ RSA公钥密码体制RSA密码体制是一种公钥密码体制，公钥公开，私钥保密，它的加密解密算法是公开的。 由公钥加密的内容可以并且只能由私钥进行解密，并且由私钥加密的内容可以并且只能由公钥进行解密。也就是说，RSA的这一对公钥、私钥都可以用来加密和解密，并且一方加密的内容可以由并且只能由对方进行解密。","categories":[{"name":"Network","slug":"Network","permalink":"https://reversescale.github.io/categories/Network/"}],"tags":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/tags/Book/"}]},{"title":"读书好伙伴 Kindle App","slug":"Kindle App","date":"2018-11-19T12:16:27.000Z","updated":"2018-11-19T12:27:11.449Z","comments":true,"path":"2018/11/19/Kindle App/","link":"","permalink":"https://reversescale.github.io/2018/11/19/Kindle App/","excerpt":"kindle 未必随身携带，但是总有那么几段时间你会没事可干，Kindle App 的意义就是为了发挥“碎片时间阅读”效能的，同步阅读进度，同步阅读内容、同步笔记等等~~","text":"kindle 未必随身携带，但是总有那么几段时间你会没事可干，Kindle App 的意义就是为了发挥“碎片时间阅读”效能的，同步阅读进度，同步阅读内容、同步笔记等等~~ Kindle App Kindle App 是亚马逊 Kindle 开发出的阅读 App，可用于同步我们在亚马逊 Kindle 书城购买中购买的书到各个客户端（Windows、OSX、Android 以及 iOS）。 只要你在 Z.cn 注册一个亚马逊账户，就可以试读各种技术类书籍，看的不错的就可以直接购买。下单后这本书就会储存在你的亚马逊云，你可以再智能手机、平板电脑和 MacBook 上随时汲取知识，不再浪费时间。 实际体验基于亚马逊的庞大图书网络，这里应有尽有，配合整齐排布的彩色图书封面，给人耳目一新的 Kindle 感觉。 如下图所示，我们可以看到，在 App 中看到的 Kindle App 在布局上是比较接近于 Kindle 设备本身的，我们可以调整字号、亮度、对其方式甚至是背景颜色，额，等等，它是彩…色的！ 当我们选择了其中一本书后就可以直接进入阅读界面，在三杠的菜单后我们会发现，这个菜单集成了同步、X-Ray、生词卡以及目录等诸多元素一身。 Kindle App 更是支持 X-Ray，其一直以来都是 Kindle 的一个亮点所在，它可以把我们需要的重点信息（人物、术语、图片）汇总在了一起，让我们可以减少成本去了解作者的写作重点。现在，这个功能也可以在 Kindle App 使用了，真是普喜大奔。 不仅如此，Kindle App 还将 X-Ray 中的排序方式也做了优化，可以说非常人性化了。 其实 Kindle App 还有很多的功能有待发现和科学使用的，比如通过卡片来学习啥的，实用性还是很强的，大家可以参考 Kindle 学习方面的资料就行了。 作为一名程序员可能面对电脑的时间会更多一些，而且大屏幕也更适合阅读，所以这里顺带推荐一下 Kindle Mac App。","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/tags/Book/"}]},{"title":"使用 Ngrok 快速实现内网穿透","slug":"Ngrok through","date":"2018-08-13T03:56:27.000Z","updated":"2018-11-16T13:22:10.603Z","comments":true,"path":"2018/08/13/Ngrok through/","link":"","permalink":"https://reversescale.github.io/2018/08/13/Ngrok through/","excerpt":"实现内网穿透的工具很多，之所以介绍 Ngrok，主要还是因为它使用便捷，不用搭建服务器等等麻烦的工序，适合前段开发过程中，快速评估检测项目~","text":"实现内网穿透的工具很多，之所以介绍 Ngrok，主要还是因为它使用便捷，不用搭建服务器等等麻烦的工序，适合前段开发过程中，快速评估检测项目~ Ngrok是什么ngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放。 而我用来在家里快速访问 Jenkins，偷个懒🤪 搭建方法由于要完成一个网页优化的作业找了很久ngrok的使用方法，都不够简便易行最后终于发现了一个好方法。 下载 MAC 版的 ngrok：https://ngrok.com/download 解压到指定目录：Safari 浏览器下载 Mac OS X 环境一般直接解压（反正我是自动解压的），将 ngrok 放进项目目录。 进入到 ngrok 所在路径：1cd /tmp 开启服务1./ngrok http localhost:8080 会出现如下 ngrok 控制台 等待 Session Status 状态为 online（变绿），就可以在外网通过 Forwarding 的地址进行连接了。 注意：Forwarding地址中的 c33faf1b 不是固定的，在每次开始 ngrok 服务的时候都会变更，想固定？ ngrok:😛要钱。 测试一下例如： ngrok 穿透前在局域网中访问地址：http://localhost:8080 ngrok 穿透后局域网 + 公网访问地址：https://c33faf1b.ngrok.io","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Web","slug":"Web","permalink":"https://reversescale.github.io/tags/Web/"}]},{"title":"如何用 Swift 打造你的第一个区块链 App","slug":"How to build DApp","date":"2018-07-06T14:51:21.000Z","updated":"2018-11-16T12:06:29.783Z","comments":true,"path":"2018/07/06/How to build DApp/","link":"","permalink":"https://reversescale.github.io/2018/07/06/How to build DApp/","excerpt":"区块链(Blockchain) 是一种突破性技术(Disruptive Technologies)，近年渐获关注，号称将互联网从信息共享，推向价值传递，让我们一步一步的来探索它设计上的奇思妙想~","text":"区块链(Blockchain) 是一种突破性技术(Disruptive Technologies)，近年渐获关注，号称将互联网从信息共享，推向价值传递，让我们一步一步的来探索它设计上的奇思妙想~ 因为区块链是许多加密货币(Cryptocurrencies) 如比特币(Bitcoin)、以太坊(Ethereum)、莱特币(Litecoin) 的创始技术。那区块链是如何运作的呢？在本次的教学里，我将会谈到所有关于区块链技术的知识，以及如何用Swift 来制作自己的「区块链」。那么，让我们开始吧！ 区块链的运作顾名思义，区块链就是一个由不同的区块串连在一起的「链」，每个区块包含三则资讯：资料(Data)、杂凑值(Hash)、和前一个区块的杂凑值。 资料 ──依据使用情境，储存在区块的资料会因区块链的类型而不同。例如，在比特币区块链中，储存资料就是与交易有关的资讯，即是转帐的金额、以及参与交易二人的资讯。 杂凑值 ──你可以把杂凑想成是一种数位指纹，它是用来识别一个区块及其资料。杂凑最重要的地方，就是它是一个独一无二的字母数字(Alphanumeric)程式码，通常会由64个字元组成。当一个区块被创造时，杂凑值也同时产生。当一个区块被更动时，杂凑值也会同时被更动。透过这种方式，当你想要查看区块上的任何变动时，杂凑值就非常重要。 前一个区块的杂凑值 ──每个区块就是藉由储存前个区块的杂凑来链结在一起，组成一个区块链！这就是让区块链如此安全的原因。看看这张图片： 如你所见，每个区块由资料（未显示）、杂凑值、和前一个区块杂凑值所组成。举个例子，黄色区块包含了自己的杂凑值H7S6、和红色区块的杂凑值8SD9。以这种方式，它们组成了一个链结，并以此连结在一起。现在，假设有个骇客入侵并尝试更动红色区块。请记住，每次一个区块以任何方式被更动时，区块的杂值凑也会被更动！因此，当下一个区块执行确认、并看到前一个区块的杂凑值并不吻合时，它会有效地将自己从「链」中分离出来，而不会被骇客读取。 这就是区块练会如此安全的原因，你几乎不可能尝试回溯并更改任何资料。杂凑值提供了不错的保密及隐私，但还有两个安全机制来让区块链更加安全：验证(Proof-of-work)及智慧合约(Smart Contract)。虽然我不会详述，但你可以在这里了解更多。区块链最后一个保全方式就是基于它的位置。与大多储存在伺服器或是资料库内的资料不同，区块链使用点对点网路(Peer-To-Peer, P2P)，它是一种网路型态，允许任何人加入并将该网路上的资料分发给每位接收者。每当有人加入这个网路时，他们就会得到区块链的完整拷贝；每当有人建立一个新区块时，就会传送到网路内的所有人。然后，透过一些复杂的程式，让节点(Node)在加入这个区块到区块链之前，先确认该区块有否被窜改。就这样，任何地方的任何人都可以取得这些资讯。如果你是HBO矽谷群瞎传(Silicon Valley)的忠实粉丝，这听起来可能有点熟悉，因为在这出美剧里，主角就是用了类似的技术来建立一个全新网路。 因为每个人或节点都有一份区块链的拷贝，他们可以有共识并确认哪些区块是合法的。因此，如果你想要骇入一个区块，你必须骇入网路上超过50% 的区块来通过你的资讯。这就是为什么区块链或许是过去十年以来最安全的技术之一。 关于范例应用现在你了解区块链是如何运作了，那么开始来制作我们的范例App吧！请先下载初始项目。（https://raw.githubusercontent.com/appcoda/BlockchainDemo/master/BlockchainStarter.zip） 如你所见，我们有两个比特币钱包。第一个帐号Account 1065 拥有500 BTC，而第二个帐号0217 则什么都没有。我们利用传送按钮来传送比特币到其他帐号。为了赚取BTC，我们按下Mine 按钮就可以获得50 BTC 为奖励。基本来说，我们做的是当App 执行时，利用控制台来观察两个比特币帐号间的交易情况。 你会注意到，侧边栏里有两个重要的类别：Block及Blockchain。打开这些档案，你会看到档案是空的，那是因为我将会引导你写出这些类别的逻辑。那我们开始吧！ 在Swift 定义Block前往Block.swift并添加程式码以定义一个区块。首先，让我们了解一下区块是什么。我们先前定义了一个区块由三个部分组成：杂凑值、记录的实际资料、以及前一个区块的杂凑值。当我们想建立自己的区块链时，必须要知道区块的排序，这一点可以很容易地在Swift中定义。添加以下程式码到类别里： 1234var hash: String!var data: String!var previousHash: String!var index: Int! 现在，我们需要添加最后一个重要的程式码。我之前提到每次一个区块被更动，杂凑就会改变；这就是区块链如此安全的特色之一。所以我们必须建立一个函式来产生一个随机字母数字的杂凑。这个函式只需要几行程式码： 123func generateHash() -&gt; String &#123; return NSUUID().uuidString.replacingOccurrences(of: \"-\", with: \"\")&#125; NSUUID是一个物件，代表桥接UUID的通用唯一值。它内置于Swift中，而且非常适合用来产生32字元的字串。这个函式产生一个UUID，消除所有连字符(-)，然后回传String，即区块的杂凑。Block.swift现在应该看起来像这样： 我们已经定义了Block类别，接着让我们定义Blockchain类别吧。切换到Blockchain.swift。 在Swift 定义Blockchain如前文所说，让我们尝试从基本面来了解区块链。在基本的术语里，区块链只是区块串在一起组成的链；换句话说，它是一个包含所有项目的列表。听起来是不是有点熟悉呢？因为这就是阵列的定义，而这个阵列就是由区块所组成！让我们把下列的程式码加进去吧： 1var chain = [Block]() 小提示：这几乎可以应用在电脑科学世界的所有事上。如果你曾遇过大问题，试着将它拆解成小组件，然后以自己的方法来解决问题；就像我们弄清楚如何在Swift中加入区块及区块链一样！ 你会注意到在阵列里面包含了先前定义的Block类别，那是我们在区块链中需要的所有变数。加入两个函式到类别里，我们就完成了。试着用我前文所教的来回答这个问题： 在一个区块链中，两个主要的函式是什么？ 希望你能够回答这个问题！这两个区块链拥有的主要函式，是用来建立初始区块，以及在后面新增新的区块。当然，现在我不会下放这个链并加入智慧合约，但是这些是基本函式！加入以下程式码到Blockchain.swift： 1234567891011121314151617func createGenesisBlock(data:String) &#123; let genesisBlock = Block() genesisBlock.hash = genesisBlock.generateHash() genesisBlock.data = data genesisBlock.previousHash = \"0000\" genesisBlock.index = 0 chain.append(genesisBlock)&#125; func createBlock(data:String) &#123; let newBlock = Block() newBlock.hash = newBlock.generateHash() newBlock.data = data newBlock.previousHash = chain[chain.count-1].hash newBlock.index = chain.count chain.append(newBlock)&#125; 我们加入的第一个函式是用来建立初始区块。为此，我们建立了一个函式来把区块的资料作为Input。然后，我们定义一个名为genesisBlock的变数，并将它设为Block型别。因为它是Block型别，所以它有我们之前在Block.swift定义的所有变数及函式。我们设定generateHash()为杂凑、 Input data为资料。因为这是第一个区块，所以我们将前一个区块的杂凑设定为000，好让我们知道这是初始区块。我们将它的索引值设为0 ，然后放到区块链chain。 我们建立的下一个函式则适用于所有genesisBlock后的区块，而它会建立剩下的所有区块。你会注意到它跟之前的函式非常相似，唯一的不同的是我们将previousHash设定为前一个区块的杂凑，并将index设为它在区块练的位置。完成了！我们已经成功定义自己的Blockchain！你的程式码应该如下图所示！ 接着，我们将所有的部分连接到ViewController.swift档案，并看看执行成果吧！ 钱包后台(Wallet Backend)切换到ViewController.swift，我们可以看到所有的UI元件都已经连结完毕。我们所需要做的就是处理交易，并将交易列印到控制台上。然而在开始之前，我们应该稍微探讨一下比特币区块链。比特币来自一个总帐号，假设这个帐号的编号是000。当你挖掘一颗比特币时，就表示你解答了数学问题，并获得一定数量的比特币作为奖励。这是发行货币一个很聪明的方法，同时也创造了让更多人去挖掘的动机。在我们的App 里，我们将100 BTC 作为奖励。首先，让我们在ViewController 添加需要的变数： 123456let firstAccount = 1065let secondAccount = 0217let bitcoinChain = Blockchain()let reward = 100var accounts: [String: Int] = [\"0000\": 10000000]let invalidAlert = UIAlertController(title: \"Invalid Transaction\", message: \"Please check the details of your transaction as we were unable to process this.\", preferredStyle: .alert) 我们定义两个帐号：一个编号为1065，另一个编号为0217。我们同时新增一个bitcoinChain变数来作为我们的区块链，并将reward设定为100。我们需要一个作为比特币来源的主帐号：这是我们的初始帐号，编号为0000，它拥有一千万个比特币。你可以把这个帐号当成银行，在每一次的奖励中，就会从中取出100个比特币，并转至合法的帐号里。我们也定义一个警告，在每次交易无法完成时显示。 现在，让我们来写些将会执行的泛用函式。你可以猜到这些函式是什么吗？ 第一个函式是用来处理交易的。我们要确认传送者及接收者的帐号中，接收或扣除的金额是正确的，而且这个资讯会被记录在我们的区块链上。 下一个函式是要在控制台里印出完整的纪录，它会显示每个区块及每个区块内的资料。 最后一个函式是用来验证区块链是否合法，方法为确认前个区块的杂凑是否符合下一个区块的资讯。因为我们不会示范任何骇客方法，所以范例中的链永远都是合法的。 Transaction 函式以下是我们的泛用交易函式。在定义变数之下输入以下程式码： 1234567891011121314151617181920212223242526func transaction(from: String, to: String, amount: Int, type: String) &#123; // 1 if accounts[from] == nil &#123; self.present(invalidAlert, animated: true, completion: nil) return &#125; else if accounts[from]!-amount &lt; 0 &#123; self.present(invalidAlert, animated: true, completion: nil) return &#125; else &#123; accounts.updateValue(accounts[from]!-amount, forKey: from) &#125; // 2 if accounts[to] == nil &#123; accounts.updateValue(amount, forKey: to) &#125; else &#123; accounts.updateValue(accounts[to]!+amount, forKey: to) &#125; // 3 if type == \"genesis\" &#123; bitcoinChain.createGenesisBlock(data: \"From: \\(from); To: \\(to); Amount: \\(amount)BTC\") &#125; else if type == \"normal\" &#123; bitcoinChain.createBlock(data: \"From: \\(from); To: \\(to); Amount: \\(amount)BTC\") &#125;&#125; 看起来程式码很多，但是它的核心只是为每次的交易定义一些规则。在开头的地方，我们有四个参数：to、from、amount以及type。To、From、及Amount的含义一目了然，而Type基本上就是定义交易的类型。这里有两种Type：Normal和Genesis。一个Normal的交易类型会是在帐号1065与0217之间进行，而Genesis交易类型则会涉及到帐号0000。 第一个if-else条件式是关于来源帐号。如果来源帐号不存在或金额不足，我们会显示交易无效的警告，然后结束函式。而如果通过的话，我们会更新数值。 第二个if-else条件式是关于接收帐号。如果接收帐号不存在，那么我们随它而去，然后结束函式。要不然，我们就会传送正确的比特币数量到帐号。 第三个if-else条件式处理交易的类型。如果一个交易涉及初始区块，我们就建立一个新的初始区块；反之我们建立一个新区块来储存资料。 Printing 函式在每次交易的最后，我们想要看到一个清单列出所有交易，来确保我们知道所有发生的事情。以下是我们在transaction函式下输入的程式码： 123456789func chainState() &#123; for i in 0...bitcoinChain.chain.count-1 &#123; print(\"\\tBlock: \\(bitcoinChain.chain[i].index!)\\n\\tHash: \\(bitcoinChain.chain[i].hash!)\\n\\tPreviousHash: \\(bitcoinChain.chain[i].previousHash!)\\n\\tData: \\(bitcoinChain.chain[i].data!)\") &#125; redLabel.text = \"Balance: \\(accounts[String(describing: firstAccount)]!) BTC\" blueLabel.text = \"Balance: \\(accounts[String(describing: secondAccount)]!) BTC\" print(accounts) print(chainValidity())&#125; 这是一个简单的for回圈，包含bitcoinChain的每个区块。我们印出区块的编号、杂凑值、前个区块的杂凑、以及储存的资料，再更新UILabel来显示每个帐号内正确的BTC数目。最后，印出一个列出每个帐号的清单（应该会有三个），并验证链的合法性。现在，你应该会在函式最后一行中发生错误。这是因为我们还没定义chainValidity()函式，那么就来开始吧！ Validity 函式记住，如果前一个区块的杂凑值符合目前区块所描述的内容，那么这一个链就是合法的。我们可以轻易地用另一个for 回圈来重复验证每个区块。 123456789func chainValidity() -&gt; String &#123; var isChainValid = true for i in 1...bitcoinChain.chain.count-1 &#123; if bitcoinChain.chain[i].previousHash != bitcoinChain.chain[i-1].hash &#123; isChainValid = false &#125; &#125; return \"Chain is valid: \\(isChainValid)\\n\"&#125; 跟之前有点相似，我们在bitcoinChain中重复验证每个区块，来确认前一个区块的杂凑值是否与目前区块所描述的内容符合。这样就完成了！我们已经定义了函式，并将会每次都用到它们！你的ViewController.swift现在应该看起来像这样： 现在我们只需要将按钮连接到函式就完成了，来开始最后的篇章吧！ 将所有东西连结在一起当我们的App首次启动时，我们想让初始帐号0000传送50 BTC到我们的第一个帐号。然后，我们将让第一个帐号传送10 BTC到第二个帐号。这个步骤仅需三行程式码就可以完成。如此更改你的viewDidLoad函式： 1234567override func viewDidLoad() &#123; super.viewDidLoad() transaction(from: \"0000\", to: \"\\(firstAccount)\", amount: 50, type: \"genesis\") transaction(from: \"\\(firstAccount)\", to: \"\\(secondAccount)\", amount: 10, type: \"normal\") chainState() self.invalidAlert.addAction(UIAlertAction(title: \"OK\", style: .default, handler: nil))&#125; 我们使用先前定义好的函式，并在最后呼叫chainState()。同时，我们新增一个OK按钮到交易无效的警告中。现在让我们来看看剩下的四个函式里要加入什么：redMine()、blueMine()、redSend()及blueSend()。 挖矿函式挖矿函式非常地简单，只要三行程式码就行了。这就是我们要添加的程式码： 1234567891011@IBAction func redMine(_ sender: Any) &#123; transaction(from: \"0000\", to: \"\\(firstAccount)\", amount: 100, type: \"normal\") print(\"New block mined by: \\(firstAccount)\") chainState()&#125; @IBAction func blueMine(_ sender: Any) &#123; transaction(from: \"0000\", to: \"\\(secondAccount)\", amount: 100, type: \"normal\") print(\"New block mined by: \\(secondAccount)\") chainState()&#125; 在第一个挖矿函式中，我们使用transaction函式从初始帐号传送100 BTC到第一个帐号，先印出一个区块被挖出，再印出chainState。同样地，我们在blueMine函式里将100 BTC传送到第二个帐号。 传送函式传送函式与先前的函式也稍微相似。 123456789101112131415161718192021@IBAction func redSend(_ sender: Any) &#123; if redAmount.text == \"\" &#123; present(invalidAlert, animated: true, completion: nil) &#125; else &#123; transaction(from: \"\\(firstAccount)\", to: \"\\(secondAccount)\", amount: Int(redAmount.text!)!, type: \"normal\") print(\"\\(redAmount.text!) BTC sent from \\(firstAccount) to \\(secondAccount)\") chainState() redAmount.text = \"\" &#125;&#125; @IBAction func blueSend(_ sender: Any) &#123; if blueAmount.text == \"\" &#123; present(invalidAlert, animated: true, completion: nil) &#125; else &#123; transaction(from: \"\\(secondAccount)\", to: \"\\(firstAccount)\", amount: Int(blueAmount.text!)!, type: \"normal\") print(\"\\(blueAmount.text!) BTC sent from \\(secondAccount) to \\(firstAccount)\") chainState() blueAmount.text = \"\" &#125;&#125; 首先，我们确认redAmount或blueAmount中的文字栏位是否为空值。如果是，我们会显示一个交易无效的警告。如果不是，我们就可以继续。我们使用transaction函式输入金额，并把交易设为normal型态，以将第一个帐号的金额传送到第二个帐号（或相反）。我们印出被传送的金额，然后呼叫chainState()函式。最后，把文字栏位清空。这样我们就完成啰！确认一下你的程式码是否符合下图所示。 执行App 试试看！从前端来说，它看起来就如一个普通的交易App，但你会知道它后台的运作。试试使用App 将BTC 从一个帐号交易给另一个帐号、并试着欺骗App 吧！ 结论在这次的教学中，你学到了如何使用Swift 来建立一个区块链，并建立自己的比特币交易。请注意在真实的加密货币后台里，实作部分是跟上文是完全不一样的东西，因为它需要藉由智慧合约来分散，但是上面的示范内容用来学习的。在这个范例中，我们运用了比特币来当加密货币，但你能想到区块链还的其他用途吗？欢迎在下面留言分享你的看法！希望你在此学到新的东西！你可以在Github下载完整项目作参考。 完整项目：https://github.com/appcoda/BlockchainDemo原文链接：https://www.appcoda.com/blockchain-introduction/","categories":[{"name":"Summary","slug":"Summary","permalink":"https://reversescale.github.io/categories/Summary/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://reversescale.github.io/tags/Blockchain/"}]},{"title":"iOS AVFoundation 音视频处理","slug":"iOS AVFoundation","date":"2018-06-16T13:56:27.000Z","updated":"2018-11-26T13:25:46.781Z","comments":true,"path":"2018/06/16/iOS AVFoundation/","link":"","permalink":"https://reversescale.github.io/2018/06/16/iOS AVFoundation/","excerpt":"AVFoundation 是苹果在 iOS 和 OS X 系统中用于处理基于时间的媒体数据的框架~","text":"AVFoundation 是苹果在 iOS 和 OS X 系统中用于处理基于时间的媒体数据的框架~ 👨🏻‍💻 Github Demo 2018.09.28更新 读书推荐《音视频开发进阶指南 基于Android与iOS平台的实践》从 FFmpeg 源码解析到 OpenGL ES 讲多端音视频开发，从原理到实践，逻辑清晰，非常值得学习的一本书。 ijkPlayer 是基于 FFmpeg 框架下 ffplay 进行改造的播放器 对于 OpenGL ES，则有业界著名的开源库 GPUImage AVFoundationAVFoundation是苹果在iOS和OS X系统中用于处理基于时间的媒体数据的框架. 下面简单介绍下AVFoundation内最主要的支撑框架和其提供的功能. CoreAudio : 处理所有音频事件.是由多个框架整合在一起的总称,为音频和MIDI内容的录制,播放和处理提供相应接口.甚至可以针对音频信号进行完全控制,并通过Audio Units来构建一些复杂的音频处理.有兴趣的可以单独了解一下这个框架. CoreMedia: 是AVFoundation所用到低层级媒体管道的一部分.提供音频样本和视频帧处理所需的低层级数据类型和接口. CoreAnimation: 动画相关框架, 封装了支持OpenGL和OpenGL ES功能的ObjC各种类. AVFoundation可以利用CoreAnimation让开发者能够在视频的编辑和播放过程中添加动画和图片效果. 在深入了解学习AVFoundation前,最好还要了解下相关现代数字媒体的采样和处理知识. 数字媒体采样: 其实就是对媒体内容进行数字化,主要有两种方式: ①时间采样：用来捕捉一个信号在一个周期内的变化.如录音时的音高和声调变化. ②空间采样：一般用在可视化内容的数字化过程中,对一幅图片在一定分辨率下捕捉其亮度和色度. 音频篇现实生活中，我们听到的声音都是时间连续的，我们称为这种信号叫模拟信号。模拟信号需要进行数字化以后才能在计算机中使用。数字化的过程如下： 采样 -&gt; 量化 -&gt; 编码 通过获取间隔相同时间的某个模拟信号的值，然后对这些采样以后得到的值进行量化，然后使用一定的bit进行编码存储，整个过程结束后就会输出PCM数据。 在iOS的Core Audio Services中使用的音频数据只能是线性PCM格式的音频数据，这是一种未进过压缩的音频数据格式。要理解整个过程就需要理解多个重要概念：采样频率和采样位数，比特率等。 采样频率采样频率是指单位时间内对声音模拟信号的采样次数。采样率类似于视频的帧数，比如电影的采样率是24Hz。 当我们把采样到的一个个静止画面再以采样率同样的速度回放时，看到的就是连续的画面。同样的道理，把以44.1kHZ采样率记录的CD以同样的速率播放时，就能听到连续的声音。 显然，这个采样率越高，听到的声音和看到的图像就越连贯。当然，人的听觉和视觉器官能分辨的采样率是有限的。对同一段声音，用20kHz和44.1kHz来采样，重放时，可能可以听出其中的差别，而基本上高于44.1kHZ采样的声音，比如说96kHz采样，绝大部分人已经觉察不到两种采样出来的声音的分别了。 之所以使用44.1kHZ这个数值是因为经过了反复实验，人们发现这个采样精度最合适，低于这个值就会有较明显的损失，而高于这个值人的耳朵已经很难分辨，而且增大了数字音频所占用的空间。我们所使用的CD的采样标准就是44.1k。 采样位数采样位数可以理解为采集卡处理声音的解析度。这个数值越大，解析度就越高，录制和回放的声音就越真实。我们首先要知道：电脑中的声音文件是用数字0和1来表示的。连续的模拟信号按一定的采样频率经数码脉冲取样后，每一个离散的脉冲信号被以一定的量化精度量化成一串二进制编码流，这串编码流的位数即为采样位数，也称为量化精度。 在电脑上录音的本质就是把模拟声音信号转换成数字信号。反之，在播放时则是把数字信号还原成模拟声音信号输出。采集卡的位数是指采集卡在采集和播放声音文件时所使用数字声音信号的二进制位数。采集卡的位数客观地反映了数字声音信号对输入声音信号描述的准确程度。 例如，同一段音频信息，使用8bit描述单个采样信息，那么采样量化的范围就是0~255,如果使用16bit表示单个采样值,那么相应的采样量化的范围为0~64k。与8位采样位数相比，16位采样的动态范围的宽度更小，动态范围更宽广，声音的被记录的更加精细。一般CD使用的采样位数为16位。 16位二进制数的最小值是0000000000000000，最大值是1111111111111111，对应的十进制数就是0和65535，也就是最大和最小值之间的差值是65535，也就是说，它量化的模拟量的动态范围可以差65535，也就是96.32分贝（20 * lg65535）），所以，量化精度只和动态范围有关，和频率响应没关系。动态范围定在96分贝也是有道理的，人耳的无痛苦极限声压是90分贝，96分贝的动态范围在普通应用中足够使用，所以96分贝动态范围内的模拟波，经量化后，不会产生削波失真的。 所谓分贝是指两个相同的物理量（例A1和A0）之比取以10为底的对数并乘以10（或20）。N = 10lg(A1/A0) 分贝符号为”dB”，它是无量纲的。式中A0是基准量（或参考量），A是被量度量。被量度量和基准量之比取对数，这对数值称为被量度量的”级”。亦即用对数标度时，所得到的是比值，它代表被量度量比基准量高出多少“级”。 比特率（位速、码率）位速/比特率/码率描述的都是一个东西，是指在一个数据流中每秒钟能通过的信息量。我们可能看到过音频文件用 “128–Kbps MP3” 或 “64–Kbps WMA” 进行描述的情形。Kbps 表示 “每秒千位数”，因此数值越大表示数据越多：128–Kbps MP3 音频文件包含的数据量是 64–Kbps WMA 文件的两倍，并占用两倍的空间。需要了解的重要一点是，位速越高，信息量越大，对这些信息进行解码的处理量就越大，文件需要占用的空间也就越多。 不过在这种情况下，这两种文件听起来没什么两样。原因是什么呢？有些文件格式比其他文件能够更有效地利用数据， 64–Kbps WMA 文件的音质与 128–Kbps MP3 的音质相同。 从码率的计算公式中可以清楚的看出码率和采样位数的关系: 码率 = 取样频率 × 量化精度 × 声道数 一张CD,双声道,采样率44.1kHz，每个采样位数13bit，时长74分钟(4440秒)，则CD的容量为13244100*4440约等于640MB。 压缩编码模式 VBR(Variable Bitrate)动态比特率动态比特率就是没有固定的比特率，压缩软件在压缩时根据音频数据即时确定使用什么比特率。这是新发展的算法，他们将一首歌的复杂部分用高Bitrate编码，简单部分用低Bitrate编码。主意虽然不错，可惜新编码器的VBR算法很差，音质与CBR相去甚远。幸运的是， Lame完美地优化了VBR算法，使之成为MP3的最佳编码模式。这是以质量为前提兼顾文件大小的方式，推荐编码模式。 ABR(Average Bitrate)平均比特率平均比特率是VBR的一种插值参数。Lame针对CBR不佳的文件体积比和VBR生成文件大小不定的特点独创了这种编码模式。ABR也被称为“Safe VBR”，它是在指定的平均Bitrate内，以每50帧(30帧约1秒)为一段，低频和不敏感频率使用相对低的流量，高频和大动态表现时使用高流量。 举例来说，当指定用192kbps ABR对一段wav文件进行编码时，Lame会将该文件的85%用192kbps固定编码，然后对剩余15%进行动态优化：复杂部分用高于192kbps 来编码、简单部分用低于192kbps来编码。与192kbps CBR相比，192kbps ABR在文件大小上相差不多，音质却提高不少。ABR编码在速度上是VBR编码的2到3倍，在128-256kbps范围内质量要好于CBR。可以做为 VBR和CBR的一种折衷选择。 CBR(Constant Bitrate)常数比特率常数比特率指文件从头到尾都是一种位速率。相对于VBR和ABR来讲，它压缩出来的文件体积很大，但音质却不会有明显的提高。 数字信号编码方式 PCM(Pulse Code Modulation)脉冲编码调制脉冲编码调制是一种将模拟语音信号变换为数字信号的编码方式。主要经过3个过程：抽样、量化和编码。抽样过程将连续时间模拟信号变为离散时间、连续幅度的抽样信号，量化过程将抽样信号变为离散时间、离散幅度的数字信号，编码过程将量化后的信号编码成为一个二进制码组输出。 LPCM(Line Pulse Code Modulation)线性脉冲编码调制线性量化在整个量化范围内，量化间隔均相等，称为LPCM。非线性量化采用不等的量化间隔。量化间隔数由编码的二进制位数决定。例如，CD采用16bit线性量化，则量化间隔数L=65536。位数（n)越多，精度越高，信噪比SNR=6.02n+1.76(dB)也越高。但编码的二进制位数不是无限制的，需要根据所需的数据率确定。比如：CD可以达到的数据率为2×44.1×16=1411.2Kbit/s。 总而言之，LPCM格式中的音频数据是未压缩的线性量化后的音频数据。 用iOS的官方文档中对几个关键词的解释： A sample is single numerical value for a single channel. A frame is a collection of time-coincident samples. For instance, a stereo sound file has two samples per frame, one for the left channel and one for the right channel. A packet is a collection of one or more contiguous frames. In linear PCM audio, a packet is always a single frame. In compressed formats, it is typically more. A packet defines the smallest meaningful set of frames for a given audio data format. 压缩过的音频格式在常见的音频格式对PCM原始帧进行封装时也是以frame帧为单位的，我们一般将压缩后的音频数据帧称为媒体帧，对应原始的PCM数据称为原始帧。每个媒体帧又分成head头，body数据体。 在帧头中，会存储这个媒体帧中body部分的码率，采样率等解码必须的信息，因此每一个媒体帧都可以独立于文件存在和播放。在body中存储着一个或者多个媒体帧，这些媒体真是若干个PCM原始帧经过特定的压缩算法压缩得到的。通常情况下，我们将单位时间的媒体帧的个数称为帧率。 上文的采样率和帧率这两个概念都描述了音频媒体的“连续”性，二者的区别在于每个音频的媒体帧中会包含多个音频采样(多个PCM data)，如1个AAC帧中包含1024个采样。 iOS 支持的 sound file 格式 Format name Format filename extensions AIFF .aif, .aiff CAF .caf MPEG-1, layer 3 .mp3 MPEG-2 or MPEG-4 ADTS .aac MPEG-4 .m4a, .mp4 WAV .wav iOS中的native format是CAF file format 文件格式和数据格式如果要理解每一个音频文件,就需要了解它的两个部分的内容:文件格式和数据格式.文件格式又称为音频容器,数据格式又可以认为是编码格式. 文件格式(音频容器) 文件格式描述的是存储在文件系统的文件的本身,而存储在文件中的音频数据是可以被编码成各种各样的格式的.比如,我们常见的CAF文件是一个文件格式(音频容器),它可以用来存储音频编码格式为MP3,LPCM或者其他的音频编码格式. 数据格式(音频编码) iPhone中支持的音频格式如下: AAC: 被设计用来取代MP3音频编码的.它会压缩原来的声音,因此会减少存储空间.实际中ACC比MP3更好的压缩率. AMR: AMR是一个编码格式用于压缩语音的音频编码格式. linear PCM: 是标准的线性脉冲编码,一般是将模拟声音转化成数字信号,这是一个未压缩的音频格式.由于是未压缩的音频编码格式,因此播放时候用这种格式最是最好的选择,但是会占用过多的空间. MP3: … Bit Rates比特率比特率是一个和音频数据格式关系密切的概念. 音频文件的比特率就是只单位时间内传送的bit数,单位是bit/s,kbit/s.更高的比特率会导致更大的文件.我们在使用有些音频数据格式例如AAC或者MP3时,需要我们去设置比特率,这个参数与音频格式在压缩过程的压缩率有关.当我们让比特率变低,那么音频质量就会更差. 注释: 1kbit/s = 1000bit/s,而不是1024bit/s 我们需要权衡比特率的大小和声音文件的质量,选择合适的比特率.如果我们使用的是语音声音,那么比特率可以适当低一点. 下面是常见的比特率: 32kbit/s: AM 无限电广播的质量 48kbit/s: 很长的语音对话 64kbit/s: 正常长度的语音对话的比特率 96kbit/s: FM广播 128kbit/s: MP3音乐 329kbit/s: CD的比特率 500kbit/s~1411kbit/s: 无损音频编码格式,比如LPCM 使用建议首先明确自己有哪些需求: 如果用于播放的音频,选用LPCM,IMA4等其他的未压缩或者轻度压缩的音频格式. 如果使用压缩率较高的AAC,MP3等这些iPhone直接硬件支持快速解码(解压缩).但是,硬件解码时候每次只支持一个文件.因此,如果需要同时播放多个需要解码(解压缩)的文件,就需要通过代码进行软件解码,非常慢. 所以如何选择数据音频格式,这里有些建议: 如果空间足够,那么最好使用的音频编码格式使用LPCM.不仅播放最快,而且可以同时播放多个音乐而不太占用CPU的资源. 如果对空间有要求,最好使用ACC音频编码来进行音乐的播放,IMA4音频编码进行系统声音的编码. 常用的音视频处理通过代码实现常用的音视频处理示例，包括AVAudioPlayer 和 AVAudioPlayer 的剪辑、合成和压缩转码处理，AVPlayer 和 AVQueuePlayer 的演示等。 AVAudioPlayer概述AVAudioPlayer 是一个属于 AVFoundation.framework 的一个类，它的功能类似于一个功能强大的播放器，AVAudioPlayer 支持广泛的音频格式，主要是以下这些格式。 AAC AMR (Adaptive multi-Rate，一种语音格式) ALAC (Apple lossless Audio Codec) iLBC (internet Low Bitrate Codec，另一种语音格式) IMA4 (IMA/ADPCM) linearPCM (uncompressed) u-law 和 a-law MP3 (MPEG-Laudio Layer 3) AVAudioPlayer 的使用首先，引入框架 AVFoundation 和 MediaPlayer 12#import &lt;AVFoundation/AVFoundation.h&gt;#import &lt;MediaPlayer/MediaPlayer.h&gt; 介绍一下常用方法： 1）AVAudioPlayer 初始化1initWithContentsOfURL: error: 从URL加载音频，返回 AVAudioPlayer 对象 1initWithData: error: 加载NSdata对象的音频文件，返回 AVAudioPlayer 对象 2）AVAudioPlayer 方法调用1- (BOOL)play 开始或恢复播放，调用该方法时，如果该音频还没有准备好，程序会转为执行 - (BOOL)prepareToPlay 方法 1- (void)pause 暂停 1- (void)stop 停止 1- (BOOL)playAtTime:(NSTimeInterval)time NS_AVAILABLE(10_7, 4_0) 在某个时间点播放 1- (BOOL)prepareToPlay 准备开始播放 1- (void)updateMeters 更新音频测量值，注意如果要更新音频测量值必须设置meteringEnabled为YES，通过音频测量值可以即时获得音频分贝等信息 1- (float)averagePowerForChannel:(NSUInteger)channelNumber 获得指定声道的分贝峰值，注意如果要获得分贝峰值必须在此之前调用updateMeters方法 3）使用 AVAudioPlayer 读取音频信息 1volume 播放器的音频增益，值：0.0～1.0 1pan NS_AVAILABLE(10_7, 4_0) 立体声设置 设为 －1.0 则左边播放 设为 0.0 则中央播放 设为 1.0 则右边播放 1enableRate 是否允许改变播放速率 1rate NS_AVAILABLE(10_8, 5_0) 播放速率 0.5 (半速播放) ～ 2.0(倍速播放) 注1.0 是正常速度 1playing 是否正在播放音频 1numberOfLoops 循环次数，如果要单曲循环，设置为负数 1numberOfChannels 该音频的声道次数 (只读) 1duration 该音频时长 1currentTime 该音频的播放点 1deviceCurrentTime 输出设备播放音频的时间，注意如果播放中被暂停此时间也会继续累加 1url 音频文件路径，只读 1data 音频数据，只读 1channelAssignments 获得或设置播放声道 4）代理方法 1- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer *)player successfully:(BOOL)flag; 音频播放完成 1- (void)audioPlayerDecodeErrorDidOccur:(AVAudioPlayer *)player error:(NSError * __nullable)error 音频解码发生错误 1- (void)audioPlayerBeginInterruption:(AVAudioPlayer *)player 如果音频被中断，比如有电话呼入，该方法就会被回调，该方法可以保存当前播放信息，以便恢复继续播放的进度 AVAudioPlayer 示例1）素材资源 两个音频文件 两张专辑图片 2）代码实现导入架包 12#import &lt;AVFoundation/AVFoundation.h&gt;#import &lt;MediaPlayer/MediaPlayer.h&gt; 必须持有一个 AVAudioPlayer 对象，若此对象不是属性，则无法播放 1@property (nonatomic , strong) AVAudioPlayer *player; 获取制定 url 对象 1NSURL *url = [[NSBundle mainBundle] URLForResource:@“dog\" withExtension:@“wav\"]; 初始化 AVAudioPlayer 对象 1self.player = [[AVAudioPlayer alloc]initWithContentsOfURL:url error:nil]; 设置代理 1self.player.delegate = self; 这样就播放器就初始化完成了 开始播放按钮事件 1234567891011if ([self.player isPlaying]) &#123; [self.startBtn setBackgroundImage:[UIImage imageNamed:@\"播放\"] forState:0]; [self.player pause];&#125; else &#123; [self.startBtn setBackgroundImage:[UIImage imageNamed:@\"暂停\"] forState:0]; [self.player play];&#125;if (_timer == nil) &#123; _timer = [NSTimer scheduledTimerWithTimeInterval:0.01 target:self selector:@selector(updateProgress) userInfo:nil repeats:YES];&#125; 定义了一个 NSTimer 变量，因为播放器没有播放进程的委托，所以只能自定义NSTimer变量对播放器进行监控，用于显示播放进度 12345- (void)updateProgress &#123; //进度条显示播放进度 self.progress.progress = self.player.currentTime/self.player.duration; self.info1.text = [NSString stringWithFormat:@\"当前播放时间%f\",self.player.currentTime];&#125; 停止播放按钮事件 12345[self.player stop];//计时器停止[_timer invalidate];//释放定时器_timer = nil; AVAudioPlayer 代理方法实现 12345678910- (void)audioPlayerDidFinishPlaying:(AVAudioPlayer *)player successfully:(BOOL)flag &#123; if (player == _player &amp;&amp; flag) &#123; [self.startBtn setBackgroundImage:[UIImage imageNamed:@\"播放\"] forState:0]; &#125;&#125;- (void)audioPlayerBeginInterruption:(AVAudioPlayer *)player &#123; if (player == _player) &#123; NSLog(@\"播放被中断\"); &#125;&#125; 在播放完成时响应回调和播放中被系统高优先级事件打断时响应回调。 效果演示： 3）其他功能 后台播放 在项目里 info.plist 中设置权限 1234&lt;key&gt;UIBackgroundModes&lt;/key&gt; &lt;array&gt; &lt;string&gt;audio&lt;/string&gt; &lt;/array&gt; 代码里面也要添加后台播放支持 1234567891011121314151617181920212223242526272829303132333435//设置锁屏仍能继续播放[[AVAudioSession sharedInstance] setCategory: AVAudioSessionCategoryPlayback error:nil];[[AVAudioSession sharedInstance] setActive: YES error: nil];``` 这样音乐在后台就可以播放了！![](http://ghexoblogimages.oss-cn-beijing.aliyuncs.com/18-11-22/74683124.jpg)* 监听播放设备那么很多播放器都有一个功能，那就是在用户拔掉耳机的时候，暂停播放```objc //添加通知，拔出耳机后暂停播放[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(routeChange:) name:AVAudioSessionRouteChangeNotification object:nil]; /** * 一旦输出改变则执行此方法 * * @param notification 输出改变通知对象 */-(void)routeChange:(NSNotification *)notification&#123; NSDictionary *dic=notification.userInfo; int changeReason= [dic[AVAudioSessionRouteChangeReasonKey] intValue]; //等于AVAudioSessionRouteChangeReasonOldDeviceUnavailable表示旧输出不可用 if (changeReason==AVAudioSessionRouteChangeReasonOldDeviceUnavailable) &#123; AVAudioSessionRouteDescription *routeDescription=dic[AVAudioSessionRouteChangePreviousRouteKey]; AVAudioSessionPortDescription *portDescription= [routeDescription.outputs firstObject]; //原设备为耳机则暂停 if ([portDescription.portType isEqualToString:@\"Headphones\"]) &#123; [self.player pause]; &#125; &#125;&#125; 这样就能在拔掉耳机的时候，暂停播放了！ 定制锁屏界面 设置后台播放时显示的东西，例如歌曲名字，图片等 要用到 &lt;MediaPlayer/MediaPlayer.h&gt; 这个库，刚才已经导入过 12345678910- (void)setPlayingInfo &#123; // 设置后台播放时显示的东西，例如歌曲名字，图片等 MPMediaItemArtwork *artWork = [[MPMediaItemArtwork alloc] initWithImage:[UIImage imageNamed:@\"dog.png\"]]; NSDictionary *dic = @&#123;MPMediaItemPropertyTitle:@\"Dog song\", MPMediaItemPropertyArtist:@\"Dog\", MPMediaItemPropertyArtwork:artWork &#125;; [[MPNowPlayingInfoCenter defaultCenter] setNowPlayingInfo:dic];&#125; 这样，图片就在锁屏界面显示了 要响应锁屏界面上面的三个按钮，需要在一个继承 UIResponder 类里面接收远程控制，添加如下代码，接受远程控制和取消远程控制： 1234567891011- (void)viewDidAppear:(BOOL)animated &#123; // 接受远程控制 [self becomeFirstResponder]; [[UIApplication sharedApplication] beginReceivingRemoteControlEvents];&#125;- (void)viewDidDisappear:(BOOL)animated &#123; // 取消远程控制 [self resignFirstResponder]; [[UIApplication sharedApplication] endReceivingRemoteControlEvents];&#125; 接收方法设置 123456789101112131415161718192021222324- (void)remoteControlReceivedWithEvent:(UIEvent *)event &#123; if (event.type == UIEventTypeRemoteControl) &#123; //判断是否为远程控制 switch (event.subtype) &#123; case UIEventSubtypeRemoteControlPlay: if (![_player isPlaying]) &#123; [_player play]; &#125; break; case UIEventSubtypeRemoteControlPause: if ([_player isPlaying]) &#123; [_player pause]; &#125; break; case UIEventSubtypeRemoteControlNextTrack: NSLog(@\"下一首\"); break; case UIEventSubtypeRemoteControlPreviousTrack: NSLog(@\"上一首 \"); break; default: break; &#125; &#125;&#125; AVAudioPlayer 的剪辑、合成和压缩转码剪辑场景：将路径 filePath 下的音频文件从 time 截取到 time2 后在 resultPath 中输出 AVURLAsset 是 AVAsset 的子类,AVAsset 类专门用于获取多媒体的相关信息,包括获取多媒体的画面、声音等信息. 这里通过 AVURLAsset 子类来根据 NSURL 来初始化 AVAsset 对象. 1AVURLAsset *videoAsset = [AVURLAsset assetWithURL:[NSURL fileURLWithPath:filePath]]; 通过 AVAssetExportSession 的 exportSessionWithAsset 方法进行剪辑，需要配置输出路径、文件类型和截取时间段参数 1234567891011//音频输出会话并且是.m4a格式AVAssetExportSession *exportSession = [AVAssetExportSession exportSessionWithAsset:videoAsset presetName:AVAssetExportPresetAppleM4A];// 设置输出路径exportSession.outputURL = [NSURL fileURLWithPath:resultPath];// 文件类型 exportSession.outputFileType = AVFileTypeAppleM4A;// 截取时间段exportSession.timeRange = CMTimeRangeFromTimeToTime(CMTimeMake(time1, 1), CMTimeMake(time2, 1));[exportSession exportAsynchronouslyWithCompletionHandler:^&#123; //exporeSession.status&#125;]; 合成场景：将路径 filePath1 和路径 filePath2 下的音频合成 先来根据 URL 初始化两个 AVAsset 对象，我们将要合成这两段音频 12AVURLAsset *videoAsset1 = [[AVURLAsset alloc] initWithURL:[NSURL fileURLWithPath:filePath1] options:nil];AVURLAsset *videoAsset2 = [[AVURLAsset alloc] initWithURL:[NSURL fileURLWithPath:filePath2] options:nil]; 创建对应的音频轨迹 12AVAssetTrack *assetTrack1 = [[videoAsset1 tracksWithMediaType:AVMediaTypeAudio] objectAtIndex:0];AVAssetTrack *assetTrack2 = [[videoAsset2 tracksWithMediaType:AVMediaTypeAudio] objectAtIndex:0]; 一般视频至少有2个轨道,一个播放声音,一个播放画面。音频只有声音通道 通过 AVMutableComposition 来进行合成处理 12345AVMutableComposition *composition = [AVMutableComposition composition];AVMutableCompositionTrack *compositionTrack = [composition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:kCMPersistentTrackID_Invalid];// 把第二段录音添加到第一段后面[compositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, videoAsset1.duration) ofTrack:assetTrack1 atTime:kCMTimeZero error:nil];[compositionTrack insertTimeRange:CMTimeRangeMake(kCMTimeZero, videoAsset2.duration) ofTrack:assetTrack2 atTime:videoAsset1.duration error:nil]; 最后将合成的音频（视频）输出 123456AVAssetExportSession *exporeSession = [AVAssetExportSession exportSessionWithAsset:composition presetName:AVAssetExportPresetAppleM4A];exporeSession.outputFileType = AVFileTypeAppleM4A;exporeSession.outputURL = [NSURL fileURLWithPath:resultPath];[exporeSession exportAsynchronouslyWithCompletionHandler:^&#123; //exporeSession.status&#125;]; 压缩转码压缩转码需要用到 LAME (Lame Aint an MP3 Encoder)，下载链接：https://sourceforge.net/projects/lame/files/lame/ 下载解压后将文件夹命名为 lame，否则无法生成.h和.m文件 控制台进入文件目录，运行命令 1234567$:cd cd /Users/mac/Desktop/lame//创建build_lame.sh$:touch build_lame.sh//打开build_lame.sh,粘贴脚本代码$:open build_lame.sh//编译执行脚本,生成静态库,需要输入本机密码$:sudo sh build_lame.sh 将fat-lame文件夹下的include文件夹和lib文件夹放入工程,再写一个OC的类调用lame.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@try &#123; int read, write; FILE *pcm = fopen([filePath cStringUsingEncoding:1], \"rb\");//被转换的音频文件位置 fseek(pcm, 4*1024, SEEK_CUR); FILE *mp3 = fopen([resultPath cStringUsingEncoding:1], \"wb\");//生成的Mp3文件位置 const int PCM_SIZE = 8192; const int MP3_SIZE = 8192; short int pcm_buffer[PCM_SIZE*2]; unsigned char mp3_buffer[MP3_SIZE]; // 初始化lame编码器 lame_t lame = lame_init(); // 设置lame mp3编码的采样率 / 声道数 / 比特率 lame_set_in_samplerate(lame, 8000); lame_set_num_channels(lame,2); lame_set_out_samplerate(lame, 8000); lame_set_brate(lame, 8); // MP3音频质量.0~9.其中0是最好,非常慢,9是最差. lame_set_quality(lame, 7); // 设置mp3的编码方式 lame_set_VBR(lame, vbr_default); lame_init_params(lame); do &#123; size_t size = (size_t)(2 * sizeof(short int)); read = fread(pcm_buffer, size, PCM_SIZE, pcm); if (read == 0) &#123; write = lame_encode_flush(lame, mp3_buffer, MP3_SIZE); &#125; else &#123; write = lame_encode_buffer_interleaved(lame, pcm_buffer, read, mp3_buffer, MP3_SIZE); &#125; fwrite(mp3_buffer, write, 1, mp3); &#125; while (read != 0); lame_close(lame); fclose(mp3); fclose(pcm);&#125;@catch (NSException *exception) &#123; NSLog(@\"%@\",[exception description]);&#125;@finally &#123; // 转码完成 return resultPath;&#125; 基本上可以将100K左右的录音文件压缩到10K以下 AVPlayerAVPlayer支持播放本地、分步下载、或在线流媒体音视频，不仅可以播放音频，配合AVPlayerLayer类可实现视频播放。另外支持播放进度监听。 使用AVPlayer需导入AVFoundation.h 1#import &lt;AVFoundation/AVFoundation.h&gt; 支持视频格式： WMV，AVI，MKV，RMVB，RM，XVID，MP4，3GP，MPG等。 支持音频格式：MP3，WMA，RM，ACC，OGG，APE，FLAC，FLV等。 在开发中，单纯使用AVPlayer类是无法显示视频的，要将视频层添加至AVPlayerLayer中，这样才能将视频显示出来 介绍一下常用方法： 1）AVPlayer 初始化 1234567+ (instancetype)playerWithURL:(NSURL *)URL;+ (instancetype)playerWithPlayerItem:(AVPlayerItem *)item;- (instancetype)initWithURL:(NSURL *)URL;- (instancetype)initWithPlayerItem:(AVPlayerItem *)item; 2）AVPlayer 方法调用AVPlayer需要通过AVPlayerItem来关联需要播放的媒体。 12AVPlayerItem *item = [[AVPlayerItem alloc] initWithURL:[NSURL URLWithString:urlStr]];AVPlayer *player = [[AVPlayer alloc] initWithPlayerItem:item]; 准备播放前，通过KVO添加播放状态改变监听 1[self.player.currentItem addObserver:self forKeyPath:@\"status\" options:NSKeyValueObservingOptionNew context:nil]; 处理KVO回调事件： 1234567891011121314151617181920-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; if ([keyPath isEqualToString:@\"status\"]) &#123; switch (self.player.status) &#123; case AVPlayerStatusUnknown: &#123; NSLog(@\"未知转态\"); &#125; break; case AVPlayerStatusReadyToPlay: &#123; NSLog(@\"准备播放\"); &#125; break; case AVPlayerStatusFailed: &#123; NSLog(@\"加载失败\"); &#125; break; default: break; &#125; &#125;&#125; KVO监听音乐缓冲状态： 1234[self.player.currentItem addObserver:self forKeyPath:@\"loadedTimeRanges\" options:NSKeyValueObservingOptionNew context:nil]; 监听事件处理 1234567891011121314151617-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; //... if ([keyPath isEqualToString:@\"loadedTimeRanges\"]) &#123; NSArray * timeRanges = self.player.currentItem.loadedTimeRanges; //本次缓冲的时间范围 CMTimeRange timeRange = [timeRanges.firstObject CMTimeRangeValue]; //缓冲总长度 NSTimeInterval totalLoadTime = CMTimeGetSeconds(timeRange.start) + CMTimeGetSeconds(timeRange.duration); //音乐的总时间 NSTimeInterval duration = CMTimeGetSeconds(self.player.currentItem.duration); //计算缓冲百分比例 NSTimeInterval scale = totalLoadTime/duration; //更新缓冲进度条 // self.loadTimeProgress.progress = scale; &#125;&#125; 开始播放后，通过KVO添加播放结束事件监听 1234[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(playFinished:) name:AVPlayerItemDidPlayToEndTimeNotification object:_player.currentItem]; 开始播放时，通过AVPlayer的方法监听播放进度，并更新进度条（定期监听的方法）： 123456789101112__weak typeof(self) weakSelf = self;[self.player addPeriodicTimeObserverForInterval:CMTimeMake(1.0, 1.0) queue:dispatch_get_main_queue() usingBlock:^(CMTime time) &#123; //当前播放的时间 float current = CMTimeGetSeconds(time); //总时间 float total = CMTimeGetSeconds(item.duration); if (current) &#123; float progress = current / total; //更新播放进度条 weakSelf.playSlider.value = progress; &#125;&#125;]; 用户拖动进度条，修改播放进度 123456- (void)playSliderValueChange:(UISlider *)sender &#123; //根据值计算时间 float time = sender.value * CMTimeGetSeconds(self.player.currentItem.duration); //跳转到当前指定时间 [self.player seekToTime:CMTimeMake(time, 1)];&#125; 演示效果： 3）其他用法 控制视频的进度使用懒加载的方式，将进度条添加到View上面 123456- (UISlider *)avSlider&#123; if (!_avSlider) &#123; _avSlider = [[UISlider alloc]initWithFrame:CGRectMake(0, 55, self.view.bounds.size.width, 30)]; [self.view addSubview:_avSlider]; &#125;return _avSlider;&#125; 在viewDidLoad中个slider（进度条）添加一个回调 12[self.avSlider addTarget:self action:@selector(avSliderAction) forControlEvents:UIControlEventTouchUpInside|UIControlEventTouchCancel|UIControlEventTouchUpOutside]; 回调方法 123456789101112- (void)avSliderAction &#123; //slider的value值为视频的时间 float seconds = self.avSlider.value; //让视频从指定的CMTime对象处播放。 CMTime startTime = CMTimeMakeWithSeconds(seconds, self.item.currentTime.timescale); //让视频从指定处播放 [self.myPlayer seekToTime:startTime completionHandler:^(BOOL finished) &#123; if (finished) &#123; [self playAction]; &#125; &#125;];&#125; 后台播放 首先 info.plist 文件中设置权限 1234&lt;key&gt;UIBackgroundModes&lt;/key&gt;&lt;array&gt; &lt;string&gt;audio&lt;/string&gt;&lt;/array&gt; 在AppDelegate.m的- (BOOL)application:didFinishLaunchingWithOptions:方法中添加代码： 123AVAudioSession *session = [AVAudioSession sharedInstance];[session setCategory:AVAudioSessionCategoryPlayback error:nil];[session setActive:YES error:nil]; 锁屏信息 Now Playing Center并不需要每一秒都去刷新（设置），它是根据你设置的PlaybackRate来计算进度条展示的进度，比如你PlaybackRate传1，那就是1秒刷新一次进度显示，当然暂停播放的时候它也会自动暂停。 12345678910111213141516171819- (void)configNowPlayingCenter &#123; BASE_INFO_FUN(@\"配置NowPlayingCenter\"); NSMutableDictionary * info = [NSMutableDictionary dictionary]; //音乐的标题 [info setObject:_player.currentSong.title forKey:MPMediaItemPropertyTitle]; //音乐的艺术家 [info setObject:_player.currentSong.artist forKey:MPMediaItemPropertyArtist]; //音乐的播放时间 [info setObject:@(self.player.playTime.intValue) forKey:MPNowPlayingInfoPropertyElapsedPlaybackTime]; //音乐的播放速度 [info setObject:@(1) forKey:MPNowPlayingInfoPropertyPlaybackRate]; //音乐的总时间 [info setObject:@(self.player.playDuration.intValue) forKey:MPMediaItemPropertyPlaybackDuration]; //音乐的封面 MPMediaItemArtwork * artwork = [[MPMediaItemArtwork alloc] initWithImage:_player.coverImg]; [info setObject:artwork forKey:MPMediaItemPropertyArtwork]; //完成设置 [[MPNowPlayingInfoCenter defaultCenter]setNowPlayingInfo:info];&#125; 那什么时候设置Now Playing Center比较合适呢？对于播放网络音乐来说，需要刷新的有几个时间点：当前播放的歌曲变化时（如切换到下一首）、当前歌曲信息变化时（如从Unknown到ReadyToPlay）、当前歌曲拖动进度时。 耳机线控或者锁屏界面控制先引入头文件 12#import &lt;MediaPlayer/MPRemoteCommandCenter.h&gt;#import &lt;MediaPlayer/MPRemoteCommand.h&gt; 在需要处理远程控制事件的具体控制器或其它类中调用下面这个方法 12345678910111213141516171819202122232425262728293031323334353637383940- (void)remoteControlEventHandler &#123; // 直接使用sharedCommandCenter来获取MPRemoteCommandCenter的shared实例 MPRemoteCommandCenter *commandCenter = [MPRemoteCommandCenter sharedCommandCenter];// 启用播放命令 (锁屏界面和上拉快捷功能菜单处的播放按钮触发的命令)commandCenter.playCommand.enabled = YES;// 为播放命令添加响应事件, 在点击后触发[commandCenter.playCommand addTarget:self action:@selector(playAction:)];// 播放, 暂停, 上下曲的命令默认都是启用状态, 即enabled默认为YES// 为暂停, 上一曲, 下一曲分别添加对应的响应事件[commandCenter.pauseCommand addTarget:self action:@selector(pauseAction:)];[commandCenter.previousTrackCommand addTarget:self action:@selector(previousTrackAction:)];[commandCenter.nextTrackCommand addTarget:self action:@selector(nextTrackAction:)];// 启用耳机的播放/暂停命令 (耳机上的播放按钮触发的命令)commandCenter.togglePlayPauseCommand.enabled = YES;// 为耳机的按钮操作添加相关的响应事件[commandCenter.togglePlayPauseCommand addTarget:self action:@selector(playOrPauseAction:)];&#125;-(void)playAction:(id)obj &#123; [[HYPlayerTool sharePlayerTool] play];&#125;-(void)pauseAction:(id)obj &#123; [[HYPlayerTool sharePlayerTool] pause];&#125;-(void)nextTrackAction:(id)obj &#123; [[HYPlayerTool sharePlayerTool] playNext];&#125;-(void)previousTrackAction:(id)obj &#123; [[HYPlayerTool sharePlayerTool] playPre];&#125;-(void)playOrPauseAction:(id)obj &#123; if ([[HYPlayerTool sharePlayerTool] isPlaying]) &#123; [[HYPlayerTool sharePlayerTool] pause]; &#125;else&#123; [[HYPlayerTool sharePlayerTool] play]; &#125;&#125; AVQueuePlayerAVPlayer只支持单个媒体资源的播放，我们可以使用AVPlayer的子类AVQueuePlayer实现列表播放。 在AVPlayer的基础上，增加以下方法： 1234567891011121314151617181920//通过给定的AVPlayerItem数组创建一个AVQueuePlayer实例+ (instancetype)queuePlayerWithItems:(NSArray&lt;AVPlayerItem *&gt; *)items;//通过给定的AVPlayerItem数组初始化AVQueuePlayer实例- (AVQueuePlayer *)initWithItems:(NSArray&lt;AVPlayerItem *&gt; *)items;//获得当前的播放队列数组- (NSArray&lt;AVPlayerItem *&gt; *)items;//停止播放当前音乐，并播放队列中的下一首- (void)advanceToNextItem;//往播放队列中插入新的AVPlayerItem- (void)insertItem:(AVPlayerItem *)item afterItem:(nullable AVPlayerItem *)afterItem;//从播放队列中移除指定AVPlayerItem- (void)removeItem:(AVPlayerItem *)item;//清空播放队列- (void)removeAllItems; 官方API中没找到播放上一首的方法，所以其实直接用AVPlayer做列表播放也是可以的，通过维护一个播放列表数组，监听用户点击上一首和下一首按钮，并监听播放结束事件，调用 AVPlayer 实例的replaceCurrentItemWithPlayerItem:方法传入播放列表中的上一首或下一首。 AVPlayer 的缓存实现这里主要展示通过AVAssetResourceLoader实现AVPlayer的缓存。 没有任何工具能适用于所有的场景，在使用AVPlayer的过程中，我们会发现它有很多局限性，比如播放网络音乐时，往往不能控制其内部播放逻辑，比如我们会发现播放时seek会失败，数据加载完毕后不能获取到数据文件进行其他操作，因此我们需要寻找弥补其不足之处的方法，这里我们选择了AVAssetResourceLoader。 AVAssetResourceLoaderAVAssetResourceLoader 可以让我们自行掌握AVPlayer数据的加载，包括获取AVPlayer需要的数据的信息，以及可以决定传递多少数据给AVPlayer。 实现原理： AVAssetResourceLoader 通过对 loadingRequest 的控制，间接控制 AVPlayer 数据的加载等操作。 使用AVAssetResourceLoader需要实现AVAssetResourceLoaderDelegate的方法： 12- (BOOL)resourceLoader:(AVAssetResourceLoader *)resourceLoadershouldWaitForLoadingOfRequestedResource:(AVAssetResourceLoadingRequest *)loadingRequest; 要求加载资源的代理方法，这时我们需要保存loadingRequest并对其所指定的数据进行读取或下载操作，当数据读取或下载完成，我们可以对loadingRequest进行完成操作。 12- (void)resourceLoader:(AVAssetResourceLoader *)resourceLoaderdidCancelLoadingRequest:(AVAssetResourceLoadingRequest *)loadingRequest; 实现策略： 通过AVAssetResourceLoader实现缓存的策略有多种，没有绝对的优与劣，只要符合我们的实际需求就可以了。 下面我们以模仿企鹅音乐的来演示AVAssetResourceLoader实现缓存的过程为例子。 先观察并猜测企鹅音乐的缓存策略（当然它不是用AVPlayer播放）： 1、开始播放，同时开始下载完整的文件，当文件下载完成时，保存到缓存文件夹中； 2、当seek时 （1）如果seek到已下载到的部分，直接seek成功；（如下载进度60%，seek进度50%） （2）如果seek到未下载到的部分，则开始新的下载（如下载进度60%，seek进度70%） PS1：此时文件下载的范围是70%-100% PS2：之前已下载的部分就被删除了 PS3：如果有别的seek操作则重复步骤2，如果此时再seek到进度40%，则会开始新的下载（范围40%-100%） 3、当开始新的下载之后，由于文件不完整，下载完成之后不会保存到缓存文件夹中； 4、下次再播放同一歌曲时，如果在缓存文件夹中存在，则直接播放缓存文件； 代码实现： 通过自定义scheme来创建avplayer，并给AVURLAsset指定代理（SUPlayer对象） 1234AVURLAsset * asset = [AVURLAsset URLAssetWithURL:[self.url customSchemeURL] options:nil];[asset.resourceLoader setDelegate:self.resourceLoader queue:dispatch_get_main_queue()];self.currentItem = [AVPlayerItem playerItemWithAsset:asset];self.player = [AVPlayer playerWithPlayerItem:self.currentItem]; 代理实现AVAssetResourceLoader的代理方法（SUResourceLoader对象） 1234567- (BOOL)resourceLoader:(AVAssetResourceLoader *)resourceLoader shouldWaitForLoadingOfRequestedResource:(AVAssetResourceLoadingRequest *)loadingRequest &#123; [self addLoadingRequest:loadingRequest]; return YES;&#125;- (void)resourceLoader:(AVAssetResourceLoader *)resourceLoader didCancelLoadingRequest:(AVAssetResourceLoadingRequest *)loadingRequest &#123; [self removeLoadingRequest:loadingRequest];&#125; 对loadingRequest的处理（addLoadingRequest方法）: 1）将其加入到requestList中 1[self.requestList addObject:loadingRequest]; 2）如果还没开始下载，则开始请求数据，否则静待数据的下载 1[self newTaskWithLoadingRequest:loadingRequest cache:YES]; 3）如果是seek之后的loadingRequest，判断请求开始的位置，如果已经缓冲到，则直接读取数据 1234if (loadingRequest.dataRequest.requestedOffset &gt;= self.requestTask.requestOffset &amp;&amp; loadingRequest.dataRequest.requestedOffset &lt;= self.requestTask.requestOffset + self.requestTask.cacheLength) &#123; [self processRequestList];&#125; 4）如果还没缓冲到，则重新请求 123if (self.seekRequired) &#123; [self newTaskWithLoadingRequest:loadingRequest cache:NO];&#125; 4、数据请求的处理（newTaskWithLoadingRequest方法） 1）先判断是否已经有下载任务，如果有，则先取消该任务 1234if (self.requestTask) &#123; fileLength = self.requestTask.fileLength; self.requestTask.cancel = YES;&#125; 2）建立新的请求，设置代理 12345678910self.requestTask = [[SURequestTask alloc]init];self.requestTask.requestURL = loadingRequest.request.URL;self.requestTask.requestOffset = loadingRequest.dataRequest.requestedOffset;self.requestTask.cache = cache;if (fileLength &gt; 0) &#123; self.requestTask.fileLength = fileLength;&#125;self.requestTask.delegate = self;[self.requestTask start];self.seekRequired = NO; 5、数据响应的处理（processRequestList方法） 对requestList里面的loadingRequest填充响应数据，如果已完全响应，则将其从requestList中移除 123456789- (void)processRequestList &#123;NSMutableArray * finishRequestList = [NSMutableArray array]; for (AVAssetResourceLoadingRequest * loadingRequest in self.requestList) &#123; if ([self finishLoadingWithLoadingRequest:loadingRequest]) &#123; [finishRequestList addObject:loadingRequest]; &#125; &#125; [self.requestList removeObjectsInArray:finishRequestList];&#125; 填充响应数据的过程如下： 1）填写 contentInformationRequest的信息，注意contentLength需要填写下载的文件的总长度，contentType需要转换 1234CFStringRef contentType = UTTypeCreatePreferredIdentifierForTag(kUTTagClassMIMEType, (__bridge CFStringRef)(MimeType), NULL);loadingRequest.contentInformationRequest.contentType = CFBridgingRelease(contentType);loadingRequest.contentInformationRequest.byteRangeAccessSupported = YES;loadingRequest.contentInformationRequest.contentLength = self.requestTask.fileLength; 2）计算可以响应的数据长度，注意数据读取的起始位置是当前avplayer当前播放的位置，结束位置是loadingRequest的结束位置或者目前文件下载到的位置 1234567NSUInteger cacheLength = self.requestTask.cacheLength;NSUInteger requestedOffset = loadingRequest.dataRequest.requestedOffset;if (loadingRequest.dataRequest.currentOffset != 0) &#123; requestedOffset = loadingRequest.dataRequest.currentOffset;&#125;NSUInteger canReadLength = cacheLength - (requestedOffset - self.requestTask.requestOffset);NSUInteger respondLength = MIN(canReadLength, loadingRequest.dataRequest.requestedLength); 3）读取数据并填充到loadingRequest 1[loadingRequest.dataRequest respondWithData:[SUFileHandle readTempFileDataWithOffset:requestedOffset - self.requestTask.requestOffset length:respondLength]]; 4） 如果完全响应了所需要的数据，则完成loadingRequest，注意判断的依据是 响应数据结束的位置 &gt;= loadingRequest结束的位置 1234567NSUInteger nowendOffset = requestedOffset + canReadLength;NSUInteger reqEndOffset = loadingRequest.dataRequest.requestedOffset + loadingRequest.dataRequest.requestedLength;if (nowendOffset &gt;= reqEndOffset) &#123; [loadingRequest finishLoading]; return YES;&#125;return NO; 6、处理requestList的时机 当有新的loadingRequest或者文件下载进度更新时，都需要处理requestList 7、新的请求任务实现的过程（SURequestTask对象） 1）初始化时，需要删除旧的临时文件，并创建新的空白临时文件 123456- (instancetype)init &#123;if (self = [super init]) &#123; [SUFileHandle createTempFile]; &#125; return self;&#125; 2）建立新的连接，如果是seek后的请求，则指定其请求内容的范围 123456789- (void)start &#123; NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[self.requestURL originalSchemeURL] cachePolicy:NSURLRequestReloadIgnoringCacheData timeoutInterval:RequestTimeout]; if (self.requestOffset &gt; 0) &#123; [request addValue:[NSString stringWithFormat:@\"bytes=%ld-%ld\", self.requestOffset, self.fileLength - 1] forHTTPHeaderField:@\"Range\"]; &#125; self.session = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration] delegate:self delegateQueue:[NSOperationQueue mainQueue]]; self.task = [self.session dataTaskWithRequest:request]; [self.task resume];&#125; 3）当收到数据时，将数据写入临时文件，更新下载进度，同时通知代理处理requestList 12345678- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123; if (self.cancel) return; [SUFileHandle writeTempFileData:data]; self.cacheLength += data.length; if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(requestTaskDidUpdateCache)]) &#123; [self.delegate requestTaskDidUpdateCache]; &#125;&#125; 4）当下载完成时，如果满足缓存的条件，则将临时文件拷贝到缓存文件夹中 123456if (self.cache) &#123; [SUFileHandle cacheTempFileWithFileName:[NSString fileNameWithURL:self.requestURL]];&#125;if (self.delegate &amp;&amp; [self.delegate respondsToSelector:@selector(requestTaskDidFinishLoadingWithCache:)]) &#123; [self.delegate requestTaskDidFinishLoadingWithCache:self.cache];&#125; 演示效果： 缓存功能优化点： 1.对缓存格式支持的处理：并不是所有文件格式都支持的哦，对于不支持的格式，你应该不使用缓存功能； 2.对缓存过程中各种错误的处理：比如下载超时、连接失败、读取数据错误等等的处理； 3.缓存文件的命名处理，如果缓存文件没有后缀（如.mp4），可能会导致播放失败； TheAmazingAudioEngine 实现音效模块TheAmazingAudioEngine就是基于AudioUnit框架、AudioToolBox框架、AVFoundation框架的封装，使其更方便使用。 播放功能和官方AVAudioPalyer以及AVAudioEngine都比较类似，拿到文件路径、或者音频buffer，调用相关方法播放即可，这里举例文件的播放。 创建AEAudioController对象； 拿到音频的路径（一个NSURL对象）； 根据音频路径创建AEAudioFilePlayer对象； 通过AEAudioController的addChannels:方法将AEAudioFilePlayer对象add到AEAudioController对象中即可。 范例如下： 123NSString *path = [[NSBundle mainBundle] pathForResource:@\"specialPeople\" ofType:@\"mp3\"];self.player = [[AEAudioFilePlayer alloc] initWithURL:[NSURL fileURLWithPath:path] error:&amp;error];[self.audioController addChannels:@[self.player]]; 播放本地音频 123456// 歌曲名和后缀名static NSString *audioFileName = @\"specialPeople\";static NSString *audioFileFormat = @\"mp3\";NSURL *songURL = [[NSBundle mainBundle] URLForResource:audioFileNamewithExtension:audioFileFormat]; 如果是想拿手机中的歌曲，则通过MPMediaPickerController的委托方法mediaPicker:didPickMediaItems:方法获得，如下： 12345678910111213141516#pragma mark - MPMediaPickerControllerDelegate- (void)mediaPicker:(MPMediaPickerController *)mediaPicker didPickMediaItems:(MPMediaItemCollection *)mediaItemCollection &#123;// 我这里要播放两首歌,所以有两个MPMediaPickerController对象,这里作一个判断if (mediaPicker == _mediaCH1PickerController) &#123;// mediaItemCollection.representativeItem.assetURL这一句即可拿到使用者选择歌曲的URL// 备注:这里已经将播放歌曲的方法playNewSongCH1:封装到自定义的engine类中[[HNMCManager shareManager].engine playNewSongCH1:mediaItemCollection.representativeItem.assetURL];&#125; else &#123;[[HNMCManager shareManager].engine playNewSongCH2:mediaItemCollection.representativeItem.assetURL];&#125;[self dismissViewControllerAnimated:YES completion:nil];&#125; 音效的实现所有音效都是基于AEAudioUnitFilter类实现的。 TheAmazingAudioEngine上的音效比苹果官方的AVAudioEngine丰富且容易实现。 总的步骤： 创建AEAudioUnitFilter或其子类对象用AEAudioController的addFilter:方法将Filter对象add到AEAudioController对象中设置相关属性值，实现音效的控制 1）实现高通音效 该框架有现成的高通音效类： 123456789101112131415161718192021#pragma mark 高通音效- (void)setupFilterHighPass:(double)cutoffFrequency &#123;// 创建并添加AEAudioUnitFilter实例[self addHighpassFilter];// 设置相关属性值，达到音效的控制_highPassFilter.cutoffFrequency = cutoffFrequency;&#125;- (void)addHighpassFilter &#123;// _highPassFilter是AEHighPassFilter类的实例// AEHighPassFilter是AEAudioUnitFilter的子类if (!_highPassFilter) &#123;_highPassFilter = [[AEHighPassFilter alloc] init];[_audioController addFilter:_highPassFilter];&#125; else &#123;if ( ![_audioController.filters containsObject:_highPassFilter] ) &#123;[_audioController addFilter:_highPassFilter];&#125;&#125;&#125; 实现EQ调整因为本来对音频相关领域的概念、知识不太了解，实现EQ调整还颇费了一番周折。需要实现的EQ调整类似下图： 可以通过AEParametricEqFilter类实现，该类也是AEAudioUnitFilter的子类，要实现10段EQ值的调整，就要创建10个AEParametricEqFilter对象，给centerFrequency属性赋值20Hz-20000Hz之间的值(取决于你要调整哪个频率的声音)。而具体音效调整，则是调整增益值(通过gain属性)，值范围：-20dB to 20dB。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#pragma mark EQ音效// 创建10个AEParametricEqFilter对象- (void)creatEqFliters &#123;_eq20HzFilter = [[AEParametricEqFilter alloc] init];_eq50HzFilter = [[AEParametricEqFilter alloc] init];_eq100HzFilter = [[AEParametricEqFilter alloc] init];_eq200HzFilter = [[AEParametricEqFilter alloc] init];_eq500HzFilter = [[AEParametricEqFilter alloc] init];_eq1kFilter = [[AEParametricEqFilter alloc] init];_eq2kFilter = [[AEParametricEqFilter alloc] init];_eq5kFilter = [[AEParametricEqFilter alloc] init];_eq10kFilter = [[AEParametricEqFilter alloc] init];_eq20kFilter = [[AEParametricEqFilter alloc] init];_eqFilters = @[_eq20HzFilter, _eq50HzFilter, _eq100HzFilter, _eq200HzFilter, _eq500HzFilter, _eq1kFilter, _eq2kFilter, _eq5kFilter, _eq10kFilter, _eq20kFilter];&#125;- (void)setupFilterEq:(NSInteger)eqType value:(double)gain &#123;switch (eqType) &#123;case EQ_20Hz: &#123;// 设置需要调整的频率，并将传入的增益值gain赋值给gain属性，达到音效调整效果[self setupEqFilter:_eq20HzFilter centerFrequency:20 gain:gain];break;&#125;case EQ_50Hz: &#123;[self setupEqFilter:_eq50HzFilter centerFrequency:50 gain:gain];break;&#125;case EQ_100Hz: &#123;[self setupEqFilter:_eq100HzFilter centerFrequency:100 gain:gain];break;&#125;case EQ_200Hz: &#123;[self setupEqFilter:_eq200HzFilter centerFrequency:200 gain:gain];break;&#125;case EQ_500Hz: &#123;[self setupEqFilter:_eq500HzFilter centerFrequency:500 gain:gain];break;&#125;case EQ_1K: &#123;[self setupEqFilter:_eq1kFilter centerFrequency:1000 gain:gain];break;&#125;case EQ_2K: &#123;[self setupEqFilter:_eq2kFilter centerFrequency:2000 gain:gain];break;&#125;case EQ_5K: &#123;[self setupEqFilter:_eq5kFilter centerFrequency:5000 gain:gain];break;&#125;case EQ_10K: &#123;[self setupEqFilter:_eq10kFilter centerFrequency:10000 gain:gain];break;&#125;case EQ_20K: &#123;[self setupEqFilter:_eq20kFilter centerFrequency:20000 gain:gain];break;&#125;&#125;&#125;- (void)setupEqFilter:(AEParametricEqFilter *)eqFilter centerFrequency:(double)centerFrequency gain:(double)gain &#123;if ( ![_audioController.filters containsObject:eqFilter] ) &#123;for (AEParametricEqFilter *existEqFilter in _eqFilters) &#123;if (eqFilter == existEqFilter) &#123;[_audioController addFilter:eqFilter];break;&#125;&#125;&#125;eqFilter.centerFrequency = centerFrequency;eqFilter.qFactor = 1.0;eqFilter.gain = gain;&#125; 以上就是应用TheAmazingAudioEngine框架进行音频播放、录制、音效实现的一次简单实践分享。 发掘 AVPlayer 的潜力音频播放的实现级别： 离线播放：这里并不是指应用不联网，而是指播放本地音频文件，包括先下完完成音频文件再进行播放的情况，这种使用AVFoundation里的AVAudioPlayer可以满足 在线播放：使用AVFoundation的AVPlayer可以满足 在线播放同时存储文件：使用AudioFileStreamer ＋ AudioQueue 可以满足 在线播放且带有音效处理：使用 AudioFileStreamer ＋ AudioQueue ＋ 音效模块（系统自带或者自行开发）来满足 未完待续，AVFoundation 体系太大，慢慢整理 🤣 以上文章整理自：https://www.jianshu.com/p/589999e53461、https://blog.csdn.net/zahuopuboss/article/details/54862749、https://blog.csdn.net/feng2qing/article/details/67655175、https://blog.csdn.net/dolacmeng/article/details/77430108、https://www.jianshu.com/p/746cec2c3759、http://www.cocoachina.com/ios/20160726/17194.html、https://www.jianshu.com/p/c48195126040、https://www.jianshu.com/p/a7d5f43a84fb","categories":[{"name":"Summary","slug":"Summary","permalink":"https://reversescale.github.io/categories/Summary/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS Principle：CGAffineTransform","slug":"iOS Principle CGAffineTransform","date":"2018-06-15T13:56:27.000Z","updated":"2018-11-26T13:08:42.161Z","comments":true,"path":"2018/06/15/iOS Principle CGAffineTransform/","link":"","permalink":"https://reversescale.github.io/2018/06/15/iOS Principle CGAffineTransform/","excerpt":"CGAffineTransform 是处理形变的类，通过”仿射变换矩阵”对控件的平移、缩放、旋转~","text":"CGAffineTransform 是处理形变的类，通过”仿射变换矩阵”对控件的平移、缩放、旋转~ 👨🏻‍💻 Github Demo 方便记忆： 本质：处理形变的类，通过”仿射变换矩阵”对控件的平移、缩放、旋转 方法： CGAffineTransformMakeTranslation：以初始位置为基准,在x轴方向上平移x单位,在y轴方向上平移y单位 CGAffineTransformMakeScale：以初始位置为基准,在x轴方向上缩放x倍,在y轴方向上缩放y倍 CGAffineTransformMakeRotation：以初始位置为基准,将坐标系统逆时针旋转angle弧度(弧度=π/180×角度,M_PI弧度代表180角度) CGAffineTransformTranslate：以一个已经存在的形变为基准,在x轴方向上平移x单位,在y轴方向上平移y单位 CGAffineTransformScale：以一个已经存在的形变为基准,在x轴方向上缩放x倍,在y轴方向上缩放y倍 CGAffineTransformRotate：以一个已经存在的形变为基准,将坐标系统逆时针旋转angle弧度(弧度=π/180×角度,M_PI弧度代表180角度) CGAffineTransformIdentity：transform属性默认值为CGAffineTransformIdentity,可以在形变之后设置该值以还原到最初状态 概述 A structure for holding an affine transformation matrix. CGAffineTransform 是一个用于处理形变的类,其可以改变控件的平移、缩放、旋转等,其坐标系统采用的是二维坐标系,即向右为x轴正方向,向下为y轴正方向。 这个矩阵和坐标之间的关系如下： 12struct CGAffineTransform &#123; CGFloat a; CGFloat b; CGFloat c; CGFloat d; CGFloat tx; CGFloat ty; &#125;; typedef struct CGAffineTransform CGAffineTransform; 我们通过 UIImageView 的 transform 方法演示这一特性，注意默认情况下 UIImageView 的 User Interaction 为不可交互状态，需要设置一下： 方法介绍 CGAffineTransformMakeTranslation CGAffineTransformMakeTranslation 实现以初始位置为基准,在x轴方向上平移x单位,在y轴方向上平移y单位。 12CGAffineTransform transform = CGAffineTransformMakeTranslation(-100, 150);imageView.transform = transform; CGAffineTransformMakeScale CGAffineTransformMakeScale 实现以初始位置为基准,在x轴方向上缩放x倍,在y轴方向上缩放y倍 12CGAffineTransform transform = CGAffineTransformMakeScale(2, 2);imageView.transform = transform; CGAffineTransformMakeRotation CGAffineTransformMakeRotation 实现以初始位置为基准,将坐标系统逆时针旋转angle弧度(弧度=π/180×角度,M_PI弧度代表180角度) 12CGAffineTransform transform = CGAffineTransformMakeRotation(M_PI);imageView.transform = transform; CGAffineTransformTranslate CGAffineTransformTranslate 实现以一个已经存在的形变为基准,在x轴方向上平移x单位,在y轴方向上平移y单位 12345678910111213141516171819CGAffineTransform transform = CGAffineTransformMakeTranslation(50, 50);imageView.transform = CGAffineTransformTranslate(transform, 50, 50);``` * CGAffineTransformScaleCGAffineTransformScale 实现以一个已经存在的形变为基准,在x轴方向上缩放x倍,在y轴方向上缩放y倍```objcCGAffineTransform transform = CGAffineTransformMakeScale(2, 0.5);imageView.transform = CGAffineTransformScale(transform, 2, 1);``` * CGAffineTransformRotateCGAffineTransformRotate 实现以一个已经存在的形变为基准,将坐标系统逆时针旋转angle弧度(弧度=π/180×角度,M_PI弧度代表180角度)```objcCGAffineTransform transform = CGAffineTransformMakeRotation(M_PI*0.25);imageView.transform = CGAffineTransformRotate(transform, M_PI*0.25); CGAffineTransformIdentity transform属性默认值为CGAffineTransformIdentity,可以在形变之后设置该值以还原到最初状态 1imageView.transform = CGAffineTransformIdentity; CGAffineTransform 原理CGAffineTransform形变是通过”仿射变换矩阵”来控制的 平移是矩阵相加 旋转与缩放则是矩阵相乘 为了合并矩阵运算中的加法和乘法,引入了齐次坐标的概念。 齐次坐标提供了用矩阵运算把二维、三维甚至高维空间中的一个点集从一个坐标系变换到另一个坐标系的有效方法. CGAffineTransform形变就是把二维形变使用一个三维矩阵来表示,其中第三列总是(0,0,1),形变通过前两列来控制,系统提供了CGAffineTransformMake结构体来控制形变。 1CGAffineTransformMake(CGFloat a, CGFloat b, CGFloat c, CGFloat d, CGFloat tx, CGFloat ty) 三维变换矩阵如下 变换矩阵左乘向量,将空间中的一个点集从一个坐标系变换到另一个坐标系中,计算方式如下 计算结果 由上可知： tx用来控制在x轴方向上的平移 ty用来控制在y轴方向上的平移 a用来控制在x轴方向上的缩放 d用来控制在y轴方向上的缩放 abcd共同控制旋转 对应的代码实现： 1）平移CGAffineTransformMakeTranslation原理12self.demoImageView.transform = CGAffineTransformMakeTranslation(100, 100);self.demoImageView.transform = CGAffineTransformMake(1, 0, 0, 1, 100, 100); 2）缩放CGAffineTransformMakeScale原理12self.demoImageView.transform = CGAffineTransformMakeScale(2, 0.5);self.demoImageView.transform = CGAffineTransformMake(2, 0, 0, 0.5, 0, 0); 3）旋转CGAffineTransformMakeRotation原理12self.demoImageView.transform = CGAffineTransformMakeRotation(M_PI*0.5);self.demoImageView.transform = CGAffineTransformMake(cos(M_PI * 0.5), sin(M_PI * 0.5), -sin(M_PI * 0.5), cos(M_PI * 0.5), 0, 0); 4）初始状态CGAffineTransformIdentity原理12self.demoImageView.transform = CGAffineTransformIdentity;self.demoImageView.transform = CGAffineTransformMake(1, 0, 0, 1, 0, 0); 以上文章整理自：https://www.jianshu.com/p/ca7f9bc62429","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS Principle：CALayer","slug":"iOS Principle CALayer","date":"2018-06-14T13:56:27.000Z","updated":"2018-11-26T13:05:54.192Z","comments":true,"path":"2018/06/14/iOS Principle CALayer/","link":"","permalink":"https://reversescale.github.io/2018/06/14/iOS Principle CALayer/","excerpt":"在 Apple 的图形架构中，CoreAnimation 是在 OpenGL 和 CoreGraphics 的基础上封装的一套动画 API，而 OpenGL 和 CoreGraphics 则提供一些接口来访问图形硬件(GPU)~","text":"在 Apple 的图形架构中，CoreAnimation 是在 OpenGL 和 CoreGraphics 的基础上封装的一套动画 API，而 OpenGL 和 CoreGraphics 则提供一些接口来访问图形硬件(GPU)~ 👨🏻‍💻 Github Demo 方便记忆： 本质：CoreAnimation（CA） 是在 OpenGL 和 CoreGraphics 上封装的动画 API，用于调用GPU 关系：UIView持有一个CALayer负责drawRect展示，view是这个layer的delegate，UIView可以响应事件 动画：CALayer图层类是CoreAnimation的基础，是所有核心动画图层的父类 CABasicAnimation：通过起止状态实现动画 CAKeyframeAnimation：额外指定关键帧间时间函数实现动画 UIView 动画原理：通过调用layer的actionForLayer:forKey实现动画 UIView动画的叠加方式：改变View属性做动画时，属性值会立即改变，动画后展示效果。动画未结束时，又加另一个动画，会进行叠加，最终停在view的真实位置。 展示层：presentationLayer为展示的状态 模型层：modelLayer是设置完立即生效的真实状态 使用实例1：注水动画效果（mask绿透性） 通过mask从两个方向为greenHead填充内容 使用实例2：大量圆角性能优化 直接改变layer的mask来替换改变cornerRadius的方式 CALayer的设计原则： 机制与策略分离：机制稳定，策略多修改 整体稳定：保证低bug率 各司其职：分散风险 减少暴露：遮蔽部分CALayer接口，易上手 CoreAnimation什么是 CoreAnimation？CoreAnimation(CA) 是苹果提供的一套基于绘图的动画框架。 CoreGraphics (CG) 是一个C语言库，是系统绘制界面、文字、图像等UI的基础。 所以 CoreAnimation 的位置关系应该是这个样子滴： GPU —&gt; OpenGL &amp; CoreGraphics —&gt; CoreAnimation CoreAnimation 和 QuartzCore 的关系？QuartzCore 主要结构: CoreAnimation CADisplayLink 定时器 CALayer 及其子类（参考上方链接） CAMediaTiming 协议相关 CATransaction 事物相关 CATransform3D QuartzCore 引用了 CoreAnimation 头文件，类似于对 CoreAnimation 的包装。 CALayer在iOS中，我们所看到的视图UIView是通过QuartzCore(CoreAnimation) 中的CALayer显示出来的，我们讨论的动画效果也是加在这个CALayer上的。 CALayer图层类是CoreAnimation的基础，它提供了一套抽象概念。CALayer是整个图层类的基础，它是所有核心动画图层的父类 为什么UIView要加一层Layer来负责显示呢？ 我们知道 QuartzCore 是跨 iOS 和 macOS 平台的，而 UIView 属于 UIKit 是 iOS 开发使用的，在 macOS 中对应 AppKit 里的 NSView。 123iOS —&gt; UIKit(触控) \\ QuartzCoremacOS —&gt; NSView(鼠标) / 这是因为macOS是基于鼠标指针操作的系统，与iOS的多点触控有本质的区别。虽然iOS在交互上与macOS有所不同，但在显示层面却可以使用同一套技术。 每一个UIView都有个属性layer、默认为CALayer类型，也可以使用自定义的Layer 12/* view的leyer，view是layer的代理 */@property(nonatomic,readonly,strong) CALayer *layer; 我们看到的 View 其实都是它的 layer，下面我们通过 CALayer 中的集合相关的属性来认识它： bounds:图层的bounds是一个CGRect的值，指定图层的大小（bounds.size)和原点(bounds.origin) position：指定图层的位置(相对于父图层而言) anchorPoint：锚点指定了position在当前图层中的位置，坐标范围0~1 transform：指定图层的几何变换，类型为上篇说过的CATransform3D 如上图的这些属性，注释最后都有一句 Animatable，就是说我们可以通过改变这些属性来实现动画。 默认地，我们修改这些属性都会导致图层从旧值动画显示为新值，称为隐式动画。 注意到frame的注释里面是没有Animatable的。事实上，我们可以理解为图层的frame并不是一个真实的属性：当我们读取frame时，会根据图层position、bounds、anchorPoint和transform的值计算出它的frame；而当我们设置frame时，图层会根据anchorPoint改变position和bounds。也就是说frame本身并没有被保存。 CALayer 也有类似于UIView的层次结构，一个view实例拥有父视图(superView)和子视图(subView)；同样一个layer也有父图层(superLayer)和子图层(subLayer)。我们可以直接在view的layer上添加子layer达到一些显示效果，但这些单独的layer无法像UIView那样进行交互响应。 CAAnimationCALayer 提供以下方法来管理动画： 12345- (void)addAnimation:(CAAnimation*)anim forKey:(nullable NSString*)key;- (void)removeAllAnimations;- (void)removeAnimationForKey:(NSString*)key;- (nullable NSArray&lt;NSString*&gt;*)animationKeys;- (nullable CAAnimation*)animationForKey:(NSString*)key; CAAnimation是动画基类，我们常用的CABasicAnimation和CAKeyframeAnimation都继承于CAPropertyAnimation即属性动画。 12345678910111213141516171819202122232425/** Subclass for property-based animations. **/CA_CLASS_AVAILABLE (10.5, 2.0, 9.0, 2.0)@interface CAPropertyAnimation : CAAnimation/* Creates a new animation object with its `keyPath' property set to * 'path'. */+ (instancetype)animationWithKeyPath:(nullable NSString *)path;/* The key-path describing the property to be animated. */@property(nullable, copy) NSString *keyPath;/* When true the value specified by the animation will be \"added\" to * the current presentation value of the property to produce the new * presentation value. The addition function is type-dependent, e.g. * for affine transforms the two matrices are concatenated. Defaults to * NO. */@property(getter=isAdditive) BOOL additive;/* The `cumulative' property affects how repeating animations produce * their result. If true then the current value of the animation is the * value at the end of the previous repeat cycle, plus the value of the * current repeat cycle. If false, the value is simply the value * calculated for the current repeat cycle. Defaults to NO. */@property(getter=isCumulative) BOOL cumulative;/* If non-nil a function that is applied to interpolated values * before they are set as the new presentation value of the animation's * target property. Defaults to nil. */@property(nullable, strong) CAValueFunction *valueFunction;@end CAPropertyAnimation(属性动画)通过改变layer的可动画属性(位置、大小等)实现动画效果。 1) CABasicAnimationCABasicAnimation可以看做有两个关键帧的CAKeyframeAnimation，通过插值形成一条通过各关键帧的动画路径。但CABasicAnimation更加灵活一些： 12345@interface CABasicAnimation : CAPropertyAnimation@property(nullable, strong) id fromValue;@property(nullable, strong) id toValue;@property(nullable, strong) id byValue;@end 我们可以通过上面三个值来规定CABasicAnimation的动画起止状态: 这三个属性都是可选的，通常给定其中一个或者两个，以下是官方建议的使用方式 给定fromValue和toValue，将在两者之间进行插值 * 给定fromValue和byValue，将在fromValue和fromValue+byValue之间插值 * 给定byValue和toValue，将在toValue-byValue和toValue之间插值 * 仅给定fromValue，将在fromValue和当前值之间插值 * 仅给定toValue，将在当前值和toValue之间插值 * 仅给定byValue，将在当前值和当前值+byValue之间插值 * 2)CAKeyframeAnimation在CAKeyframeAnimation中，除了给定各关键帧之外还可以指定关键帧之间的时间和时间函数： 123456@interface CAKeyframeAnimation : CAPropertyAnimation@property(nullable, copy) NSArray *values;@property(nullable, copy) NSArray&lt;NSNumber *&gt; *keyTimes;/* 时间函数有线性、淡入、淡出等简单效果，还可以指定一条三次贝塞尔曲线 */@property(nullable, copy) NSArray&lt;CAMediaTimingFunction *&gt; *timingFunctions;@end 到这我们已经能够感觉到，所谓动画实际上就是在不同的时间显示不同画面，时间在走进而形成连续变化的效果。所以，动画的关键就是对时间的控制。 CAMediaTimingCAMediaTiming是CoreAnimation中一个非常重要的协议，CALayer和CAAnimation都实现了它来对时间进行管理。 协议定义了8个属性，通过它们来控制时间，这些属性大都见名知意： 12345678910111213@protocol CAMediaTiming@property CFTimeInterval beginTime;@property CFTimeInterval duration;@proterty float speed;/* timeOffset时间的偏移量，用它可以实现动画的暂停、继续等效果*/@proterty CFTimeInterval timeOffset;@property float repeatCount;@property CFTimeInterval repeatDuration;/* autoreverses为true时时间结束后会原路返回，默认为false */@property BOOL autoreverses;/* fillMode填充模式，有4种，见下 */@property(copy) NSString *fillMode;@end 下面这张图形象的说明了这些属性是如何灵活的进行动画时间控制的： 需要注意的是，CALayer也实现了CAMediaTiming协议，也就是说如果我们将layer的speed设置为2，那么加到这个layer上的动画都会以两倍速执行。 上面从图层、动画和时间控制的关系上简单认识了CALayer、属性动画和动画时间控制，了解属性动画是根据时间在各关键帧之间进行插值，随时间连续改变layer的某动画属性来实现的。 UIView与CALayer动画原理下面从以下两点结合具体代码来探索下CoreAnimation的一些原理 1.UIView动画实现原理 2.展示层(presentationLayer)和模型层(modelLayer) 1) UIView动画实现原理 UIView提供了一系列UIViewAnimationWithBlocks，我们只需要把改变可动画属性的代码放在animations的block中即可实现动画效果，比如： 123456789[UIView animateWithDuration:1 animations:^(void)&#123; if (_testView.bounds.size.width &gt; 150) &#123; _testView.bounds = CGRectMake(0, 0, 100, 100); &#125; else &#123; _testView.bounds = CGRectMake(0, 0, 200, 200); &#125;&#125; completion:^(BOOL finished)&#123; NSLog(@\"%d\",finished);&#125;]; 效果如下： 之前说过，UIView对象持有一个CALayer，真正来做动画的是这个layer，UIView只是对它做了一层封装，可以通过一个简单的实验验证一下：我们写一个MyTestLayer类继承CALayer，并重写它的set方法；再写一个MyTestView类继承UIView，重写它的layerClass方法指定图层类为MyTestLayer： MyTestLayer 实现： 12345678910@interface MyTestLayer : CALayer@end@implementation MyTestLayer- (void)setBounds:(CGRect)bounds &#123; NSLog(@\"----layer setBounds\"); [super setBounds:bounds]; NSLog(@\"----layer setBounds end\");&#125;...@end MyTestView 实现： 1234567891011@interface MyTestView : UIView- (void)setBounds:(CGRect)bounds &#123; NSLog(@\"----view setBounds\"); [super setBounds:bounds]; NSLog(@\"----view setBounds end\");&#125;...+ (Class)layerClass &#123; return [MyTestLayer class];&#125;@end 当我们给view设置bounds时，getter、setter的调用顺序是这样的： 也就是说，在view的setBounds方法中，会调用layer的setBounds；同样view的getBounds也会调用layer的getBounds。其他属性也会得到相同的结论。那么动画又是怎么产生的呢？当我们layer的属性发生变化时，会调用代理方法actionForLayer: forKey: 来获得这次属性变化的动画方案，而view就是它所持有的layer的代理： 123456789101112131415161718@interface CALayer : NSObject &lt;NSCoding, CAMediaTiming&gt;...@property(nullable, weak) id &lt;CALayerDelegate&gt; delegate;...@end@protocol CALayerDelegate &lt;NSObject&gt;@optional.../* If defined, called by the default implementation of the * -actionForKey: method. Should return an object implementating the * CAAction protocol. May return 'nil' if the delegate doesn't specify * a behavior for the current event. Returning the null object (i.e. * '[NSNull null]') explicitly forces no further search. (I.e. the * +defaultActionForKey: method will not be called.) */- (nullable id&lt;CAAction&gt;)actionForLayer:(CALayer *)layer forKey:(NSString *)event;...@end 注释中说明，该方法返回一个实现了CAAction的对象，通常是一个动画对象；当返回nil时执行默认的隐式动画，返回null时不执行动画。还是上面那个改变bounds的动画，我们在MyTestView中重写actionForLayer:方法 1234- (id&lt;CAAction&gt;)actionForLayer:(CALayer *)layer forKey:(NSString *)event &#123; id&lt;CAAction&gt; action = [super actionForLayer:layer forKey:event]; return action;&#125; 观察它的返回值： 是一个内部使用的_UIViewAddtiveAnimationAction对象，其中包含一个CABassicAnimation，默认fillMode为both，默认时间函数为淡入淡出，只包含fromValue(即动画之前的值，会在这个值和当前值(block中修改过后的值)之间做动画)。我们可以尝试在重写的这个方法中强制返回nil，会发现我们不写任何动画的代码直接改变属性也将产生一个默认0.25s的隐式动画，这和上面的注释描述是一致的。 2) 关于显式动画和隐式动画显式动画是指用户自己通过beginAnimations:context:和commitAnimations创建的动画。 隐式动画（iOS 4.0后）是指通过UIView的animateWithDuration:animations:方法创建的动画。 3) 如果两个动画重叠在一起会是什么效果呢？ 还是最开始的例子，我们添加两个相同的UIView动画，一个时间为3s，一个时间为1s，并打印finished的值和两个动画的持续时间。先执行3s的动画，当它还没有结束时加上一个1s的动画，可以先看下实际效果： log 打印 很明显，两个动画的finished都为true且时间也是我们设置好的3s和1s。也就是说第二个动画并不会打断第一个动画的执行，而是将动画进行了叠加。 动画的心酸路程： 最开始方块的bounds为(100,100)，点击执行3s动画，bounds变为(200,200)，并开始展示变大的动画； 动画过程中(假设到了(120,120))，点击1s动画，由于这时真实bounds已经是(200,200)了，所以bounds将变回100，并产生一个fromValue为(200,200)的动画。 但此时方块并没有从200开始，而是马上开始变小，并明显变到一个比100更小的值。 1s动画结束，finished为1，耗时1s。此时屏幕上的方块是一个比100还要小的状态，又缓缓变回到100—3s动画结束，finished为1，耗时3s，方块最终停在(100,100)的大小。 从这个现象我们可以猜想UIView动画的叠加方式：当我们通过改变View属性实现动画时，这个属性的值是会立即改变的，动画只是展示出来的效果。当动画还未结束时如果对同个属性又加上另一个动画，两个动画会从当前展示的状态开始进行叠加，并最终停在view的真实位置。 举个通俗点的例子，我们8点从家出发，要在9点到达学校，我们按照正常的步速行走，这可以理解为一个动画；假如我们半路突然想到忘记带书包了，需要回家拿书包（相当于又添加了一个动画），这时我们肯定需要加快步速，当我们拿到书包时相当于第二个动画结束了，但我们上学这个动画还要继续执行，我们要以合适的速度继续往学校赶，保证在9点准时到达终点—学校。 所以刚才那个方块为什么会有一个比100还小的过程就不难理解了：当第二个动画加上去的时候，由于它是一个1s由200变为100的动画，肯定要比3s动画执行的快，而且是从120的位置开始执行的，所以一定会朝反方向变化到比100还小；1s动画结束后，又会以适当的速度在3s的时间点回到最终位置(100,100)。当然叠加后的整个过程在内部实现中可能是根据时间函数已经计算好的。 这么做或许是为了让动画显得更流畅平滑，那么既然我们设置属性值是立即生效的，动画只是看上去的效果，那刚才叠加的时刻屏幕展示上的位置(120,120)又是什么呢？这就是本篇要讨论的下一个话题。 展示层(presentationLayer)和模型层(modelLayer)我们知道UIView动画其实是layer层做的，而view是对layer的一层封装，我们对view的bounds等这些属性的操作其实都是对它所持有的layer进行操作，我们做一个简单的实验—在UIView动画的block中改变view的bounds后，分别查看下view和layer的bounds的实际值： 1234_testView.bounds = CGRectMake(0, 0, 100, 100);[UIView animateWithDuration:1 animations:^(void)&#123; _testView.bounds = CGRectMake(0, 0, 200, 200);&#125; completion:nil]; 赋值完成后我们分别打印view，layer的bounds： 都已经变成了(200,200)，这是肯定的，之前已经验证过set view的bounds实际上就是set 它的layer的bounds。可动画不是layer实现的么？layer也已经到达终点了，它是怎么将动画展示出来的呢？ 这里就要提到CALayer的两个实例方法presentationLayer和modelLayer： 123456789101112131415161718@interface CALayer : NSObject &lt;NSCoding, CAMediaTiming&gt;.../* 以下参考官方api注释 *//* presentationLayer * 返回一个layer的拷贝，如果有任何活动动画时，包含当前状态的所有layer属性 * 实际上是逼近当前状态的近似值。 * 尝试以任何方式修改返回的结果都是未定义的。 * 返回值的sublayers 、mask、superlayer是当前layer的这些属性的presentationLayer */- (nullable instancetype)presentationLayer;/* modelLayer * 对presentationLayer调用，返回当前模型值。 * 对非presentationLayer调用，返回本身。 * 在生成表示层的事务完成后调用此方法的结果未定义。 */- (instancetype)modelLayer;... 从注释不难看出，这个presentationLayer即是我们看到的屏幕上展示的状态，而modelLayer就是我们设置完立即生效的真实状态，我们动画开始后延迟0.1s分别打印layer，layer.presentationLayer，layer.modelLayer和layer.presentationLayer.modelLayer : 明显，layer.presentationLayer是动画当前状态的值，而layer.modelLayer 和 layer.presentationLayer.modelLayer 都是layer本身。 到这里，CALayer动画的原理基本清晰了，当有动画加入时，presentationLayer会不断的(从按某种插值或逼近得到的动画路径上)取值来进行展示，当动画结束被移除时则取modelLayer的状态展示。这也是为什么我们用CABasicAnimation时，设定当前值为fromValue时动画执行结束又会回到起点的原因，实际上动画结束并不是回到起点而是到了modelLayer的位置。 虽然我们可以使用fillMode控制它结束时保持状态，但这种方法在动画执行完之后并没有将动画从渲染树中移除(因为我们需要设置animation.removedOnCompletion = NO才能让fillMode生效)。如果我们想让动画停在终点，更合理的办法是一开始就将layer设置成终点状态，其实前文提到的UIView的block动画就是这么做的。 如果我们一开始就将layer设置成终点状态再加入动画，会不会造成动画在终点位置闪一下呢？其实是不会的，因为我们看到的实际上是presentationLayer，而我们修改layer的属性，presentationLayer是不会立即改变的： 12345678910111213MyTestView *view = [[MyTestView alloc]initWithFrame:CGRectMake(200, 200, 100, 100)];[self.view addSubview:view];view.center = CGPointMake(1000, 1000);dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)((1/60) * NSEC_PER_SEC)), dispatchQueue, ^&#123; NSLog(@\"presentationLayer %@ y %f\",view.layer.presentationLayer, view.layer.presentationLayer.position.y); NSLog(@\"layer.modelLayer %@ y %f\",view.layer.modelLayer,view.layer.modelLayer.position.y);&#125;);dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)((1/20) * NSEC_PER_SEC)), dispatchQueue, ^&#123; NSLog(@\"presentationLayer %@ y %f\",view.layer.presentationLayer, view.layer.presentationLayer.position.y); NSLog(@\"layer.modelLayer %@ y %f\",view.layer.modelLayer,view.layer.modelLayer.position.y);&#125;); 在上面代码中我们改变view的center，modelLayer是立即改变的因为它就是layer本身。但presentationLayer是没有变的，我们尝试延迟一定时间再去取presentationLayer，发现它是在一个很短的时间之后才发生变化的，这个时间跟具体设备的屏幕刷新频率有关。 也就是说我们给layer设置属性后，当下次屏幕刷新时，presentationLayer才会获取新值进行绘制。因为我们不可能对每一次属性修改都进行一次绘制，而是将这些修改保存在model层，当下次屏幕刷新时再统一取model层的值重绘。 如果我们添加了动画，并将modelLayer设置到终点位置，下次屏幕刷新时，presentationLayer会优先从动画中取值来绘制，所以并不会造成在终点位置闪一下。 小结一下 UIView持有一个CALayer负责展示，view是这个layer的delegate。改变view的属性实际上是在改变它持有的layer的属性，layer属性发生改变时会调用代理方法actionForLayer: forKey: 来得知此次变化是否需要动画。对同一个属性叠加动画会从当前展示状态开始叠加并最终停在modelLayer的真实位置。 CALayer内部控制两个属性presentationLayer和modelLayer，modelLayer为当前layer真实的状态，presentationLayer为当前layer在屏幕上展示的状态。presentationLayer会在每次屏幕刷新时更新状态，如果有动画则根据动画获取当前状态进行绘制，动画移除后则取modelLayer的状态。 初探CALayer属性 CALayer和UIView的区别 1.UIView是UIKit的(只能iOS使用)，CALayer是QuartzCore的(iOS和mac os通用) 2.UIView继承UIResponder,CALayer继承NSObject,UIView比CALayer多了一个事件处理的功能，也就是说，CALayer不能处理用户的触摸事件，而UIView可以 3.UIView来自CALayer，是CALayer的高层实现和封装，UIView的所有特性来源于CALayer支持 4.CABasicAnimation，CAAnimation，CAKeyframeAnimation等动画类都需要加到CALayer上 其实UIView之所以能显示在屏幕上，完全是因为它内部的一个图层，在创建UIView对象时，UIView内部会自动创建一个图层(即CALayer对象)，通过UIView的layer属性可以访问这个层。 1@property(nonatomic,readonly,retain) CALayer *layer; 当UIView需要显示到屏幕上时，会调用drawRect:方法进行绘图，并且会将所有内容绘制在自己的图层上，绘图完毕后，系统会将图层拷贝到屏幕上，于是就完成了UIView的显示。 换句话说，UIView本身不具备显示的功能，是它内部的层才有显示功能 CALayer属性表 使用CALayer的Mask实现注水动画效果Core Animation一直是iOS比较有意思的一个主题，使用Core Animation可以实现非常平滑的炫酷动画。Core animtion的API是较高级的封装，使用便捷，使得我们免于自己使用OpenGL实现动画。 下面主要介绍如何使用CALayer的mask实现一个双向注水动画 了解CALayer的mask 1@property(strong) CALayer *mask; mask实际上layer内容的一个遮罩。 如果把mask设置为透明的，实际看到的layer是完全透明的，也就是说只有mask的内容不透明的部分和layer叠加。 实现思路：设计的思路参考基于Core Animation的KTV歌词视图的平滑实现(http://www.iwangke.me/2014/10/06/how-to-implement-a-core-animation-based-60-fps-ktv-lyrics-view/) flow 在View上重叠放置两个UIImageView: grayHead&amp;greenHead，默认greenHead会遮挡住grayHead。 为greenHead设置一个mask，这个mask不是普通的mask，它由两个subLayer:maskLayerUp maskLayerDown组成。 默认情况下，subLayer都显示在mask内容之外，此时mask实际上透明的，由此greenHead也是透明的。 现在我们希望greenHead从左上角和右下角慢慢显示内容，那么我们只需要从两个方向为greenHead填充内容就可以了. 创建mask遮罩 12345678910111213141516171819202122232425262728- (CALayer *)greenHeadMaskLayer &#123; CALayer *mask = [CALayer layer]; mask.frame = self.greenHead.bounds; self.maskLayerUp = [CAShapeLayer layer]; self.maskLayerUp.bounds = CGRectMake(0, 0, 30.0f, 30.0f); self.maskLayerUp.fillColor = [UIColor greenColor].CGColor; // Any color but clear will be OK self.maskLayerUp.path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(15.0f, 15.0f) radius:15.0f startAngle:0 endAngle:2*M_PI clockwise:YES].CGPath; self.maskLayerUp.opacity = 0.8f; self.maskLayerUp.position = CGPointMake(-5.0f, -5.0f); [mask addSublayer:self.maskLayerUp]; self.maskLayerDown = [CAShapeLayer layer]; self.maskLayerDown.bounds = CGRectMake(0, 0, 30.0f, 30.0f); self.maskLayerDown.fillColor = [UIColor greenColor].CGColor; // Any color but clear will be OK self.maskLayerDown.path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(15.0f, 15.0f) radius:15.0f startAngle:0 endAngle:2*M_PI clockwise:YES].CGPath; self.maskLayerDown.position = CGPointMake(35.0f, 35.0f); [mask addSublayer:self.maskLayerDown]; return mask;&#125; 做夹角动画 12345678910111213- (void)startGreenHeadAnimation &#123; CABasicAnimation *downAnimation = [CABasicAnimation animationWithKeyPath:@\"position\"]; downAnimation.fromValue = [NSValue valueWithCGPoint:CGPointMake(-5.0f, -5.0f)]; downAnimation.toValue = [NSValue valueWithCGPoint:CGPointMake(10.0f, 10.0f)]; downAnimation.duration = duration; [self.maskLayerUp addAnimation:downAnimation forKey:@\"downAnimation\"]; CABasicAnimation *upAnimation = [CABasicAnimation animationWithKeyPath:@\"position\"]; upAnimation.fromValue = [NSValue valueWithCGPoint:CGPointMake(35.0f, 35.0f)]; upAnimation.toValue = [NSValue valueWithCGPoint:CGPointMake(20.0f, 20.0f)]; upAnimation.duration = duration; [self.maskLayerDown addAnimation:upAnimation forKey:@\"upAnimation\"];&#125; 小结一下 CALayer提供另外一种操作UI的手段，虽然它提供的API比UIView较底层，但它能提供更加丰富的功能和更高的性能(CALayer的动画是在专门的线程渲染的)。涉及到复杂且性能要求高的UI界面，CALayer的作用就比较明显了，比如AsyncDisplayKit。 其实也能看出CALayer的一个用处，通常我们处理圆角时会直接去修改CALayer的cornerRadius，但这种做法性能比较差，尤其是放在列表里的时候，现在我们有了mask，这样我们可以直接改变layer的mask，而不会影响到图形渲染的性能。 █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 2018.11.25 更新 为啥有了CALayer了还要UIViewUIView继承自UIResponder，主要特点是可以响应触摸事件。而CALayer实际的图层内容管理。大家干的的事情不一样，是两个东西，大家的存在互不影响，理所当然。 假设有一个UIView和CALayer集合体UILayer这个UILayer是一个全能的Layer，可以负责管理显示内容，也能处理触摸事件 。 但由于iOS系统的更新，所以你要不断修改维护UILayer，比如iOS3.2版本增加手势识别、iOS4引入了Block语法、iOS6增加AutoLayout特性、iOS7的UI得改头换面，每次都要打开巨长的UILayer从头改到脚。这样的维护成本太高了。 所以，在这份理所当然的SDK的背后，蕴藏着大牛门几十年的设计智慧。当中应该能够看到很多门道。这次就UIView和CALayer来分析，就可以得出一些东西。 这方面的设计原则： 机制与策略分离 整体稳定 各司其职 减少暴露 机制与策略分离Unix内核设计的一个主要思想是——提供(Mechanism)机制而不是策略(Policy)。编程问题都可以抽离出机制和策略部分。机制一旦实现，就会很少更改，但策略会经常得到优化。例如原子可以看做是机制，而各种原子的组成就是一种策略。 CALayer也可以看做是一种机制，提供图层绘制，你们可以翻开CALayer的头文件看看，基本上是没怎么变过的，而UIView可以看做是策略，变动很多。越是底层，越是机制，越是机制就越是稳定。机制与策略分离，可以使得需要修改的代码更少，特别是底层代码，这样可以提高系统的稳定性。 整体稳定稳定给你的是什么感觉？坚固？不可形变？稳定其实就是不可变。一个系统不可变的东西越多，越是稳定。所以机制恰是满足这个不可变的因素的。构建一个系统有一个指导思想就是尽量抽取不可变的东西和可变的东西分离。水是成不了万丈高楼的，坚固的混凝土才可以。更少的修改，意味着更少的bug的几率。 各司其职即使能力再大也不能把说有事情都干了，万一哪一天不行了呢，那就是突然什么都不能干了。所以仅仅是基于分散风险原则也不应该出现全能类。各司其职，相互合作，把可控粒度降到最低，这样也可以是系统更稳定，更易修改。 减少暴露接口应该面向大众的，按照八二原则，其实20%的接口就可以满足80%的需求，剩下的80%应该隐藏在背后。因为漏的少总是安全的，不是吗。剩下的80%专家接口可以隐藏与深层次。比如UIView遮蔽了大部分的CALayer接口，抽取构造出更易用的frame和动画实现，这样上手更容易。 以上文章整理自：https://blog.csdn.net/zmmzxxx/article/details/74276077#一calayer简介","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS Principle：weak","slug":"iOS Principle weak","date":"2018-06-13T13:56:27.000Z","updated":"2018-11-26T12:57:10.860Z","comments":true,"path":"2018/06/13/iOS Principle weak/","link":"","permalink":"https://reversescale.github.io/2018/06/13/iOS Principle weak/","excerpt":"之前只是认识到 weak 作为一种弱引用属性修饰词，不增加对象的引用计数，也不持有对象，对象消失后，指针自动变成nil。在ARC环境下，为避免循环引用，往往会把delegate属性用weak修饰~","text":"之前只是认识到 weak 作为一种弱引用属性修饰词，不增加对象的引用计数，也不持有对象，对象消失后，指针自动变成nil。在ARC环境下，为避免循环引用，往往会把delegate属性用weak修饰~ 👨🏻‍💻 Github Demo 方便记忆： 作用：作为一种弱引用属性修饰词，不增加对象的引用计数，也不持有对象，对象消失后，指针自动变成nil 原理：weak 其实是一个 hash（哈希）表，Key:对象的地址，Value:weak 指针的地址数组 底层实现过程 初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址 添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表 释放时：调用clearDeallocating函数，对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil 引文今天整理一下 weak 的实现原理，先概括的讲 weak 其实是一个 hash（哈希）表，Key 是所指对象的地址，Value 是 weak 指针的地址数组。 顺便发现其实现在想循环引用也挺难的，Xcode会有个提醒，黄黄的挺显眼的… 实现原理Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。 底层的实现大体分为三步： 1.初始化时：runtime会调用objc_initWeak函数，初始化一个新的weak指针指向对象的地址。（给你添个干兄弟） 2.添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。（给这个干兄弟落个户口，介绍给亲戚朋友） 3.释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。（最后等这个干兄弟干完活后，被卸磨杀驴） 分步解析内部实现：1）初始化时：runtime会调用objc_initWeak函数，objc_initWeak函数会初始化一个新的weak指针指向对象的地址。 12NSObject *obj = [[NSObject alloc] init];id __weak obj1 = obj; // 看好 weak 了 当我们初始化一个weak变量时，runtime会调用 NSObject.mm 中的objc_initWeak函数。这个函数在Clang中的声明如下： 1id objc_initWeak(id *object, id value); objc_initWeak() 方法的实现 123456789101112id objc_initWeak(id *location, id newObj) &#123; // 查看对象实例是否有效 // 无效对象直接导致指针释放 if (!newObj) &#123; *location = nil; return nil; &#125; // 这里传递了三个 bool 数值 // 使用 template 进行常量参数传递是为了优化性能 return storeWeakfalse/*old*/, true/*new*/, true/*crash*/&gt; (location, (objc_object*)newObj);&#125; 可以看出，这个函数仅仅是一个深层函数的调用入口，而一般的入口函数中，都会做一些简单的判断（例如 objc_msgSend 中的缓存判断），这里判断了其指针指向的类对象是否有效，无效直接释放，不再往深层调用函数。否则，object将被注册为一个指向value的__weak对象。 注意：objc_initWeak函数有一个前提条件：就是object必须是一个没有被注册为__weak对象的有效指针。而value则可以是null，或者指向一个有效的对象。 2）添加引用时：objc_initWeak函数会调用 objc_storeWeak() 函数， objc_storeWeak() 的作用是更新指针指向，创建对应的弱引用表。 objc_storeWeak的函数声明如下： 1id objc_storeWeak(id *location, id value); objc_storeWeak 方法的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// HaveOld: true - 变量有值// false - 需要被及时清理，当前值可能为 nil// HaveNew: true - 需要被分配的新值，当前值可能为 nil// false - 不需要分配新值// CrashIfDeallocating: true - 说明 newObj 已经释放或者 newObj 不支持弱引用，该过程需要暂停// false - 用 nil 替代存储template bool HaveOld, bool HaveNew, bool CrashIfDeallocating&gt;static id storeWeak(id *location, objc_object *newObj) &#123; // 该过程用来更新弱引用指针的指向 // 初始化 previouslyInitializedClass 指针 Class previouslyInitializedClass = nil; id oldObj; // 声明两个 SideTable // ① 新旧散列创建 SideTable *oldTable; SideTable *newTable; // 获得新值和旧值的锁存位置（用地址作为唯一标示） // 通过地址来建立索引标志，防止桶重复 // 下面指向的操作会改变旧值 retry: if (HaveOld) &#123; // 更改指针，获得以 oldObj 为索引所存储的值地址 oldObj = *location; oldTable = &amp;SideTables()[oldObj]; &#125; else &#123; oldTable = nil; &#125; if (HaveNew) &#123; // 更改新值指针，获得以 newObj 为索引所存储的值地址 newTable = &amp;SideTables()[newObj]; &#125; else &#123; newTable = nil; &#125; // 加锁操作，防止多线程中竞争冲突 SideTable::lockTwoHaveOld, HaveNew&gt;(oldTable, newTable); // 避免线程冲突重处理 // location 应该与 oldObj 保持一致，如果不同，说明当前的 location 已经处理过 oldObj 可是又被其他线程所修改 if (HaveOld &amp;&amp; *location != oldObj) &#123; SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable); goto retry; &#125; // 防止弱引用间死锁 // 并且通过 +initialize 初始化构造器保证所有弱引用的 isa 非空指向 if (HaveNew &amp;&amp; newObj) &#123; // 获得新对象的 isa 指针 Class cls = newObj-&gt;getIsa(); // 判断 isa 非空且已经初始化 if (cls != previouslyInitializedClass &amp;&amp; !((objc_class *)cls)-&gt;isInitialized()) &#123; // 解锁 SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable); // 对其 isa 指针进行初始化 _class_initialize(_class_getNonMetaClass(cls, (id)newObj)); // 如果该类已经完成执行 +initialize 方法是最理想情况 // 如果该类 +initialize 在线程中 // 例如 +initialize 正在调用 storeWeak 方法 // 需要手动对其增加保护策略，并设置 previouslyInitializedClass 指针进行标记 previouslyInitializedClass = cls; // 重新尝试 goto retry; &#125; &#125; // ② 清除旧值 if (HaveOld) &#123; weak_unregister_no_lock(&amp;oldTable-&gt;weak_table, oldObj, location); &#125; // ③ 分配新值 if (HaveNew) &#123; newObj = (objc_object *)weak_register_no_lock(&amp;newTable-&gt;weak_table, (id)newObj, location, CrashIfDeallocating); // 如果弱引用被释放 weak_register_no_lock 方法返回 nil // 在引用计数表中设置若引用标记位 if (newObj &amp;&amp; !newObj-&gt;isTaggedPointer()) &#123; // 弱引用位初始化操作 // 引用计数那张散列表的weak引用对象的引用计数中标识为weak引用 newObj-&gt;setWeaklyReferenced_nolock(); &#125; // 之前不要设置 location 对象，这里需要更改指针指向 *location = (id)newObj; &#125; else &#123; // 没有新值，则无需更改 &#125; SideTable::unlockTwoHaveOld, HaveNew&gt;(oldTable, newTable); return (id)newObj;&#125; 拆分解析上述代码① SideTable 主要用于管理对象的引用计数和 weak 表。在 NSObject.mm 中声明其数据结构： 12345678struct SideTable &#123; // 保证原子操作的自旋锁 spinlock_t slock; // 引用计数的 hash 表 RefcountMap refcnts; // weak 引用全局 hash 表 weak_table_t weak_table;&#125; 对于 slock 和 refcnts 两个成员不用多说，第一个是为了防止竞争选择的自旋锁，第二个是协助对象的 isa 指针的 extra_rc 共同引用计数的变量（对于对象结果，在今后的文中提到）。这里主要看 weak 全局 hash 表的结构与作用。 ② weak 表 weak表是一个弱引用表，实现为一个weak_table_t结构体，存储了某个对象相关的所有的弱引用信息。 在objc-weak.h中其定义如下 12345678910struct weak_table_t &#123; // 保存了所有指向指定对象的 weak 指针 weak_entry_t *weak_entries; // 存储空间 size_t num_entries; // 参与判断引用计数辅助量 uintptr_t mask; // hash key 最大偏移值 uintptr_t max_hash_displacement;&#125;; 这是一个全局弱引用hash表。使用不定类型对象的地址作为 key ，用 weak_entry_t 类型结构体对象作为 value 。其中的 weak_entries 成员，从字面意思上看，即为弱引用表入口。其实现也是这样的。 其中weak_entry_t是存储在弱引用表中的一个内部结构体，它负责维护和存储指向一个对象的所有弱引用hash表。其定义如下： 1234567891011121314151617typedef objc_object ** weak_referrer_t;struct weak_entry_t &#123; DisguisedPtrobjc_object&gt; referent; union &#123; struct &#123; weak_referrer_t *referrers; uintptr_t out_of_line : 1; uintptr_t num_refs : PTR_MINUS_1; uintptr_t mask; uintptr_t max_hash_displacement; &#125;; struct &#123; // out_of_line=0 is LSB of one of these (don't care which) weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; &#125;; &#125;&#125; 在 weak_entry_t 的结构中，DisguisedPtr referent 是对泛型对象的指针做了一个封装，通过这个泛型类来解决内存泄漏的问题。从注释中写 out_of_line 成员为最低有效位，当其为0的时候， weak_referrer_t 成员将扩展为多行静态 hash table。 其实其中的 weak_referrer_t 是二维 objc_object 的别名，通过一个二维指针地址偏移，用下标作为 hash 的 key，做成了一个弱引用散列。 out_of_line 的值通常情况下是等于零的，所以弱引用表总是一个 objc_objective 指针二维数组。一维 objc_objective 指针可构成一张弱引用散列表，通过第三纬度实现了多张散列表，并且表数量为 WEAK_INLINE_COUNT 。 StripedMap 是一个模板类，在这个类中有一个 array 成员，用来存储 PaddedT 对象，并且其中对于 [] 符的重载定义中，会返回这个 PaddedT 的 value 成员，这个 value 就是我们传入的 T 泛型成员，也就是 SideTable 对象。 在 array 的下标中，这里使用了 indexForPointer 方法通过位运算计算下标，实现了静态的 Hash Table。而在 weak_table 中，其成员 weak_entry 会将传入对象的地址加以封装起来，并且其中也有访问全局弱引用表的入口。 旧对象解除注册操作 weak_unregister_no_lock 该方法主要作用是将旧对象在 weak_table 中接触 weak 指针的对应绑定。根据函数名，称之为解除注册操作。从源码中，可以知道其功能就是从 weak_table 中接触 weak 指针的绑定。而其中的遍历查询，就是针对于 weak_entry 中的多张弱引用散列表。 新对象添加注册操作 weak_register_no_lock 这一步与上一步相反，通过 weak_register_no_lock 函数把心的对象进行注册操作，完成与对应的弱引用表进行绑定操作。 ③ 初始化弱引用对象流程一览 弱引用的初始化，从上文的分析中可以看出，主要的操作部分就在弱引用表的取键、查询散列、创建弱引用表等操作，可以总结出如下的流程图： 这个图中省略了很多情况的判断，但是当声明一个 weak 会调用上图中的这些方法。当然， storeWeak 方法不仅仅用在 weak 的声明中，在 class 内部的操作中也会常常通过该方法来对 weak 对象进行操作。 3）释放时，调用clearDeallocating函数。clearDeallocating函数首先根据对象地址获取所有weak指针地址的数组，然后遍历这个数组把其中的数据设为nil，最后把这个entry从weak表中删除，最后清理对象的记录。 当weak引用指向的对象被释放时，又是如何去处理weak指针的呢？当释放对象时，其基本流程如下： 1、调用objc_release 2、因为对象的引用计数为0，所以执行dealloc 3、在dealloc中，调用了_objc_rootDealloc函数 4、在_objc_rootDealloc中，调用了object_dispose函数 5、调用objc_destructInstance 6、最后调用objc_clear_deallocating 重点看对象被释放时调用的objc_clear_deallocating函数。 123456void objc_clear_deallocating(id obj) &#123; assert(obj); assert(!UseGC); if (obj-&gt;isTaggedPointer()) return; obj-&gt;clearDeallocating();&#125; 也就是调用了clearDeallocating，继续追踪可以发现，它最终是使用了迭代器来取weak表的value，然后调用weak_clear_no_lock,然后查找对应的value，将该weak指针置空，weak_clear_no_lock函数的实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*** Called by dealloc; nils out all weak pointers that point to the* provided object so that they can no longer be used.** @param weak_table* @param referent The object being deallocated.*/void weak_clear_no_lock(weak_table_t *weak_table, id referent_id) &#123; objc_object *referent = (objc_object *)referent_id; weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); if (entry == nil) &#123; /// XXX shouldn't happen, but does with mismatched CF/objc //printf(\"XXX no entry for clear deallocating %p\\n\", referent); return; &#125; // zero out references weak_referrer_t *referrers; size_t count; if (entry-&gt;out_of_line) &#123; referrers = entry-&gt;referrers; count = TABLE_SIZE(entry); &#125; else &#123; referrers = entry-&gt;inline_referrers; count = WEAK_INLINE_COUNT; &#125; for (size_t i = 0; i &lt; count; ++i) &#123; objc_object **referrer = referrers[i]; if (referrer) &#123; if (*referrer == referent) &#123; *referrer = nil; &#125; else if (*referrer) &#123; _objc_inform(\"__weak variable at %p holds %p instead of %p. \" \"This is probably incorrect use of \" \"objc_storeWeak() and objc_loadWeak(). \" \"Break on objc_weak_error to debug.\\n\", referrer, (void*)*referrer, (void*)referent); objc_weak_error(); &#125; &#125; &#125; weak_entry_remove(weak_table, entry);&#125; objc_clear_deallocating 实现如下 1、从weak表中获取废弃对象的地址为键值的记录 2、将包含在记录中的所有附有 weak修饰符变量的地址，赋值为nil 3、将weak表中该记录删除 4、从引用计数表中删除废弃对象的地址为键值的记录 注释：哈希表最大的优点就是把数据的存储和查找消耗的时间大大降低，几乎可以看成是常数时间；而代价仅仅是消耗比较多的内存。然而在当前可利用内存越来越多的情况下，用空间换时间的做法是值得的。另外，编码比较容易也是它的特点之一。 以上原理解析文章来源：http://www.cocoachina.com/ios/20170328/18962.html","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS Principle：Notification","slug":"iOS Principle Notification","date":"2018-06-12T13:56:27.000Z","updated":"2018-11-26T12:56:16.794Z","comments":true,"path":"2018/06/12/iOS Principle Notification/","link":"","permalink":"https://reversescale.github.io/2018/06/12/iOS Principle Notification/","excerpt":"Cocoa 中使用 NSNotification、NSNotificationCenter 和 KVO 来实现观察者模式，实现对象间一对多的依赖关系~","text":"Cocoa 中使用 NSNotification、NSNotificationCenter 和 KVO 来实现观察者模式，实现对象间一对多的依赖关系~ 👨🏻‍💻 Github Demo 方便记忆： 设计模式：观察者模式，实现对象间一对多的依赖关系 NSNotification：方便 NSNotificationCenter 广播到其他对象的封装对象 NSNotificationCenter：管理通知调度表中对象的发送和接收通知 发送时机： NSPostWhenIdle：空闲发送通知 (当运行循环处于等待或空闲状态时，发送通知，对于不重要的通知可以使用) NSPostASAP：尽快发送通知 (当前运行循环迭代完成时，通知将会被发送，有点类似没有延迟的定时器) NSPostNow ：同步发送通知 (如果不使用合并通知和postNotification:一样是同步通知) 合并通知（系统的drawRect方法）： NSNotificationNoCoalescing：不合并通知 NSNotificationCoalescingOnName：合并相同名称的通知 NSNotificationCoalescingOnSender：合并相同通知和同一对象的通知 异步通知：NSNotificationQueue实现对通知的控制管理 多线程通知：使用runloop维持多个线程使用NSPort进行通知（NSPort的runloop兼容mode） 前言本篇文章主要来讨论NSNotification、NSNotificationCenter、同步异步通知、通知中心底层原理 NSNotification、NSNotificationCenter 等NSNotificationNSNotification 是方便 NSNotificationCenter 广播到其他对象的封装对象，通知中心(NSNotificationCenter)对通知调度表中的对象广播时发送NSNotification对象 1234@interface NSNotification : NSObject &lt;NSCopying, NSCoding&gt;@property (readonly, copy) NSNotificationName name; //标识通知的标记@property (nullable, readonly, retain) id object; //要通知的对象@property (nullable, readonly, copy) NSDictionary *userInfo; //存储发送通知时附带的信息 NSNotificationCenterNSNotificationCenter是类似一个广播中心站，使用defaultCenter来获取应用中的通知中心，它可以向应用任何地方发送和接收通知。 在通知中心注册观察者，发送者使用通知中心广播时，以NSNotification的name和object来确定需要发送给哪个观察者。 为保证观察者能接收到通知，所以应先向通知中心注册观察者，接着再发送通知这样才能在通知中心调度表中查找到相应观察者进行通知。 发送者发送者其实就是对post的使用，后面单独讲，发送通知可使用以下方法发送通知 123- (void)postNotification:(NSNotification *)notification;- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject;- (void)postNotificationName:(NSNotificationName)aName object:(nullable id)anObject userInfo:(nullable NSDictionary *)aUserInfo; 三种方式实际上都是发送NSNotification对象给通知中心注册的观察者。 发送通知通过name和object来确定来标识观察者,name和object两个参数的规则相同即当通知设置name为kChangeNotifition时，那么只会发送给符合name为kChangeNotifition的观察者 同理object指发送给某个特定对象通知 如果只设置了name，那么只有对应名称的通知会触发。 如果同时设置name和object参数时就必须同时符合这两个条件的观察者才能接收到通知。 观察者你可以使用以下两种方式注册观察者 123- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSNotificationName)aName object:(nullable id)anObject;- (id &lt;NSObject&gt;)addObserverForName:(nullable NSNotificationName)name object:(nullable id)obj queue:(nullable NSOperationQueue *)queue usingBlock:(void (^)(NSNotification *note))block NS_AVAILABLE(10_6, 4_0); 第一种方式是比较常用的添加Oberver的方式，接到通知时执行aSelector。 第二种方式是基于Block来添加观察者，往通知中心的调度表中添加观察者，这个观察者包括一个queue和一个block,并且会返回这个观察者对象。当接到通知时执行block所在的线程为添加观察者时传入的queue参数，queue也可以为nil，那么block就在通知所在的线程同步执行。 这里需要注意的是如果使用第二种的方式创建观察者需要弱引用可能引起循环引用的对象,避免内存泄漏。 移除观察者在对象被释放前需要移除掉观察者，避免已经被释放的对象还接收到通知导致崩溃。 移除观察者有两种方式： 12- (void)removeObserver:(id)observer;- (void)removeObserver:(id)observer name:(nullable NSNotificationName)aName object:(nullable id)anObject; 传入相应的需要移除的observer 或者使用第二种方式三个参数来移除指定某个观察者。 如果使用基于-[NSNotificationCenter addObserverForName:object:queue:usingBlock:]方法在获取方法返回的观察者进行释放。基于这个方法我们还可以让观察者接到通知后只执行一次： 1234__block __weak id&lt;NSObject&gt; observer = [[NSNotificationCenter defaultCenter] addObserverForName:kChangeNotifition object:nil queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification * _Nonnull note) &#123; NSLog(@\"-[NSNotificationCenter addObserverForName:object:queue:usingBlock:]\"); [[NSNotificationCenter defaultCenter] removeObserver:observer];&#125;]; 在iOS9中使用-[NSNotificationCenter addObserverForName:object:queue:usingBlock:]方法需要手动释放 NSNotificationQueueNSNotificationQueue通知队列，用来管理多个通知的调用。通知队列通常以先进先出（FIFO）顺序维护通。 NSNotificationQueue就像一个缓冲池把一个个通知放进池子中，使用特定方式通过NSNotificationCenter发送到相应的观察者。下面我们会提到特定的方式即合并通知和异步通知。 1.创建通知队列方法: 123- (instancetype)initWithNotificationCenter:(NSNotificationCenter *)notificationCenter NS_DESIGNATED_INITIALIZER;// 或者直接 defaultQueueNSNotificationQueue * notificationQueue = [NSNotificationQueue defaultQueue]; 2.往队列加入通知方法: 12- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle;- (void)enqueueNotification:(NSNotification *)notification postingStyle:(NSPostingStyle)postingStyle coalesceMask:(NSNotificationCoalescing)coalesceMask forModes:(nullable NSArray&lt;NSRunLoopMode&gt; *)modes; 3.移除队列中的通知方法:1- (void)dequeueNotificationsMatching:(NSNotification *)notification coalesceMask:(NSUInteger)coalesceMask; 4.发送方式 控制通知发送的时机 NSPostingStyle包括三种类型：12345typedef NS_ENUM(NSUInteger, NSPostingStyle) &#123; NSPostWhenIdle = 1, NSPostASAP = 2, NSPostNow = 3 &#125;; NSPostWhenIdle：空闲发送通知 (当运行循环处于等待或空闲状态时，发送通知，对于不重要的通知可以使用) NSPostASAP：尽快发送通知 (当前运行循环迭代完成时，通知将会被发送，有点类似没有延迟的定时器) NSPostNow ：同步发送通知 (如果不使用合并通知和postNotification:一样是同步通知) 5.合并通知 通过合并我们可以用来保证相同的通知只被发送一次 NSNotificationCoalescing包括三种类型： 12345typedef NS_OPTIONS(NSUInteger, NSNotificationCoalescing) &#123; NSNotificationNoCoalescing = 0, NSNotificationCoalescingOnName = 1, NSNotificationCoalescingOnSender = 2&#125;; NSNotificationNoCoalescing：不合并通知。 NSNotificationCoalescingOnName：合并相同名称的通知。 NSNotificationCoalescingOnSender：合并相同通知和同一对象的通知。 forModes:(nullable NSArray *)modes可以使用不同的NSRunLoopMode配合来发送通知，可以看出实际上NSNotificationQueue与RunLoop的机制以及运行循环有关系，通过NSNotificationQueue队列来发送的通知和关联的RunLoop运行机制来进行的。 通知管理：同(异)步、单(多)线程同步通知先写一个简单的通知示例 1234567891011121314151617- (void)viewDidLoad &#123; [super viewDidLoad]; //object：指定接受某个对象的通知，为nil表示可以接受任意对象的通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(handleNotifi:) name:@\"EdisonNotif\" object:nil];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; [self sendNotification];&#125;- (void)sendNotification &#123; NSLog(@\"发送通知before：%@\", [NSThread currentThread]); [[NSNotificationCenter defaultCenter] postNotificationName:@\"EdisonNotif\" object:nil]; NSLog(@\"发送通知after：%@\", [NSThread currentThread]);&#125;- (void)handleNotifi:(NSNotification*)notif &#123; NSLog(@\"接收到通知了:%@\", [NSThread currentThread]);&#125; 从 log 结果看出，通知处理都是同步的 发送通知before -&gt; 接收到通知了 -&gt; 发送通知after 说明消息发完之后要等处理了消息才跑发送消息之后的代码，这跟多线程中的同步概念相似 异步通知发送完之后就继续执行下面的代码，不需要去等待接受通知的处理，这里用到通知对列 NSNotificationQueue 12345678- (void)sendNotificationQueue &#123; //每个线程都默认又一个通知队列，可以直接获取，也可以alloc NSNotificationQueue * notificationQueue = [NSNotificationQueue defaultQueue]; NSNotification * notification = [NSNotification notificationWithName:@\"EdisonNotif\" object:nil]; NSLog(@\"异步发送通知before:%@\",[NSThread currentThread]); [notificationQueue enqueueNotification:notification postingStyle:NSPostWhenIdle coalesceMask:NSNotificationCoalescingOnName forModes:nil]; NSLog(@\"异步发送通知after:%@\",[NSThread currentThread]);&#125; 从 log 结果看出，通知处理实现了异步 发送通知before -&gt; 发送通知after -&gt; 接收到通知了 多线程通知点击屏幕直接发送通知，开启一个线程发送通知 123- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; [NSThread detachNewThreadSelector:@selector(sendNotification) toTarget:self withObject:nil];&#125; 而用线程发送同步的是可以接受到通知的，并且处理也是在线程里处理的，这说通知队列跟线程是有关系的，再继续改代码，回到线程发送异步通知，只是把发送时机改成马上发送 1[notificationQueue enqueueNotification:notification postingStyle:NSPostNow coalesceMask:NSNotificationNoCoalescing forModes:nil]; 这又能处理通知，所以可以说NSPostNow就是同步，其实呢，[[NSNotificationCenter defaultCenter]通知中心这句代码的意思就是：你在哪个线程里面就是获取当前线程的通知队列并且默认采用NSPostNow发送时机 1[notificationQueue enqueueNotification:notification postingStyle:NSPostWhenIdle coalesceMask:NSNotificationNoCoalescing forModes:nil]; 那么通知队列到底和线程有什么关系呢：每个线程都有一个通知队列，当线程结束了，通知队列就被释放了，所以当前选择发送时机为NSPostWhenIdle时也就是空闲的时候发送通知，通知队列就已经释放了，所以通知发送不出去了 如果线程不结束，就可以发送通知了，用runloop让线程不结束 1234567891011- (void)sendAsyncNotification &#123; //每个线程都默认又一个通知队列，可以直接获取，也可以alloc NSNotificationQueue * notificationQueue = [NSNotificationQueue defaultQueue]; NSNotification * notification = [NSNotification notificationWithName:@\"EdisonNotif\" object:nil]; NSLog(@\"异步发送通知before:%@\",[NSThread currentThread]); [notificationQueue enqueueNotification:notification postingStyle:NSPostWhenIdle coalesceMask:NSNotificationNoCoalescing forModes:nil]; NSLog(@\"异步发送通知after:%@\",[NSThread currentThread]); NSPort * port = [NSPort new]; [[NSRunLoop currentRunLoop] addPort:port forMode:NSRunLoopCommonModes]; [[NSRunLoop currentRunLoop] run];&#125; 这样通知就被发送出去了，而且发送和处理也在线程中，这还没有达到真正的异步是吧，应该发送在一个线程，处理在另一个线程 消息合并处理 12345678910111213- (void)sendAsyncNotificationTwo &#123; NSNotificationQueue * notificationQueue = [NSNotificationQueue defaultQueue]; NSNotification * notification = [NSNotification notificationWithName:@\"EdisonNotif\" object:nil]; NSNotification * notificationtwo = [NSNotification notificationWithName:@\"EdisonNotif\" object:nil]; NSLog(@\"异步发送通知before:%@\",[NSThread currentThread]); [notificationQueue enqueueNotification:notification postingStyle:NSPostWhenIdle coalesceMask:NSNotificationCoalescingOnName forModes:nil]; [notificationQueue enqueueNotification:notificationtwo postingStyle:NSPostWhenIdle coalesceMask:NSNotificationCoalescingOnName forModes:nil]; [notificationQueue enqueueNotification:notification postingStyle:NSPostWhenIdle coalesceMask:NSNotificationCoalescingOnName forModes:nil]; NSLog(@\"异步发送通知after:%@\",[NSThread currentThread]); NSPort * port = [NSPort new]; [[NSRunLoop currentRunLoop] addPort:port forMode:NSRunLoopCommonModes]; [[NSRunLoop currentRunLoop] run];&#125; 设置成NSNotificationCoalescingOnName按名称合并，此时我连续发送三条,但是只处理了一次，再继续，上面代码就只是把发送时机改成NSPostNow 123[notificationQueue enqueueNotification:notification postingStyle:NSPostNow coalesceMask:NSNotificationCoalescingOnName forModes:nil];[notificationQueue enqueueNotification:notificationTwo postingStyle:NSPostNow coalesceMask:NSNotificationCoalescingOnName forModes:nil];[notificationQueue enqueueNotification:notification postingStyle:NSPostNow coalesceMask:NSNotificationCoalescingOnName forModes:nil]; 打印结果 1234567/*2017-08-30 16:30:04.114 通知的底层解析[4442:164620] 异步发送通知before:&lt;NSThread: 0x600000269a40&gt;&#123;number = 3, name = (null)&#125;2017-08-30 16:30:04.115 通知的底层解析[4442:164620] 接收到通知了:&lt;NSThread: 0x600000269a40&gt;&#123;number = 3, name = (null)&#125;2017-08-30 16:30:04.115 通知的底层解析[4442:164620] 接收到通知了:&lt;NSThread: 0x600000269a40&gt;&#123;number = 3, name = (null)&#125;2017-08-30 16:30:04.115 通知的底层解析[4442:164620] 接收到通知了:&lt;NSThread: 0x600000269a40&gt;&#123;number = 3, name = (null)&#125;2017-08-30 16:30:04.116 通知的底层解析[4442:164620] 异步发送通知after:&lt;NSThread: 0x600000269a40&gt;&#123;number = 3, name = (null)&#125;*/ 结果就打印了处理了三次通知，这个应该好理解吧，就跟dispatch_sync原理一样，就是得发送因为NSPostNow是同步的，所以发送第一条通知，得等处理完第一条通知，才跑发送第二条通知，这样肯定就没有合并消息一说了，因为这有点类似线程阻塞的意思，只有异步，就是三个发送通知全部跑完，在处理通知的时候看是否需要合并和怎么合并，再去处理 系统的很多方法，如 drawRect，就是默认消息合并处理，多次方法只响应一次 实现原理先猜想一下首先，信息的传递就依靠通知(NSNotification),也就是说，通知就是信息(执行的方法，观察者本身(self),参数)的包装。 通知中心(NSNotificationCenter)是个单例，向通知中心注册观察者，也就是说，这个通知中心有个集合，这个集合存放着观察者。 可以想象的是，发送通知需要name参数，添加观察者也有个name参数，这两个name一样的时候，当发送通知时候，观察者对象就能接受到信息，执行对应的操作。那么这个集合很容易想到就是NSDictionary! key就是name，value就是NSArray(存放数据模型)，里面存放观察者对象。如下图 实现探究根据NSNotification&amp;NSNotificationCenter接口给出实现代码,创建两个新类YFLNotification,YFLNotificationCenter，这两个类的接口和苹果提供的接口完全一样，我将根据接口提供的功能给出实现代码。 要点是通知中心是单例类，并且通知中心维护了一个包含所有注册的观察者的集合，这里我选择了动态数组来存储所有的观察者，源码如下： 1234567891011121314+ (YFLNotificationCenter*)defaultCenter &#123; static YFLNotificationCenter *singleton; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; singleton = [[self alloc] initSingleton]; &#125;); return singleton;&#125;- (instancetype)initSingleton &#123; if ([super init]) &#123; _obsetvers = [[NSMutableDictionary alloc] init]; &#125; return self;&#125; 还定义了一个观察者模型用于保存观察者，通知消息名，观察者收到通知后执行代码所在的操作队列和执行代码的回调，模型源码如下： 12345678@interface YFLObserverModel: NSObject@property (nonatomic, strong) id observer; //观察者对象@property (nonatomic, assign) SEL selector; //执行的方法@property (nonatomic, copy) NSString *notificationName; //通知名字@property (nonatomic, strong) id object; //携带参数@property (nonatomic, strong) NSOperationQueue *operationQueue;//队列@property (nonatomic, copy) OperationBlock block; //回调@end 向通知中心注册观察者，源码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051- (void)addObserver:(id)observer selector:(SEL)aSelector name:(nullable NSString*)aName object:(nullable id)anObject &#123; //如果不存在，那么即创建 if (![self.obsetvers objectForKey:aName]) &#123; NSMutableArray *arrays = [[NSMutableArray alloc]init]; // 创建数组模型 YFLObserverModel *observerModel = [[YFLObserverModel alloc]init]; observerModel.observer = observer; observerModel.selector = aSelector; observerModel.notificationName = aName; observerModel.object = anObject; [arrays addObject:observerModel]; //填充进入数组 [self.obsetvers setObject:arrays forKey:aName]; &#125; else &#123; //如果存在，取出来，继续添加减去即可 NSMutableArray *arrays = (NSMutableArray*)[self.obsetvers objectForKey:aName]; // 创建数组模型 YFLObserverModel *observerModel = [[YFLObserverModel alloc]init]; observerModel.observer = observer; observerModel.selector = aSelector; observerModel.notificationName = aName; observerModel.object = anObject; [arrays addObject:observerModel]; &#125;&#125;- (id &lt;NSObject&gt;)addObserverForName:(nullable NSString *)name object:(nullable id)obj queue:(nullable NSOperationQueue *)queue usingBlock:(void (^)(YFLNotification *note))block &#123; //如果不存在，那么即创建 if (![self.obsetvers objectForKey:name]) &#123; NSMutableArray *arrays = [[NSMutableArray alloc]init]; // 创建数组模型 YFLObserverModel *observerModel = [[YFLObserverModel alloc]init]; observerModel.block = block; observerModel.notificationName = name; observerModel.object = obj; observerModel.operationQueue = queue; [arrays addObject:observerModel]; //填充进入数组 [self.obsetvers setObject:arrays forKey:name]; &#125; else &#123; //如果存在，取出来，继续添加即可 NSMutableArray *arrays = (NSMutableArray*)[self.obsetvers objectForKey:name]; // 创建数组模型 YFLObserverModel *observerModel = [[YFLObserverModel alloc]init]; observerModel.block = block; observerModel.notificationName = name; observerModel.object = obj; observerModel.operationQueue = queue; [arrays addObject:observerModel]; &#125; return nil;&#125; 发送通知有三种方式，最终都是调用- (void)postNotification:(YFLNotification *)notification，源码如下： 12345678910111213141516171819202122232425- (void)postNotification:(YFLNotification *)notification &#123; //name 取出来对应观察者数组，执行任务 NSMutableArray *arrays = (NSMutableArray*)[self.obsetvers objectForKey:notification.name]; [arrays enumerateObjectsUsingBlock:^(id _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; //取出数据模型 YFLObserverModel *observerModel = obj; id observer = observerModel.observer; SEL secector = observerModel.selector; if (!observerModel.operationQueue) &#123; #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Warc-performSelector-leaks\" [observer performSelector:secector withObject:notification]; #pragma clang diagnostic pop &#125; else &#123; //创建任务 NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123; //这里用block回调出去 observerModel.block(notification); &#125;]; // 如果添加观察者 传入 队列，那么就任务放在队列中执行(子线程异步执行) NSOperationQueue *operationQueue = observerModel.operationQueue; [operationQueue addOperation:operation]; &#125; &#125;];&#125; 底层通信 port通知队列也可以实现异步，但是真正的异步还是得通过port 底层所有的消息触发都是通过端口 NSPort 来进行操作的 NSPort 接口通信实现代码 12345678910111213141516171819202122232425262728293031323334@interface ViewController ()&lt;NSPortDelegate&gt;&#123;NSPort *_port;&#125;@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; [self testPortDemo];&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; // NSPort // [self sendPort]; [NSThread detachNewThreadSelector:@selector(sendPort) toTarget:self withObject:nil];&#125;- (void)testPortDemo &#123; _port =[[NSPort alloc] init]; //消息处理通过代理来处理的 _port.delegate = self; //把端口加在哪个线程里，就在哪个线程进行处理，下面：加在当前线程的runloop里 [[NSRunLoop currentRunLoop] addPort:_port forMode:NSRunLoopCommonModes];&#125;//发送消息- (void)sendPort &#123; NSLog(@\"port发送通知before:%@\",[NSThread currentThread]); [_port sendBeforeDate:[NSDate date] msgid:1212 components:nil from:nil reserved:0]; NSLog(@\"port发送通知after:%@\",[NSThread currentThread]);&#125;//处理消息- (void)handlePortMessage:(NSPortMessage *)message &#123; NSLog(@\"port处理任务:%@\",[NSThread currentThread]); NSObject * messageObj = (NSObject*)message; NSLog(@\"=%@\",[messageObj valueForKey:@\"msgid\"]);&#125; 运行结果 发送和处理在不同线程，实现通知的效果 以上原理解析文章来源：https://www.jianshu.com/p/051a9a3af1a4，https://www.jianshu.com/p/087a35d5f778，https://blog.csdn.net/qq_18505715/article/details/76146575","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS Principle：ReactNative","slug":"iOS Principle ReactNative","date":"2018-06-11T13:56:27.000Z","updated":"2018-11-18T05:45:34.574Z","comments":true,"path":"2018/06/11/iOS Principle ReactNative/","link":"","permalink":"https://reversescale.github.io/2018/06/11/iOS Principle ReactNative/","excerpt":"ReactNative 利用了移动平台能够运行 JavaScript (脚本语言)代码的能力，并且发挥了 JavaScript 不仅仅可以传递配置信息，还可以表达逻辑信息的优点~","text":"ReactNative 利用了移动平台能够运行 JavaScript (脚本语言)代码的能力，并且发挥了 JavaScript 不仅仅可以传递配置信息，还可以表达逻辑信息的优点~ 👨🏻‍💻 Github Demo 方便记忆： React原理：一套可以用简洁的语法高效绘制 DOM 的框架 React特点： 简洁：不单单指它的 HTML 和 CSS 语法，更因为可以单用 JavaScript 构造页面 高效：因为 React 独创了 Virtual DOM 机制，两大特征 它存在于内存中的 JavaScript 对象，并且与 DOM 是对应关系 使用高效的 DOM Diff 算法不需要对 DOM 进行重新绘制 React Native原理：通过 JS 对 OC 的 JavaScript Core 框架的交互来实现对原生的调用 rn 在 OC 和 JS 两端都保存了一份配置表，里面标记了所有 OC 暴露给 JS 的模块和方法 ，js对oc的调用通过block方式实现回调 AppDelegate初始化过程中创建bridge，内部通过setUp创建BatchedBridge来批量读取 JS 对 OC 的方法调用并通过JavaScriptExecutor执行 JS 代码 创建 BatchedBridge 步骤 读取 JS 源码：把 JSX 代码转成 JS 加载进内存中 初始化模块信息：找到所有需要暴露给 JS 的类 初始化 JS 代码的执行器：即 RCTJSCExecutor 对象 生成模块列表并写入 JS 端：接受 ModuleName 并且生成模块信息 执行 JavaScript 源码：通过RCTJSCExecutor执行代码，写入信息 相互调用方法： OC调用JS：OC会通过executeBlockOnJavaScriptQueue方法在单独的线程上运行 JS 代码 处理参数：_executeJSCall:(NSString *)method方法 实际调用：sendAppEventWithName和body方法 JS调用OC：JS 会解析出方法的类、方法和方法参数并放入到 MessageQueue 中，等待 OC 调用或超时发送 使用RCT_EXPORT_METHOD 宏，用来注册模块表 JS中使用NativeModules.CryptoExport.注册方法调用 rn 的更新机制：React 状态机，不停地检查确认更新 文本元素：ReactDOMTextComponent 比较替换文本元素 基本元素：updateComponent方法分属性、节点替换基本元素 自定义元素：_performComponentUpdate判断-先卸载再安装子节点 20180522更新：React Native 原理解析 准备工作，首先要有个解剖对象从 HelloWord 看起，我们来分析RN的实现原理 1234567891011import React, &#123; Component &#125; from 'react';import &#123; AppRegistry, Text &#125; from 'react-native';class HelloWorldApp extends Component &#123; render() &#123; return ( &lt;Text&gt;Hello world!&lt;/Text&gt; ); &#125;&#125;// 注意，这里用引号括起来的'HelloWorldApp'必须和你init创建的项目名一致AppRegistry.registerComponent('HelloWorldApp', () =&gt; HelloWorldApp); 可以创建一个新的项目 1react-native init ProjectName 创建完成你可以手动打开项目，也可以在项目根目录执行 1234// 启动 iOSreact-native run-ios// 启动 Androidreact-native run-android 准备工作完成了 React 原理探究首先我们聊聊 React，我们注意到这条数据源代码 123return ( &lt;Text&gt;Hello world!&lt;/Text&gt;); “为什么 JavaScript 代码里面出现了 HTML 的语法？” React Native 把一组相关的 HTML 标签，也就是 app 内的 UI 控件，封装进一个组件(Component)中，这种语法被称为 JSX，它是一种 JavaScript 语法拓展。 JSX 允许我们写 HTML 标签或 React 标签，它们终将被转换成原生的 JavaScript 并创建 DOM。 在 React 框架中，除了可以用 JavaScript 写 HTML 以外，我们甚至可以写 CSS。 总之 React 是一套可以用简洁的语法高效绘制 DOM 的框架 简洁：不单单指它的 HTML 和 CSS 语法，更因为可以单用 JavaScript 构造页面； 高效：因为 React 独创了 Virtual DOM 机制，Virtual DOM 有两大特征，一它存在于内存中的 JavaScript 对象，并且与 DOM 是一一对应的关系；二使用高效的 DOM Diff 算法不需要对 DOM 进行重新绘制。 当然，React 并不是前端开发的全部。从之前的描述也能看出，它专注于 UI 部分，对应到 MVC 结构中就是 View 层。 要想实现完整的 MVC 架构，还需要 Model 和 Controller 的结构。在前端开发时，我们可以采用 Flux 和 Redux（基于Flux） 架构，它们并非框架(Library)，而是和 MVC 一样都是一种架构设计(Architecture)。 React Native 原理探究谈谈 RN 的故事背景React 在前端取得突破性成功以后，JavaScript 开始试图一统三端。 最终，一个基于 JavaScript，具备动态配置能力，面向前端开发者的移动端开发框架 —— React Native 谈谈 RN 的原理即使使用了 React Native，我们依然需要 UIKit 等框架，调用的是 Objective-C 代码，JavaScript 只是提供了配置信息和逻辑的处理结果。 而 JavaScript 是一种脚本语言，它不会经过编译、链接等操作，而是在运行时才动态的进行词法、语法分析，生成抽象语法树(AST)和字节码，然后由解释器负责执行或者使用 JIT 将字节码转化为机器码再执行。 苹果提供了一个叫做 JavaScript Core 的框架，这是一个 JavaScript 引擎。整个流程由 JavaScript 引擎负责完成。 123JSContext *context = [[JSContext alloc] init]; JSValue *jsVal = [context evaluateScript:@\"21+7\"]; int iVal = [jsVal toInt32]; JavaScript 是一种单线程的语言，它不具备自运行的能力，因此总是被动调用。很多介绍 React Native 的文章都会提到 “JavaScript 线程” 的概念，实际上，它表示的是 Objective-C 创建了一个单独的线程，这个线程只用于执行 JavaScript 代码，而且 JavaScript 代码只会在这个线程中执行。 下面将 JavaScript 👉 OC 由于 JavaScript Core 是一个面向 Objective-C 的框架，在 Objective-C 这一端，我们对 JavaScript 上下文知根知底，可以很容易的获取到对象，方法等各种信息，当然也包括调用 JavaScript 函数。 真正复杂的问题在于，JavaScript 不知道 Objective-C 有哪些方法可以调用。 React Native 解决这个问题的方案是在 Objective-C 和 JavaScript 两端都保存了一份配置表，里面标记了所有 Objective-C 暴露给 JavaScript 的模块和方法。 这样，无论是哪一方调用另一方的方法，实际上传递的数据只有 ModuleId 类 MethodId 方法 Arguments 方法参数 当 Objective-C 接收到这三个值后，就可以通过 runtime 唯一确定要调用的是哪个函数，然后调用这个函数。 对于 Objective-C 来说，执行完 JavaScript 代码再执行 Objective-C 回调毫无难度，难点依然在于 JavaScript 代码调用 Objective-C 之后，如何在 Objective-C 的代码中，回调执行 JavaScript 代码。 目前 React Native 的做法是：在 JavaScript 调用 Objective-C 代码时，注册要回调的 Block，并且把 Block Id 作为参数发送给 Objective-C，Objective-C 收到参数时会创建 Block，调用完 Objective-C 函数后就会执行这个刚刚创建的 Block。 Objective-C 会向 Block 中传入参数和 Block Id，然后在 Block 内部调用 JavaScript 的方法，随后 JavaScript 查找到当时注册的 Block 并执行。 简单的表示就是：JS 👉 OC (Block 👉 JS) 继续看项目-初始化除了 index.js 中的 JavaScript 代码，留给我们的还有 AppDelegate 中的入口方法： 123456789101112131415161718- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; NSURL *jsCodeLocation; jsCodeLocation = [[RCTBundleURLProvider sharedSettings] jsBundleURLForBundleRoot:@\"index\" fallbackResource:nil]; RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation moduleName:@\"demo\" initialProperties:nil launchOptions:launchOptions]; rootView.backgroundColor = [[UIColor alloc] initWithRed:1.0f green:1.0f blue:1.0f alpha:1]; self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds]; UIViewController *rootViewController = [UIViewController new]; rootViewController.view = rootView; self.window.rootViewController = rootViewController; [self.window makeKeyAndVisible]; return YES;&#125; 实际我们操作的视图就是这个 RootView ，但是 RootView 是依托于 Bridge 对象，它是 Objective-C 与 JavaScript 交互的桥梁，后续的方法交互完全依赖于它，而整个初始化过程的最终目的其实也就是创建这个桥梁对象。 12345678910- (instancetype)initWithBundleURL:(NSURL *)bundleURL moduleName:(NSString *)moduleName initialProperties:(NSDictionary *)initialProperties launchOptions:(NSDictionary *)launchOptions &#123; RCTBridge *bridge = [[RCTBridge alloc] initWithBundleURL:bundleURL moduleProvider:nil launchOptions:launchOptions]; return [self initWithBridge:bridge moduleName:moduleName initialProperties:initialProperties];&#125; 初始化方法的核心是 setUp 方法，而 setUp 方法的主要任务则是创建 BatchedBridge。 123456789101112131415161718192021222324252627282930- (void)setUp &#123; RCT_PROFILE_BEGIN_EVENT(0, @\"-[RCTBridge setUp]\", nil); _performanceLogger = [RCTPerformanceLogger new]; [_performanceLogger markStartForTag:RCTPLBridgeStartup]; [_performanceLogger markStartForTag:RCTPLTTI]; Class bridgeClass = self.bridgeClass; #if RCT_DEV RCTExecuteOnMainQueue(^&#123; RCTRegisterReloadCommandListener(self); &#125;); #endif // Only update bundleURL from delegate if delegate bundleURL has changed NSURL *previousDelegateURL = _delegateBundleURL; _delegateBundleURL = [self.delegate sourceURLForBridge:self]; if (_delegateBundleURL &amp;&amp; ![_delegateBundleURL isEqual:previousDelegateURL]) &#123; _bundleURL = _delegateBundleURL; &#125; // Sanitize the bundle URL _bundleURL = [RCTConvert NSURL:_bundleURL.absoluteString]; self.batchedBridge = [[bridgeClass alloc] initWithParentBridge:self]; [self.batchedBridge start]; RCT_PROFILE_END_EVENT(RCTProfileTagAlways, @\"\");&#125; BatchedBridge 的作用是批量读取 JavaScript 对 Objective-C 的方法调用，同时它内部持有一个 JavaScriptExecutor，顾名思义，这个对象用来执行 JavaScript 代码。 创建 BatchedBridge 的关键是 start 方法，它可以分为五个步骤： 读取 JavaScript 源码 初始化模块信息 初始化 JavaScript 代码的执行器，即 RCTJSCExecutor 对象 生成模块列表并写入 JavaScript 端 执行 JavaScript 源码 逐个分析上面每一步完成的操作： 1.读取JavaScript源码这一部分的具体代码实现没有太大的讨论意义。我们只要明白，JavaScript 的代码是在 Objective-C 提供的环境下运行的，所以第一步就是把 JavaScript 加载进内存中，对于一个空的项目来说，所有的 JavaScript 代码大约占用 1.5 Mb 的内存空间。 需要说明的是，在这一步中，JSX 代码已经被转化成原生的 JavaScript 代码。 2.初始化模块信息这一步在方法 initModulesWithDispatchGroup: 中实现，主要任务是找到所有需要暴露给 JavaScript 的类。 每一个需要暴露给 JavaScript 的类(也成为 Module，以下不作区分)都会标记一个宏：RCT_EXPORT_MODULE，这个宏的具体实现并不复杂 1234#define RCT_EXPORT_MODULE(js_name) \\RCT_EXTERN void RCTRegisterModule(Class); \\+ (NSString *)moduleName &#123; return @#js_name; &#125; \\+ (void)load &#123; RCTRegisterModule(self); &#125; 这样，这个类在 load 方法中就会调用 RCTRegisterModule 方法注册自己： 1234567void RCTRegisterModule(Class moduleClass) &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; RCTModuleClasses = [NSMutableArray new]; &#125;); [RCTModuleClasses addObject:moduleClass];&#125; 因此，React Native 可以通过 RCTModuleClasses 拿到所有暴露给 JavaScript 的类。下一步操作是遍历这个数组，然后生成 RCTModuleData 对象： 12345for (Class moduleClass in RCTGetModuleClasses()) &#123; RCTModuleData *moduleData = [[RCTModuleData alloc]initWithModuleClass:moduleClass bridge:self]; [moduleClassesByID addObject:moduleClass]; [moduleDataByID addObject:moduleData];&#125; 可以想见，RCTModuleData 对象是模块配置表的主要组成部分。如果把模块配置表想象成一个数组，那么每一个元素就是一个 RCTModuleData 对象。 这个对象保存了 Module 的名字，常量等基本信息，最重要的属性是一个数组，保存了所有需要暴露给 JavaScript 的方法。 暴露给 JavaScript 的方法需要用 RCT_EXPORT_METHOD 这个宏来标记，它的实现原理比较复杂，有兴趣的读者可以自行阅读。简单来说，它为函数名加上了 rct_export 前缀，再通过 runtime 获取类的函数列表，找出其中带有指定前缀的方法并放入数组中: 12345678910- (NSArray&lt;id&lt;RCTBridgeMethod&gt;&gt; *)methods&#123; unsigned int methodCount; Method *methods = class_copyMethodList(object_getClass(_moduleClass), &amp;methodCount); // 获取方法列表 for (unsigned int i = 0; i &lt; methodCount; i++) &#123; RCTModuleMethod *moduleMethod = /* 创建 method */ [_methods addObject:moduleMethod]; &#125; &#125; return _methods;&#125; 因此 Objective-C 管理模块配置表的逻辑是：Bridge 持有一个数组，数组中保存了所有的模块的 RCTModuleData 对象，RCTModuleData又保存了类的方法、常亮、类名等信息。只要给定 ModuleId 和 MethodId 就可以唯一确定要调用的方法。 3.初始化JavaScript执行器（RCTJSCExecutor）通过查看源码可以看到，初始化 JavaScript 执行器的时候，会调用12345+ (instancetype)initializedExecutorWithContextProvider:(RCTJSContextProvider *)JSContextProvider applicationScript:(NSData *)applicationScript sourceURL:(NSURL *)sourceURL JSContext:(JSContext **)JSContext error:(NSError **)error; 返回的 excuter 对象是已经被同步执行的12345// 执行对应的方法- (void)callFunctionOnModule:(NSString *)module method:(NSString *)method arguments:(NSArray *)args jsValueCallback:(RCTJavaScriptValueCallback)onComplete&#123; [self _callFunctionOnModule:module method:method arguments:args returnValue:NO unwrapResult:NO callback:onComplete];&#125; 这里需要关注 nativeRequireModuleConfig 和 nativeFlushQueueImmediate 这两个block。 在这两个 block 中会通过 bridge 调用 oc 的方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192[self executeBlockOnJavaScriptQueue:^&#123; if (!self.valid) &#123; return; &#125; JSContext *context = nil; if (self-&gt;_jscWrapper) &#123; RCTAssert(self-&gt;_context != nil, @\"If wrapper was pre-initialized, context should be too\"); context = self-&gt;_context.context; &#125; else &#123; [self-&gt;_performanceLogger markStartForTag:RCTPLJSCWrapperOpenLibrary]; self-&gt;_jscWrapper = RCTJSCWrapperCreate(self-&gt;_useCustomJSCLibrary); [self-&gt;_performanceLogger markStopForTag:RCTPLJSCWrapperOpenLibrary]; RCTAssert(self-&gt;_context == nil, @\"Didn't expect to set up twice\"); context = [self-&gt;_jscWrapper-&gt;JSContext new]; self-&gt;_context = [[RCTJavaScriptContext alloc] initWithJSContext:context onThread:self-&gt;_javaScriptThread]; [[NSNotificationCenter defaultCenter] postNotificationName:RCTJavaScriptContextCreatedNotification object:context]; configureCacheOnContext(context, self-&gt;_jscWrapper); installBasicSynchronousHooksOnContext(context); &#125; __weak RCTJSCExecutor *weakSelf = self; context[@\"nativeRequireModuleConfig\"] = ^NSString *(NSString *moduleName) &#123; RCTJSCExecutor *strongSelf = weakSelf; if (!strongSelf.valid) &#123; return nil; &#125; RCT_PROFILE_BEGIN_EVENT(RCTProfileTagAlways, @\"nativeRequireModuleConfig\", nil); NSArray *config = [strongSelf-&gt;_bridge configForModuleName:moduleName]; NSString *result = config ? RCTJSONStringify(config, NULL) : nil; RCT_PROFILE_END_EVENT(RCTProfileTagAlways, @\"js_call,config\", @&#123; @\"moduleName\": moduleName &#125;); return result; &#125;; context[@\"nativeFlushQueueImmediate\"] = ^(NSArray&lt;NSArray *&gt; *calls)&#123; RCTJSCExecutor *strongSelf = weakSelf; if (!strongSelf.valid || !calls) &#123; return; &#125; RCT_PROFILE_BEGIN_EVENT(RCTProfileTagAlways, @\"nativeFlushQueueImmediate\", nil); [strongSelf-&gt;_bridge handleBuffer:calls batchEnded:NO]; RCT_PROFILE_END_EVENT(RCTProfileTagAlways, @\"js_call\", nil); &#125;;#if RCT_PROFILE __weak RCTBridge *weakBridge = self-&gt;_bridge; context[@\"nativeTraceBeginAsyncFlow\"] = ^(__unused uint64_t tag, __unused NSString *name, int64_t cookie) &#123; if (RCTProfileIsProfiling()) &#123; [weakBridge.flowIDMapLock lock]; int64_t newCookie = [_RCTProfileBeginFlowEvent() longLongValue]; CFDictionarySetValue(weakBridge.flowIDMap, (const void *)cookie, (const void *)newCookie); [weakBridge.flowIDMapLock unlock]; &#125; &#125;; context[@\"nativeTraceEndAsyncFlow\"] = ^(__unused uint64_t tag, __unused NSString *name, int64_t cookie) &#123; if (RCTProfileIsProfiling()) &#123; [weakBridge.flowIDMapLock lock]; int64_t newCookie = (int64_t)CFDictionaryGetValue(weakBridge.flowIDMap, (const void *)cookie); _RCTProfileEndFlowEvent(@(newCookie)); CFDictionaryRemoveValue(weakBridge.flowIDMap, (const void *)cookie); [weakBridge.flowIDMapLock unlock]; &#125; &#125;;#endif#if RCT_DEV RCTInstallJSCProfiler(self-&gt;_bridge, context.JSGlobalContextRef); // Inject handler used by HMR context[@\"nativeInjectHMRUpdate\"] = ^(NSString *sourceCode, NSString *sourceCodeURL) &#123; RCTJSCExecutor *strongSelf = weakSelf; if (!strongSelf.valid) &#123; return; &#125; RCTJSCWrapper *jscWrapper = strongSelf-&gt;_jscWrapper; JSStringRef execJSString = jscWrapper-&gt;JSStringCreateWithUTF8CString(sourceCode.UTF8String); JSStringRef jsURL = jscWrapper-&gt;JSStringCreateWithUTF8CString(sourceCodeURL.UTF8String); jscWrapper-&gt;JSEvaluateScript(strongSelf-&gt;_context.context.JSGlobalContextRef, execJSString, NULL, jsURL, 0, NULL); jscWrapper-&gt;JSStringRelease(jsURL); jscWrapper-&gt;JSStringRelease(execJSString); &#125;;#endif &#125;];&#125; 4.生成模块配置表并写入JavaScript端 复习一下 nativeRequireModuleConfig 这个 Block，它可以接受 ModuleName 并且生成详细的模块信息，但在前文中我们没有提到 JavaScript 是如何知道 Objective-C 要暴露哪些类的(目前只是 Objective-C 自己知道)。 这一步的操作就是为了让 JavaScript 获取所有模块的名字 1234567891011121314- (NSString *)moduleConfig &#123; NSMutableArray&lt;NSArray *&gt; *config = [NSMutableArray new]; for (RCTModuleData *moduleData in _moduleDataByID) &#123; if (self.executorClass == [RCTJSCExecutor class]) &#123; [config addObject:@[moduleData.name]]; &#125; else &#123; [config addObject:RCTNullIfNil(moduleData.config)]; &#125; &#125; return RCTJSONStringify(@&#123; @\"remoteModuleConfig\": config, &#125;, NULL);&#125; 5.执行JavaScript代码 这一步也没什么技术难度可以，代码已经加载进了内存，该做的配置也已经完成，只要把 JavaScript 代码运行一遍即可。 运行代码时，第三步中所说的那些 Block 就会被执行，从而向 JavaScript 端写入配置信息。 至此，JavaScript 和 Objective-C 都具备了向对方交互的能力，准备工作也就全部完成了。 方法调用如前文所述，在 React Native 中，Objective-C 和 JavaScript 的交互都是通过传递 ModuleId、MethodId 和 Arguments 进行的。以下是分情况讨论 OC 调用 JavaScript也许你在其他文章中曾经多次听说 JavaScript 代码总是在一个单独的线程上面调用，它的实际含义是 Objective-C 会在单独的线程上运行 JavaScript 代码 12345678- (void)executeBlockOnJavaScriptQueue:(dispatch_block_t)block &#123; if ([NSThread currentThread] != _javaScriptThread) &#123; [self performSelector:@selector(executeBlockOnJavaScriptQueue:) onThread:_javaScriptThread withObject:block waitUntilDone:NO]; &#125; else &#123; block(); &#125;&#125; 调用JavaScript的核心代码如下 12345678910- (void)_executeJSCall:(NSString *)method arguments:(NSArray *)arguments callback:(RCTJavaScriptCallback)onComplete&#123; [self executeBlockOnJavaScriptQueue:^&#123; // 获取 contextJSRef、methodJSRef、moduleJSRef resultJSRef = JSObjectCallAsFunction(contextJSRef, (JSObjectRef)methodJSRef, (JSObjectRef)moduleJSRef, arguments.count, jsArgs, &amp;errorJSRef); objcValue = /*resultJSRef 转换成 Objective-C 类型*/ onComplete(objcValue, nil); &#125;];&#125; 需要注意的是，这个函数名是我们要调用 JavaScript 的中转函数名，比如 callFunctionReturnFlushedQueue。也就是说它的作用其实是处理参数，而非真正要调用的 JavaScript 函数。 在实际使用的时候，我们可以这样发起对 JavaScript 的调用： 12[_bridge.eventDispatcher sendAppEventWithName:@\"greeted\" body:@&#123; @\"name\": @\"nmae\"&#125;]; 这里的 Name 和 Body 参数分别表示要调用的 JavaScript 的函数名和参数。 JavaScript调用OC在调用 Objective-C 代码时，如前文所述，JavaScript 会解析出方法的 ModuleId、MethodId 和 Arguments 并放入到 MessageQueue 中，等待 Objective-C 主动拿走，或者超时后主动发送给 Objective-C。 Objective-C 负责处理调用的方法是 handleBuffer，它的参数是一个含有四个元素的数组，每个元素也都是一个数组，分别存放了 ModuleId、MethodId、Params，第四个元素目测用处不大。 函数内部在每一次方调用中调用 _handleRequestNumber:moduleID:methodID:params 方法，通过查找模块配置表找出要调用的方法，并通过 runtime 动态的调用： 演示JavaScript调用OC方法: 123456789101112131415161718//.h文件#import &lt;Foundation/Foundation.h&gt;#import \"RCTBridge.h\"#import \"RCTLog.h\"#import \"EncryptUtil.h\"#import \"RSA.h\"@interface CryptoExport : NSObject&lt;RCTBridgeModule&gt;@end//.m文件#import \"CryptoExport.h\"@implementation CryptoExportRCT_EXPORT_MODULE()//必须定义的宏RCT_EXPORT_METHOD(rsaEncryptValue:(NSString *)src withKey:(NSString *)rsaKey successCallback:(RCTResponseSenderBlock)successCallback)&#123; NSString *rsaValue = [RSA encryptString:src publicKey:rsaKey]; successCallback(@[rsaValue]);&#125;@end 每个oc的方法前必须加上 RCT_EXPORT_METHOD 宏，用来注册模块表。 在JavaScript中的调动如下 123NativeModules.CryptoExport.rsaEncryptValue(value, rsaKey,function (rsaValue) &#123; console.log(rsaValue)&#125;); React Native 更新机制之前我们说过，React是状态机，就是不停的去检查当前的状态，判断是否需要刷新。 调用this.setState123ReactClass.prototype.setState = function(newState) &#123; this._reactInternalInstance.receiveComponent(null, newState);&#125; 调用内部receiveComponent方法，这里在接受元素的时候主要分三种情况： 文本元素 基本元素 自定义元素 文本元素1234567891011121314151617ReactDOMTextComponent.prototype.receiveComponent(nextText, transaction) &#123; //跟以前保存的字符串比较 if (nextText !== this._currentElement) &#123; this._currentElement = nextText; var nextStringText = '' + nextText; if (nextStringText !== this._stringText) &#123; this._stringText = nextStringText; var commentNodes = this.getHostNode(); // 替换文本元素 DOMChildrenOperations.replaceDelimitedText( commentNodes[0], commentNodes[1], nextStringText ); &#125; &#125; &#125; 基本元素12345ReactDOMComponent.prototype.receiveComponent = function(nextElement, transaction, context) &#123; var prevElement = this._currentElement; this._currentElement = nextElement; this.updateComponent(transaction, prevElement, nextElement, context);&#125; updateComponent 方法12345678910111213ReactDOMComponent.prototype.updateComponent = function(transaction, prevElement, nextElement, context) &#123; // 略..... //需要单独的更新属性 this._updateDOMProperties(lastProps, nextProps, transaction, isCustomComponentTag); //再更新子节点 this._updateDOMChildren( lastProps, nextProps, transaction, context ); // ......&#125; 自定义元素123456789101112ReactCompositeComponent.prototype.receiveComponent = function(nextElement, transaction, nextContext) &#123; var prevElement = this._currentElement; var prevContext = this._context; this._pendingElement = null; this.updateComponent( transaction, prevElement, nextElement, prevContext, nextContext );&#125; updateComponent 方法123456789ReactCompositeComponent.prototype.updateComponent = function( transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext)&#123;//省略&#125; 调用内部 _performComponentUpdate 方法123456789101112131415161718192021222324252627282930313233343536ReactCompositeComponent.prototype._updateRenderedComponentWithNextElement = function() &#123; // 判定两个element需不需要更新 if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) &#123; // 如果需要更新，就继续调用子节点的receiveComponent的方法，传入新的element更新子节点。 ReactReconciler.receiveComponent( prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context) ); &#125; else &#123; // 卸载之前的子节点，安装新的子节点 var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance); ReactReconciler.unmountComponent( prevComponentInstance, safely, false /* skipLifecycle */ ); var nodeType = ReactNodeTypes.getType(nextRenderedElement); this._renderedNodeType = nodeType; var child = this._instantiateReactComponent( nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */ ); this._renderedComponent = child; var nextMarkup = ReactReconciler.mountComponent( child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID ); &#125; this._updateDOMChildren 方法内部调用diff算法 实现过程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283_updateChildren: function(nextNestedChildrenElements, transaction, context) &#123; var prevChildren = this._renderedChildren; var removedNodes = &#123;&#125;; var mountImages = []; // 获取新的子元素数组 var nextChildren = this._reconcilerUpdateChildren( prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context ); if (!nextChildren &amp;&amp; !prevChildren) &#123; return; &#125; var updates = null; var name; var nextIndex = 0; var lastIndex = 0; var nextMountIndex = 0; var lastPlacedNode = null; for (name in nextChildren) &#123; if (!nextChildren.hasOwnProperty(name)) &#123; continue; &#125; var prevChild = prevChildren &amp;&amp; prevChildren[name]; var nextChild = nextChildren[name]; if (prevChild === nextChild) &#123; // 同一个引用，说明是使用的同一个component,所以我们需要做移动的操作 // 移动已有的子节点 // NOTICE：这里根据nextIndex, lastIndex决定是否移动 updates = enqueue( updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex) ); // 更新lastIndex lastIndex = Math.max(prevChild._mountIndex, lastIndex); // 更新component的.mountIndex属性 prevChild._mountIndex = nextIndex; &#125; else &#123; if (prevChild) &#123; // 更新lastIndex lastIndex = Math.max(prevChild._mountIndex, lastIndex); &#125; // 添加新的子节点在指定的位置上 updates = enqueue( updates, this._mountChildAtIndex( nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context ) ); nextMountIndex++; &#125; // 更新nextIndex nextIndex++; lastPlacedNode = ReactReconciler.getHostNode(nextChild); &#125; // 移除掉不存在的旧子节点，和旧子节点和新子节点不同的旧子节点 for (name in removedNodes) &#123; if (removedNodes.hasOwnProperty(name)) &#123; updates = enqueue( updates, this._unmountChild(prevChildren[name], removedNodes[name]) ); &#125; &#125; &#125; 以下是针对 Demo 项目的通信原理解释 通信基本原理首先，我们来看一下在iOS中Native如何调用JS。从iOS7开始，系统进一步开放了WebCore SDK，提供JavaScript引擎库，使得我们能够直接与引擎交互拥有更多的控制权。其中，有两个最基础的概念： 12JSContext // JS代码的环境，一个JSContext是一个全局环境的实例JSValue // 包装了每一个可能的JS值：字符串、数字、数组、对象、方法等 通过这两个类，我们能够非常方便的实现Javascript与Native代码之间的交互，首先我们通过一个简单示例来观察Native如何调用Javascript代码： 🌰：Native -&gt; JavaScript 1234567891011121314// 头文件#import &lt;JavaScriptCore/JSContext.h&gt;#import &lt;JavaScriptCore/JSValue.h&gt;- (void)createJSContext &#123; JSContext *context = [[JSContext alloc] init]; [context evaluateScript:@\"var num = 5 + 5\"]; [context evaluateScript:@\"var names = ['Grace', 'Ada', 'Margaret']\"]; [context evaluateScript:@\"var triple = function(value) &#123; return value * 3 &#125;\"]; JSValue *tripleNum = [context evaluateScript:@\"triple(num)\"]; JSValue *tripleFunction = context[@\"triple\"]; JSValue *result = [tripleFunction callWithArguments:@[@5]]; // 打印结果 NSLog(@\"JSContext function \\ntripleNum:%@ \\nresult:%@\", tripleNum, result);&#125; 那么，JSContext如何访问我们本地客户端OC代码呢？答案是通过Blocks和JSExports协议两种方式。我们来看一个通过Blocks来实现JS访问本地代码的示例： 🌰：JavaScript -&gt; Native 1234567context[@\"testSay\"] = ^(NSString *input) &#123; NSMutableString *mutableString = [input mutableCopy]; CFStringTransform((__bridge CFMutableStringRef)mutableString, NULL, kCFStringTransformToLatin, NO); CFStringTransform((__bridge CFMutableStringRef)mutableString, NULL, kCFStringTransformStripCombiningMarks, NO); return mutableString;&#125;;NSLog(@\"%@\", [context evaluateScript:@\"testSay('hello world')\"]); 关于JSCore库的更多学习介绍，请看JavaScriptCore。 Java​Script​Core 相关介绍 http://nshipster.cn/javascriptcore/ React Native 初始化过程解析在了解React-Native中JS-&gt;Native的具体调用之前，我们先做一些准备工作，看看框架中Native app的启动过程。打开FB提供的AwesomeProject定位到appDelegate的didFinishLaunchingWithOptions方法中： 12345678910111213// 指定JS页面文件位置jsCodeLocation = [NSURL URLWithString:@\"http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=false\"];// 创建React Native视图对象RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocationmoduleName:@\"ReactExperiment\"initialProperties:nillaunchOptions:launchOptions];self.window = [[UIWindow alloc] initWithFrame:[UIScreen mainScreen].bounds];// 创建VC，并且把React Native Root View赋值给VCUIViewController *rootViewController = [UIViewController new];rootViewController.view = rootView;self.window.rootViewController = rootViewController;[self.window makeKeyAndVisible]; 可以看到使用集成非常简单，那么RCTRootView到底做了哪些事情最后渲染将视图呈现在用户面前呢？我们继续跟着代码往下分析就会看到我们今天的主角RCTBridge。 🥟：RCTBridge 123456789- (instancetype)initWithBundleURL:(NSURL *)bundleURLmoduleName:(NSString *)moduleNameinitialProperties:(NSDictionary *)initialPropertieslaunchOptions:(NSDictionary *)launchOptions &#123; RCTBridge *bridge = [[RCTBridge alloc] initWithBundleURL:bundleURL moduleProvider:nil launchOptions:launchOptions]; return [self initWithBridge:bridge moduleName:moduleName initialProperties:initialProperties];&#125; RCTBridge是Naitive端的bridge，起着桥接两端的作用 。事实上具体的实现放置在RCTBatchedBridge中，在它的start方法中执行了一系列重要的初始化工作。这部分也是ReactNative SDK的精髓所在，基于GCD实现一套异步初始化组件框架。大致的工作流程如下图所示： Load JS Source Code（并行）加载页面源码阶段。该阶段主要负责从指定的位置（网络或者本地）加载React Native页面代码。与initModules各模块初始化过程并行执行，通过GCD分组队列保证两个阶段完成后才会加载解析页面源码。 Init Module（同步）初始化加载React Native模块。该阶段会将所有注册的Native模块类整理保存到一个以Module Id为下标的数组对象中（同时还会保存一个以Module Name为Key的Dictionary，用于做索引方便后续的模块查找）。 整个模块的基础初始化和注册过程在系统Load Class阶段就会完成。React Native对模块注册的实现还是比较巧妙、方便，只需要对目标类添加相应的宏即可。 1.注册模块。实现RCTBridgeModule协议，并且在响应的Implemention文件中添加RCT_EXPORT_MODULE宏，该宏会为所在类自动添加一个+load方法，调用RCTBridge的RCTRegisterModule实现在Load Class阶段就完成模块注册工作。 2.注册函数。待注册函数所在的类必须是已注册模块，在需要注册的函数前添加RCT_EXPORT_MODULE宏即可。 当然这里需要注意的问题是模块初始化是一个同步任务，它必须被同步加载，所以当模块较多时势必会带来高延迟的问题，也是在新的版本中SDK将Module Method改为Lazy Load的原因之一。 Setup JS Executor（并行）初始化JS引擎。React Native在0.18中已经很好的抽象了原来了JSExecutor，目前实现了RCTWebSocketExecutor和RCTJSCExecutor两个脚本引擎的封装，前者用于通过WebSocket链接到Chrome调试，后者则是内置默认引擎直接通过IOS SDK JSContext来实现相关的逻辑。 另外，在本阶段还会通过block hook的方式注册部分核心API 1.nativeRequireModuleConfig：用于在JS端获取对应的Native Module，在0.14后的版本React Native已经对初始化模块做了部分优化，把关于Native Module Method部分的加载工作放置在requireModuleConfig时才做 2.nativeLoggingHook：调用Native写入日志 3.nativeFlushQueueImmediate：手动触发执行当前Native Call队列中所有的Native处理请求 4.nativePerformanceNow：用于性能统计，获取当前Native的绝对时间（毫秒） 对于模块类中想要声明的方法，需要添加RCT_EXPORT_METHOD宏。它会给方法名添加” rct_export “前缀。 🌰：React 调用 Native 的 SVProgressHUD 提示窗 在 Native 中声明方法1234RCT_EXPORT_METHOD(calliOSActionWithOneParams:(NSString *)name) &#123; [SVProgressHUD setDefaultMaskType:SVProgressHUDMaskTypeBlack]; [SVProgressHUD showSuccessWithStatus:[NSString stringWithFormat:@\"参数：%@\",name]];&#125; 在 React 中调用 calliOSActionWithOneParams 方法123456&lt;TouchableOpacity style=&#123;styles.calltonative&#125; onPress=&#123;()=&gt;&#123; RNCalliOSAction.calliOSActionWithOneParams('hello'); &#125;&#125;&gt; &lt;Text&gt;点击调用 Native 方法, 并传递一个参数&lt;/Text&gt;&lt;/TouchableOpacity&gt; Module Config（并行）这步将第2步中的Native模块类转换成Json，保存为remoteModuleConfig。注意在这里获取到的列表并非含有完整模块信息，而仅仅是一个Module List而已。 1234567891011121314151617&#123;\"remoteModuleConfig\":[[\"HTSimpleAPI\", // module],[\"RCTViewManager\",],[\"HTTestView\",],[\"RCTAccessibilityManager\",],...],&#125; JS Source Code代码分析JS的主入口index.ios.js在我们看来只有短短数十行，然而这不是最终执行的代码。React-Native页面源码需要通过Transform Server转换处理，并把转化后的模块一起合并为一个bundle.js，这个过程称为buildBundle。转换后的index.ios.bundle才是最终可被Javascript引擎直接解释运行的代码。下面我们按照主程序的逻辑来分析源码几个核心模块实现原理。 在React Server中需要查看Bundle的模块映射关系可以直接访问：http://localhost:8081/index.ios.bundle.map，查看相关依赖和Bundle的缓存则可以访问： http://localhost:8081/debug 1.BatchedBridge 在上一部分我们知道，Native完成模块初始化后会通过Inject Json Config将配置信息同步至JS里中的全局变量__fbBatchedBridgeConfig，打开BatchedBridge.js我们可以看到如下代码。 123456789__d('BatchedBridge',function(global, require, module, exports) &#123; 'use strict';var MessageQueue=require('MessageQueue');var BatchedBridge=new MessageQueue(__fbBatchedBridgeConfig.remoteModuleConfig,__fbBatchedBridgeConfig.localModulesConfig);//......Object.defineProperty(global,'__fbBatchedBridge',&#123;value:BatchedBridge&#125;);module.exports = BatchedBridge;&#125;); 对于这段代码，我们可以得出以下几个结论： 1.在JS端也存在一个bridge模块BatchedBridge，也是与Native建立双向通信的关键所在 2.BatchedBridge是一个MessageQueue实例，它在创建时传入了__fbBatchedBridgeConfig值保存Native端支持的模块列表配置 BatchedBridge在创建时将自己写入全局变量fbBatchedBridge上，这样Native可以通过JSContext[@”fbBatchedBridge”]访问到JS bridge对象。 2.MessageQueue 接着我们继续看MessageQueue，它在整个通讯链路的机制上面有着重要作用，首先我们来观察一下它的构造函数。 1234567891011121314constructor(remoteModules, localModules) &#123;this.RemoteModules = &#123;&#125;;this._callableModules = &#123;&#125;;this._queue = [[], [], [], 0];this._moduleTable = &#123;&#125;;this._methodTable = &#123;&#125;;this._callbacks = [];this._callbackID = 0;this._callID = 0;//......let modulesConfig = this._genModulesConfig(remoteModules);this._genModules(modulesConfig);//......&#125; 从构造函数，我们大致能了解MessageQueue的几个信息： 1.RemoteModules属性，用于保存Native端模块配置 2.Callbacks属性缓存js的回调方法 3.Queue事件队列用于处理各类事件等 在构造函数中，解析Native传入的remoteModules JSON，转换成JS对象 3.Config Modules 根据上一步MessageQueue的逻辑，继续往下跟踪_genModules函数，可以看到在MessageQueue已经对Native注入的Module Config做了一次预处理，如果debug模式可以看到大致的数据结构会转换成如下表中所示结构（其中HTSimepleAPI是一个自定义模块）。 1234config = [\"HTSimpleAPI\", Array[1]], moduleID = 0config = null, moduleID = 1config = null, moduleID = 2config = [\"RCTAccessibilityManager\", Array[3]], moduleID = 3 至于这样的预处理有什么作用，我们继续往下分析，后面再来总结。 4.Lazily Config Methods 对于NativeModule，它们在上一步之后只有一个包含Module Name等简单信息的Module List的对象，只有在实际调用了该模块之后才会加载该模块的具体信息（比如暴露的API等）。 12345678910111213141516const NativeModules = &#123;&#125;;Object.keys(RemoteModules).forEach((moduleName) =&gt; &#123;Object.defineProperty(NativeModules, moduleName, &#123;enumerable: true,get: () =&gt; &#123;let module = RemoteModules[moduleName];if (module &amp;&amp; typeof module.moduleID === 'number' &amp;&amp; global.nativeRequireModuleConfig) &#123;const json = global.nativeRequireModuleConfig(moduleName);const config = json &amp;&amp; JSON.parse(json);module = config &amp;&amp; BatchedBridge.processModuleConfig(config, module.moduleID);RemoteModules[moduleName] = module;&#125;return module;&#125;,&#125;);&#125;); 这段代码定义了一个全局模块NativeModules，遍历之前取到的remoteModules，将每一个module在NativeModules对象上扩展了一个getter方法，该方法中通过nativeRequireModuleConfig进一步加载模块的详细信息，通过processModuleConfig对模块信息进行预处理。进一步分析代码就可以发现这个方法其实是Native中定义的全局JS Block（nativeRequireModuleConfig）。 接下来我们继续看processModuleConfig中具体的代码逻辑，如下表所示： 123456789101112processModuleConfig(config, moduleID) &#123; const module = this._genModule(config, moduleID); return module;&#125;_genMethod(module, method, type) &#123;//...... fn = function(...args) &#123; return self.__nativeCall(module, method, args, onFail, onSucc);&#125;;//......return fn;&#125; processModuleConfig方法的主要工作是生成methods配置，并对每一个method封装了一个闭包fn，当调用method时，会转换成成调用self.__nativeCall(moduleID, methodID, args, onFail, onSucc)方法 预处理完成后，在JavaScript环境中的Moudle Config信息才算完整，包含Module Name、Native Method等信息，具体信息如下所示。 12345678config = [\"HTSimpleAPI\", Array[1]], moduleID = 0methodName = \"test\", methodID = 0config = null, moduleID = 1config = null, moduleID = 2config = [\"RCTAccessibilityManager\", Array[3]], moduleID = 3methodName = \"setAccessibilityContentSizeMultipliers\", methodID = 0methodName = \"getMultiplier\", methodID = 1methodName = \"getCurrentVoiceOverState\", methodID = 2 还记得第二部分第5步中Native端生成的模块配置表吗？结合它的结构，我们可以得知：对于Module&amp;Method，在Native和JS端都以数组的形式存放，数组下标即为它们的ModuleID和MethodID。 5.__nativeCall 分析完Bridge部分的映射关系以及模块加载，那么我们再来看看最终调用Native代码是如何实现的。当JS调用module.method时，其实调用了self.nativeCall(module, method, args, onFail, onSucc)，对于nativeCall方法： 1234567891011121314__nativeCall(module, method, params, onFail, onSucc) &#123; if (onFail || onSucc) &#123; ...... onFail &amp;&amp; params.push(this._callbackID); this._callbacks[this._callbackID++] = onFail; onSucc &amp;&amp; params.push(this._callbackID); this._callbacks[this._callbackID++] = onSucc; &#125;this._queue[MODULE_IDS].push(module);this._queue[METHOD_IDS].push(method);this._queue[PARAMS].push(params);global.nativeFlushQueueImmediate(this._queue);......&#125; 这段代码为每个method创建了一个闭包fn，在__nativeCall方法中，并且在这里做了两件重要的工作： 1.把onFail和onSucc缓存到_callbacks中，同时把callbackID添加到params 2.把moduleID, methodID, params放入队列中，回调Native代码. __nativeCall如何做到回调Native代码呢？看第二部分第3步，在初始化JS引擎JSExecutor Setup时，Native端注册一个全局block回调nativeFlushedQueueImmediate，nativeCall在处理完毕后，通过该回调把队列作为返回值传给Native。nativeFlushedQueueImmediate的实现如下所示。 1234567[self addSynchronousHookWithName:@\"nativeFlushQueueImmediate\" usingBlock:^(NSArray *calls)&#123;RCTJSCExecutor *strongSelf = weakSelf; if (!strongSelf.valid || !calls) &#123; return; &#125;[strongSelf-&gt;_bridge handleBuffer:calls batchEnded:NO];&#125;]; 这里的handleBuffer就是Native端解析JS的模块调用最后通过NSInvocation机制调用Native代码对应的逻辑。有兴趣的朋友继续跟踪handleBuffer代码会发现，他的实现和React在JS端定义的MessageQueue有惊人的相似之处。 6.Call JS function &amp; Callbacks 最后，我们回过头来看看Native端是如何调用JS端的相关逻辑的，这部分我们需要回到MessageQueue.js代码中来，可以看到MessageQueue暴露了3个核心方法：’invokeCallbackAndReturnFlushedQueue’、’callFunctionReturnFlushedQueue’、’flushedQueue’。 1234567891011121314151617181920212223// 将API暴露到全局作用域中['invokeCallbackAndReturnFlushedQueue','callFunctionReturnFlushedQueue','flushedQueue',].forEach((fn) =&gt; this[fn] = this[fn].bind(this));…// 声明带有返回值的函数callFunctionReturnFlushedQueue(module, method, args) &#123;guard(() =&gt; &#123;Cthis.__callFunction(module, method, args);this.__callImmediates();&#125;);return this.flushedQueue();&#125;// 声明带有Callback的函数invokeCallbackAndReturnFlushedQueue(cbID, args) &#123;guard(() =&gt; &#123;this.__invokeCallback(cbID, args);this.__callImmediates();&#125;);return this.flushedQueue();&#125; callFunctionReturnFlushedQueue用于实现Native调用带有返回值的JS端函数（这里的返回值也是通过Queue来模拟）；invokeCallbackAndReturnFlushedQueue用于实现Native调用带有Call的JS端函数（可以将Native的Callback作为JS端函数的入参，JS端执行完后调用Native的Callback）。 对于callFunctionReturnFlushedQueue方法，它最终调用的是__callFunction： 123456__callFunction(module, method, args) &#123;......var moduleMethods = this._callableModules[module];......moduleMethods[method].apply(moduleMethods, args);&#125; 可以看到，此处会根据Native传入的module, method，调用JS端相应的模块并传入参数列表args.同时我们又可以获得对于MessageQueue的另一条推测，_callableModules用来存放JS端暴露给Native的模块，进一步分析我们可以发现SDK中正是通过registerCallableModules方法注册JS端暴露API模块。 对于JS bridge提供的调用回调方法invokeCallbackAndReturnFlushedQueue，原理上和callFunction差不多，不再细说。 JS Native 通信原理1.Native-&gt;JS 综上所述，在JS端提供callFunctionReturnFlushedQueue，Native bridge调用JS端方法时，应该使用这个方法。查看Native代码实现可知，RCTBridge封装了enqueueJSCall方法调用JS，梳理Native-&gt;JS的整体交互流程如下图所示。 之前已经论述过，如果在NATIVE端需要自定义模块提供给JS端使用那么该类需要实现RCTBridgeModule协议 。 此外，React-Native提供了另一种基于通知的方式，通过RCTEventDispatcher发送消息通知 。eventDispatcher作为Native Bridge的属性，封装了sendEventWithName:body:方法。使用时，Native中类同样需要实现RCTBridgeModule协议，通过self.bridge发送通知，JS端对应事件的EventEmitter添加监听处理调用。 查看sendEvent方法的代码可以发现，这种方式本质上还是调用enqueueJSCall方法。官方推荐我们使用通知的方式来实现 Native-&gt;JS，这样可以减少模块初始化加载解析的时间。 2.JS-&gt;Native 最后，我们来看一下JS如何调用Native。答案是JS不会主动传递数据给Native，也不能直接调用Native（一种情况除外，在入口直接通过NativeModules调用API），只有在Native调用JS时才会通过返回值触发调用。因为Native是基于事件响应机制的，比如触摸事件、启动事件、定时器事件、回调事件等。 当事件发生时，Native会调用JS相应模块处理，完毕后再通过返回值把队列传递给Native执行对应的代码。 如上图所示，整个调用过程可以归纳为： 1.JS把需要Module, Method, args(CallbackID)保存在队列中， 作为返回值通过blocks回调Native 2.Native调用相应模块方法，完成 3.Native通过CallbackID调用JS回调 总结React Native的通讯基础建立在传统的JS Bridge之上，不过对于Bridge处理的MessageQueue机制、模块定义、加载机制上的巧妙处理指的借鉴。对于上述的整个原理解析可以概括为以下四个部分： 1.在启动阶段，初始化JS引擎，生成Native端模块配置表存于两端，其中模块配置是同步取得，而各模块的方法配置在该方法被真正调用时懒加载。 2.Native和JS端分别有一个bridge，发生调用时，调用端bridge查找模块配置表将调用转换成{moduleID, methodID, args(callbackID)}，处理端通过同一份模块配置表转换为实际的方法实现。 3.Native-&gt;JS，原理上使用JSCore从Native执行JS代码，React-Native在此基础上给我们提供了通知发送的执行方式。 4.JS-&gt;Native，原理上JS并不主动调用Native，而是把方法和参数(回调)缓存到队列中，在Native事件触发并访问JS后，通过blocks回调Native。 以上原理解析文章来源：http://i.dotidea.cn/2016/05/react-native-communication-principle-for-ios/、https://blog.csdn.net/passionhe/article/details/52498061、https://blog.csdn.net/xiangzhihong8/article/details/54425807","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS Principle：Block","slug":"iOS Principle Block","date":"2018-06-10T13:56:27.000Z","updated":"2018-11-18T05:44:25.499Z","comments":true,"path":"2018/06/10/iOS Principle Block/","link":"","permalink":"https://reversescale.github.io/2018/06/10/iOS Principle Block/","excerpt":"Block 其实就是 C 语言的扩充功能，实现了对 C 的闭包实现，一个带有局部变量的匿名函数~","text":"Block 其实就是 C 语言的扩充功能，实现了对 C 的闭包实现，一个带有局部变量的匿名函数~ 👨🏻‍💻 Github Demo 方便记忆： Block 实现了对C的闭包实现，一个带有局部变量的匿名函数 源码结构分析 本体部分：block实际的结构体部分 成员变量：impl和Desc 结构体的构造函数：__main_block_impl_0 捕获外部变量 局部变量作为Block结构体的成员变量追加到了__main_block_impl_0 根据传递给构造函数的参数对由局部变量追加的成员变量进行初始化 __main_block_func_0中进行了变量获取_cself-&gt;ch(变量的值-深拷贝) 改变Block里的值 c方法：静态变量、静态全局变量、全局变量 __block修饰符：变成了结构体实例，初始化_main_block_impl_0的时候追加的是_block生成的结构体指针 三种Block本体 NSConcreteStackBlock：在局部定义的（栈） NSConcreteGlobalBlock：在全局中定义的（数据区域）-不存在对局部变量的捕获 NSConcreteMallocBlock：分配在堆中-Block从栈上复制到堆上的方法 声明一个Block:使用场景一：返回值 (^名称) (参数列表) = ^(参数列表) {}; 123int (^name)(int, int) = ^(int a, int b) &#123; return (a+b);&#125;; 使用场景二：作为一个函数的参数： 12345678910- (void)testBlock:(NSString *(返回类型) (^)(int a))s (block名字） &#123; NSString *a = s(1);&#125;&#123; [self testBlock:^NSString *(int a) &#123; a = 5; return @\"1\"; &#125;];&#125; Demo 中文件对照 mainTestBlock.cpp -&gt; 基本的block转译 mainTestBlockValue.cpp -&gt; block捕获外部变量 mainTestBlockValueC.cpp -&gt; 通过C语言变量访问值 mainTestBlockValueValueBlock.cpp -&gt; 通过__block变量访问值 从底层分析Block的实现先从最简单的看起1234void (^block)(void) = ^(void) &#123; &#125;;block(); 使用 Clang（LLVM）转化为 C++ 的实现1clang -rewrite-objc 文件名 注意：由于 ViewController 中使用 UIKit 库，编译时会出现找不到文件的情况。 转化后的代码如下：12345678910111213141516171819202122232425262728struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr; &#125;; struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125; &#125;; static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; printf(\"aaa\\n\");&#125; static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; &#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;; int main() &#123; void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); return 0; &#125; 源码结构分析1.block实际的结构体部分（本体）12345678910struct __main_block_impl_0 &#123; struct __block_impl impl; // 结构体 impl，见下 2 struct __main_block_desc_0* Desc; // 结构体 Desc，见下 3 __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; // 构造函数，见下 4 impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125; &#125;; 2.再看看第一个成员变量impl123456struct __block_impl &#123; void *isa; // struct 中，首地址是 *isa，证明 block 是 objc 中的对象 int Flags; // 标记 int Reserved; // 标记 void *FuncPtr; // 函数指针，block所需要执行的代码段&#125;; 他的第一个属性也是一个结构__block_impl，而第一个参数也是一个isa的指针。 在运行时，NSObject和block的isa指针都是指向对象的一个8字节。NSObject及派生类对象的isa指向Class的prototype，而block的isa指向了_NSConcreteStackBlock这个指针。就是说当一个block被声明的时候他都是一个_NSConcreteStackBlock类的对象。 3.第二个成员变量Desc1234static struct __main_block_desc_0 &#123; size_t reserved; // 版本升级所需的区域 size_t Block_size; // Block的占用空间大小&#125; 4.第三个就是这个结构体的构造函数（可以理解为对象的初始化方法）123456__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int flags=0) &#123; impl.isa = &amp;_NSConcreteStackBlock; // block 的本体类型，后面专门讲解 impl.Flags = flags; impl.FuncPtr = fp; // void *fp的指针赋值给了FuncPtr指针 Desc = desc; // desc 结构体的指针传入的初始化&#125; 以下是源码调用分析 5.现在来看看Main函数中调用的基本转换（初始化转换）1void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA)); 看起来这个函数好吓人啊，没事，咱们把类型都去了，而且分开两步来写12345/* 调用结构体函数初始化 struct __main_block_impl_0 impBlock = __main_block_impl_0(__main_block_func_0,&amp;__main_block_desc_0_DATA); /* 赋值给该结构体类型指针变量 struct __main_block_impl_0 *block = &amp;impBlock; 把栈上生成的main_block_impl_0的结构体实例的指针，赋值给main_block_impl_0结构体指针类型的变量block __main_block_func_0就是转换成的函数指针，这样void (*block)(void) = ^{}这句简单的代码最终就是上面的结构体初始化函数的内部实现逻辑 6.再来细看下初始化函数内部的实现__block_main_impl_01__main_block_impl_0(__main_block_func_0,&amp;__main_block_desc_0_DATA); 第一个参数是由Block块语法转换的正真内部函数指针，第二个参数就是作为静态全局变量初始化__main_block_desc_0的结构体实例指针，初始化如下1__main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;; 最终，初始化内部进行赋值12345isa = &amp;_NSConcreteStackBlockFlags = 0Reversed = 0FuncPtr = __main_blcok_func_0 // 就是Block块代码转换成的C语言函数指针Desc = &amp;__ main_block_desc_0_DATA 7.最终 block() 调用的内部实现1((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); 老规矩 ，去掉类型就是1(*block-&gt;imp.FuncPtr)(block); 打印换行12static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; printf(\"aaa\\n\");&#125; 没错，最后就是直接调用函数指针进行最终的调用，由上面所描述的，FuncPtr就是由__main_block_func_0的函数指针所赋值的指针，而且可以看出，这个函数的参数正是指向block本身结构体实例，block作为参数进行了传递 综上所述，block的实质，就是一个对象，包含了一个指向函数首地址的指针，和一些与自己相关的成员变量。 Block 访问外部变量是怎么回事123456789101112int main()&#123; int a = 100; int b = 200; const char *ch = \"b = %d\\n\"; void (^block)(void) = ^&#123; &#125;; b = 300; ch = \"value had changed.b = %d\\n\"; block(); return 0; &#125; Clang 转化后代码12345678910111213141516171819202122232425262728293031323334353637struct __block_impl &#123; void *isa; int Flags; int Reserved; void *FuncPtr;&#125;;struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; const char *ch; int b; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, const char *_ch, int _b, int flags=0) : ch(_ch), b(_b) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;;static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; const char *ch = __cself-&gt;ch; // bound by copy int b = __cself-&gt;b; // bound by copy printf(ch,b);&#125;static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size;&#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;;int main()&#123; int a = 100; int b = 200; const char *ch = \"b = %d\\n\"; void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, ch, b)); b = 300; ch = \"value had changed.b = %d\\n\"; ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); return 0;&#125; 1.首先看看Block的内部结构本尊和没有截获的区别123456789101112struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; const char *ch; int b; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, const char *_ch, int _b, int flags=0) : ch(_ch), b(_b) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125;&#125;; 根据main函数里面的Block语法，这里把Block块表达式里面的局部变量作为了这个Block结构体的成员变量追加到了__main_block_impl_0的结构体中 值得注意的是： 结构体内声明的成员变量类型与局部变量类型完全相同 语法中没有使用的局部变量（例如咱们这里的a变量）不会被追加 细节需要注意，这里截获的ch是不可修改的，而且捕捉的b只是截获了该局部变量的值而已（下面在将如何截获指针） 2.再来看看该结构体实例化的构造函数以及调用和没有截获的区别1234567__main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, const charchar *_ch, int _b, int flags=0) : ch(_ch), b(_b) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125; void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, ch, b)); 根据传递给构造函数的参数对由局部变量追加的成员变量进行初始化。（这里传递的参数仅仅只是ch和b的值而已） 理解为把Block语法块里面截获的局部变量对__main_block_impl_0的成员追加并且传递赋值，如：123456impl.isa = &amp;_NSConcreteStackBlock;impl.Flags = 0;impl.FuncPtr = __main_block_func_0;Desc = &amp;__main_block_desc_0_DATA;ch = \"b=%d\\n\";b = 200; 由此可以看出，__main_block_impl_0的结构体（即Block）对自动变量进行了截获 3.再来看看最终调用Block的时候和没有截获的区别123456((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; const charchar *ch = __cself-&gt;ch; // bound by copy int b = __cself-&gt;b; // bound by copy printf(ch,b); &#125; 可以看出block()这句代码转换的调用方式没有任何变化还是转换为一下这句话，而且把本身结构体作为参数进行了传递1(*block-impl.FuncPtr)(block) 现在注意看main_block_func_0这个C语言的函数，和之前相比这里对传递过来的block结构体参数进行了变量获取cself-&gt;ch 和 __cself-&gt;b（这两个变量已经在Block表达式之前进行了声明定义），并最终打印出来 但是，Block中所捕获的变量就犹如“带有局部变量值的匿名函数”所说，仅仅截获局部变量的值而已，如果在截获的Block里面重写局部变量也不会改变原先所截获的局部变量 block 引用外部对象时候，不是简单的指针引用（浅复制），而是一种重建（深复制）方式（括号内外分别对于基本数据类型和对象分别描述） 所以如果在 block 中对外部对象进行修改，无论是值修改还是指针修改，自然是没有任何效果 例如：12int a = 0；void (^block)(void) = ^&#123;a = 1&#125;; 这样写直接就编译出错了！！！ 可以直接看__block_main_block_impl_0的实现上，并不能改写其捕获变量的值，因此直接报错了 综上所述，所谓的“截获自动变量”，无非就是在执行Block语法的时候，Block语法所用到的局部变量值被保存到Block的结构体实例当中（即所谓的Block本体） 要在 Block 中改变里面的值第一种方法：运用C语言中的变量 静态变量 静态全局变量 全局变量 1234567891011int global_val = 1; // 全局变量 static int static_global_val = 2; // 静态全局 int main()&#123; static int static_val = 3; // 静态局部 void (^block)(void) = ^&#123; global_val *= 1; static_global_val *= 2; static_val *= 3; &#125;; block(); &#125; 这里全局和静态全局问题不大，出了作用于照样能访问，但是静态局部的话如果去掉Static按上面那种写法，就直接报错了，原因就是实现上不能改变捕获的局部变量的值。 没错，应该能想到了，能改变的情况就是直接让Block截获局部变量的指针，看Clang的源码12345678910111213141516171819202122232425262728293031int global_val = 1; static int static_global_val = 2; struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; intint *static_val; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, intint *_static_val, int flags=0) : static_val(_static_val) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125; &#125;; static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; intint *static_val = __cself-&gt;static_val; // bound by copy global_val *= 1; static_global_val *= 2; (*static_val) *= 3; &#125; static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; &#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0)&#125;; int main()&#123; static int static_val = 3; void (*block)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, &amp;static_val)); ((void (*)(__block_impl *))((__block_impl *)block)-&gt;FuncPtr)((__block_impl *)block); printf(\"%d\\n\",global_val); printf(\"%d\\n\",static_global_val); printf(\"%d\\n\",static_val); &#125; 很简单就能看出区别了 在__main_block_impl_0这个结构体中的追加的成员变量变成了int *_static_val指针了 在结构体实例化函数中__main_block_impl_0参数也变为了&amp;static_val地址了 123456static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; intint *static_val = __cself-&gt;static_val; // bound by copy global_val *= 1; static_global_val *= 2; (*static_val) *= 3; &#125; 根据Block语法转换而来的C静态函数，使用static_val的指针进行访问，上面参数可以看出，初始化的时候将静态变量的static_val指针传递给__main_block_impl_0结构体进行追加成员变量初始化并保存，这样做也是对超出作用于使用变量的最简单的方法 第二种方法：就是大家所熟知的__block修饰符的使用12__block int a = 0;void (^block)(void) = ^&#123;a = 1&#125;; Clang 转化后代码1234567891011121314151617181920212223242526272829303132333435363738394041struct __Block_byref_a_0 &#123; void *__isa; __Block_byref_a_0 *__forwarding; int __flags; int __size; int a; &#125;; struct __main_block_impl_0 &#123; struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_a_0 *a; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_a_0 *_a, int flags=0) : a(_a-&gt;__forwarding) &#123; impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; &#125; &#125;; static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref (a-&gt;__forwarding-&gt;a) = 1;&#125; static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) &#123; _Block_object_assign((void*)&amp;dst-&gt;a, (void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125; static void __main_block_dispose_0(struct __main_block_impl_0*src) &#123; _Block_object_dispose((void*)src-&gt;a, 8/*BLOCK_FIELD_IS_BYREF*/);&#125; static struct __main_block_desc_0 &#123; size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*); &#125; __main_block_desc_0_DATA = &#123; 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0&#125;; int main()&#123; __attribute__((__blocks__(byref))) __Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a, 0, sizeof(__Block_byref_a_0), 0&#125;; void(*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344)); return 0; &#125; 代码多了不少，分解一下1__block int a = 0； Clang 的代码如下1__Block_byref_a_0 a = &#123;(void*)0,(__Block_byref_a_0 *)&amp;a,0,sizeof(__Block_byref_a_0),0&#125;; 这货竟然加了_block变成了结构体实例，在栈上生成了__block_byref_a_0的结构体实例，a变量初始化为0，这个值也出现在了这个结构体成员变量变量中，意味着该结构体持有相当于原局部变量的成员变量 12345678struct __Block_byref_a_0 &#123; *__isa; __Block_byref_a_0 *__forwarding; int __flags; int __size; int a; &#125;; 这个初始化的原结构，里面的最后一个int a就是原局部变量的成员变量 1void (^block)(void) = ^&#123;a = 1&#125;; 分解如下 1void(*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_a_0 *)&amp;a, 570425344)); 还是调用main_block_impl_0的初始化结构体，由于int a加了block修饰符，那么这个初始化函数传递的不再是&amp;a的地址，而是换成__Block_byref_a_0这个结构体实例的指针进行传递（该结构体其实也是个对象，最后的属性放着需要截获的局部变量） 这里的__main_block_func_0对应的block块函数转换为C 1234static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref (a-&gt;__forwarding-&gt;a) = 1;&#125; 看了两个方案，第一个用C语言的静态变量来解决，那么直接操作静态变量的指针就完事了，但是block要比这个真的复杂多了。Block的结构体实例持有指向block变量的 __Block_byref_a_0结构体实例的指针。 Block_byref_a_0这个结构体实例的成员变量forwarding持有指向该结构体实例自身的指针。通过__forwarding访问成员变量a。 另外提一点，block内部的Block_byhef_val_0这个也是独立的结构体实例，不属于main_blocl_impl_0结构体中，这样方便了在多个block中都能访问block变量。 小结一下，不然太乱： 1.普通的局部变量被Block截获只是单纯的截获其值，并追加到__main_block_impl_0结构体中（无法修改重写） 2.要允许Block修改值有两个方法，第一个就是用C语言的变量，代表就是静态局部变量，第二个就是__block修饰符 3.block修饰的变量，其实这就是变成了个对象结构体Block_byref_val_0,初始化main_block_impl_0的时候追加的是block生成的结构体指针,例如__block int a = 0;这个int不在是普通的数据类型，而是在标识符的引用下变成了对象 1234567struct __Block_byref_a_0 &#123; void *__isa; __Block_byref_a_0 *__forwarding; int __flags; int __size; int a; &#125;; 而int的值就存储在这个对象的一个字段 a中，而Block截获的就是这个结构体对象的指针，可以随意修改结构体内部a的值 4.最终在main_block_func_0函数中调用block结构体指针的forwarding指针（这一节指向自己，后面会变）的成员变量a来进行重新赋值 5.其实__block这方法生成的源码，能大致看出来这其实类似OC里面对象的retain和release一系列操作 三种 Block 本体到这个阶段，我们用C的结构编译的代码以及源码能看到Block结构体内部的isa指针是指向_NSConcreteStackBlock的，其实这只是其中的一种，分别还有_NSContreteGlobalBlock 和 _NSContreteMallocBlock,可以根据命名的后缀看出来StackBlock是设置在栈上的，GlobalBlock就类似全局变量，设置在程序的数据区域（.data区域），那么最重要的也是我们写OC代码的时候根本不关注的一种类型NSContreteMallocBlock，没错，他就是和对象一样分类内存块(堆)中。 12345&#123; NSConcreteGlobalBlock; // 在全局中定义的（数据区域） NSConcreteStackBlock; // 在局部定义的（栈） NSConcreteMallocBlock; // 分配在堆中&#125; NSConcreteGlobalBlock 全局定义上面我们说的都是 NSConcreteStackBlock 在局部定义的（栈），下面我们来看看 NSConcreteGlobalBlock 你可以把它理解为全局变量，反正存储在.data区域的，最直接得写法是这样的 123void (^block)(void) = ^&#123;&#125;; int main()&#123;&#125; Clang 转换过后的源码指针impl.isa = &amp;_NSContreteGlobalBlock类型的 由于在使用全局变量的地方不能使用局部变量，这么说来就根本不存在对局部变量的捕获。那么这个Block的结构体实例的内容压根不会再进行追加成员变量，所以不会依赖于执行状态，所以整个程序运行只有一个实例。因此将Block使用的结构体实例设置在与全局变量相同的数据区域即可。（把它理解为单纯的全局变量就好了，而且不会有任何值的捕获） 存在的两种案例 全局变量的地方，用这种Block语法时，如上面所示 Block语法中表达式不截获任何局部变量时，这个稍后Demo介绍，也很简单 NSContreteMallocBlock 堆定义配置在全局的GlobalBlock可以出了作用域还是能继续访问，但是在栈上的StackBlock就废弃了，因此为了出了作用域能继续使用，Blocks提供了把Block和block这两个东西从栈上复制到堆上的方法来解决这个问题。而_forwarding其实既可以指向自己，也可以指向复制后的自己，也就是说有了这个指针的存在，无论block变量配置在堆上还是栈上都能够正确的访问__block变量 一种作为返回值返回的情况1234typedef void(^block)(void); block func (int a) &#123; return ^&#123;&#125;; &#125; 转换后12345block func (int a) &#123; block tmp = ((void (*)())&amp;__func_block_impl_0((void *)__func_block_func_0, &amp;__func_block_desc_0_DATA)); tmp = objc_retainBlock(tmp); return objc_autoreleaseReturnValue(tmp); &#125; 这里先是通过Block语法生成Block，即生成配置在栈上的Block结构体实例，然后赋值给Block类型的变量tmp中，然后执行objc_retainBlock(tmp)这句其实就是_Block_copy(tmp)，将栈上的的Block复制到堆上，赋值后将堆上的指针赋值给tmp，然后堆上的所有都是对象，需要注册陶autoreleasepool中进行管理，然后返回其对象 其实这种内部调用方式，MallocBlock就是对象，而且这种写法是否很似曾相识，就是类方法实例化 1234- (NSArray *) myTestArray &#123; NSArray *array = [[NSArray alloc] initWithObjects: @\"a\", @\"b\", @\"c\", nil nil]; return [array autorelease]; &#125; 简单来说就是第一步copyBlock到堆上，然后和OC对象一样，返回的对象需要进行autorelease防治内存泄露 ARC下面很多都已经自动帮我们Copy成了MallocBlock了，请看一下几种情况 由于Block是默认建立在栈上,所以如果离开方法作用域，Block就会被丢弃，在非ARC情况下，我们要返回一个Block，需要 1[Block copy]; 在ARC下,以下几种情况, Block会自动被从栈复制到堆: 1.被执行copy方法 2.作为方法返回值 3.将Block赋值给附有__strong修饰符的id类型的类或者Blcok类型成员变量时 4.在方法名中含有usingBlock的Cocoa框架方法或者GDC的API中传递的时候 来猜一猜1234567891011121314151617181920212223242526272829303132333435363738394041424344454647int a = 1; // 这里的^&#123;&#125;初始化的block赋值给block变量，在OC中没有具体写明的情况下应该就是strong类型的，这就是上面第三点的例子 // 打印出来 first &lt;__NSMallocBlock__: 0x60800004d290&gt; void (^block)(void) = ^&#123; NSLog(@\"%d\",a); &#125;; NSLog(@\"first %@\",block); // 没有截获变量的时候就是globalBlock // second&lt;__NSGlobalBlock__: 0x102f80100&gt; NSLog(@\"second%@\",^&#123;NSLog(@\"呵呵\");&#125;); // 截获了变量就是stackBlock // third&lt;__NSStackBlock__: 0x7fff5cc7faa0&gt; NSLog(@\"third%@\",^&#123;NSLog(@\"%d\",a);&#125;); __block int val = 10; __strong blk strongPointerBlock = ^&#123;NSLog(@\"val1 = %d\", ++val);&#125;; // strongPointerBlock: &lt;__NSMallocBlock__: 0x600000044e90&gt; NSLog(@\"strongPointerBlock: %@\", strongPointerBlock); //1 __weak blk weakPointerBlock = ^&#123;NSLog(@\"val2 = %d\", ++val);&#125;; // weakPointerBlock: &lt;__NSStackBlock__: 0x7fff5282ea70&gt; NSLog(@\"weakPointerBlock: %@\", weakPointerBlock); //2 // mallocBlock3: &lt;__NSMallocBlock__: 0x608000046930&gt; NSLog(@\"mallocBlock3: %@\", [weakPointerBlock copy]); //3 // 截获了test &lt;__NSStackBlock__: 0x7fff5282ea48&gt; NSLog(@\"test4 %@\", ^&#123;NSLog(@\"val4 = %d\", ++val);&#125;); //4 // test5 &lt;__NSMallocBlock__: 0x60800005c0b0&gt; NSLog(@\"test5 %@\", [^&#123;NSLog(@\"val4 = %d\", ++val);&#125; copy]); //5 // stackBlock经过传参 打印 NSLog(@\"传参后 %@\",[self getBlock]); &#125; - (blk)getBlock &#123; int val = 11; // 上面已经介绍了，这种直接打印传参前的block，应该是__NSStackBlock__ NSLog(@\"传参前：%@\",^&#123;NSLog(@\"%d\",val);&#125;); // 那么现在我们直接传出去 return ^&#123;NSLog(@\"%d\",val);&#125;; &#125; 这里把几种情况都打印了一下看看到底是哪个类型 1.第一个和第二个打印的区别在于，第一个生成的Block默认赋值给了block变量，第二个直接打印，由于OC里面没有修饰符默认就是strong，所以这么看来遵循第三条规则之后，第二条条打印就是NSGlobalBlock（没有截获变量），第一条打印就是NSMallocBlock（自动复制到堆上了） 2.后面用strong修饰符和weak修饰符分别打印的是malloc的和stack的，但是无论哪种，只要copy就是变成malloc类型了 3.最后一种就是上面介绍的，stackBlock经过传参，自动变成了mallocBlock 属性修饰符 copy 修饰 Block来看一张表，看看三种类型copy之后有什么区别 1@property (nonatomic,copy) blk blk; 当我们这么声明属性的时候，其setter方法就是用了copy方法 123456- (void)setBlk:(blk)blk &#123; if (_blk != blk) &#123; [_blk release]; // MRC _blk = [blk copy]; &#125; &#125; 1.超出作用域存在的理由就是生成了MallocBlock对象，即使出栈了还是能继续调用 2.forwarding的理由就是无论在堆上还是栈上，我们都能访问Block，而且能保证访问同一个 3.GlobalBlock 、MallocBlock和StackBlock的区别以及如何Block如何会被copy到堆上 4.特别上作为参数传递时，类似类方法的autoreleasepool注册进去，避免内存泄露 5.在正常写代码的时候不需要管理这个，默认百分之99的情况基本都是MallocBlock 6.无论什么情况下，copy一下或者强指针引用一下是不会有错的，能保证必然是MallocBlock 7.各种迹象表明，他就是一个对象，可以通过copy改变类型的特殊对象 以上文章整理自：https://blog.csdn.net/deft_mkjing/article/details/53143076","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS Principle：Thread","slug":"iOS Principle Thread","date":"2018-06-09T13:56:27.000Z","updated":"2018-11-18T05:37:42.197Z","comments":true,"path":"2018/06/09/iOS Principle Thread/","link":"","permalink":"https://reversescale.github.io/2018/06/09/iOS Principle Thread/","excerpt":"进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础~","text":"进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础~ 👨🏻‍💻 Github Demo 方便记忆： 进程和线程：进程是饭馆、线程是工作人员 线程的执行：1个线程中任务的执行是串行的 多线程并发执行：CPU快速地在多条线程之间调度 iOS 多线程 pthread：c语言的通用api，跨平台、难度大、非自动管理生命周期 NSThread：面向对象的非自动管理生命周期 GCD：利用设备的多核自动管理生命周期 NSOperation、NSOperationQueue：封装GCD，加强依赖关系、监控状态、并发管理 常用安全锁：@synchronized{}、[self.lock lock] 相关概念进程进程是指在系统中正在运行的一个应用程序。每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。 线程线程和进程的关系 1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程），线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行。 线程内部是串行执行的？ 1个线程中任务的执行是串行的，如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务。也就是说，在同一时间内，1个线程只能执行1个任务。 多线程即1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务。比如同时开启3条线程分别下载3个文件（分别是文件A、文件B、文件C）。 多线程并发执行的原理？ 在同一时间里，CPU只能处理1条线程，只有1条线程在工作（执行）。多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换），如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。 多线程的优缺点？ 优点： 1）能适当提高程序的执行效率。 2）能适当提高资源利用率（CPU、内存利用率） 缺点： 1）开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能。 2）线程越多，CPU在调度线程上的开销就越大。 3）程序设计更加复杂：比如线程之间的通信、多线程的数据共享 多线程在 iOS 开发中的应用iOS 的主线程？ 一个 iOS 程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”，用于刷新显示UI,处理UI事件。 不要将耗时操作放到主线程中去处理，会卡住线程。 iOS 的多线程？ 1）第一种：pthread 特点： 一套通用的多线程API 适用于Unix\\Linux\\Windows等系统 跨平台\\可移植 使用难度大 使用语言：c语言 使用频率：几乎不用 线程生命周期：由程序员进行管理 2）第二种：NSThread 特点： 使用更加面向对象 简单易用，可直接操作线程对象 使用语言：OC语言 使用频率：偶尔使用 线程生命周期：由程序员进行管理 3）第三种：GCD 特点： 旨在替代NSThread等线程技术 充分利用设备的多核(自动) 使用语言：OC语言 使用频率：经常使用 线程生命周期：自动管理 4）第四种：NSOperation 特点： 基于GCD（底层是GCD） 比GCD多了一些更简单实用的功能 使用更加面向对象 对比 GCD 的优点： 在NSOperationQueue中，可以建立各个NSOperation之间的依赖关系 有KVO，可以监测operation是否正在执行（isExecuted）、是否结束（isFinished），是否取消（isCanceld） NSOperationQueue可以方便的管理并发、NSOperation之间的优先级 使用语言：OC语言 使用频率：经常使用 线程生命周期：自动管理 代码示例由于要使用一些 c 来演示，先说明些规范，防懵逼 😳 1.在c语言中，没有对象的概念，对象类型是以-t/Ref结尾的; 2.c语言中的void * 和OC的id是等价的; 3.在混合开发时，如果在 C 和 OC 之间传递数据，需要使用 __bridge 进行桥接，桥接的目的就是为了告诉编译器如何管理内存，MRC 中不需要使用桥接; 4.在 OC 中，如果是 ARC 开发，编译器会在编译时，根据代码结构， 自动添加 retain/release/autorelease。但是，ARC 只负责管理 OC 部分的内存管理，而不负责 C 语言 代码的内存管理。因此，开发过程中，如果使用的 C 语言框架出现retain/create/copy/new 等字样的函数，大多都需要 release，否则会出现内存泄漏。 pthread 基本使用需要引入 pthread 头文件1#import &lt;pthread.h&gt; 使用 pthread_create 方法12345678/**pthread_create(&lt;#pthread_t _Nullable *restrict _Nonnull#&gt;, &lt;#const pthread_attr_t *restrict _Nullable#&gt;, &lt;#void * _Nullable (* _Nonnull)(void * _Nullable)#&gt;, &lt;#void *restrict _Nullable#&gt;)参数：1.指向线程标识符的指针，C 语言中类型的结尾通常 _t/Ref，而且不需要使用 *;2.用来设置线程属性;3.指向函数的指针,传入函数名(函数的地址)，线程要执行的函数/任务;4.运行函数的参数;*/ 完整代码1234567891011121314151617&#123; //1.创建线程对象 pthread_t thread; //2.创建线程 NSString *param = @\"参数\"; int result = pthread_create(&amp;thread, NULL, task, (__bridge void *)(param)); result == 0?NSLog(@\"success\"):NSLog(@\"failure\"); //3.设置子线程的状态设置为detached,则该线程运行结束后会自动释放所有资源，或者在子线程中添加 pthread_detach(pthread_self()),其中pthread_self()是获得线程自身的id pthread_detach(thread);&#125;void *task(void * param) &#123; //在此做耗时操作 NSLog(@\"new thread : %@ 参数是: %@\",[NSThread currentThread],(__bridge NSString *)(param)); return NULL;&#125; NSThread 基本使用1.1）第一种 创建线程的方式：alloc init. 特点：需要手动开启线程，可以拿到线程对象进行详细设置 第一个参数：目标对象 第二个参数：选择器，线程启动要调用哪个方法 第三个参数：前面方法要接收的参数（最多只能接收一个参数，没有则传nil） 123NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(run) object:@\"wendingding\"];//启动线程[thread start]; 1.2）第二种 创建线程的方式：分离出一条子线程 特点：自动启动线程，无法对线程进行更详细的设置 第一个参数：线程启动调用的方法 第二个参数：目标对象 第三个参数：传递给调用方法的参数 1[NSThread detachNewThreadSelector:@selector(run) toTarget:self withObject:@\"我是分离出来的子线程\"]; 1.3）第三种 创建线程的方式：后台线程 特点：自动启动县城，无法进行更详细设置 1[self performSelectorInBackground:@selector(run) withObject:@\"我是后台线程\"]; 2）常用的控制线程方法 为线程命名，以便区分12//设置线程的名称thread.name = @\"线程A\"; 设置优先级，取值范围为0.0~1.0之间，1.0表示线程的优先级最高,如果不设置该值，那么理想状态下默认为0.512//设置线程的优先级thread.threadPriority = 1.0; 退出当前线程12//退出当前线程[NSThread exit]; 线程的各种状态：新建-就绪-运行-阻塞-死亡，阻塞线程方法来了123[NSThread sleepForTimeInterval:2.0]; //阻塞线程[NSThread sleepUntilDate:[NSDate dateWithTimeIntervalSinceNow:2.0]]; //阻塞线程//注意：线程死了不能复生 3）线程安全 前提：多个线程访问同一块资源会发生数据安全问题 解决方案：加互斥锁 相关代码：@synchronized(self){} 专业术语-线程同步 原子和非原子属性（是否对setter方法加锁） 死锁：是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。 产生死锁的四个必要条件： 互斥条件：一个资源每次只能被一个进程使用。 占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 不可强行占有:进程已获得的资源，在末使用完之前，不能强行剥夺。 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 产生死锁的原因主要是： 因为系统资源不足。 进程运行推进的顺序不合适。 资源分配不当等。 售票员售票问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@interface NSThreadSafeViewController ()//三只售票员🐱🐶🐭@property (nonatomic, strong) NSThread *thread01;@property (nonatomic, strong) NSThread *thread02;@property (nonatomic, strong) NSThread *thread03;//总票数@property(nonatomic, assign) NSInteger totalticket;@end@implementation NSThreadSafeViewController- (void)viewDidLoad &#123; [super viewDidLoad]; //假设有10张票 self.totalticket = 10; //创建线程 self.thread01 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicket) object:nil]; self.thread01.name = @\"小🐱\"; self.thread02 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicket) object:nil]; self.thread02.name = @\"小🐶\"; self.thread03 = [[NSThread alloc]initWithTarget:self selector:@selector(saleTicket) object:nil]; self.thread03.name = @\"小🐭\";&#125;- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; //启动线程 [self.thread01 start]; [self.thread02 start]; [self.thread03 start];&#125;//售票- (void)saleTicket &#123; while (1) &#123; //2.加互斥锁 @synchronized(self) &#123; [NSThread sleepForTimeInterval:0.03]; //1.先查看余票数量 NSInteger count = self.totalticket; if (count &gt; 0) &#123; self.totalticket = count - 1; NSLog(@\"%@卖出去了一张票,还剩下%zd张票\",[NSThread currentThread].name,self.totalticket); &#125; else &#123; NSLog(@\"%@发现当前票已经买完了--\",[NSThread currentThread].name); break; &#125; &#125; &#125;&#125; 运行结果 4）NSThread 线程间通信（子线程加载图片完成通知主线程更新UI）123456789101112131415161718192021222324- (void)touchesBegan:(nonnull NSSet&lt;UITouch *&gt; *)touches withEvent:(nullable UIEvent *)event &#123; //开启一条子线程来下载图片 [NSThread detachNewThreadSelector:@selector(downloadImage) toTarget:self withObject:nil];&#125;- (void)downloadImage &#123; //1.确定要下载网络图片的url地址，一个url唯一对应着网络上的一个资源 NSURL *url = [NSURL URLWithString:@\"http://p6.qhimg.com/t01d2954e2799c461ab.jpg\"]; //2.根据url地址下载图片数据到本地（二进制数据 NSData *data = [NSData dataWithContentsOfURL:url]; //3.把下载到本地的二进制数据转换成图片 UIImage *image = [UIImage imageWithData:data]; //4.回到主线程刷新UI //4.1 第一种方式 // [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES]; //4.2 第二种方式 // [self.imageView performSelectorOnMainThread:@selector(setImage:) withObject:image waitUntilDone:YES]; //4.3 第三种方式 [self.imageView performSelector:@selector(setImage:) onThread:[NSThread mainThread] withObject:image waitUntilDone:YES];&#125; 5）特殊用法（计算代码段的执行时间）1234567891011121314151617NSURL *url = [NSURL URLWithString:@\"http://p6.qhimg.com/t01d2954e2799c461ab.jpg\"];//第一种方法NSDate *start = [NSDate date];//2.根据url地址下载图片数据到本地（二进制数据）NSData *data = [NSData dataWithContentsOfURL:url];NSDate *end = [NSDate date];NSLog(@\"第二步操作花费的时间为%f\",[end timeIntervalSinceDate:start]);//第二种方法CFTimeInterval start = CFAbsoluteTimeGetCurrent();NSData *data = [NSData dataWithContentsOfURL:url];CFTimeInterval end = CFAbsoluteTimeGetCurrent();NSLog(@\"第二步操作花费的时间为%f\",end - start); GCD 基本使用1）GCD 核心概念 队列和任务 同步函数和异步函数 2）GCD 组合拳 🤣 异步函数： 异步函数+并发队列：开启多条线程，并发执行任务 异步函数+串行队列：开启一条线程，串行执行任务 同步函数： 同步函数+并发队列：不开线程，串行执行任务 同步函数+串行队列：不开线程，串行执行任务 主队列： 异步函数+主队列：不开线程，在主线程中串行执行任务 同步函数+主队列：不开线程，串行执行任务（注意死锁发生） 3）GCD 线程间通信123456789101112131415161718//0.获取一个全局的队列dispatch_queue_t queue = dispatch_get_global_queue(0, 0);//1.先开启一个线程，把下载图片的操作放在子线程中处理dispatch_async(queue, ^&#123; //2.下载图片 NSURL *url = [NSURL URLWithString:@\"http://h.hiphotos.baidu.com/zhidao/pic/item/6a63f6246b600c3320b14bb3184c510fd8f9a185.jpg\"]; NSData *data = [NSData dataWithContentsOfURL:url]; UIImage *image = [UIImage imageWithData:data]; NSLog(@\"下载操作所在的线程--%@\",[NSThread currentThread]); //3.回到主线程刷新UI dispatch_async(dispatch_get_main_queue(), ^&#123; self.imageView.image = image; //打印查看当前线程 NSLog(@\"刷新UI---%@\",[NSThread currentThread]); &#125;);&#125;); 4）GCD 常用小功能 栅栏函数（控制任务的执行顺序）123dispatch_barrier_async(queue, ^&#123; NSLog(@\"--dispatch_barrier_async-\");&#125;); 延迟执行（延迟·控制在哪个线程执行）123dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_global_ queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@\"---%@\",[NSThread currentThread]);&#125;); 一次性代码（注意不能放到懒加载）12345678- (void)once &#123; //整个程序运行过程中只会执行一次 //onceToken用来记录该部分的代码是否被执行过 static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSLog(@\"-----\"); &#125;);&#125; 快速迭代（开多个线程并发完成迭代操作）12dispatch_apply(subpaths.count, queue, ^(size_t index) &#123;&#125;); 队列组（同栅栏函数）12345678910111213141516171819202122232425//创建队列组dispatch_group_t group = dispatch_group_create();dispatch_queue_t globalQueue = dispatch_get_global_queue(0, 0);dispatch_group_enter(group);//模拟多线程耗时操作dispatch_group_async(group, globalQueue, ^&#123; sleep(3); NSLog(@\"%@---block1结束。。。\",[NSThread currentThread]); dispatch_group_leave(group);&#125;);NSLog(@\"%@---1结束。。。\",[NSThread currentThread]);dispatch_group_enter(group);//模拟多线程耗时操作dispatch_group_async(group, globalQueue, ^&#123; sleep(3); NSLog(@\"%@---block2结束。。。\",[NSThread currentThread]); dispatch_group_leave(group);&#125;);NSLog(@\"%@---2结束。。。\",[NSThread currentThread]);dispatch_group_notify(group, globalQueue, ^&#123; NSLog(@\"%@---全部结束。。。\",[NSThread currentThread]);&#125;); NSOperation 基本使用1）NSOperation、NSOperationQueue 简介 NSOperation、NSOperationQueue 是苹果提供给我们的一套多线程解决方案。实际上 NSOperation、NSOperationQueue 是基于 GCD 更高一层的封装，完全面向对象。但是比 GCD 更简单易用、代码可读性也更高。 为什么要使用 NSOperation、NSOperationQueue？ 1.可添加完成的代码块，在操作完成后执行。 2.添加操作之间的依赖关系，方便的控制执行顺序。 3.设定操作执行的优先级。 4.可以很方便的取消一个操作的执行。 5.使用 KVO 观察对操作执行状态的更改：isExecuteing、isFinished、isCancelled。 2）NSOperation、NSOperationQueue 操作和操作队列 既然是基于 GCD 的更高一层的封装。那么，GCD 中的一些概念同样适用于 NSOperation、NSOperationQueue。在 NSOperation、NSOperationQueue 中也有类似的任务（操作）和队列（操作队列）的概念。 操作（Operation）： 执行操作的意思，换句话说就是你在线程中执行的那段代码。 在 GCD 中是放在 block 中的。在 NSOperation 中，我们使用 NSOperation 子类 NSInvocationOperation、NSBlockOperation，或者自定义子类来封装操作。 操作队列（Operation Queues）： 这里的队列指操作队列，即用来存放操作的队列。不同于 GCD 中的调度队列 FIFO（先进先出）的原则。NSOperationQueue 对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。 操作队列通过设置最大并发操作数（maxConcurrentOperationCount）来控制并发、串行。 NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。 3）NSOperation、NSOperationQueue 使用步骤 NSOperation 需要配合 NSOperationQueue 来实现多线程。因为默认情况下，NSOperation 单独使用时系统同步执行操作，配合 NSOperationQueue 我们能更好的实现异步执行。 NSOperation 实现多线程的使用步骤分为三步： 1.创建操作：先将需要执行的操作封装到一个 NSOperation 对象中。 2.创建队列：创建 NSOperationQueue 对象。 3.将操作加入到队列中：将 NSOperation 对象添加到 NSOperationQueue 对象中。 之后呢，系统就会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作。 下面我们来学习下 NSOperation 和 NSOperationQueue 的基本使用。 4）NSOperation 和 NSOperationQueue 基本使用 4.1）创建操作 NSOperation 是个抽象类，不能用来封装操作。我们只有使用它的子类来封装操作。我们有三种方式来封装操作。 使用子类 NSInvocationOperation 使用子类 NSBlockOperation 自定义继承自 NSOperation 的子类，通过实现内部相应的方法来封装操作。 在不使用 NSOperationQueue，单独使用 NSOperation 的情况下系统同步执行操作，下面我们学习以下操作的三种创建方式。 4.1.1）使用子类 NSInvocationOperation 1234567891011121314151617181920/*** 使用子类 NSInvocationOperation*/- (void)useInvocationOperation &#123; // 1.创建 NSInvocationOperation 对象 NSInvocationOperation *op = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil]; // 2.调用 start 方法开始执行操作 [op start];&#125;/*** 任务1*/- (void)task1 &#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"1---%@\", [NSThread currentThread]); // 打印当前线程 &#125;&#125; 运行结果 可以看到：在没有使用 NSOperationQueue、在主线程中单独使用使用子类 NSInvocationOperation 执行一个操作的情况下，操作是在当前线程执行的，并没有开启新线程。 如果在其他线程中执行操作，则打印结果为其他线程 12// 在其他线程使用子类 NSInvocationOperation[NSThread detachNewThreadSelector:@selector(useInvocationOperation) toTarget:self withObject:nil]; 可以看到：在其他线程中单独使用子类 NSInvocationOperation，操作是在当前调用的其他线程执行的，并没有开启新线程。 4.1.2）使用子类 NSBlockOperation1234567891011121314/*** 使用子类 NSBlockOperation*/- (void)useBlockOperation &#123; // 1.创建 NSBlockOperation 对象 NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"1---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; // 2.调用 start 方法开始执行操作 [op start];&#125; 运行结果 注意：和上边 NSInvocationOperation 使用一样。因为代码是在主线程中调用的，所以打印结果为主线程。如果在其他线程中执行操作，则打印结果为其他线程。 但是，NSBlockOperation 还提供了一个方法 addExecutionBlock:，通过 addExecutionBlock: 就可以为 NSBlockOperation 添加额外的操作。这些操作（包括 blockOperationWithBlock 中的操作）可以在不同的线程中同时（并发）执行。只有当所有相关的操作已经完成执行时，才视为完成。 如果添加的操作多的话，blockOperationWithBlock: 中的操作也可能会在其他线程（非当前线程）中执行，这是由系统决定的，并不是说添加到 blockOperationWithBlock: 中的操作一定会在当前线程中执行。（可以使用 addExecutionBlock: 多添加几个操作试试）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 使用子类 NSBlockOperation * 调用方法 AddExecutionBlock:*/- (void)useBlockOperationAddExecutionBlock &#123; // 1.创建 NSBlockOperation 对象 NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"1---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; // 2.添加额外的操作 [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"2---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"3---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"4---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"5---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"6---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"7---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [op addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"8---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; // 3.调用 start 方法开始执行操作 [op start];&#125; 运行结果 可以看出：使用子类 NSBlockOperation，并调用方法 AddExecutionBlock: 的情况下，blockOperationWithBlock:方法中的操作 和 addExecutionBlock: 中的操作是在不同的线程中异步执行的。而且，这次执行结果中 blockOperationWithBlock:方法中的操作也不是在当前线程（主线程）中执行的。从而印证了blockOperationWithBlock: 中的操作也可能会在其他线程（非当前线程）中执行。 一般情况下，如果一个 NSBlockOperation 对象封装了多个操作。NSBlockOperation 是否开启新线程，取决于操作的个数。如果添加的操作的个数多，就会自动开启新线程。当然开启的线程数是由系统来决定的。 4.1.3）使用自定义继承自 NSOperation 的子类 如果使用子类 NSInvocationOperation、NSBlockOperation 不能满足日常需求，我们可以使用自定义继承自 NSOperation 的子类。可以通过重写 main 或者 start 方法 来定义自己的 NSOperation 对象。重写main方法比较简单，我们不需要管理操作的状态属性 isExecuting 和 isFinished。当 main 执行完返回的时候，这个操作就结束了。 先定义一个继承自 NSOperation 的子类，重写main方法。 CustomOperation.h123#import &lt;Foundation/Foundation.h&gt;@interface CustomOperation : NSOperation@end CustomOperation.m1234567891011#import \"CustomOperation.h\"@implementation CustomOperation- (void)main &#123; if (!self.isCancelled) &#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@\"1---%@\", [NSThread currentThread]); &#125; &#125;&#125;@end 使用示例123456789/*** 使用自定义继承自 NSOperation 的子类*/- (void)useCustomOperation &#123; // 1.创建 YSCOperation 对象 CustomOperation *op = [[CustomOperation alloc] init]; // 2.调用 start 方法开始执行操作 [op start];&#125; 可以看出：在没有使用 NSOperationQueue、在主线程单独使用自定义继承自 NSOperation 的子类的情况下，是在主线程执行操作，并没有开启新线程。 4.2）创建队列 NSOperationQueue 一共有两种队列：主队列、自定义队列。其中自定义队列同时包含了串行、并发功能。下边是主队列、自定义队列的基本创建方法和特点。 主队列 凡是添加到主队列中的操作，都会放到主线程中执行。12// 主队列获取方法NSOperationQueue *queue = [NSOperationQueue mainQueue]; 自定义队列（非主队列） 添加到这种队列中的操作，就会自动放到子线程中执行（同时包含了：串行、并发功能）12// 自定义队列创建方法NSOperationQueue *queue = [[NSOperationQueue alloc] init]; 4.3）将操作加入到队列中 上边我们说到 NSOperation 需要配合 NSOperationQueue 来实现多线程。 那么我们需要将创建好的操作加入到队列中去。总共有两种方法： 1.-(void)addOperation:(NSOperation *)op; 需要先创建操作，再将创建好的操作加入到创建好的队列中去。 123456789101112131415161718192021222324252627282930313233/*** 使用 addOperation: 将操作加入到操作队列中*/- (void)addOperationToQueue &#123; // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.创建操作 // 使用 NSInvocationOperation 创建操作1 NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil]; // 使用 NSInvocationOperation 创建操作2 NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task2) object:nil]; // 使用 NSBlockOperation 创建操作3 NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"3---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [op3 addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"4---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; // 3.使用 addOperation: 添加所有操作到队列中 [queue addOperation:op1]; // [op1 start] [queue addOperation:op2]; // [op2 start] [queue addOperation:op3]; // [op3 start]&#125; 运行结果 可以看出：使用 NSOperation 子类创建操作，并使用 addOperation: 将操作加入到操作队列后能够开启新线程，进行并发执行。 2.-(void)addOperationWithBlock:(void (^)(void))block; 无需先创建操作，在 block 中添加操作，直接将包含操作的 block 加入到队列中 123456789101112131415161718192021222324252627/*** 使用 addOperationWithBlock: 将操作加入到操作队列中*/- (void)addOperationWithBlockToQueue &#123; // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.使用 addOperationWithBlock: 添加操作到队列中 [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"1---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"2---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"3---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;];&#125; 运行结果 可以看出：使用 addOperationWithBlock: 将操作加入到操作队列后能够开启新线程，进行并发执行。 5）NSOperationQueue 控制串行执行、并发执行 之前我们说过，NSOperationQueue 创建的自定义队列同时具有串行、并发功能，上边我们演示了并发功能，那么他的串行功能是如何实现的？ 这里有个关键属性 maxConcurrentOperationCount，叫做最大并发操作数。用来控制一个特定队列中可以有多少个操作同时参与并发执行。 注意：这里 maxConcurrentOperationCount 控制的不是并发线程的数量，而是一个队列中同时能并发执行的最大操作数。而且一个操作也并非只能在一个线程中运行。 maxConcurrentOperationCount 最大并发操作数： maxConcurrentOperationCount 默认情况下为-1，表示不进行限制，可进行并发执行。 maxConcurrentOperationCount 为1时，队列为串行队列。只能串行执行。 maxConcurrentOperationCount 大于1时，队列为并发队列。操作并发执行，当然这个值不应超过系统限制，即使自己设置一个很大的值，系统也会自动调整为 min{自己设定的值，系统设定的默认最大值}。 1234567891011121314151617181920212223242526272829303132333435363738/*** 设置 MaxConcurrentOperationCount（最大并发操作数）*/- (void)setMaxConcurrentOperationCount &#123; // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.设置最大并发操作数 queue.maxConcurrentOperationCount = 1; // 串行队列 // queue.maxConcurrentOperationCount = 2; // 并发队列 // queue.maxConcurrentOperationCount = 8; // 并发队列 // 3.添加操作 [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"1---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"2---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"3---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"4---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;];&#125; maxConcurrentOperationCount 设置为 1，运行结果 maxConcurrentOperationCount 设置为 2，运行结果 可以看出：当最大并发操作数为1时，操作是按顺序串行执行的，并且一个操作完成之后，下一个操作才开始执行。当最大操作并发数为2时，操作是并发执行的，可以同时执行两个操作。而开启线程数量是由系统决定的，不需要我们来管理。 6）NSOperation 操作依赖 NSOperation、NSOperationQueue 最吸引人的地方是它能添加操作之间的依赖关系。通过操作依赖，我们可以很方便的控制操作之间的执行先后顺序。NSOperation 提供了3个接口供我们管理和查看依赖。 -(void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。 -(void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。 @property (readonly, copy) NSArray *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。 当然，我们经常用到的还是添加依赖操作。现在考虑这样的需求，比如说有 A、B 两个操作，其中 A 执行完操作，B 才能执行操作。 如果使用依赖来处理的话，那么就需要让操作 B 依赖于操作 A。具体代码如下： 1234567891011121314151617181920212223242526272829/*** 操作依赖* 使用方法：addDependency:*/- (void)addDependency &#123; // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.创建操作 NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"1---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"2---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; // 3.添加依赖 [op2 addDependency:op1]; // 让op2 依赖于 op1，则先执行op1，在执行op2 // 4.添加操作到队列中 [queue addOperation:op1]; [queue addOperation:op2];&#125; 运行结果 可以看到：通过添加操作依赖，无论运行几次，其结果都是 op1 先执行，op2 后执行。 7）NSOperation 优先级 NSOperation 提供了queuePriority（优先级）属性，queuePriority属性适用于同一操作队列中的操作，不适用于不同操作队列中的操作。默认情况下，所有新创建的操作对象优先级都是NSOperationQueuePriorityNormal。但是我们可以通过setQueuePriority:方法来改变当前操作在同一队列中的执行优先级。 12345678// 优先级的取值typedef NS_ENUM(NSInteger, NSOperationQueuePriority) &#123;NSOperationQueuePriorityVeryLow = -8L,NSOperationQueuePriorityLow = -4L,NSOperationQueuePriorityNormal = 0,NSOperationQueuePriorityHigh = 4,NSOperationQueuePriorityVeryHigh = 8&#125;; 上边我们说过：对于添加到队列中的操作，首先进入准备就绪的状态（就绪状态取决于操作之间的依赖关系），然后进入就绪状态的操作的开始执行顺序（非结束执行顺序）由操作之间相对的优先级决定（优先级是操作对象自身的属性）。 那么，什么样的操作才是进入就绪状态的操作呢？ 当一个操作的所有依赖都已经完成时，操作对象通常会进入准备就绪状态，等待执行。举个例子，现在有4个优先级都是 NSOperationQueuePriorityNormal（默认级别）的操作：op1，op2，op3，op4。其中 op3 依赖于 op2，op2 依赖于 op1，即 op3 -&gt; op2 -&gt; op1。现在将这4个操作添加到队列中并发执行。 因为 op1 和 op4 都没有需要依赖的操作，所以在 op1，op4 执行之前，就是处于准备就绪状态的操作。而 op3 和 op2 都有依赖的操作（op3 依赖于 op2，op2 依赖于 op1），所以 op3 和 op2 都不是准备就绪状态下的操作。理解了进入就绪状态的操作，那么我们就理解了queuePriority 属性的作用对象。 queuePriority 属性决定了进入准备就绪状态下的操作之间的开始执行顺序。并且，优先级不能取代依赖关系。如果一个队列中既包含高优先级操作，又包含低优先级操作，并且两个操作都已经准备就绪，那么队列先执行高优先级操作。比如上例中，如果 op1 和 op4 是不同优先级的操作，那么就会先执行优先级高的操作。 如果，一个队列中既包含了准备就绪状态的操作，又包含了未准备就绪的操作，未准备就绪的操作优先级比准备就绪的操作优先级高。那么，虽然准备就绪的操作优先级低，也会优先执行。优先级不能取代依赖关系。如果要控制操作间的启动顺序，则必须使用依赖关系。 8）NSOperation、NSOperationQueue 线程间的通信 在 iOS 开发过程中，我们一般在主线程里边进行 UI 刷新，例如：点击、滚动、拖拽等事件。我们通常把一些耗时的操作放在其他线程，比如说图片下载、文件上传等耗时操作。而当我们有时候在其他线程完成了耗时操作时，需要回到主线程，那么就用到了线程之间的通讯。 12345678910111213141516171819202122232425/*** 线程间通信*/- (void)communication &#123; // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc]init]; // 2.添加操作 [queue addOperationWithBlock:^&#123; // 异步进行耗时操作 for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"1---%@\", [NSThread currentThread]); // 打印当前线程 &#125; // 回到主线程 [[NSOperationQueue mainQueue] addOperationWithBlock:^&#123; // 进行一些 UI 刷新等操作 for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@\"2---%@\", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; &#125;];&#125; 运行结果 9）NSOperation、NSOperationQueue 线程同步和线程安全 线程安全：如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。 若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说，这个全局变量是线程安全的；若有多个线程同时执行写操作（更改变量），一般都需要考虑线程同步，否则的话就可能影响线程安全。 线程同步：可理解为线程 A 和 线程 B 一块配合，A 执行到一定程度时要依靠线程 B 的某个结果，于是停下来，示意 B 运行；B 依言执行，再将结果给 A；A 再继续操作。 举个简单例子就是：两个人在一起聊天。两个人不能同时说话，避免听不清(操作冲突)。等一个人说完(一个线程结束操作)，另一个再说(另一个线程再开始操作)。 下面，我们模拟火车票售卖的方式，实现 NSOperation 线程安全和解决线程同步问题。 场景：总共有50张火车票，有两个售卖火车票的窗口，一个是北京火车票售卖窗口，另一个是上海火车票售卖窗口。两个窗口同时售卖火车票，卖完为止。 9.1）NSOperation、NSOperationQueue 非线程安全 先来看看不考虑线程安全的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/*** 非线程安全：不使用 NSLock* 初始化火车票数量、卖票窗口(非线程安全)、并开始卖票*/- (void)initTicketStatusNotSave &#123; NSLog(@\"currentThread---%@\",[NSThread currentThread]); // 打印当前线程 self.ticketSurplusCount = 50; // 1.创建 queue1,queue1 代表北京火车票售卖窗口 NSOperationQueue *queue1 = [[NSOperationQueue alloc] init]; queue1.maxConcurrentOperationCount = 1; // 2.创建 queue2,queue2 代表上海火车票售卖窗口 NSOperationQueue *queue2 = [[NSOperationQueue alloc] init]; queue2.maxConcurrentOperationCount = 1; // 3.创建卖票操作 op1 __weak typeof(self) weakSelf = self; NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; [weakSelf saleTicketNotSafe]; &#125;]; // 4.创建卖票操作 op2 NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; [weakSelf saleTicketNotSafe]; &#125;]; // 5.添加操作，开始卖票 [queue1 addOperation:op1]; [queue2 addOperation:op2];&#125;/*** 售卖火车票(非线程安全)*/- (void)saleTicketNotSafe &#123; while (1) &#123; if (self.ticketSurplusCount &gt; 0) &#123; //如果还有票，继续售卖 self.ticketSurplusCount--; NSLog(@\"%@\", [NSString stringWithFormat:@\"剩余票数:%d 窗口:%@\", self.ticketSurplusCount, [NSThread currentThread]]); [NSThread sleepForTimeInterval:0.2]; &#125; else &#123; NSLog(@\"所有火车票均已售完\"); break; &#125; &#125;&#125; 运行结果 可以看到：在不考虑线程安全，不使用 NSLock 情况下，在0票后依然出票，数据混乱，这样显然不符合我们的需求，所以我们需要考虑线程安全问题。 9.2）NSOperation、NSOperationQueue 非线程安全 线程安全解决方案：可以给线程加锁，在一个线程执行该操作的时候，不允许其他线程进行操作。iOS 实现线程加锁有很多种方式。@synchronized、 NSLock、NSRecursiveLock、NSCondition、NSConditionLock、pthread_mutex、dispatch_semaphore、OSSpinLock、atomic(property) set/ge等等各种方式。这里我们使用 NSLock 对象来解决线程同步问题。 NSLock 对象可以通过进入锁时调用 lock 方法，解锁时调用 unlock 方法来保证线程安全。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/*** 线程安全：使用 NSLock 加锁* 初始化火车票数量、卖票窗口(线程安全)、并开始卖票*/- (void)initTicketStatusSave &#123; NSLog(@\"currentThread---%@\",[NSThread currentThread]); // 打印当前线程 self.ticketSurplusCount = 50; self.lock = [[NSLock alloc] init]; // 初始化 NSLock 对象 // 1.创建 queue1,queue1 代表北京火车票售卖窗口 NSOperationQueue *queue1 = [[NSOperationQueue alloc] init]; queue1.maxConcurrentOperationCount = 1; // 2.创建 queue2,queue2 代表上海火车票售卖窗口 NSOperationQueue *queue2 = [[NSOperationQueue alloc] init]; queue2.maxConcurrentOperationCount = 1; // 3.创建卖票操作 op1 __weak typeof(self) weakSelf = self; NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; [weakSelf saleTicketSafe]; &#125;]; // 4.创建卖票操作 op2 NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; [weakSelf saleTicketSafe]; &#125;]; // 5.添加操作，开始卖票 [queue1 addOperation:op1]; [queue2 addOperation:op2];&#125;/*** 售卖火车票(线程安全)*/- (void)saleTicketSafe &#123; while (1) &#123; // 加锁 [self.lock lock]; if (self.ticketSurplusCount &gt; 0) &#123; //如果还有票，继续售卖 self.ticketSurplusCount--; NSLog(@\"%@\", [NSString stringWithFormat:@\"剩余票数:%d 窗口:%@\", self.ticketSurplusCount, [NSThread currentThread]]); [NSThread sleepForTimeInterval:0.2]; &#125; // 解锁 [self.lock unlock]; if (self.ticketSurplusCount &lt;= 0) &#123; NSLog(@\"所有火车票均已售完\"); break; &#125; &#125;&#125; 运行结果 可以看出：在考虑了线程安全，使用 NSLock 加锁、解锁机制的情况下，得到的票数是正确的，没有出现混乱的情况。我们也就解决了多个线程同步的问题。 10）NSOperation、NSOperationQueue 常用属性和方法归纳 10.1）NSOperation 常用属性和方法 取消操作方法 -(void)cancel; 可取消操作，实质是标记 isCancelled 状态。判断操作状态方法 -(BOOL)isFinished; 判断操作是否已经结束。 -(BOOL)isCancelled; 判断操作是否已经标记为取消。 -(BOOL)isExecuting; 判断操作是否正在在运行。 -(BOOL)isReady; 判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。操作同步 -(void)waitUntilFinished; 阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。 -(void)setCompletionBlock:(void (^)(void))block; completionBlock 会在当前操作执行完毕时执行 completionBlock。 -(void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。 -(void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。 @property (readonly, copy) NSArray *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。 10.2 NSOperationQueue 常用属性和方法 取消/暂停/恢复操作 -(void)cancelAllOperations; 可以取消队列的所有操作。 -(BOOL)isSuspended; 判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态。 -(void)setSuspended:(BOOL)b; 可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列。操作同步 -(void)waitUntilAllOperationsAreFinished; 阻塞当前线程，直到队列中的操作全部执行完毕。添加/获取操作` -(void)addOperationWithBlock:(void (^)(void))block; 向队列中添加一个 NSBlockOperation 类型操作对象。 -(void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait; 向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束 -(NSArray *)operations; 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）。 -(NSUInteger)operationCount; 当前队列中的操作数。获取队列 +(id)currentQueue; 获取当前队列，如果当前线程不是在 NSOperationQueue 上运行则返回 nil。 +(id)mainQueue; 获取主队列。 注意：这里的暂停和取消（包括操作的取消和队列的取消）并不代表可以将当前的操作立即取消，而是当当前的操作执行完毕之后不再执行新的操作。暂停和取消的区别就在于：暂停操作之后还可以恢复操作，继续向下执行；而取消操作之后，所有的操作就清空了，无法再接着执行剩下的操作。 以上文章整理自：https://blog.csdn.net/sunnyboy9/article/details/19848031、https://www.jianshu.com/p/4b1d77054b35","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS Principle：Singleton","slug":"iOS Principle Singleton","date":"2018-06-08T13:56:27.000Z","updated":"2018-11-18T05:33:17.757Z","comments":true,"path":"2018/06/08/iOS Principle Singleton/","link":"","permalink":"https://reversescale.github.io/2018/06/08/iOS Principle Singleton/","excerpt":"SINGLETON—俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Singleton，她们只要说道“老公”，都是指的同一个人，那就是我。(刚才做了个梦啦，哪有这么好的事)~","text":"SINGLETON—俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Singleton，她们只要说道“老公”，都是指的同一个人，那就是我。(刚才做了个梦啦，哪有这么好的事)~ 👨🏻‍💻 Github Demo 方便记忆： 单例模式：确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式（通过防护措施，禁止其再创建其他实例） 安全保障：防止两个线程同时调用shareInstance，使用@synchronized锁定 GCD创建：dispatch_once中dispatch_once_t类型为typedef long onceToken= 0，线程执行dispatch_once的block中代码 onceToken= -1，线程跳过dispatch_once的block中代码不执行 onceToken= 其他值，线程被线程被阻塞，等待onceToken值改变 用途：限制创建，提供全局调用，节约资源和提高性能 常见的应用场景： UIApplication NSNotificationCenter NSFileManager NSUserDefaults NSURLCache NSHTTPCookieStorage 引文 《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书）是由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995）。这几位作者常被称为”四人组（Gang of Four）。 开篇引用 GoF 的示例帮助理解创建型设计模式——单例 单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。 单例的创建单线程单例我们知道对于单例类，我们必须留出一个接口来返回生成的单例，由于一个类中只能有一个实例，所以我们在第一次访问这个实例的时候创建，之后访问直接取已经创建好的实例 123456789@implementationSingleton+ (instancetype)shareInstance&#123; staticSingleton* single; if(!single) &#123; single = [[Singleton alloc] init]; &#125; return single;&#125;@end ps:严格意义上来说，我们还需要将alloc方法封住，因为严格的单例是不允许再创建其他实例的，而alloc方法可以在外部任意生成实例。但是考虑到alloc属于NSObject，iOS中无法将alloc变成私有方法，最多只能覆盖alloc让其返回空，不过这样做也可能会让使用接口的人误解，造成其他问题。所以我们一般情况下对alloc不做特殊处理。系统的单例也未对alloc做任何处理 @synchronized单例对于一个实例，我们一般并不能保证他一定会在单线程模式下使用，所以我们得适配多线程情况。在多线程情况下，上面的单例创建方式可能会出现问题。如果两个线程同时调用shareInstance,可能会创建出2个single来。所以对于多线程情况下，我们需要使用@synchronized来加锁。 1234567891011@implementationSingleton+ (instancetype)shareInstance&#123; staticSingleton* single; @synchronized(self) &#123; if(!single) &#123; single = [[Singleton alloc] init]; &#125; &#125; return single;&#125;@end 这样的话，当多个线程同时调用shareInstance时，由于@synchronized已经加锁，所以只能有一个线程进入创建single。这样就解决了多线程下调用单例的问题 dispatch_once单例使用@synchronized虽然解决了多线程的问题，但是并不完美。因为只有在single未创建时，我们加锁才是有必要的。如果single已经创建.这时候锁不仅没有好处，而且还会影响到程序执行的性能（多个线程执行@synchronized中的代码时，只有一个线程执行，其他线程需要等待）。那么有没有方法既可以解决问题，又不影响性能呢？这个方法就是GCD中的dispatch_once 123456789101112+ (SingletonManager*)shareManager &#123; static dispatch_once_t token; dispatch_once(&amp;token, ^&#123; if(defaultManager == nil) &#123; NSLog(@\"dispatch_once Token: %ld\",token); defaultManager = [[self alloc] init]; &#125; &#125;); NSLog(@\"Token: %ld\",token); NSLog(@\"DefaultManager: %@\",defaultManager); return defaultManager;&#125; 打印结果 dispatch_once 为什么能做到既解决同步多线程问题又不影响性能呢？下面我们来看看dispatch_once的原理： dispatch_once主要是根据onceToken的值来决定怎么去执行代码。 当onceToken= 0时，线程执行dispatch_once的block中代码 当onceToken= -1时，线程跳过dispatch_once的block中代码不执行 当onceToken为其他值时，线程被线程被阻塞，等待onceToken值改变 当线程首先调用shareInstance，某一线程要执行block中的代码时，首先需要改变onceToken的值，再去执行block中的代码。这里onceToken的值变为了768。 这样当其他线程再获取onceToken的值时，值已经变为768。其他线程被阻塞。 当block线程执行完block之后。onceToken变为-1。其他线程不再阻塞，跳过block。 下次再调用shareInstance时，block已经为-1。直接跳过block。 这样dispatch_once在首次调用时同步阻塞线程，生成单例之后，不再阻塞线程。 遇到问题：线程1和线程2，都在调用shareInstance方法来创建单例，那么线程1运行到if (_instance == nil)发现_instance = nil,那么就会初始化一个_instance，假设此时线程2也运行到if的判断处了，此时线程1还没有创建完成实例_instance，所以此时_instance = nil还是成立的，那么线程2又会创建一个_instace。 虽然使用互斥锁也可以解决多线程同时创建的问题，但是dispatch_once更为高效安全是解决这类问题的最优方案。 宏方法创建单例Singleton.h 中进行宏定义 12345678910111213141516171819202122232425262728293031323334// Singleton.h#import &lt;Foundation/Foundation.h&gt;#define SingletonH(name) + (instancetype)shared##name;#define SingletonM(name) \\static id _instance; \\\\+ (instancetype)allocWithZone:(struct _NSZone *)zone \\&#123; \\static dispatch_once_t onceToken; \\dispatch_once(&amp;onceToken, ^&#123; \\_instance = [super allocWithZone:zone]; \\&#125;); \\return _instance; \\&#125; \\\\+ (instancetype)shared##name \\&#123; \\static dispatch_once_t onceToken; \\dispatch_once(&amp;onceToken, ^&#123; \\_instance = [[self alloc] init]; \\&#125;); \\return _instance; \\&#125; \\\\- (id)copyWithZone:(NSZone *)zone \\&#123; \\return _instance; \\&#125;\\\\- (id)mutableCopyWithZone:(NSZone *)zone &#123; \\return _instance; \\&#125;@interface Singleton : NSObject@end 使用方法 ViewController.h 中 123456// ViewController.h#import &lt;UIKit/UIKit.h&gt;#import \"Singleton.h\" //宏方法@interface ViewController : UIViewControllerSingletonH(viewController)@end ViewController.m 中 123456SingletonM(ViewController)- (void)viewDidLoad &#123; [super viewDidLoad]; // 调用宏定义单例 NSLog(@\"地址打印：\\n%@\\n%@\\n%@\\n%@\", [ViewController sharedViewController], [ViewController sharedViewController], [[ViewController alloc] init], [[ViewController alloc] init]);&#125; 打印结果 打印结果可见地址相同 单例的用途1）单例模式用来限制一个类只能创建一个对象，那么此对象的属性可以存储全局共享的数据。所有类都可以访问、设置此单例对象中的属性数据； 2）如果一个类创建的时候非常的耗费资源或影响性能，那么此对象可以设置为单例以节约资源和提高性能。 单例类保证了应用程序的生命周期中有且仅有一个该类的实例对象，而且易于外界访问。 iOS 系统中使用的单例类 UIApplication NSNotificationCenter NSFileManager NSUserDefaults NSURLCache NSHTTPCookieStorage dispatch_once 原理剖析在IOS开发中，为保证单例在整个程序运行中只被初始化一次，单线程的时候，通过静态变量可以实现；但是多线程的出现，使得在如上面的极端条件下，单例也可能返回了不同的对象。如在单例初始化完成前，多个进程同时访问单例，那么这些进程可能都获得了不同的单例对象。 多线程保护下的单例初始化代码 12345678+ (instancetype)defaultObject&#123; static SharedObject *sharedObject = nil; static dispatch_once_t predicate; dispatch_once(&amp;predicate, ^&#123; sharedObject = [[SharedObject alloc] init]; &#125;); return sharedObject;&#125; 点击查看 dispatch_once_t 发现其是 typedef long 类型 静态变量在程序运行期间只被初始化一次，然后其在下一次被访问时，其值都是上次的值，其在除了这个初始化方法以外的任何地方都不能直接修改这两个变量的值。这是单例只被初始化一次的前提。 点击查看 dispatch_once 发现内部通过宏把 _dispatch_once 转化成 dispatch_once 查找到 _dispatch_once 函数，我们发现 DISPATCH_EXPECT 方法 ~0l 是长整型0按位取反，就是长整型的-1 GNUC 只代表gcc的主版本号，我们忽略它，剩下就是 DISPATCH_EXPECT(x, v) 了，DISPATCH_EXPECT(predicate, ~0l) 就是说，predicate 很可能是 ~0l ，而当 DISPATCH_EXPECT(*predicate, ~0l) 不是 ~0! 时 才调用真正的 dispatch_once 函数。 第一次运行，predicate的值是默认值0，按照逻辑，如果有两个进程同时运行到 dispatch_once 方法时，这个两个进程获取到的 predicate 值都是0，那么最终两个进程都会调用 最原始那个 dispatch_once 函数。 由此我再把上面的规则贴一遍，可以自己调试看看 当onceToken= 0时，线程执行dispatch_once的block中代码 当onceToken= -1时，线程跳过dispatch_once的block中代码不执行 当onceToken为其他值时，线程被线程被阻塞，等待onceToken值改变 以上文章整理自：http://www.cocoachina.com/ios/20160907/17497.html，https://www.jianshu.com/p/160d77888443，https://blog.csdn.net/mlibai/article/details/46945331","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS Principle：Runloop","slug":"iOS Principle Runloop","date":"2018-06-07T13:56:27.000Z","updated":"2018-11-18T05:30:32.020Z","comments":true,"path":"2018/06/07/iOS Principle Runloop/","link":"","permalink":"https://reversescale.github.io/2018/06/07/iOS Principle Runloop/","excerpt":"一个线程一次只能执行一个任务，执行完成后线程就会退出。RunLoop 机制能让线程随时处理事件但并不退出。这里说的随时是指：程序需要运行时就保持程序的持续运行，不需要的时候就进入休眠状态~","text":"一个线程一次只能执行一个任务，执行完成后线程就会退出。RunLoop 机制能让线程随时处理事件但并不退出。这里说的随时是指：程序需要运行时就保持程序的持续运行，不需要的时候就进入休眠状态~ 👨🏻‍💻 Github Demo 方便记忆： 实质作用：保证在需要的时候自己跑起来运行，在没有操作的时候就停下来休息 运行机制：启动主线程保证持续运行，处理触摸、定时器、Selector事件，空闲通知CPU释放资源 Runloop和线程关系：每个线程有对应runloop，线程结束时销毁 Mode：代表RunLoop的运行模式，启动是选择一种mode（currentMode），mode为空立即退出 Source1：基于Port通过内核和其他线程相互发送消息 Source0：触摸事件，PerformSelectors Timers：定时器，NSTimer Observer：监听器，用于监听RunLoop的状态 RunLoop 运行模式 kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行 UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响 UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用，会切换到kCFRunLoopDefaultMode GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到 kCFRunLoopCommonModes: 这是一个占位用的Mode，作为标记kCFRunLoopDefaultMode和UITrackingRunLoopMode用，并不是一种真正的Mode CFRunLoopObserverRef 监听RunLoop的状态改变 kCFRunLoopEntry:RunLoop进入 kCFRunLoopBeforeTimers:RunLoop要处理Timers了 kCFRunLoopBeforeSources:RunLoop要处理Sources了 kCFRunLoopBeforeWaiting:RunLoop要休息了 kCFRunLoopAfterWaiting:RunLoop醒来了 kCFRunLoopExit:RunLoop退出了 常见的应用场景： 常驻线程 自动释放池 AFNetworking的connection连接处理 TableView平滑滚动延迟加载图片 程序崩溃时自主处理例，如：弹出提示等 RunLoop简介运行循环，在程序运行过程中循环做一些事情，如果没有Runloop程序执行完毕就会立即退出，如果有Runloop程序会一直运行，并且时时刻刻在等待用户的输入操作。RunLoop可以在需要的时候自己跑起来运行，在没有操作的时候就停下来休息。能够充分节省CPU资源，提高程序性能。 RunLoop基本作用 1.保持程序持续运行，程序一启动就会开一个主线程，主线程一开起来就会跑一个主线程对应的RunLoop,RunLoop保证主线程不会被销毁，也就保证了程序的持续运行 2.处理App中的各种事件（比如：触摸事件，定时器事件，Selector事件等） 3.节省CPU资源，提高程序性能，程序运行起来时，当什么操作都没有做的时候，RunLoop就告诉CPU，现在没有事情做，我要去休息，这时CPU就会将其资源释放出来去做其他的事情，当有事情做的时候RunLoop就会立马起来去做事情 我们先通过API内一张图片来简单看一下RunLoop内部运行原理 通过图片可以看出，RunLoop在跑圈过程中，当接收到Input sources 或者 Timer sources时就会交给对应的处理方去处理。当没有事件消息传入的时候，RunLoop就休息了。这里只是简单的理解一下这张图，接下来我们来了解RunLoop对象和其一些相关类，来更深入的理解RunLoop运行流程。 RunLoop在哪里开启UIApplicationMain函数内启动了Runloop，程序不会马上退出，而是保持运行状态。因此每一个应用必须要有一个runloop，我们知道主线程一开起来，就会跑一个和主线程对应的RunLoop，那么RunLoop一定是在程序的入口main函数中开启。 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 进入UIApplicationMain 1UIKIT_EXTERN int UIApplicationMain(int argc, char *argv[], NSString * __nullable principalClassName, NSString * __nullable delegateClassName); 我们发现它返回的是一个int数，那么我们对main函数做一些修改 12345678int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; NSLog(@\"开始\"); int re = UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); NSLog(@\"结束\"); return re; &#125;&#125; 运行程序，我们发现只会打印开始，并不会打印结束，这说明在UIApplicationMain函数中，开启了一个和主线程相关的RunLoop，导致UIApplicationMain不会返回，一直在运行中，也就保证了程序的持续运行。我们来看到RunLoop的源码 12345678// 用DefaultMode启动void CFRunLoopRun(void) &#123; /* DOES CALLOUT */ int32_t result; do &#123; result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); CHECK_FOR_FORK(); &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);&#125; 我们发现RunLoop确实是do while通过判断result的值实现的。因此，我们可以把RunLoop看成一个死循环。如果没有RunLoop，UIApplicationMain函数执行完毕之后将直接返回，也就没有程序持续运行一说了。 RunLoop对象 Fundation框架（基于CFRunLoopRef的封装） NSRunLoop 对象 CoreFoundation CFRunLoopRef 对象 因为Fundation框架是基于CFRunLoopRef的一层OC封装，这里我们主要研究CFRunLoopRef源码 如何获得RunLoop对象Foundation12[NSRunLoop currentRunLoop]; // 获得当前线程的RunLoop对象[NSRunLoop mainRunLoop]; // 获得主线程的RunLoop对象 Core Foundation12CFRunLoopGetCurrent(); // 获得当前线程的RunLoop对象CFRunLoopGetMain(); // 获得主线程的RunLoop对象 RunLoop和线程间的关系 1.每条线程都有唯一的一个与之对应的RunLoop对象 2.RunLoop保存在一个全局的Dictionary里，线程作为key,RunLoop作为value 3.主线程的RunLoop已经自动创建好了，子线程的RunLoop需要主动创建 4.RunLoop在第一次获取时创建，在线程结束时销毁 通过源码查看上述对应 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 拿到当前Runloop 调用_CFRunLoopGet0CFRunLoopRef CFRunLoopGetCurrent(void) &#123; CHECK_FOR_FORK(); CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop); if (rl) return rl; return _CFRunLoopGet0(pthread_self());&#125;// 查看_CFRunLoopGet0方法内部CF_EXPORT CFRunLoopRef _CFRunLoopGet0(pthread_t t) &#123; if (pthread_equal(t, kNilPthreadT)) &#123; t = pthread_main_thread_np(); &#125; __CFLock(&amp;loopsLock); if (!__CFRunLoops) &#123; __CFUnlock(&amp;loopsLock); CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks); // 根据传入的主线程获取主线程对应的RunLoop CFRunLoopRef mainLoop = __CFRunLoopCreate(pthread_main_thread_np()); // 保存主线程 将主线程-key和RunLoop-Value保存到字典中 CFDictionarySetValue(dict, pthreadPointer(pthread_main_thread_np()), mainLoop); if (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (void * volatile *)&amp;__CFRunLoops)) &#123; CFRelease(dict); &#125; CFRelease(mainLoop); __CFLock(&amp;loopsLock); &#125; // 从字典里面拿，将线程作为key从字典里获取一个loop CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); __CFUnlock(&amp;loopsLock); // 如果loop为空，则创建一个新的loop，所以runloop会在第一次获取的时候创建 if (!loop) &#123; CFRunLoopRef newLoop = __CFRunLoopCreate(t); __CFLock(&amp;loopsLock); loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t)); // 创建好之后，以线程为key runloop为value，一对一存储在字典中，下次获取的时候，则直接返回字典内的runloop if (!loop) &#123; CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop); loop = newLoop; &#125; // don't release run loops inside the loopsLock, because CFRunLoopDeallocate may end up taking it __CFUnlock(&amp;loopsLock); CFRelease(newLoop); &#125; if (pthread_equal(t, pthread_self())) &#123; _CFSetTSD(__CFTSDKeyRunLoop, (void *)loop, NULL); if (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) &#123; _CFSetTSD(__CFTSDKeyRunLoopCntr, (void *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (void (*)(void *))__CFFinalizeRunLoop); &#125; &#125; return loop;&#125; 从上面的代码可以看出，线程和 RunLoop 之间是一一对应的，其关系是保存在一个 Dictionary 里。所以我们创建子线程RunLoop时，只需在子线程中获取当前线程的RunLoop对象即可 1[NSRunLoop currentRunLoop]; 如果不获取，那子线程就不会创建与之相关联的RunLoop，并且只能在一个线程的内部获取其 RunLoop[NSRunLoop currentRunLoop];方法调用时，会先看一下字典里有没有存子线程相对用的RunLoop，如果有则直接返回RunLoop，如果没有则会创建一个，并将与之对应的子线程存入字典中。当线程结束时，RunLoop会被销毁。 RunLoop结构体通过源码我们找到__CFRunLoop结构体123456789101112131415161718struct __CFRunLoop &#123; CFRuntimeBase _base; pthread_mutex_t _lock; /* locked for accessing mode list */ __CFPort _wakeUpPort; // used for CFRunLoopWakeUp Boolean _unused; volatile _per_run_data *_perRunData; // reset for runs of the run loop pthread_t _pthread; uint32_t _winthread; CFMutableSetRef _commonModes; CFMutableSetRef _commonModeItems; CFRunLoopModeRef _currentMode; CFMutableSetRef _modes; struct _block_item *_blocks_head; struct _block_item *_blocks_tail; CFAbsoluteTime _runTime; CFAbsoluteTime _sleepTime; CFTypeRef _counterpart;&#125;; 除一些记录性属性外，主要来看一下以下两个成员变量12CFRunLoopModeRef _currentMode;CFMutableSetRef _modes; CFRunLoopModeRef 其实是指向CFRunLoopMode结构体的指针，CFRunLoopMode结构体源码如下12345678910111213141516171819202122232425262728293031typedef struct __CFRunLoopMode *CFRunLoopModeRef;struct __CFRunLoopMode &#123; CFRuntimeBase _base; pthread_mutex_t _lock; /* must have the run loop locked before locking this */ CFStringRef _name; Boolean _stopped; char _padding[3]; CFMutableSetRef _sources0; CFMutableSetRef _sources1; CFMutableArrayRef _observers; CFMutableArrayRef _timers; CFMutableDictionaryRef _portToV1SourceMap; __CFPortSet _portSet; CFIndex _observerMask;#if USE_DISPATCH_SOURCE_FOR_TIMERS dispatch_source_t _timerSource; dispatch_queue_t _queue; Boolean _timerFired; // set to true by the source when a timer has fired Boolean _dispatchTimerArmed;#endif#if USE_MK_TIMER_TOO mach_port_t _timerPort; Boolean _mkTimerArmed;#endif#if DEPLOYMENT_TARGET_WINDOWS DWORD _msgQMask; void (*_msgPump)(void);#endif uint64_t _timerSoftDeadline; /* TSR */ uint64_t _timerHardDeadline; /* TSR */&#125;; 主要查看以下成员变量1234CFMutableSetRef _sources0;CFMutableSetRef _sources1;CFMutableArrayRef _observers;CFMutableArrayRef _timers; 通过上面分析我们知道，CFRunLoopModeRef代表RunLoop的运行模式，一个RunLoop包含若干个Mode，每个Mode又包含若干个Source0/Source1/Timer/Observer，而RunLoop启动时只能选择其中一个Mode作为currentMode。 Source1/Source0/Timers/Observer分别代表什么 Source1 : 基于Port的线程间通信Source0 : 触摸事件，PerformSelectors我们通过代码验证一下 123- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@\"点击了屏幕\");&#125; 打断点之后打印堆栈信息，当xcode工具区打印的堆栈信息不全时，可以在控制台通过“bt”指令打印完整的堆栈信息，由堆栈信息中可以发现，触摸事件确实是会触发Source0事件。 同样的方式验证performSelector堆栈信息 123dispatch_async(dispatch_get_global_queue(0, 0), ^&#123; [self performSelectorOnMainThread:@selector(test) withObject:nil waitUntilDone:YES];&#125;); 可以发现PerformSelectors同样是触发Source0事件 其实，当我们触发了事件（触摸/锁屏/摇晃等）后，由IOKit.framework生成一个 IOHIDEvent事件 IOKit是苹果的硬件驱动框架，由它进行底层接口的抽象封装与系统进行交互传递硬件感应的事件，并专门处理用户交互设备，由IOHIDServices和IOHIDDisplays两部分组成，其中IOHIDServices是专门处理用户交互的，它会将事件封装成IOHIDEvents对象 接着用mach port转发给需要的App进程，随后 Source1就会接收IOHIDEvent，之后再回调IOHIDEventSystemClientQueueCallback()，IOHIDEventSystemClientQueueCallback()内触发Source0，Source0 再触发 _UIApplicationHandleEventQueue()。所以触摸事件看到是在 Source0 内的。 Timers : 定时器，NSTimer通过代码验证123[NSTimer scheduledTimerWithTimeInterval:3.0 repeats:NO block:^(NSTimer * _Nonnull timer) &#123; NSLog(@\"NSTimer ---- timer调用了\");&#125;]; 打印完整堆栈信息 Observer : 监听器，用于监听RunLoop的状态详解RunLoop相关类及作用通过上面的分析，我们对RunLoop内部结构有了大致的了解，接下来来详细分析RunLoop的相关类。以下为Core Foundation中关于RunLoop的5个类 CFRunLoopRef - 获得当前RunLoop和主RunLoop CFRunLoopModeRef - RunLoop 运行模式，只能选择一种，在不同模式中做不同的操作 CFRunLoopSourceRef - 事件源，输入源 CFRunLoopTimerRef - 定时器时间 CFRunLoopObserverRef - 观察者 1）CFRunLoopModeRefCFRunLoopModeRef代表RunLoop的运行模式一个 RunLoop 包含若干个 Mode，每个Mode又包含若干个Source、Timer、Observer每次RunLoop启动时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode如果需要切换Mode，只能退出RunLoop，再重新指定一个Mode进入，这样做主要是为了分隔开不同组的Source、Timer、Observer，让其互不影响。如果Mode里没有任何Source0/Source1/Timer/Observer，RunLoop会立马退出如图所示： 注意：一种Mode中可以有多个Source(事件源，输入源，基于端口事件源例键盘触摸等) Observer(观察者，观察当前RunLoop运行状态) 和Timer(定时器事件源)。但是必须至少有一个Source或者Timer，因为如果Mode为空，RunLoop运行到空模式不会进行空转，就会立刻退出。 系统默认注册的5个Mode: RunLoop 有五种运行模式，其中常见的有1.2两种 kCFRunLoopDefaultMode：App的默认Mode，通常主线程是在这个Mode下运行 UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响 UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用，会切换到kCFRunLoopDefaultMode GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到 kCFRunLoopCommonModes: 这是一个占位用的Mode，作为标记kCFRunLoopDefaultMode和UITrackingRunLoopMode用，并不是一种真正的Mode Mode间的切换我们平时在开发中一定遇到过，当我们使用NSTimer每一段时间执行一些事情时滑动UIScrollView，NSTimer就会暂停，当我们停止滑动以后，NSTimer又会重新恢复的情况，我们通过一段代码来看一下代码中的注释也很重要，展示了我们探索的过程 123456789101112131415161718192021222324-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; // [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(show) userInfo:nil repeats:YES]; NSTimer *timer = [NSTimer timerWithTimeInterval:2.0 target:self selector:@selector(show) userInfo:nil repeats:YES]; // 加入到RunLoop中才可以运行 // 1. 把定时器添加到RunLoop中，并且选择默认运行模式NSDefaultRunLoopMode = kCFRunLoopDefaultMode // [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; // 当textFiled滑动的时候，timer失效，停止滑动时，timer恢复 // 原因：当textFiled滑动的时候，RunLoop的Mode会自动切换成UITrackingRunLoopMode模式，因此timer失效，当停止滑动，RunLoop又会切换回NSDefaultRunLoopMode模式，因此timer又会重新启动了 // 2. 当我们将timer添加到UITrackingRunLoopMode模式中，此时只有我们在滑动textField时timer才会运行 // [[NSRunLoop mainRunLoop] addTimer:timer forMode:UITrackingRunLoopMode]; // 3. 那个如何让timer在两个模式下都可以运行呢？ // 3.1 在两个模式下都添加timer 是可以的，但是timer添加了两次，并不是同一个timer // 3.2 使用站位的运行模式 NSRunLoopCommonModes标记，凡是被打上NSRunLoopCommonModes标记的都可以运行，下面两种模式被打上标签 //0 : &lt;CFString 0x10b7fe210 [0x10a8c7a40]&gt;&#123;contents = \"UITrackingRunLoopMode\"&#125; //2 : &lt;CFString 0x10a8e85e0 [0x10a8c7a40]&gt;&#123;contents = \"kCFRunLoopDefaultMode\"&#125; // 因此也就是说如果我们使用NSRunLoopCommonModes，timer可以在UITrackingRunLoopMode，kCFRunLoopDefaultMode两种模式下运行 [[NSRunLoop mainRunLoop] addTimer:timer forMode:NSRunLoopCommonModes]; NSLog(@\"%@\",[NSRunLoop mainRunLoop]);&#125;-(void)show &#123; NSLog(@\"-------\");&#125; 由上述代码可以看出，NSTimer不管用是因为Mode的切换，因为如果我们在主线程使用定时器，此时RunLoop的Mode为kCFRunLoopDefaultMode，即定时器属于kCFRunLoopDefaultMode，那么此时我们滑动ScrollView时，RunLoop的Mode会切换到UITrackingRunLoopMode，因此在主线程的定时器就不在管用了，调用的方法也就不再执行了，当我们停止滑动时，RunLoop的Mode切换回kCFRunLoopDefaultMode，所以NSTimer就又管用了。同样道理的还有ImageView的显示，我们直接来看代码，不再赘述了 1234567- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; NSLog(@\"%s\",__func__); // performSelector默认是在default模式下运行，因此在滑动ScrollView时，图片不会加载 // [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@\"abc\"] afterDelay:2.0 ]; // inModes: 传入Mode数组 [self.imageView performSelector:@selector(setImage:) withObject:[UIImage imageNamed:@\"abc\"] afterDelay:2.0 inModes:@[NSDefaultRunLoopMode,UITrackingRunLoopMode]];&#125; 使用GCD也可是创建计时器，而且更为精确我们来看一下代码 123456789101112131415161718192021222324252627282930- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; //创建队列 dispatch_queue_t queue = dispatch_get_global_queue(0, 0); //1.创建一个GCD定时器 /* 第一个参数:表明创建的是一个定时器 第四个参数:队列 */ dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); // 需要对timer进行强引用，保证其不会被释放掉，才会按时调用block块 // 局部变量，让指针强引用 self.timer = timer; //2.设置定时器的开始时间,间隔时间,精准度 /* 第1个参数:要给哪个定时器设置 第2个参数:开始时间 第3个参数:间隔时间 第4个参数:精准度 一般为0 在允许范围内增加误差可提高程序的性能 GCD的单位是纳秒 所以要*NSEC_PER_SEC */ dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 2.0 * NSEC_PER_SEC, 0 * NSEC_PER_SEC); //3.设置定时器要执行的事情 dispatch_source_set_event_handler(timer, ^&#123; NSLog(@\"---%@--\",[NSThread currentThread]); &#125;); // 启动 dispatch_resume(timer);&#125; 2）CFRunLoopSourceRef事件源（输入源）Source分为两种 Source0：非基于Port的 用于用户主动触发的事件（点击button 或点击屏幕） Source1：基于Port的 通过内核和其他线程相互发送消息（与内核相关） 触摸事件及PerformSelectors会触发Source0事件源在前文已经验证过，这里不在赘述 3）CFRunLoopObserverRef CFRunLoopObserverRef是观察者，能够监听RunLoop的状态改变 我们直接来看代码，给RunLoop添加监听者，监听其运行状态 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; //创建监听者 /* 第一个参数 CFAllocatorRef allocator：分配存储空间 CFAllocatorGetDefault()默认分配 第二个参数 CFOptionFlags activities：要监听的状态 kCFRunLoopAllActivities 监听所有状态 第三个参数 Boolean repeats：YES:持续监听 NO:不持续 第四个参数 CFIndex order：优先级，一般填0即可 第五个参数 回调 两个参数observer:监听者 activity:监听的事件 */ /* 所有事件 typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入RunLoop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), //即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6),// 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7),// 即将退出RunLoop kCFRunLoopAllActivities = 0x0FFFFFFFU &#125;; */ CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; switch (activity) &#123; case kCFRunLoopEntry: NSLog(@\"RunLoop进入\"); break; case kCFRunLoopBeforeTimers: NSLog(@\"RunLoop要处理Timers了\"); break; case kCFRunLoopBeforeSources: NSLog(@\"RunLoop要处理Sources了\"); break; case kCFRunLoopBeforeWaiting: NSLog(@\"RunLoop要休息了\"); break; case kCFRunLoopAfterWaiting: NSLog(@\"RunLoop醒来了\"); break; case kCFRunLoopExit: NSLog(@\"RunLoop退出了\"); break; default: break; &#125; &#125;); // 给RunLoop添加监听者 /* 第一个参数 CFRunLoopRef rl：要监听哪个RunLoop,这里监听的是主线程的RunLoop 第二个参数 CFRunLoopObserverRef observer 监听者 第三个参数 CFStringRef mode 要监听RunLoop在哪种运行模式下的状态 */ CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode); /* CF的内存管理（Core Foundation） 凡是带有Create、Copy、Retain等字眼的函数，创建出来的对象，都需要在最后做一次release GCD本来在iOS6.0之前也是需要我们释放的，6.0之后GCD已经纳入到了ARC中，所以我们不需要管了 */ CFRelease(observer);&#125; 我们来看一下输出 以上可以看出，Observer确实用来监听RunLoop的状态，包括唤醒，休息，以及处理各种事件。 RunLoop处理逻辑这时我们再来分析RunLoop的处理逻辑，就会简单明了很多，现在回头看官方文档RunLoop的处理逻辑，对RunLoop的处理逻辑有新的认识。 源码解析下面源码仅保留了主流程代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 共外部调用的公开的CFRunLoopRun方法，其内部会调用CFRunLoopRunSpecificvoid CFRunLoopRun(void) &#123; /* DOES CALLOUT */ int32_t result; do &#123; result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false); CHECK_FOR_FORK(); &#125; while (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);&#125;// 经过精简的 CFRunLoopRunSpecific 函数代码，其内部会调用__CFRunLoopRun函数SInt32 CFRunLoopRunSpecific(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) &#123; /* DOES CALLOUT */ // 通知Observers : 进入Loop // __CFRunLoopDoObservers内部会调用 __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__函数 if (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry); // 核心的Loop逻辑 result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode); // 通知Observers : 退出Loop if (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit); return result;&#125;// 精简后的 __CFRunLoopRun函数，保留了主要代码static int32_t __CFRunLoopRun(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) &#123; int32_t retVal = 0; do &#123; // 通知Observers：即将处理Timers __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers); // 通知Observers：即将处理Sources __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources); // 处理Blocks __CFRunLoopDoBlocks(rl, rlm); // 处理Sources0 if (__CFRunLoopDoSources0(rl, rlm, stopAfterHandle)) &#123; // 处理Blocks __CFRunLoopDoBlocks(rl, rlm); &#125; // 如果有Sources1，就跳转到handle_msg标记处 if (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, sizeof(msg_buffer), &amp;livePort, 0, &amp;voucherState, NULL)) &#123; goto handle_msg; &#125; // 通知Observers：即将休眠 __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting); // 进入休眠，等待其他消息唤醒 __CFRunLoopSetSleeping(rl); __CFPortSetInsert(dispatchPort, waitSet); do &#123; __CFRunLoopServiceMachPort(waitSet, &amp;msg, sizeof(msg_buffer), &amp;livePort, poll ? 0 : TIMEOUT_INFINITY, &amp;voucherState, &amp;voucherCopy); &#125; while (1); // 醒来 __CFPortSetRemove(dispatchPort, waitSet); __CFRunLoopUnsetSleeping(rl); // 通知Observers：已经唤醒 __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting); handle_msg: // 看看是谁唤醒了RunLoop，进行相应的处理 if (被Timer唤醒的) &#123; // 处理Timer __CFRunLoopDoTimers(rl, rlm, mach_absolute_time()); &#125; else if (被GCD唤醒的) &#123; __CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__(msg); &#125; else &#123; // 被Sources1唤醒的 __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply); &#125; // 执行Blocks __CFRunLoopDoBlocks(rl, rlm); // 根据之前的执行结果，来决定怎么做，为retVal赋相应的值 if (sourceHandledThisLoop &amp;&amp; stopAfterHandle) &#123; retVal = kCFRunLoopRunHandledSource; &#125; else if (timeout_context-&gt;termTSR &lt; mach_absolute_time()) &#123; retVal = kCFRunLoopRunTimedOut; &#125; else if (__CFRunLoopIsStopped(rl)) &#123; __CFRunLoopUnsetStopped(rl); retVal = kCFRunLoopRunStopped; &#125; else if (rlm-&gt;_stopped) &#123; rlm-&gt;_stopped = false; retVal = kCFRunLoopRunStopped; &#125; else if (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) &#123; retVal = kCFRunLoopRunFinished; &#125; &#125; while (0 == retVal); return retVal;&#125; 上述源代码中，相应处理事件函数内部还会调用更底层的函数，内部调用才是真正处理事件的函数，通过上面bt打印全部堆栈信息也可以得到验证。 1）CFRunLoopDoObservers 内部调用： CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__ 2）CFRunLoopDoBlocks 内部调用： CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__ 3）CFRunLoopDoSources0 内部调用： CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ 4）CFRunLoopDoTimers 内部调用： CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__ 5）GCD 调用：CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE 6）CFRunLoopDoSource1 内部调用： CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__ RunLoop处理逻辑流程图此时我们按照源码重新整理一下RunLoop处理逻辑就会很清晰 RunLoop 退出 1.主线程销毁RunLoop退出 2.Mode中有一些Timer 、Source、 Observer，这些保证Mode不为空时保证RunLoop没有空转并且是在运行的，当Mode中为空的时候，RunLoop会立刻退出 3.我们在启动RunLoop的时候可以设置什么时候停止 12[NSRunLoop currentRunLoop]runUntilDate:&lt;#(nonnull NSDate *)#&gt;[NSRunLoop currentRunLoop]runMode:&lt;#(nonnull NSString *)#&gt; beforeDate:&lt;#(nonnull NSDate *)#&gt; 相关问题一些有关Runloop的问题 1）基于NSTimer的轮播器什么情况下会被页面滚动暂停，怎样可以不被暂停，为什么？ NSTimer不管用是因为Mode的切换，因为如果我们在主线程使用定时器，此时RunLoop的Mode为kCFRunLoopDefaultMode，即定时器属于kCFRunLoopDefaultMode，那么此时我们滑动ScrollView时，RunLoop的Mode会切换到UITrackingRunLoopMode，因此在主线程的定时器就不在管用了，调用的方法也就不再执行了，当我们停止滑动时，RunLoop的Mode切换回kCFRunLoopDefaultMode，所有NSTimer就又管用了。若想定时器继续执行，需要将NSTimer 注册为 kCFRunLoopCommonModes 。 2）延迟执行performSelecter相关方法是怎样被执行的？在子线程中也是一样的吗？当调用 NSObject 的 performSelecter:afterDelay: 后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。 当调用 performSelector:onThread: 时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 RunLoop 该方法也会失效。 3）事件响应和手势识别底层处理是一致的吗，为什么？ 事件响应： 苹果注册了一个 Source1 (基于 mach port 的) 用来接收系统事件，其回调函数为 _IOHIDEventSystemClientQueueCallback()。当一个硬件事件(触摸/锁屏/摇晃等)发生后，首先由 IOKit.framework 生成一个 IOHIDEvent 事件并由 SpringBoard 接收。SpringBoard 只接收按键(锁屏/静音等)，触摸，加速，接近传感器等几种 Event，随后用 mach port 转发给需要的App进程。随后苹果注册的那个 Source1 就会触发回调，并调用 _UIApplicationHandleEventQueue() 进行应用内部的分发。 _UIApplicationHandleEventQueue() 会把 IOHIDEvent 处理并包装成 UIEvent 进行处理或分发，其中包括识别 UIGesture/处理屏幕旋转/发送给 UIWindow 等。通常事件比如 UIButton 点击、touchesBegin/Move/End/Cancel 事件都是在这个回调中完成的。 手势识别： 当上面的 _UIApplicationHandleEventQueue() 识别了一个手势时，其首先会调用 Cancel 将当前的 touchesBegin/Move/End 系列回调打断。随后系统将对应的 UIGestureRecognizer 标记为待处理。 苹果注册了一个 Observer 监测 BeforeWaiting (Loop即将进入休眠) 事件，这个Observer的回调函数是 _UIGestureRecognizerUpdateObserver()，其内部会获取所有刚被标记为待处理的 GestureRecognizer，并执行GestureRecognizer的回调。 当有 UIGestureRecognizer 的变化(创建/销毁/状态改变)时，这个回调都会进行相应处理。 4）界面刷新时，是在什么时候会真正执行刷新，为什么会刷新不及时？当在操作 UI 时，比如改变了 Frame、更新了 UIView/CALayer 的层次时，或者手动调用了 UIView/CALayer 的 setNeedsLayout/setNeedsDisplay方法后，这个 UIView/CALayer 就被标记为待处理，并被提交到一个全局的容器去。 苹果注册了一个 Observer 监听 BeforeWaiting(即将进入休眠) 和 Exit (即将退出Loop) 事件，回调去执行一个很长的函数： _ZN2CA11Transaction17observer_callbackEP19__CFRunLoopObservermPv()。这个函数里会遍历所有待处理的 UIView/CAlayer 以执行实际的绘制和调整，并更新 UI 界面。所以说界面刷新并不一定是在setNeedsLayout相关的代码执行后立刻进行的。 5）项目程序运行中，总是伴随着多次自动释放池的创建和销毁，这些是在什么时候发生的呢？ 系统就是通过@autoreleasepool {}这种方式来为我们创建自动释放池的，一个线程对应一个runloop，系统会为每一个runloop隐式的创建一个自动释放池，所有的autoreleasePool构成一个栈式结构，在每个runloop结束时，当前栈顶的autoreleasePool会被销毁，而且会对其中的每一个对象做一次release（严格来说，是你对这个对象做了几次autorelease就会做几次release，不一定是一次)，特别指出，使用容器的block版本的枚举器的时候，系统会自动添加一个autoreleasePool 123[array enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) &#123; // 这里被一个局部@autoreleasepool包围着 &#125;]; 6）当我们在子线程上需要执行代理方法或者回调时，怎么确保当前线程没有被销毁？首先引入一个概念：Event_loop，一般一个线程执行完任务后就会退出，当需要保证该线程不退出，可以通过类似以下方式： 1234567function do_loop() &#123; initialize(); do &#123; var message = get_next_message(); process_message(message); &#125; while (message != quit);&#125; 开启一个循环，保证线程不退出，这就是Event_loop模型。这是在很多操作系统中都使用的模型，例如OS/iOS中的RunLoop。这种模型最大的作用就是管理事件/消息，在有新消息到来时立刻唤醒处理，没有待处理消息时线程休眠，避免资源浪费。 RunLoop 使用场景1）常驻线程 常驻线程的作用：我们知道，当子线程中的任务执行完毕之后就被销毁了，那么如果我们需要开启一个子线程，在程序运行过程中永远都存在，那么我们就会面临一个问题，如何让子线程永远活着，这时就要用到常驻线程：给子线程开启一个RunLoop 注意：子线程执行完操作之后就会立即释放，即使我们使用强引用引用子线程使子线程不被释放，也不能给子线程再次添加操作，或者再次开启。 子线程开启RunLoop的代码，先点击屏幕开启子线程并开启子线程RunLoop，然后点击button。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; // 创建子线程并开启 NSThread *thread = [[NSThread alloc]initWithTarget:self selector:@selector(show) object:nil]; self.thread = thread; [thread start];&#125;- (void)show &#123; // 注意：打印方法一定要在RunLoop创建开始运行之前，如果在RunLoop跑起来之后打印，RunLoop先运行起来，已经在跑圈了就出不来了，进入死循环也就无法执行后面的操作了。 // 但是此时点击Button还是有操作的，因为Button是在RunLoop跑起来之后加入到子线程的，当Button加入到子线程RunLoop就会跑起来 NSLog(@\"%s\",__func__); // 1.创建子线程相关的RunLoop，在子线程中创建即可，并且RunLoop中要至少有一个Timer 或 一个Source 保证RunLoop不会因为空转而退出，因此在创建的时候直接加入 // 添加Source [NSMachPort port] 添加一个端口 [[NSRunLoop currentRunLoop] addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; // 添加一个Timer NSTimer *timer = [NSTimer scheduledTimerWithTimeInterval:2.0 target:self selector:@selector(test) userInfo:nil repeats:YES]; [[NSRunLoop currentRunLoop] addTimer:timer forMode:NSDefaultRunLoopMode]; //创建监听者 CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(CFAllocatorGetDefault(), kCFRunLoopAllActivities, YES, 0, ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; switch (activity) &#123; case kCFRunLoopEntry: NSLog(@\"RunLoop进入\"); break; case kCFRunLoopBeforeTimers: NSLog(@\"RunLoop要处理Timers了\"); break; case kCFRunLoopBeforeSources: NSLog(@\"RunLoop要处理Sources了\"); break; case kCFRunLoopBeforeWaiting: NSLog(@\"RunLoop要休息了\"); break; case kCFRunLoopAfterWaiting: NSLog(@\"RunLoop醒来了\"); break; case kCFRunLoopExit: NSLog(@\"RunLoop退出了\"); break; default: break; &#125; &#125;); // 给RunLoop添加监听者 CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode); // 2.子线程需要开启RunLoop [[NSRunLoop currentRunLoop]run]; CFRelease(observer);&#125;- (IBAction)btnClick:(id)sender &#123; [self performSelector:@selector(test) onThread:self.thread withObject:nil waitUntilDone:NO];&#125;- (void)test &#123; NSLog(@\"%@\",[NSThread currentThread]);&#125; 注意：创建子线程相关的RunLoop，在子线程中创建即可，并且RunLoop中要至少有一个Timer 或 一个Source 保证RunLoop不会因为空转而退出，因此在创建的时候直接加入，如果没有加入Timer或者Source，或者只加入一个监听者，运行程序会崩溃 2）自动释放池Timer和Source也是一些变量，需要占用一部分存储空间，所以要释放掉，如果不释放掉，就会一直积累，占用的内存也就越来越大，这显然不是我们想要的。 那么什么时候释放，怎么释放呢？ RunLoop内部有一个自动释放池，当RunLoop开启时，就会自动创建一个自动释放池，当RunLoop在休息之前会释放掉自动释放池的东西，然后重新创建一个新的空的自动释放池，当RunLoop被唤醒重新开始跑圈时，Timer,Source等新的事件就会放到新的自动释放池中，当RunLoop退出的时候也会被释放。 注意：只有主线程的RunLoop会默认启动。也就意味着会自动创建自动释放池，子线程需要在线程调度方法中手动添加自动释放池。 123@autorelease&#123; // 执行代码 &#125; 3）AFNetworking使用NSOperation+NSURLConnection并发模型都会面临NSURLConnection下载完成前线程退出导致NSOperation对象接收不到回调的问题。AFNetWorking解决这个问题的方法是按照官方的guid NSURLConnection 上写的NSURLConnection的delegate方法需要在connection发起的线程runloop中调用，于是AFNetWorking直接借鉴了Apple自己的一个Demo的实现方法单独起一个global thread，内置一个runloop，所有的connection都由这个runloop发起，回调也是它接收，不占用主线程，也不耗CPU资源。 12345678910111213141516171819202122+ (void)networkRequestThreadEntryPoint:(id)__unused object &#123; @autoreleasepool &#123; [[NSThread currentThread] setName:@\"AFNetworking\"]; NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode]; [runLoop run]; &#125;&#125;+ (NSThread *)networkRequestThread &#123; static NSThread *_networkRequestThread = nil; static dispatch_once_t oncePredicate; dispatch_once(&amp;oncePredicate, ^&#123; _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil]; [_networkRequestThread start]; &#125;); return _networkRequestThread;&#125; 类似的可以用这个方法创建一个常驻服务的线程。 4）TableView中实现平滑滚动延迟加载图片 利用CFRunLoopMode的特性，可以将图片的加载放到NSDefaultRunLoopMode的mode里，这样在滚动UITrackingRunLoopMode这个mode时不会被加载而影响到。12345UIImage *downloadedImage = ...;[self.imageView performSelector:@selector(setImage:) withObject:downloadedImage afterDelay:0 inModes:@[NSDefaultRunLoopMode]]; 5）接到程序崩溃时的信号进行自主处理例如弹出提示等1234567CFRunLoopRef runLoop = CFRunLoopGetCurrent();NSArray *allModes = CFBridgingRelease(CFRunLoopCopyAllModes(runLoop));while (1) &#123; for (NSString *mode in allModes) &#123; CFRunLoopRunInMode((CFStringRef)mode, 0.001, false); &#125;&#125; 6）异步测试12345678910111213141516171819202122- (BOOL)runUntilBlock:(BOOL(^)())block timeout:(NSTimeInterval)timeout&#123; __block Boolean fulfilled = NO; void (^beforeWaiting) (CFRunLoopObserverRef observer, CFRunLoopActivity activity) = ^(CFRunLoopObserverRef observer, CFRunLoopActivity activity) &#123; fulfilled = block(); if (fulfilled) &#123; CFRunLoopStop(CFRunLoopGetCurrent()); &#125; &#125;; CFRunLoopObserverRef observer = CFRunLoopObserverCreateWithHandler(NULL, kCFRunLoopBeforeWaiting, true, 0, beforeWaiting); CFRunLoopAddObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode); // Run! CFRunLoopRunInMode(kCFRunLoopDefaultMode, timeout, false); CFRunLoopRemoveObserver(CFRunLoopGetCurrent(), observer, kCFRunLoopDefaultMode); CFRelease(observer); return fulfilled;&#125; NSTimer、ImageView显示、PerformSelector等在上面已经有过例子，这里不再赘述。 以上文章整理自：https://juejin.im/post/5add46606fb9a07abf721d1d","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS Principle：KVO","slug":"iOS Principle KVO","date":"2018-06-06T13:56:27.000Z","updated":"2018-11-18T05:15:15.406Z","comments":true,"path":"2018/06/06/iOS Principle KVO/","link":"","permalink":"https://reversescale.github.io/2018/06/06/iOS Principle KVO/","excerpt":"KVO 的全称 Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变~","text":"KVO 的全称 Key-Value Observing，俗称“键值监听”，可以用于监听某个对象属性值的改变~ 👨🏻‍💻 Github Demo 方便记忆： 作用：“键值监听”，可以用于监听某个对象属性值的改变 实现原理： 将监听对象的isa指针指向NSKVONotifyin_类（runtime动态创建的子类） 先实现NSKVONotifyin_类的set方法，先willChangeValueForKey赋值 再didChangeValueForKey调用监听器，到observeValueForKeyPath的方法 引子 123@interface Person : NSObject@property (nonatomic, assign) int age;@end 对 Person 的 age 进行监听的使用方法： 123456789101112131415161718- (void)test_kvo &#123; Person *p1 = [[Person alloc] init]; Person *p2 = [[Person alloc] init]; p1.age = 1; p2.age = 2; NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld; [p1 addObserver:self forKeyPath:@\"age\" options:options context:nil]; p1.age = 10; [p1 removeObserver:self forKeyPath:@\"age\"];&#125;// kvo action- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123; NSLog(@\"监听到%@的%@改变了%@\", object, keyPath,change);&#125; 在添加监听之后，age属性的值在发生改变时，就会通知到监听者，执行监听者的observeValueForKeyPath方法。 探寻KVO底层实现原理通过上述代码我们发现，一旦age属性的值发生改变时，就会通知到监听者，并且我们知道赋值操作都是调用 set方法，我们可以来到Person类中重写age的set方法，观察是否是KVO在set方法内部做了一些操作来通知监听者。 我们发现即使重写了set方法，p1对象和p2对象调用同样的set方法，但是我们发现p1除了调用set方法之外还会另外执行监听器的observeValueForKeyPath方法。 说明KVO在运行时获取对p1对象做了一些改变。相当于在程序运行过程中，对p1对象做了一些变化，使得p1对象在调用setage方法的时候可能做了一些额外的操作，所以问题出在对象身上，两个对象在内存中肯定不一样，两个对象可能本质上并不一样。接下来来探索KVO内部是怎么实现的。 KVO底层实现分析首先我们对上述代码中添加监听的地方打断点，看观察一下，addObserver方法对p1对象做了什么处理？也就是说p1对象在经过addObserver方法之后发生了什么改变，我们通过打印isa指针如下图所示 通过上图我们发现，p1对象执行过addObserver操作之后，p1对象的isa指针由之前的指向类对象Person变为指向NSKVONotifyin_Person类对象，而p2对象没有任何改变。也就是说一旦p1对象添加了KVO监听以后，其isa指针就会发生变化，因此set方法的执行效果就不一样了。 那么我们先来观察p2对象在内容中是如何存储的，然后对比p2来观察p1。 首先我们知道，p2在调用setage方法的时候，首先会通过p2对象中的isa指针找到Person类对象，然后在类对象中找到setage方法。然后找到方法对应的实现。如下图所示 但是刚才我们发现p1对象的isa指针在经过KVO监听之后已经指向了NSKVONotifyin_Person类对象，NSKVONotifyin_Person其实是Person的子类，那么也就是说其superclass指针是指向Person类对象的，NSKVONotifyin_Person是runtime在运行时生成的。那么p1对象在调用setage方法的时候，肯定会根据p1的isa找到NSKVONotifyin_Person，在NSKVONotifyin_Person中找setage的方法及实现。 经过查阅资料我们可以了解到，NSKVONotifyin_Person中的setage方法中其实调用了 Fundation框架中C语言函数 _NSsetIntValueAndNotify，_NSsetIntValueAndNotify内部做的操作相当于，首先调用willChangeValueForKey 将要改变方法，之后调用父类的setage方法对成员变量赋值，最后调用didChangeValueForKey已经改变方法。didChangeValueForKey中会调用监听器的监听方法，最终来到监听者的observeValueForKeyPath方法中。 那么如何验证KVO真的如上面所讲的方式实现？首先经过之前打断点打印isa指针，我们已经验证了，在执行添加监听的方法时，会将isa指针指向一个通过runtime创建的Person的子类NSKVONotifyin_Person。另外我们可以通过打印方法实现的地址来看一下p1和p2的setage的方法实现的地址在添加KVO前后有什么变化。 12345678910111213&#123; [self methodForSelectorLogWithP1:p1 P2:p2]; NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld; [p1 addObserver:self forKeyPath:@\"age\" options:options context:nil]; [self methodForSelectorLogWithP1:p1 P2:p2];&#125;// kvo func to show working- (void)methodForSelectorLogWithP1:(NSObject *)p1 P2:(NSObject *)p2 &#123; NSLog(@\"添加KVO监听之前 - p1 = %p, p2 = %p\", [p1 methodForSelector: @selector(setAge:)],[p2 methodForSelector: @selector(setAge:)]);&#125; 我们发现在添加KVO监听之前，p1和p2的setAge方法实现的地址相同，而经过KVO监听之后，p1的setAge方法实现的地址发生了变化，我们通过打印方法实现来看一下前后的变化发现，确实如我们上面所讲的一样，p1的setAge方法的实现由Person类方法中的setAge方法转换为了C语言的Foundation框架的_NSsetIntValueAndNotify函数。 Foundation框架中会根据属性的类型，调用不同的方法。例如我们之前定义的int类型的age属性，那么我们看到Foundation框架中调用的_NSsetIntValueAndNotify函数。那么我们把age的属性类型变为double重新打印一遍 我们发现调用的函数变为了_NSSetDoubleValueAndNotify，那么这说明Foundation框架中有许多此类型的函数，通过属性的不同类型调用不同的函数。那么我们可以推测Foundation框架中还有很多例如_NSSetBoolValueAndNotify、_NSSetCharValueAndNotify、_NSSetFloatValueAndNotify、_NSSetLongValueAndNotify等等函数。我们可以找到Foundation框架文件，通过命令行查询关键字找到相关函数 NSKVONotifyin_Person内部结构是怎样的？首先我们知道，NSKVONotifyin_Person作为Person的子类，其superclass指针指向Person类，并且NSKVONotifyin_Person内部一定对setAge方法做了单独的实现，那么NSKVONotifyin_Person同Person类的差别可能就在于其内存储的对象方法及实现不同。我们通过runtime分别打印Person类对象和NSKVONotifyin_Person类对象内存储的对象方法 12345678910111213141516171819202122232425&#123; p1.age = 10; [self printMethods: object_getClass(p2)]; [self printMethods: object_getClass(p1)]; [p1 removeObserver:self forKeyPath:@\"age\"];&#125;// runtime to print class methods- (void)printMethods:(Class)cls &#123; unsigned int count ; Method *methods = class_copyMethodList(cls, &amp;count); NSMutableString *methodNames = [NSMutableString string]; [methodNames appendFormat:@\"%@ method list: \", cls]; for (int i = 0 ; i &lt; count; i++) &#123; Method method = methods[i]; NSString *methodName = NSStringFromSelector(method_getName(method)); [methodNames appendString:@\"\\n\"]; [methodNames appendString: methodName]; &#125; NSLog(@\"%@\",methodNames); free(methods);&#125; 上述打印内容如下 通过上述代码我们发现NSKVONotifyin_Person中有4个对象方法。分别为setAge: class dealloc _isKVOA，那么至此我们可以画出NSKVONotifyin_Person的内存结构以及方法调用顺序。 这里NSKVONotifyin_Person重写class方法是为了隐藏NSKVONotifyin_Person。不被外界所看到。我们在p1添加过KVO监听之后，分别打印p1和p2对象的class可以发现他们都返回Person。 1NSLog(@\"%@,%@\",[p1 class],[p2 class]); 如果NSKVONotifyin_Person不重写class方法，那么当对象要调用class对象方法的时候就会一直向上找来到nsobject，而nsobect的class的实现大致为返回自己isa指向的类，返回p1的isa指向的类那么打印出来的类就是NSKVONotifyin_Person，但是apple不希望将NSKVONotifyin_Person类暴露出来，并且不希望我们知道NSKVONotifyin_Person内部实现，所以在内部重写了class类，直接返回Person类，所以外界在调用p1的class对象方法时，是Person类。这样p1给外界的感觉p1还是Person类，并不知道NSKVONotifyin_Person子类的存在。那么我们可以猜测NSKVONotifyin_Person内重写的class内部实现大致为 1234- (Class) class &#123;// 得到类对象，在找到类对象父类 return class_getSuperclass(object_getClass(self));&#125; 验证验证 didChangeValueForKey:内部会调用observer的observeValueForKeyPath:ofObject:change:context:方法我们在Person类中重写willChangeValueForKey:和didChangeValueForKey:方法，模拟他们的实现。 1234567891011121314- (void)setAge:(int)age &#123; NSLog(@\"setAge:\"); _age = age;&#125;- (void)willChangeValueForKey:(NSString *)key &#123; NSLog(@\"willChangeValueForKey: - begin\"); [super willChangeValueForKey:key]; NSLog(@\"willChangeValueForKey: - end\");&#125;- (void)didChangeValueForKey:(NSString *)key &#123; NSLog(@\"didChangeValueForKey: - begin\"); [super didChangeValueForKey:key]; NSLog(@\"didChangeValueForKey: - end\");&#125; 再次运行来查看didChangeValueForKey的方法内运行过程，通过打印内容可以看到，确实在didChangeValueForKey方法内部已经调用了observer的observeValueForKeyPath:ofObject:change:context:方法。 如何手动调用 KVO被监听的属性的值被修改时，就会自动触发KVO。如果想要手动触发KVO，则需要我们自己调用willChangeValueForKey和didChangeValueForKey方法即可在不改变属性值的情况下手动触发KVO，并且这两个方法缺一不可。 123456789101112&#123; Person *p1 = [[Person alloc] init]; p1.age = 1.0; NSKeyValueObservingOptions options = NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld; [p1 addObserver:self forKeyPath:@\"age\" options:options context:nil]; [p1 willChangeValueForKey:@\"age\"]; [p1 didChangeValueForKey:@\"age\"]; [p1 removeObserver:self forKeyPath:@\"age\"];&#125; 通过打印我们可以发现，didChangeValueForKey方法内部成功调用了observeValueForKeyPath:ofObject:change:context:，并且age的值并没有发生改变。 小结当一个对象使用了KVO监听，iOS系统会修改这个对象的isa指针，改为指向一个全新的通过Runtime动态创建的子类，子类拥有自己的set方法实现，set方法实现内部会顺序调用willChangeValueForKey方法、原来的setter方法实现、didChangeValueForKey方法，而didChangeValueForKey方法内部又会调用监听器的observeValueForKeyPath:ofObject:change:context:监听方法。 以上文章整理自：https://juejin.im/post/5adab70cf265da0b736d37a8","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS Principle：Runtime","slug":"iOS Principle Runtime","date":"2018-06-05T13:56:27.000Z","updated":"2018-11-16T13:15:05.076Z","comments":true,"path":"2018/06/05/iOS Principle Runtime/","link":"","permalink":"https://reversescale.github.io/2018/06/05/iOS Principle Runtime/","excerpt":"Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石~","text":"Objective-C 扩展了 C 语言，并加入了面向对象特性和 Smalltalk 式的消息传递机制。而这个扩展的核心是一个用 C 和 编译语言 写的 Runtime 库。它是 Objective-C 面向对象和动态机制的基石~ 👨🏻‍💻 Github Demo 方便记忆 实质作用：从OC到C语言的过渡 消息传递方法：objec_msgSend 方法 objc_method 结构体内容：SEL method_name 方法名、char *method_types 方法类型、IMP method_imp 方法实现（方法指针） 消息转发：unrecognized selector 三次机会 动态方法解析：对象在接收到未知的消息时，首先会调用所属类的类方法+resolveInstanceMethod:(实例方法)或者+resolveClassMethod:(类方法)。 备用接收者：- (id)forwardingTargetForSelector:(SEL)aSelector;这是一个实例方法，因为是询问该实例对象是否有其他实例对象可以接收这个未知的selector，如果没有就返回nil 完整转发：- (void)forwardInvocation: (NSInvocation*)invocation;调用这个方法如果不能处理就会调用父类的相关方法，一直到NSObject的这个方法，如果NSObject都无法处理就会调用doesNotRecognizeSelector:方法抛出异常。 用途：做异常处理收集，避免crash，增强用户体验 常见的应用场景： 关联对象(Objective-C Associated Objects)：给分类增加属性 方法魔法(Method Swizzling)：方法添加和替换和KVO实现 消息转发(热更新)：解决Bug(JSPatch) 实现NSCoding的自动归档和自动解档 实现字典和模型的自动转换(MJExtension) Runtime 相关介绍Objective-C 是一个动态语言，这意味着它不仅需要一个编译器，也需要一个运行时系统来动态得创建类和对象、进行消息传递和转发。理解 Objective-C 的 Runtime 机制可以帮我们更好的了解这个语言，适当的时候还能对语言进行扩展，从系统层面解决项目中的一些设计或技术问题。 Runtime 版本演化Runtime其实有两个版本: “modern” 和 “legacy”。 我们现在用的 Objective-C 2.0 采用的是现行 (Modern) 版的 Runtime 系统，只能运行在 iOS 和 macOS 10.5 之后的 64 位程序中。 而 macOS 较老的32位程序仍采用 Objective-C 1.0 中的（早期）Legacy 版本的 Runtime 系统。 这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。 Runtime 实质作用高级编程语言想要成为可执行文件需要先编译为汇编语言再汇编为机器语言，机器语言也是计算机能够识别的唯一语言，但是OC并不能直接编译为汇编语言，而是要先转写为纯C语言再进行编译和汇编的操作，从OC到C语言的过渡就是由runtime来实现的。 然而我们使用OC进行面向对象开发，而C语言更多的是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。 OC 中一个对象方法1[obj foo]; 编译器转成消息发送1objc_msgSend(obj, foo) 在上段代码中 Runtime 的执行流程： 首先，通过obj的isa指针找到它的 class ; 在 class 的 method list 找 foo ; 如果 class 中没到 foo，继续往它的 superclass 中找 ; 一旦找到 foo 这个函数，就去执行它的实现IMP 。 objc_cache 缓存机制但是，上面这种实现有个问题，效率低。 一个class 往往只有 20% 的函数会被经常调用，可能占总调用次数的 80% 。每个消息都需要遍历一次objc_method_list 并不合理。如果把经常被调用的函数缓存下来，那可以大大提高函数查询的效率。 这也就是 objc_class 中另一个重要成员 objc_cache 做的事情，再找到 foo 之后，把 foo 的 method_name 作为key，method_imp 作为 value 给存起来。当再次收到 foo 消息的时候，可以直接在 cache 里找到，避免去遍历 objc_method_list。 从前面的源代码可以看到objc_cache是存在objc_class 结构体中的。 objec_msgSend 方法objec_msgSend的方法定义如下：1OBJC_EXPORT id objc_msgSend(id self, SEL op, ...) 那消息传递是怎么实现的呢？我们看看对象(object)，类(class)，方法(method)这几个的结构体：1234567891011121314151617181920212223242526272829303132333435//对象struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;//类struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;//方法列表struct objc_method_list &#123; struct objc_method_list *obsolete OBJC2_UNAVAILABLE; int method_count OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif /* variable length structure */ struct objc_method method_list[1] OBJC2_UNAVAILABLE;&#125; OBJC2_UNAVAILABLE;//方法struct objc_method &#123; SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE;&#125; 1.系统首先找到消息的接收对象，然后通过对象的isa找到它的类。 2.在它的类中查找method_list，是否有selector方法。 3.没有则查找父类的method_list。 4.找到对应的method，执行它的IMP。 5.转发IMP的return值。 消息传递用到的概念：类对象(objc_class)Objective-C类是由Class类型来表示的，它实际上是一个指向objc_class结构体的指针。1typedef struct objc_class *Class; 查看objc/runtime.h中objc_class结构体的定义如下：1234567891011121314struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE; struct objc_class结构体定义了很多变量，通过命名不难发现，结构体里保存了指向父类的指针、类的名字、版本、实例大小、实例变量列表、方法列表、缓存、遵守的协议列表等，一个类包含的信息也不就正是这些吗？ 没错，类对象就是一个结构体struct objc_class，这个结构体存放的数据称为元数据(metadata)，该结构体的第一个成员变量也是isa指针，这就说明了Class本身其实也是一个对象，因此我们称之为类对象，类对象在编译期产生用于创建实例对象，是单例。 实例(objc_object)123456/// Represents an instance of a class.struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;/// A pointer to an instance of a class.typedef struct objc_object *id; 类对象中的元数据存储的都是如何创建一个实例的相关信息，那么类对象和类方法应该从哪里创建呢？ 就是从isa指针指向的结构体创建，类对象的isa指针指向的我们称之为元类(metaclass)，元类中保存了创建类对象以及类方法所需的所有信息，因此整个结构应该如下图所示: 元类(Meta Class)通过上图我们可以看出整个体系构成了一个自闭环，struct objc_object结构体实例它的isa指针指向类对象，类对象的isa指针指向了元类，super_class指针指向了父类的类对象，而元类的super_class指针指向了父类的元类，那元类的isa指针又指向了自己。 元类(Meta Class)是一个类对象的类。在上面我们提到，所有的类自身也是一个对象，我们可以向这个对象发送消息(即调用类方法)。为了调用类方法，这个类的isa指针必须指向一个包含这些类方法的一个objc_class结构体。这就引出了meta-class的概念，元类中保存了创建类对象以及类方法所需的所有信息。任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。 Method(objc_method)先看下定义 12345678runtime.h/// An opaque type that represents a method in a class definition.代表类定义中一个方法的不透明类型typedef struct objc_method *Method;struct objc_method &#123; SEL method_name OBJC2_UNAVAILABLE; // 方法名 char *method_types OBJC2_UNAVAILABLE; // 方法类型 IMP method_imp OBJC2_UNAVAILABLE; // 方法实现&#125; Method和我们平时理解的函数是一致的，就是表示能够独立完成一个功能的一段代码，比如：123- (void)logName &#123; NSLog(@\"name\");&#125; 这段代码，就是一个函数。我们来看下objc_method这个结构体的内容： SEL method_name 方法名 char *method_types 方法类型 IMP method_imp 方法实现 在这个结构体重，我们已经看到了SEL和IMP，说明SEL和IMP其实都是Method的属性。我们接着来看SEL。 SEL(objc_selector)先看下定义123Objc.h/// An opaque type that represents a method selector.代表一个方法的不透明类型typedef struct objc_selector *SEL; objc_msgSend函数第二个参数类型为SEL，它是selector在Objective-C中的表示类型（Swift中是Selector类）。selector是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是SEL:1@property SEL selector; 可以看到selector是SEL的一个实例。1A method selector is a C string that has been registered (or “mapped“) with the Objective-C runtime. Selectors generated by the compiler are automatically mapped by the runtime when the class is loaded. 其实selector就是个映射到方法的C字符串，你可以用 Objective-C 编译器命令@selector()或者 Runtime 系统的sel_registerName函数来获得一个 SEL 类型的方法选择器。 selector既然是一个string，我觉得应该是类似className+method的组合，命名规则有两条： 同一个类，selector不能重复 不同的类，selector可以重复 这也带来了一个弊端，我们在写C代码的时候，经常会用到函数重载，就是函数名相同，参数不同，但是这在Objective-C中是行不通的，因为selector只记了method的name，没有参数，所以没法区分不同的method。比如：12- (void)caculate(NSInteger)num;- (void)caculate(CGFloat)num; 是会报错的。 我们只能通过命名来区别：12- (void)caculateWithInt(NSInteger)num;- (void)caculateWithFloat(CGFloat)num; 在不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器。 IMP看下IMP的定义 12/// A pointer to the function of a method implementation. 指向一个方法实现的指针typedef id (*IMP)(id, SEL, ...); 就是指向最终实现程序的内存地址的指针。 在iOS的Runtime中，Method通过selector和IMP两个属性，实现了快速查询方法及实现，相对提高了性能，又保持了灵活性。 类缓存(objc_cache)当Objective-C运行时通过跟踪它的isa指针检查对象时，它可以找到一个实现许多方法的对象。然而，你可能只调用它们的一小部分，并且每次查找时，搜索所有选择器的类分派表没有意义。所以类实现一个缓存，每当你搜索一个类分派表，并找到相应的选择器，它把它放入它的缓存。所以当objc_msgSend查找一个类的选择器，它首先搜索类缓存。这是基于这样的理论：如果你在类上调用一个消息，你可能以后再次调用该消息。 为了加速消息分发， 系统会对方法和对应的地址进行缓存，就放在上述的objc_cache，所以在实际运行中，大部分常用的方法都是会被缓存起来的，Runtime系统实际上非常快，接近直接执行内存地址的程序速度。 Category(objc_category)Category是表示一个指向分类的结构体的指针，其定义如下：12345678struct category_t &#123; const char *name; classref_t cls; struct method_list_t *instanceMethods; struct method_list_t *classMethods; struct protocol_list_t *protocols; struct property_list_t *instanceProperties;&#125;; name：是指 class_name 而不是 category_name。 cls：要扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对应到对应的类对象。 instanceMethods：category中所有给类添加的实例方法的列表。 classMethods：category中所有添加的类方法的列表。 protocols：category实现的所有协议的列表。 instanceProperties：表示Category里所有的properties，这就是我们可以通过objc_setAssociatedObject和objc_getAssociatedObject增加实例变量的原因，不过这个和一般的实例变量是不一样的。 从上面的category_t的结构体中可以看出，分类中可以添加实例方法，类方法，甚至可以实现协议，添加属性，不可以添加成员变量。 Runtime消息转发前文介绍了进行一次发送消息会在相关的类对象中搜索方法列表，如果找不到则会沿着继承树向上一直搜索知道继承树根部（通常为NSObject），如果还是找不到并且消息转发都失败了就回执行doesNotRecognizeSelector:方法报unrecognized selector错。那么消息转发到底是什么呢？接下来将会逐一介绍最后的三次机会。 第一次机会: 所属类动态方法解析对象在接收到未知的消息时，首先会调用所属类的类方法+resolveInstanceMethod:(实例方法)或者+resolveClassMethod:(类方法)。1+(BOOL)resolveInstanceMethod:(SEL)name 动态转发1BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types); 第一个参数是需要添加方法的类，第二个参数是一个selector，也就是实例方法的名字，第三个参数是一个IMP类型的变量也就是函数实现，需要传入一个C函数，这个函数至少有两个参数，一个是id self一个是SEL _cmd，第四个参数是函数类型。 实现一个动态方法解析的例子如下：12345678910111213141516- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //执行foo函数 [self performSelector:@selector(foo:)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; if (sel == @selector(foo:)) &#123;//如果是执行foo函数，就动态解析，指定新的IMP class_addMethod([self class], sel, (IMP)fooMethod, \"v@:\"); return YES; &#125; return [super resolveInstanceMethod:sel];&#125;void fooMethod(id obj, SEL _cmd) &#123; NSLog(@\"Doing foo\");//新的foo函数&#125; 打印结果： 2018-04-01 12:23:35.952670+0800 ocram[87546:23235469] Doing foo 可以看到虽然没有实现foo:这个函数，但是我们通过class_addMethod动态添加fooMethod函数，并执行fooMethod这个函数的IMP。从打印结果看，成功实现了。 如果resolve方法返回 NO ，运行时就会移到下一步：forwardingTargetForSelector。 第二次机会: 备援接收者动态方法解析无法处理消息，则会走备用接受者。这个备用接受者只能是一个新的对象，不能是self本身，否则就会出现无限循环。如果我们没有指定相应的对象来处理aSelector，则应该调用父类的实现来返回结果。1- (id)forwardingTargetForSelector:(SEL)aSelector; 该方法的参数就是那个未知的selector，这是一个实例方法，因为是询问该实例对象是否有其他实例对象可以接收这个未知的selector，如果没有就返回nil，可以自行实验。 实现一个备用接收者的例子如下：12345678910111213141516171819202122232425262728293031323334353637#import \"ViewController.h\"#import \"objc/runtime.h\"@interface Person: NSObject@end@implementation Person- (void)foo &#123; NSLog(@\"Doing foo\");//Person的foo函数&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //执行foo函数 [self performSelector:@selector(foo)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; return YES;//返回YES，进入下一步转发&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123; if (aSelector == @selector(foo)) &#123; return [Person new];//返回Person对象，让Person对象接收这个消息 &#125; return [super forwardingTargetForSelector:aSelector];&#125;@end 打印结果： 2018-04-01 12:45:04.757929+0800 ocram[88023:23260346] Doing foo 可以看到我们通过forwardingTargetForSelector把当前ViewController的方法转发给了Person去执行了。打印结果也证明我们成功实现了转发。 如果在这一步还不能处理未知消息，则唯一能做的就是启用完整的消息转发机制了。 第三次机会: 消息重定向如果动态方法解析和备用接受者都没有处理这个消息，那么就会走完整消息转发。 首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。 如果-methodSignatureForSelector:返回nil ，Runtime则会发出 -doesNotRecognizeSelector: 消息，程序这时也就挂掉了。 如果返回了一个函数签名，Runtime就会创建一个NSInvocation 对象并发送 -forwardInvocation:消息给目标对象。 1- (void)forwardInvocation: (NSInvocation*)invocation; 调用这个方法如果不能处理就会调用父类的相关方法，一直到NSObject的这个方法，如果NSObject都无法处理就会调用doesNotRecognizeSelector:方法抛出异常。 实现一个完整转发的例子如下：123456789101112131415161718192021222324252627282930313233343536373839404142#import \"ViewController.h\"#import \"objc/runtime.h\"@interface Person: NSObject@end@implementation Person- (void)foo &#123; NSLog(@\"Doing foo\");//Person的foo函数&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. //执行foo函数 [self performSelector:@selector(foo)];&#125;+ (BOOL)resolveInstanceMethod:(SEL)sel &#123; return YES;//返回YES，进入下一步转发&#125;- (id)forwardingTargetForSelector:(SEL)aSelector &#123; return nil;//返回nil，进入下一步转发&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; if ([NSStringFromSelector(aSelector) isEqualToString:@\"foo\"]) &#123; return [NSMethodSignature signatureWithObjCTypes:\"v@:\"];//签名，进入forwardInvocation &#125; return [super methodSignatureForSelector:aSelector];&#125;- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; SEL sel = anInvocation.selector; Person *p = [Person new]; if([p respondsToSelector:sel]) &#123; [anInvocation invokeWithTarget:p]; &#125; else &#123; [self doesNotRecognizeSelector:sel]; &#125;&#125;@end 打印结果：2018-04-01 13:00:45.423385+0800 ocram[88353:23279961] Doing foo 从打印结果来看，我们实现了完整的转发。通过签名，Runtime生成了一个对象anInvocation，发送给了forwardInvocation，我们在forwardInvocation方法里面让Person对象去执行了foo函数。 签名参数v@:怎么解释呢，这里苹果文档Type Encodings有详细的解释。Type Encodings: https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1 以上就是Runtime的三次转发流程。下面我们讲讲Runtime的实际应用。 Runtime应用Runtime简直就是做大型框架的利器。它的应用场景非常多，下面就介绍一些常见的应用场景。 关联对象(Objective-C Associated Objects)：给分类增加属性 方法魔法(Method Swizzling)：方法添加和替换和KVO实现 消息转发(热更新)：解决Bug(JSPatch) 实现NSCoding的自动归档和自动解档 实现字典和模型的自动转换(MJExtension) 1）关联对象(Objective-C Associated Objects)：给分类增加属性 我们都是知道分类是不能自定义属性和变量的。下面通过关联对象实现给分类添加属性。关联对象Runtime提供了下面几个接口：123456//关联对象void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)//获取关联的对象id objc_getAssociatedObject(id object, const void *key)//移除关联的对象void objc_removeAssociatedObjects(id object) 参数解释1234id object：被关联的对象const void *key：关联的key，要求唯一id value：关联的对象objc_AssociationPolicy policy：内存管理的策略 这里插一下内存管理的策略相关知识，防懵逼 😳1234567891011typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN = 0, /**&lt; Specifies a weak reference to the associated object. */ OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**&lt; Specifies a strong reference to the associated object. * The association is not made atomically. */ OBJC_ASSOCIATION_COPY_NONATOMIC = 3, /**&lt; Specifies that the associated object is copied. * The association is not made atomically. */ OBJC_ASSOCIATION_RETAIN = 01401, /**&lt; Specifies a strong reference to the associated object. * The association is made atomically. */ OBJC_ASSOCIATION_COPY = 01403 /**&lt; Specifies that the associated object is copied. * The association is made atomically. */&#125;; 我们看看内存测量对于的属性修饰 下面实现一个UIView的Category添加自定义属性defaultColor12345678910111213141516171819202122232425262728293031323334#import \"ViewController.h\"#import \"objc/runtime.h\"@interface UIView (DefaultColor)@property (nonatomic, strong) UIColor *defaultColor;@end@implementation UIView (DefaultColor)@dynamic defaultColor;static char kDefaultColorKey;- (void)setDefaultColor:(UIColor *)defaultColor &#123; objc_setAssociatedObject(self, &amp;kDefaultColorKey, defaultColor, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (id)defaultColor &#123; return objc_getAssociatedObject(self, &amp;kDefaultColorKey);&#125;@end@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. UIView *test = [UIView new]; test.defaultColor = [UIColor blackColor]; NSLog(@\"%@\", test.defaultColor);&#125;@end 打印结果： 2018-04-01 15:41:44.977732+0800 ocram[2053:63739] UIExtendedGrayColorSpace 0 1 打印结果来看，我们成功在分类上添加了一个属性，实现了它的setter和getter方法。 通过关联对象实现的属性的内存管理也是有ARC管理的，所以我们只需要给定适当的内存策略就行了，不需要操心对象的释放。 2）方法魔法(Method Swizzling)：方法添加和替换和KVO实现 方法添加 实际上添加方法刚才在讲消息转发的时候，动态方法解析的时候就提到了。 12//class_addMethod(Class _Nullable __unsafe_unretained cls, SEL _Nonnull name, IMP _Nonnull imp, const char * _Nullable types)class_addMethod([self class], sel, (IMP)fooMethod, \"v@:\"); cls 被添加方法的类 name 添加的方法的名称的SEL imp 方法的实现。该函数必须至少要有两个参数，self,_cmd 类型编码 方法替换 下面实现一个替换ViewController的viewDidLoad方法的例子。 123456789101112131415161718192021222324252627282930@implementation ViewController+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; SEL originalSelector = @selector(viewDidLoad); SEL swizzledSelector = @selector(jkviewDidLoad); Method originalMethod = class_getInstanceMethod(class,originalSelector); Method swizzledMethod = class_getInstanceMethod(class,swizzledSelector); //judge the method named swizzledMethod is already existed. BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); // if swizzledMethod is already existed. if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;- (void)jkviewDidLoad &#123; NSLog(@\"替换的方法\"); [self jkviewDidLoad];&#125;- (void)viewDidLoad &#123; NSLog(@\"自带的方法\"); [super viewDidLoad];&#125;@end swizzling应该只在+load中完成。 在 Objective-C 的运行时中，每个类有两个方法都会自动调用。+load 是在一个类被初始装载时调用，+initialize 是在应用第一次调用该类的类方法或实例方法前调用的。两个方法都是可选的，并且只有在方法被实现的情况下才会被调用。 swizzling应该只在dispatch_once 中完成,由于swizzling 改变了全局的状态，所以我们需要确保每个预防措施在运行时都是可用的。原子操作就是这样一个用于确保代码只会被执行一次的预防措施，就算是在不同的线程中也能确保代码只执行一次。Grand Central Dispatch 的 dispatch_once满足了所需要的需求，并且应该被当做使用swizzling 的初始化单例方法的标准。 实现图解如下图 从图中可以看出，我们通过swizzling特性，将selectorC的方法实现IMPc与selectorN的方法实现IMPn交换了，当我们调用selectorC，也就是给对象发送selectorC消息时，所查找到的对应的方法实现就是IMPn而不是IMPc了。 KVO 实现 全称是Key-value observing，翻译成键值观察。提供了一种当其它对象属性被修改的时候能通知当前对象的机制。再MVC大行其道的Cocoa中，KVO机制很适合实现model和controller类之间的通讯。 KVO的实现依赖于 Objective-C 强大的 Runtime，当观察某对象 A 时，KVO 机制动态创建一个对象A当前类的子类，并为这个新的子类重写了被观察属性 keyPath 的 setter 方法。setter 方法随后负责通知观察对象属性的改变状况。 Apple 使用了 isa-swizzling 来实现 KVO 。当观察对象A时，KVO机制动态创建一个新的名为：NSKVONotifying_A的新类，该类继承自对象A的本类，且 KVO 为 NSKVONotifying_A 重写观察属性的 setter 方法，setter 方法会负责在调用原 setter 方法之前和之后，通知所有观察对象属性值的更改情况。 NSKVONotifying_A 类剖析 12NSLog(@\"self-&gt;isa:%@\",self-&gt;isa); NSLog(@\"self class:%@\",[self class]); 在建立KVO监听前，打印结果为： 12self-&gt;isa:Aself class:A 在建立KVO监听之后，打印结果为： 12self-&gt;isa:NSKVONotifying_Aself class:A 在这个过程，被观察对象的 isa 指针从指向原来的 A 类，被KVO 机制修改为指向系统新创建的子类NSKVONotifying_A 类，来实现当前类属性值改变的监听；所以当我们从应用层面上看来，完全没有意识到有新的类出现，这是系统“隐瞒”了对 KVO 的底层实现过程，让我们误以为还是原来的类。但是此时如果我们创建一个新的名为“NSKVONotifying_A”的类，就会发现系统运行到注册 KVO 的那段代码时程序就崩溃，因为系统在注册监听的时候动态创建了名为 NSKVONotifying_A 的中间类，并指向这个中间类了。 子类setter方法剖析 KVO 的键值观察通知依赖于 NSObject 的两个方法:willChangeValueForKey:和 didChangeValueForKey: ，在存取数值的前后分别调用 2 个方法： 被观察属性发生改变之前，willChangeValueForKey:被调用，通知系统该 keyPath 的属性值即将变更 当改变发生后， didChangeValueForKey: 被调用，通知系统该keyPath 的属性值已经变更 之后， observeValueForKey:ofObject:change:context:也会被调用。且重写观察属性的setter 方法这种继承方式的注入是在运行时而不是编译时实现的。 KVO 为子类的观察者属性重写调用存取方法的工作原理在代码中相当于： 12345- (void)setName:(NSString *)newName &#123; [self willChangeValueForKey:@\"name\"]; //KVO 在调用存取方法之前总调用 [super setValue:newName forKey:@\"name\"]; //调用父类的存取方法 [self didChangeValueForKey:@\"name\"]; //KVO 在调用存取方法之后总调用&#125; 3）消息转发(热更新)：解决Bug(JSPatch) JSPatch 是一个 iOS 动态更新框架，只需在项目中引入极小的引擎，就可以使用 JavaScript 调用任何 Objective-C 原生接口，获得脚本语言的优势：为项目动态添加模块，或替换项目原生代码动态修复 bug。 关于消息转发，前面已经讲到过了，消息转发分为三级，我们可以在每级实现替换功能，实现消息转发，从而不会造成崩溃。JSPatch不仅能够实现消息转发，还可以实现方法添加、替换能一系列功能。 4）实现NSCoding的自动归档和自动解档 原理描述：用runtime提供的函数遍历Model自身所有属性，并对属性进行encode和decode操作。 核心方法：在Model的基类中重写方法： 123456789101112131415161718192021- (id)initWithCoder:(NSCoder *)aDecoder &#123; if (self = [super init]) &#123; unsigned int outCount; Ivar * ivars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar ivar = ivars[i]; NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)]; [self setValue:[aDecoder decodeObjectForKey:key] forKey:key]; &#125; &#125; return self;&#125;- (void)encodeWithCoder:(NSCoder *)aCoder &#123; unsigned int outCount; Ivar * ivars = class_copyIvarList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; Ivar ivar = ivars[i]; NSString * key = [NSString stringWithUTF8String:ivar_getName(ivar)]; [aCoder encodeObject:[self valueForKey:key] forKey:key]; &#125;&#125; 5）实现字典和模型的自动转换(MJExtension) 原理描述：用runtime提供的函数遍历Model自身所有属性，如果属性在json中有对应的值，则将其赋值。 核心方法：在NSObject的分类中添加方法 1234567891011121314151617181920212223242526272829303132- (instancetype)initWithDict:(NSDictionary *)dict &#123; if (self = [self init]) &#123; //(1)获取类的属性及属性对应的类型 NSMutableArray * keys = [NSMutableArray array]; NSMutableArray * attributes = [NSMutableArray array]; /* * 例子 * name = value3 attribute = T@\"NSString\",C,N,V_value3 * name = value4 attribute = T^i,N,V_value4 */ unsigned int outCount; objc_property_t * properties = class_copyPropertyList([self class], &amp;outCount); for (int i = 0; i &lt; outCount; i ++) &#123; objc_property_t property = properties[i]; //通过property_getName函数获得属性的名字 NSString * propertyName = [NSString stringWithCString:property_getName(property) encoding:NSUTF8StringEncoding]; [keys addObject:propertyName]; //通过property_getAttributes函数可以获得属性的名字和@encode编码 NSString * propertyAttribute = [NSString stringWithCString:property_getAttributes(property) encoding:NSUTF8StringEncoding]; [attributes addObject:propertyAttribute]; &#125; //立即释放properties指向的内存 free(properties); //(2)根据类型给属性赋值 for (NSString * key in keys) &#123; if ([dict valueForKey:key] == nil) continue; [self setValue:[dict valueForKey:key] forKey:key]; &#125; &#125; return self;&#125; 以上就是 Runtime 的底层原理，Runtime 也可以说是很多 iOS 特性的动效支撑。 以上文章整理自：https://juejin.im/post/5ac0a6116fb9a028de44d717","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS Principle：NamedTypes","slug":"iOS Principle NamedTypes","date":"2018-06-04T13:56:27.000Z","updated":"2018-11-16T13:10:20.545Z","comments":true,"path":"2018/06/04/iOS Principle NamedTypes/","link":"","permalink":"https://reversescale.github.io/2018/06/04/iOS Principle NamedTypes/","excerpt":"在开发过程中常常需要用到系统提供的基础类型之外的的类型，Swift 作为一款成长中的语言，自然敏锐的注意到这一点，所以 Swift 允许我们根据自己的需要构建属于自己的类型系统，以便于更加灵活和方便的开发程序并其称之为named types~","text":"在开发过程中常常需要用到系统提供的基础类型之外的的类型，Swift 作为一款成长中的语言，自然敏锐的注意到这一点，所以 Swift 允许我们根据自己的需要构建属于自己的类型系统，以便于更加灵活和方便的开发程序并其称之为named types~ 👨🏻‍💻 Github Demo 方便记忆 Named types 的四种类型：enum、struct、class、protocol enum：值类型，一组有限种可能性的相关值提供的通用类型 struct：值类型，一系列具有相同类型或不同类型的数据构成的数据集合 class：引用类型，类可继承，允许类型转换，有引用计数，析构方法释放资源 protocol：引用类型，协议中没有属性和方法的实现，可以当做类型来使用 Named types 的四种类型 enum struct class protocol 相比于 Objective-C 中的这三者，Swift 将 enum 和 struct 变得更加灵活且强大，并且赋予了他们很多和class 相似的属性实现更加丰富多彩的功能。 本文重点介绍在 Swift 中 enum 和 struct 的定义和新特性以及两者与 class 之间的异同。 枚举（enum）Swift 中的枚举的定义与C家族有些许不同，Swift 中枚举定义是“为一组有限种可能性的相关值提供的通用类型”，而在 C/C++/C# 中，“枚举是一个被命名的整型常数的集合”。 使用枚举可以类型安全并且有提示性地操作这些值。与结构体、类相似，使用关键词enum来定义枚举，并在一对大括号内定义具体内容包括使用case关键字列举成员。 就像下面一样： 12345enum StudentType &#123; case pupils case middleSchoolStudent case collegeStudent&#125; 上面的代码可以读作：如果存在一个StudentType的实例，他要么是pupils （小学生）、要么是middleSchoolStudent（中学生）、要么是collegeStudent（大学生）。 和C、objective-c中枚举的不同，Swift 中的枚举成员在被创建时不会分配一个默认的整数值。而且不强制要求给枚举中的每一个成员都提供值。 如果一个值（所谓“原始值”）要被提供给每一个枚举成员，那么这个值可以是字符串、字符、任意的整数值，或者是浮点类型。 Swift中定义的枚举只需要帮助我们表明不同的情况就够了，他的成员可以没有值，也可以有其他类型的值，不像 OC 中枚举值只局限于整数类型，缺点就是你再回去写 OC 时可能会不习惯。 枚举中有两个很容易混淆的概念：原始值(raw value)、关联值(associated value)，两个词听起来比较模糊，下面简单介绍一下： 枚举的原始值(raw value) 枚举成员可以用相同类型的默认值预先填充，这样的值我们称为原始值(raw value)。 123456//枚举的原始值(raw value)enum StudentType: Int&#123; case pupil = 10 case middleSchoolStudent = 15 case collegeStudents = 20&#125; 上面的StudentType中三个成员分别被Int类型的10 、15、 20填充表示不同阶段学生的年龄。 注意：Int修饰的是StudentType成员原始值的类型而不是StudentType的类型，StudentType类型从定义开始就是一个全新的枚举类型。 12345678910111213// 常量student1值是 10let student1 = StudentType.pupils.rawValueprint(\"student1:\\(student1)\")// 变量student2值是 15let student2 = StudentType.middleSchoolStudent.rawValueprint(\"student2:\\(student2)\")// 使用成员rawValue属性创建一个`StudentType`枚举的新实例let student3 = StudentType.init(rawValue: 15)// student3的值是 Optional&lt;senson&gt;.Typeprint(\"student3:\\(type(of: student3))\")// student4的值是nil，因为并不能通过整数30得到一个StudentType实例的值let student4 = StudentType.init(rawValue: 30)print(\"student4:\\(student4)\") 使用原始值初始化器这种方式初始化创建得到StudentType的实例student4是一个StudentType的可选类型，因为并不是给定一个年龄就能找到对应的学生类型，比如在StudentType中给定年龄为30就找不到对应的学生类型（很可能30岁的人已经是博士了） 总之，原始值是为枚举的成员们绑定了一组类型必须相同值不同的固定的值（可能是整型，浮点型，字符类型等等）。这样很好解释为什么提供原始值的时候用的是等号。 枚举的关联值(associated value) 关联值和原始值不同，关联值更像是为枚举的成员们绑定了一组类型，不同的成员可以是不同的类型(提供关联值时用的是括号)。例如下面的代码： 1234567//枚举的关联值(associated value)//定义一个表示学生类型的枚举类型 StudentType，他有三个成员分别是pupils、middleSchoolStudent、collegeStudentsenum StudentTypeAssociated &#123; case pupils(String) case middleSchoolStudent(Int, String) case collegeStudents(Int, String)&#125; 这里我们并没有为StudentType的成员提供具体的值，而是为他们绑定了不同的类型，分别是pupil绑定String类型、middleSchoolStudent和collegeStudents绑定（Int， String）元祖类型。接下来就可以创建不同StudentType枚举实例并为对应的成员赋值了。 123456789//student1 是一个StudentType类型的常量，其值为pupil（小学生），特征是\"have fun\"（总是在玩耍）let student1 = StudentTypeAssociated.pupils(\"have fun\")print(\"student1:\\(student1)\")//student2 是一个StudentType类型的常量，其值为middleSchoolStudent（中学生），特征是 7, \"always study\"（一周7天总是在学习）let student2 = StudentTypeAssociated.middleSchoolStudent(7, \"always study\")print(\"student2:\\(student2)\")//student3 是一个StudentType类型的常量，其值为collegeStudent（大学生），特征是 7, \"always LOL\"（一周7天总是在撸啊撸）let student3 = StudentTypeAssociated.middleSchoolStudent(7, \"always LOL\")print(\"student3:\\(student3)\") 这个时候如果需要判断某个StudentType实例的具体的值就需要这样做了： 12345678switch student3 &#123; case .pupils(let things): print(\"is a pupil and \\(things)\") case .middleSchoolStudent(let day, let things): print(\"is a middleSchoolStudent and \\(day) days \\(things)\") case .collegeStudents(let day, let things): print(\"is a collegeStudent and \\(day) days \\(things)\")&#125; 控制台输出：is a collegeStudent and 7 days always LOL，看到这你可能会想，是否可以为一个枚举成员提供原始值并且绑定类型呢，答案是不能的！因为首先给成员提供了固定的原始值，那他以后就不能改变了；而为成员提供关联值(绑定类型)就是为了创建枚举实例的时候赋值。 递归枚举 递归枚举是拥有另一个枚举作为枚举成员关联值的枚举。 关于递归枚举我们可以拆封成两个概念来看：递归 + 枚举。递归是指在程序运行中函数（或方法）直接或间接调用自己的这样一种方式，其特点为重复有限个步骤、格式较为简单。 下面是一个经典的通过递归算法求解n!（阶乘）的函数。 123456789func factorial(n: Int)-&gt;Int &#123; if n &gt; 0 &#123; return n * factorial(n: n - 1) &#125; else &#123; return 1 &#125;&#125; //1 * 2 * 3 * 4 * 5 * 6 = 720 let sum = factorial(n: 6) 函数factorial (n: int)-&gt; Int在执行过程中很明显的调用了自身。结合枚举的概念我们这里可以简单的理解为递归枚举类似上面将枚举值本身传入给成员去判断的情况。 可以看出Swift中枚举变得更加灵活和复杂，有递归枚举的概念，还有很多和类类似的特性，比如：计算属性用来提供关于枚举当前值的额外信息；实例方法提供与枚举表示值相关的功能；定义初始化器来初始化成员值；而且能够遵循协议来提供标准功能等等。 结构体（struct）结构体是由一系列具有相同类型或不同类型的数据构成的数据集合。结构体是一种值类型的数据结构，在Swift中常常使用结构体封装一些属性甚至是方法来组成新的复杂类型，目的是简化运算。 定义好的结构体存在一个自动生成的成员初始化器，使用它来初始化结构体实例的成员属性。 12345struct Student &#123; var chinese: Int var math: Int var english: Int&#125; 看到木有，定义结构体类型时其成员可以没有初始值，要是类那个坑货早报错了…(提醒这个类没有被初始化) 结构体实例的创建 创建结构体和类的实例的语法非常相似，结构体和类两者都能使用初始化器语法来生成新的实例。 最简单的语法是在类或结构体名字后面接一个空的圆括号，例如: 1let student1 = Student() 这样就创建了一个新的类或者结构体的实例，任何成员都被初始化为它们的默认值（前提是成员均有默认值）。 但是如果定义结构体时没有设置初始值，像上面直接()的写法编译器会报错（出来混迟早是要给初始值的） 12//使用Student类型的结构体创建Student类型的实例（变量或常量）并初始化三个成员（这个学生的成绩会不会太好了点）let student2 = Student(chinese: 90, math: 80, english: 70) 所有的结构体都有一个自动生成的成员初始化器，你可以使用它来初始化新结构体实例的成员就像上面一样（前提是没有自定义的初始化器）。如果我们在定义Student时为他的成员赋上初值，那么下面的代码是编译通过的： 1234567struct Students &#123; var chinese: Int = 50 var math: Int = 50 var english: Int = 50&#125;let student3 = Students()print(\"student3:\\(student3)\") 总之，定义结构体类型时其成员可以没有初始值，但是创建结构体实例时该实例的成员必须有初值。 自定义的初始化器 当我们想要使用自己的方式去初始化创建一个Student类型的实例时，系统提供的成员初始化器可能就不够用了。例如，我们希望通过如下方式创建实例时，就需要自定义初始化方法了： 1let student5 = Student(stringScore: \"70,80,90\") 自定义初始化方法 1234567891011121314151617181920struct Student &#123; var chinese: Int = 50 var math: Int = 50 var english: Int = 50 init() &#123;&#125; init(chinese: Int, math: Int, english: Int) &#123; self.chinese = chinese self.math = math self.english = english &#125; init(stringScore: String) &#123; let cme = stringScore.characters.split(separator: \",\") chinese = Int(atoi(String(cme.first!))) math = Int(atoi(String(cme[1]))) english = Int(atoi(String(cme.last!))) &#125;&#125;let student6 = Student()let student7 = Student(chinese: 90, math: 80, english: 70)let student8 = Student(stringScore: \"70,80,90\") 一旦我们自定义了初始化器，系统自动的初始化器就不起作用了，如果还需要使用到系统提供的初始化器，在我们自定义初始化器后就必须显式的定义出来。 定义其他方法 如果此时需要修改某个学生某科的成绩，该如何实现呢？可以定义下面的方法： 12345//更改某个学生某门学科的成绩func changeChinese(num: Int, student: inout Student)&#123; student.chinese += num&#125;changeChinese(num: 20, student: &amp;student7) 此时student7的语文成绩就由原来的70被修改到了90 但是此方法有两个明显的弊端： 1.学生的语文成绩chinese是Student结构体的内部成员，一个学生的某科成绩无需被Student的使用者了解。即我们只关心学生的语文成绩更改了多少，而不是关心学生语文成绩本身是多少。 2.更改一个学生的语文成绩本身就是和Student结构体内部成员计算相关的事情，我们更希望达到如下形如： 1student7.changeChinese(num: 10) 因为只有学生本身清楚自己需要将语文成绩更改多少（更像是面向对象封装的思想）。很明显此时changeChinese(num:)方法是Student结构体内部的方法而不是外部的方法，所以我定义了一个修改某个学生数学成绩的内部方法用于和之前修改语文成绩的外部方法对比： 123456789101112struct Studentes &#123; var chinese: Int = 50 var math: Int = 50 var english: Int = 50 //修改数学成绩 mutating func changeMath(num: Int) &#123; self.math += num &#125;&#125;var student7 = Studentes(chinese: 20, math: 30, english: 40)student7.changeMath(num: 10)print(\"student7:\\(student7)\") 运行结果： 尽管两者都能达到同样的效果，但是把修改结构体成员的方法定义在结构体内部显得更加合理同时满足面向对象封装的特点。以上两点就是我们为Student结构体内部添加changeMath(num:)的原因，他让我们把类型相关的计算表现的更加自然和统一，即自己的事情应该用自己的方法实现不应该被别人关心。 值得一提的是在结构体内部方法中如果修改了结构体的成员，那么该方法之前应该加入：mutating关键字。由于结构体是值类型，Swift规定不能直接在结构体的方法（初始化器除外）中修改成员。原因很简单，结构体作为值的一种表现类型怎么能提供改变自己值的方法呢，但是使用mutating我们便可以办到这点，当然这也是和类的不同点。 常见的结构体 Swift中很多的基础数据类型都是结构体类型，下面列举的是一些常用的结构体类型： 12345678//表示数值类型的结构体：Int，Float，Double，CGFloat...//表示字符和字符串类型的结构体Character，String...//位置和尺寸的结构体CGPoint，CGSize...//集合类型结构体Array，Set，Dictionary... 很多时候你不细心观察的话可能不会想到自己信手拈来的代码中居然藏了这么多结构体。另外有时候在使用类和结构体的时候会出现下面的情况 类方法：123456789// Person 类class Person &#123; var name: String = \"jack\" let life: Int = 1&#125;var s1 = Person()var s2 = s1s2.name = \"mike\"s1 结构体方法：123456789// People 结构体数据结构struct People &#123; var name: String = \"jack\" let life: Int = 1&#125;var p1 = People()var p2 = p1p2.name = \"mike\"p1 细心的同学可能已经发现了其中的诡异。变量s1、s2是Person类的实例，修改了s2的name属性，s1的name也会改变；而p1、p2作为People结构体的实例，修改了p1的name属性，p2的name并不会发生改变。这是为什么呢？ 类能够改变是因为，类是引用类型，内部做浅拷贝处理，本质是指向同一个对象，自然可以改name；结构体之前已经说过是值类型，内部做深拷贝处理，会重新生成一个对象，在复制时修改一个实例的数据并不影响副本的数据。 性能对比其实本质是对比值类型和引用类型的性能，因此擂台上的选手就是结构体（struct）和类（class）。 测试1: 循环创建类和结构体a.执行1亿次类创建 12345678910111213// 定义类class StudentC&#123; var name:String init(name:String) &#123; self.name = name &#125;&#125;// 统计时间let date = Date()for i in 0...100_000_000&#123; let s = StudentC(name: \"酷走天涯\")&#125;print(Date().timeIntervalSince(date)) 运行三次结果: 19.392848014831520.991949281292120.7549253872943 b.执行10亿次结构体创建 123456789101112// 定义结构体struct StudentS&#123; var name:String init( name:String) &#123; self.name = name &#125;&#125;let date = Date()for i in 0...1000_000_000&#123; let s = StudentS(name: \"酷走天涯\")&#125;print(Date().timeIntervalSince(date)) 运行三次结果: 9.9922145421245510.928164827391710.7281881727434 我们上面的属性为基本数据类型,我们将属性改为对象测试一下速度 c.创建10_000_000个对象 123456class StudentC&#123; var date = NSDate()&#125;for i in 0...10_000_000&#123; let s = StudentS()&#125; 测试结果: 6.385093986988076.436492025852226.39519000053406 d.创建10_000_000个结构体实例 123456struct StudentS&#123; var date = NSDate()&#125;for i in 0...10_000_000&#123; let s = StudentS()&#125; 测试结果: 4.385093986988074.436492025852224.39519000053406 结论：创建结构体要比创建对象速度快 测试2:创建1000_000 个对象或者结构体放在数组中,查看内存占用率a.循环创建1000_000个对象 123456789101112class StudentC&#123; var name:String init( name:String) &#123; self.name = name &#125;&#125;var students:[StudentC] = []// 创建for i in 0...1000_000&#123;let s = StudentC(name: \"酷走天涯\")students.append(s)&#125; 运行结果: 内存占用61.8MB b.循环创建1000_000个结构体 1234567891011struct StudentS&#123; var name:String init( name:String) &#123; self.name = name &#125;&#125;var students:[StudentS] = []for i in 0...1000_000&#123;let s = StudentS(name: \"酷走天涯\")students.append(s)&#125; 运行结果: 内存占用32.6MB 照样,我们将基本属性改为对象继续测试 c.10_000_000 个对象添加到数组中 12345678class StudentC&#123; var date = NSDate()&#125;var students:[StudentC] = []for i in 0...10_000_000&#123; let s = StudentC() students.append(s)&#125; 测试结果: 占内存538.7MB d.10_000_000 个结构体添加到数组中 1234567struct StudentS&#123; var date = NSDate()&#125;for i in 0...10_000_000&#123; let s = StudentS() students.append(s)&#125; 测试结构: 占用225.7MB 结论：创建相同属性的结构体比类更加节省内存 测试3:对1_000_000个结构体实体和对象进行排序,测消耗时间a.对1_000_000个结构体实体进行排序 12345let date = Date()students.sort &#123; (stu1, stu2) -&gt; Bool in return stu1.name &gt; stu2.name&#125;print(Date().timeIntervalSince(date)) 运行结果: 13.378394961357113.6793909668922 b.对1_000_000个对象进行排序 12345let date = Date()students.sort &#123; (stu1, stu2) -&gt; Bool in return stu1.name &gt; stu2.name&#125;print(Date().timeIntervalSince(date)) 运行结果: 6.708819985389716.60394102334976 结论: 在数据量比较大的排序中,结构体排序的速度比较慢,因为结构体是值类型,排序的时候,需要大量的赋值运算。而对象只需要交换地址即可。 对比总结枚举、结构体、类的共同点： 定义属性和方法； 下标语法访问值； 初始化器； 支持扩展增加功能； 可以遵循协议； 结构体、类的不同点： 类可以继承,结构体不能继承； 类能够在运行时检查和解释类实例的类型； Deinitializers使一个类的实例来释放任何资源分配； 类有引用计数,允许对象被多次引用； 类特有的功能： 继承； 允许类型转换； 析构方法释放资源； 引用计数； 如何选择使用：当你使用Cocoa框架的时候，很多API都要通过NSObject的子类使用，所以这时候必须要用到引用类型class。在其他情况下，有下面几个准则： 1.什么时候该用值类型： 要用==运算符来比较实例的数据时 你希望那个实例的拷贝能保持独立的状态时 数据会被多个线程使用时 2.什么时候该用引用类型（class）： 要用==运算符来比较实例身份的时候 你希望有创建一个共享的、可变对象的时候 3.类和结构体在效率上的差异： 结构体创建速度,内存占用更小,如果需要使用复杂的运算,这个时候,就需要综合考虑两者的有缺点了。 以上文章整理自：https://www.jianshu.com/p/51f99a352838，http://www.cocoachina.com/swift/20161221/18377.html","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS Principle：Category","slug":"iOS Principle Category","date":"2018-06-03T13:56:27.000Z","updated":"2018-11-16T13:08:51.519Z","comments":true,"path":"2018/06/03/iOS Principle Category/","link":"","permalink":"https://reversescale.github.io/2018/06/03/iOS Principle Category/","excerpt":"分类就是对一个类的功能进行扩展,让这个类能够适应不不同情况的需求.在一般的实际开发中,我们都会对系统的一些常用类进行扩展,比如,NSString,Button,Label等等,简单来说类别是一种为现有的类添加新方法的方式~","text":"分类就是对一个类的功能进行扩展,让这个类能够适应不不同情况的需求.在一般的实际开发中,我们都会对系统的一些常用类进行扩展,比如,NSString,Button,Label等等,简单来说类别是一种为现有的类添加新方法的方式~ 👨🏻‍💻 Github Demo 方便记忆 调用顺序：先调用类的load方法，再调用分类的load方法 为分类添加属性： 实现：RunTime 为 Category 动态关联对象，objc_setAssociatedObject方法，内部调用_object_set_associative_reference函数 原理：关联对象并不是放在了原来的对象里面，而是自己维护了一个全局的map用来存放每一个对象及其对应关联属性表格 目录结构 我们之前讲到过实例对象的isa指针指向类对象，类对象的isa指针指向元类对象，当p调用run方法时，类对象的isa指针找到类对象的isa指针，然后在类对象中查找对象方法，如果没有找到，就通过类对象的superclass指针找到父类对象，接着去寻找run方法。 Category 的底层实现将Preson+Test.m文件转化为c++文件，查看其中的编译过程 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc Person+Test.m 在分类转化为c++文件中可以看出_category_t结构体中，存放着类名，对象方法列表，类方法列表，协议列表，以及属性列表 12345678struct _category_t &#123; const char *name; struct _class_t *cls; const struct _method_list_t *instance_methods; const struct _method_list_t *class_methods; const struct _protocol_list_t *protocols; const struct _prop_list_t *properties;&#125;; 紧接着，我们可以看到_method_list_t类型的结构体 1234567891011static struct /*_method_list_t*/ &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[3];&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_objc_method), 3, &#123;&#123;(struct objc_selector *)\"test\", \"v16@0:8\", (void *)_I_Person_Test_test&#125;, &#123;(struct objc_selector *)\"setAge:\", \"v20@0:8i16\", (void *)_I_Person_Test_setAge_&#125;, &#123;(struct objc_selector *)\"age\", \"i16@0:8\", (void *)_I_Person_Test_age&#125;&#125;&#125;; 从中我们发现这个结构体_OBJC_CATEGORY_INSTANCE_METHODS_Preson_Test从名称可以看出是INSTANCE_METHODS对象方法，并且一一对应为上面结构体内赋值。我们可以看到结构体中存储了方法占用的内存，方法数量，以及方法列表。并且找到分类中我们实现对应的对象方法，test , setAge, age三个方法 123456789static struct /*_method_list_t*/ &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[1];&#125; _OBJC_$_CATEGORY_CLASS_METHODS_Person_$_Test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_objc_method), 1, &#123;&#123;(struct objc_selector *)\"abc\", \"v16@0:8\", (void *)_C_Person_Test_abc&#125;&#125;&#125;; 同上面对象方法列表一样，这个我们可以看出是类方法列表结构体 _OBJC_CATEGORY_CLASS_METHODS_Preson_Test，同对象方法结构体相同，同样可以看到我们实现的类方法，abc 接下来是协议方法列表 1234567891011121314151617181920212223242526272829303132static struct /*_method_list_t*/ &#123; unsigned int entsize; // sizeof(struct _objc_method) unsigned int method_count; struct _objc_method method_list[1];&#125; _OBJC_PROTOCOL_INSTANCE_METHODS_NSCopying __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_objc_method), 1, &#123;&#123;(struct objc_selector *)\"copyWithZone:\", \"@24@0:8^&#123;_NSZone=&#125;16\", 0&#125;&#125;&#125;;struct _protocol_t _OBJC_PROTOCOL_NSCopying __attribute__ ((used)) = &#123; 0, \"NSCopying\", 0, (const struct method_list_t *)&amp;_OBJC_PROTOCOL_INSTANCE_METHODS_NSCopying, 0, 0, 0, 0, sizeof(_protocol_t), 0, (const char **)&amp;_OBJC_PROTOCOL_METHOD_TYPES_NSCopying&#125;;struct _protocol_t *_OBJC_LABEL_PROTOCOL_$_NSCopying = &amp;_OBJC_PROTOCOL_NSCopying;static struct /*_protocol_list_t*/ &#123; long protocol_count; // Note, this is 32/64 bit struct _protocol_t *super_protocols[1];&#125; _OBJC_CATEGORY_PROTOCOLS_$_Person_$_Test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; 1, &amp;_OBJC_PROTOCOL_NSCopying&#125;; 通过上述源码可以看到先将协议方法通过_method_list_t结构体存储，之后通过_protocol_t结构体存储在_OBJC_CATEGORY_PROTOCOLS_Preson_Test中同_protocol_list_t结构体一一对应，分别为protocol_count 协议数量以及存储了协议方法的_protocol_t结构体 最后我们可以看到属性列表 123456789static struct /*_prop_list_t*/ &#123; unsigned int entsize; // sizeof(struct _prop_t) unsigned int count_of_properties; struct _prop_t prop_list[1];&#125; _OBJC_$_PROP_LIST_Person_$_Test __attribute__ ((used, section (\"__DATA,__objc_const\"))) = &#123; sizeof(_prop_t), 1, &#123;&#123;\"age\",\"Ti,N\"&#125;&#125;&#125;; 属性列表结构体_OBJC_PROP_LIST_Preson_Test同_prop_list_t结构体对应，存储属性的占用空间，属性属性数量，以及属性列表，可以看到我们自己写的age属性。 最后我们可以看到定义了_OBJC_CATEGORY_Preson_Test结构体，并且将我们上面着重分析的结构体一一赋值，我们通过两张图片对照一下。 上下两张图一一对应，并且我们看到定义_class_t类型的OBJC_CLASS_Preson结构体，最后将_OBJC_CATEGORY_Preson_Test的cls指针指向OBJC_CLASS_Preson结构体地址。我们这里可以看出，cls指针指向的应该是分类的主类类对象的地址。 通过以上分析我们发现。分类源码中确实是将我们定义的对象方法，类方法，属性等都存放在catagory_t结构体中。通过 runtime 源码查看catagory_t存储的方法，属性，协议等我们得知，分类的实现原理是将category中的方法，属性，协议数据放在category_t结构体中，然后将结构体内的方法列表拷贝到类对象的方法列表中。 Category可以添加属性，但是并不会自动生成成员变量及set/get方法。因为category_t结构体中并不存在成员变量。通过之前对对象的分析我们知道成员变量是存放在实例对象中的，并且编译的那一刻就已经决定好了。而分类是在运行时才去加载的。那么我们就无法再程序运行时将分类的成员变量中添加到实例对象的结构体中。因此分类中不可以添加成员变量。 load 和 initializeload方法会在程序启动就会调用，当装载类信息的时候就会调用。 调用顺序看一下源代码。 通过源码我们发现是优先调用类的load方法，之后调用分类的load方法 我们通过代码验证一下： 我们添加Student继承Presen类，并添加Student+Test分类，分别重写只+load方法，其他什么都不做通过打印发现 确实是优先调用类的load方法之后调用分类的load方法，不过调用类的load方法之前会保证其父类已经调用过load方法。之后我们为Preson、Student 、Student+Test 添加initialize方法。 我们知道当类第一次接收到消息时，就会调用initialize，相当于第一次使用类的时候就会调用initialize方法。调用子类的initialize之前，会先保证调用父类的initialize方法。如果之前已经调用过initialize，就不会再调用initialize方法了。当分类重写initialize方法时会先调用分类的方法。但是load方法并不会被覆盖，首先我们来看一下initialize的源码。 上图中我们发现，initialize是通过消息发送机制调用的，消息发送机制通过isa指针找到对应的方法与实现，因此先找到分类方法中的实现，会优先调用分类方法中的实现 我们再来看一下load方法的调用源码 我们看到load方法中直接拿到load方法的内存地址直接调用方法，不在是通过消息发送机制调用 我们可以看到分类中也是通过直接拿到load方法的地址进行调用。因此正如我们之前试验的一样，分类中重写load方法，并不会优先调用分类的load方法，而不调用本类中的load方法了。 RunTime 为 Category 动态关联对象使用RunTime给系统的类添加属性，首先需要了解对象与属性的关系。我们通过之前的学习知道，对象一开始初始化的时候其属性为nil，给属性赋值其实就是让属性指向一块存储内容的内存，使这个对象的属性跟这块内存产生一种关联。 那么如果想动态的添加属性，其实就是动态的产生某种关联就好了。而想要给系统的类添加属性，只能通过分类。 这里给NSObject添加name属性，创建NSObject的分类 我们可以使用@property给分类添加属性 1@property(nonatomic,strong)NSString *name; 通过探寻Category的本质我们知道，虽然在分类中可以写@property添加属性，但是不会自动生成私有属性，也不会生成set,get方法的实现，只会生成set,get的声明，需要我们自己去实现。 方法一：我们可以通过使用静态全局变量给分类添加属性 1234567static NSString *_name;- (void)setName:(NSString *)name &#123; _name = name;&#125;- (NSString *)name &#123; return _name;&#125; 但是这样_name静态全局变量与类并没有关联，无论对象创建与销毁，只要程序在运行_name变量就存在，并不是真正意义上的属性。 方法二：使用RunTime动态添加属性RunTime提供了动态添加属性和获得属性的方法。 123456-(void)setName:(NSString *)name &#123; objc_setAssociatedObject(self, @\"name\",name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;-(NSString *)name &#123; return objc_getAssociatedObject(self, @\"name\"); &#125; 1.动态添加属性 objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy); 参数一：id object : 给哪个对象添加属性，这里要给自己添加属性，用self。 参数二：void * == id key : 属性名，根据key获取关联对象的属性的值，在**objc_getAssociatedObject中通过次key获得属性的值并返回。 参数三：id value** : 关联的值，也就是set方法传入的值给属性去保存。 参数四：objc_AssociationPolicy policy : 策略，属性以什么形式保存。 有以下几种1234567typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN = 0, // 指定一个弱引用相关联的对象 OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, // 指定相关对象的强引用，非原子性 OBJC_ASSOCIATION_COPY_NONATOMIC = 3, // 指定相关的对象被复制，非原子性 OBJC_ASSOCIATION_RETAIN = 01401, // 指定相关对象的强引用，原子性 OBJC_ASSOCIATION_COPY = 01403 // 指定相关的对象被复制，原子性 &#125;; key值只要是一个指针即可，我们可以传入@selector(name) 2.获得属性1objc_getAssociatedObject(id object, const void *key); 参数一：id object : 获取哪个对象里面的关联的属性。 参数二：void * == id key : 什么属性，与objc_setAssociatedObject中的key相对应，即通过key值取出value。 3.移除所有关联对象 1234- (void)removeAssociatedObjects &#123; // 移除所有关联对象 objc_removeAssociatedObjects(self);&#125; 此时已经成功给NSObject添加name属性，并且NSObject对象可以通过点语法为属性赋值。 123NSObject *objc = [[NSObject alloc]init];objc.name = @\"xx_cc\";NSLog(@\"%@\",objc.name); 可以看出关联对象的使用非常简单，接下来我们来探寻关联对象的底层原理 objc_setAssociatedObject函数 来到runtime源码，首先找到objc_setAssociatedObject函数，看一下其实现 我们看到其实内部调用的是_object_set_associative_reference函数，我们来到_object_set_associative_reference函数中 _object_set_associative_reference函数 _object_set_associative_reference函数内部我们可以全部找到我们上面说过的实现关联对象技术的核心对象。接下来我们来一个一个看其内部实现原理探寻他们之间的关系。 AssociationsManager 通过AssociationsManager内部源码发现，AssociationsManager内部有一个AssociationsHashMap对象。 AssociationsHashMap 我们来看一下AssociationsHashMap内部的源码。 通过AssociationsHashMap内部源码我们发现AssociationsHashMap继承自unordered_map首先来看一下unordered_map内的源码 从unordered_map源码中我们可以看出_Key和_Tp也就是前两个参数对应着map中的Key和Value，那么对照上面AssociationsHashMap内源码发现_Key中传入的是disguised_ptr_t，_Tp中传入的值则为ObjectAssociationMap*。 紧接着我们来到ObjectAssociationMap中，上图中ObjectAssociationMap已经标记出，我们发现ObjectAssociationMap中同样以key、Value的方式存储着ObjcAssociation。 接着我们来到ObjcAssociation中 我们发现ObjcAssociation存储着_policy、_value，而这两个值我们可以发现正是我们调用objc_setAssociatedObject函数传入的值，也就是说我们在调用objc_setAssociatedObject函数中传入的value和policy这两个值最终是存储在ObjcAssociation中的。 现在我们已经对AssociationsManager、 AssociationsHashMap、 ObjectAssociationMap、ObjcAssociation四个对象之间的关系有了简单的认识，那么接下来我们来细读源码，看一下objc_setAssociatedObject函数中传入的四个参数分别放在哪个对象中充当什么作用。 重新回到_object_set_associative_reference函数实现中 细读上述源码我们可以发现，首先根据我们传入的value经过acquireValue函数处理获取new_value。acquireValue函数内部其实是通过对策略的判断返回不同的值 之后创建 AssociationsManager manager 以及拿到manager内部的AssociationsHashMap即associations。之后我们看到了我们传入的第一个参数object，object经过DISGUISE函数被转化为了disguised_ptr_t类型的disguised_object。 DISGUISE函数其实仅仅对object做了位运算 之后我们看到被处理成new_value的value，同policy被存入了ObjcAssociation中。 而ObjcAssociation对应我们传入的key被存入了ObjectAssociationMap中。 disguised_object和ObjectAssociationMap则以key-value的形式对应存储在associations中也就是AssociationsHashMap中。 如果我们value设置为nil的话那么会执行下面的代码 从上述代码中可以看出，如果我们设置value为nil时，就会将关联对象从ObjectAssociationMap中移除。 最后我们通过一张图可以很清晰的理清楚其中的关系 通过上图我们可以总结为：一个实例对象就对应一个ObjectAssociationMap，而ObjectAssociationMap中存储着多个此实例对象的关联对象的key以及ObjcAssociation，为ObjcAssociation中存储着关联对象的value和policy策略。 由此我们可以知道关联对象并不是放在了原来的对象里面，而是自己维护了一个全局的map用来存放每一个对象及其对应关联属性表格。 objc_getAssociatedObject函数 objc_getAssociatedObject内部调用的是_object_get_associative_reference _object_get_associative_reference函数 从_object_get_associative_reference函数内部可以看出，向set方法中那样，反向将value一层一层取出最后return出去。 objc_removeAssociatedObjects函数 objc_removeAssociatedObjects用来删除所有的关联对象，objc_removeAssociatedObjects函数内部调用的是_object_remove_assocations函数 _object_remove_assocations函数 上述源码可以看出_object_remove_assocations函数将object对象向对应的所有关联对象全部删除。 关联对象并不是存储在被关联对象本身内存中，而是存储在全局的统一的一个AssociationsManager中，如果设置关联对象为nil，就相当于是移除关联对象。 此时我们我们在回过头来看objc_AssociationPolicy policy 参数: 属性以什么形式保存的策略。 1234567typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123; OBJC_ASSOCIATION_ASSIGN = 0, // 指定一个弱引用相关联的对象 OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, // 指定相关对象的强引用，非原子性 OBJC_ASSOCIATION_COPY_NONATOMIC = 3, // 指定相关的对象被复制，非原子性 OBJC_ASSOCIATION_RETAIN = 01401, // 指定相关对象的强引用，原子性 OBJC_ASSOCIATION_COPY = 01403 // 指定相关的对象被复制，原子性 &#125;; 我们会发现其中只有RETAIN和COPY而为什么没有weak呢？总过上面对源码的分析我们知道，object经过DISGUISE函数被转化为了disguised_ptr_t类型的disguised_object。 1disguised_ptr_t disguised_object = DISGUISE(object); 而同时我们知道，weak修饰的属性，当没有拥有对象之后就会被销毁，并且指针置位nil，那么在对象销毁之后，虽然在map中既然存在值object对应的AssociationsHashMap，但是因为object地址已经被置位nil，会造成坏地址访问而无法根据object对象的地址转化为disguised_object了。 相关问题问：Category中有load方法吗？load方法是什么时候调用的？load 方法能继承吗？ 答：Category中有load方法，load方法在程序启动装载类信息的时候就会调用。load方法可以继承。调用子类的load方法之前，会先调用父类的load方法 问：load、initialize的区别，以及它们在category重写的时候的调用的次序。 答：区别在于调用方式和调用时刻 调用方式：load是根据函数地址直接调用，initialize是通过objc_msgSend调用 调用时刻：load是runtime加载类、分类的时候调用（只会调用1次），initialize是类第一次接收到消息的时候调用，每一个类只会initialize一次（父类的initialize方法可能会被调用多次） 调用顺序：先调用类的load方法，先编译那个类，就先调用load。在调用load之前会先调用父类的load方法。分类中load方法不会覆盖本类的load方法，先编译的分类优先调用load方法。initialize先初始化父类，之后再初始化子类。如果子类没有实现+initialize，会调用父类的+initialize（所以父类的+initialize可能会被调用多次），如果分类实现了+initialize，就覆盖类本身的+initialize调用。 以上文章整理自：https://juejin.im/post/5aef0a3b518825670f7bc0f3、https://juejin.im/post/5af86b276fb9a07aa34a59e6","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS Principle：ClassAndObjective","slug":"iOS Principle ClassAndObjective","date":"2018-06-02T13:56:27.000Z","updated":"2018-11-16T13:06:02.391Z","comments":true,"path":"2018/06/02/iOS Principle ClassAndObjective/","link":"","permalink":"https://reversescale.github.io/2018/06/02/iOS Principle ClassAndObjective/","excerpt":"面向对象(Object Oriented,OO)是软件开发方法。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域~","text":"面向对象(Object Oriented,OO)是软件开发方法。面向对象的概念和应用已超越了程序设计和软件开发，扩展到如数据库系统、交互式界面、应用结构、应用平台、分布式系统、网络管理结构、CAD技术、人工智能等领域~ 👨🏻‍💻 Github Demo 方便记忆 OC 三种对象：instance实例对象、class类对象、meta-class元类对象 instance实例对象：NSObject转化为c语言其实就是一个结构体，系统分配内存空间，存放一个成员isa指针表示对象的地址（结构体的地址）64bit占用8个字节，32bit占用4个字节 class类对象：类对象内存存储的信息：isa和superclass指针、类的属性信息和成员变量、对象方法和协议信息 meta-class元类对象：元类对象和class对象的内存结构一样，isa指针指向基类对象，基类的元类对象的isa指针指向自己 OC 三种对象原理：objc_class结构体的指针 关于OC对象的底层实现寻OC对象的本质，我们平时编写的Objective-C代码，底层实现其实都是C\\C++代码。 OC的对象结构都是通过基础C\\C++的结构体实现的。 我们通过创建OC文件及对象，并将OC文件转化为C++文件来探寻OC对象的本质 OC如下代码 12345678#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSObject *objc = [[NSObject alloc] init]; NSLog(@\"Hello, World!\"); &#125; return 0;&#125; 我们通过命令行将OC的mian.m文件转化为c++文件 1clang -rewrite-objc main.m -o main.cpp // 这种方式没有指定架构例如arm64架构 我们可以指定架构模式的命令行，使用xcode工具 xcrun 1xcrun -sdk iphoneos clang -arch arm64 -rewrite-objc main.m -o main-arm64.cpp // 生成 main-arm64.cpp main-arm64.cpp 文件中搜索NSObjcet，可以找到 NSObjcet_IMPL（IMPL代表 implementation 实现） 我们看一下NSObject_IMPL内部 123456struct NSObject_IMPL &#123; Class isa;&#125;;// 查看Class本质typedef struct objc_class *Class;// 我们发现Class其实就是一个指针，对象底层实现其实就是这个样子。 思考： 一个OC对象在内存中是如何布局的? NSObjcet的底层实现，点击NSObjcet进入发现NSObject的内部实现 1234567@interface NSObject &lt;NSObject&gt; &#123; #pragma clang diagnostic push #pragma clang diagnostic ignored \"-Wobjc-interface-ivars\" Class isa OBJC_ISA_AVAILABILITY; #pragma clang diagnostic pop&#125;@end 转化为c语言其实就是一个结构体 123struct NSObject_IMPL &#123; Class isa;&#125;; 那么这个结构体占多大的内存空间呢，我们发现这个结构体只有一个成员，isa指针，而指针在64位架构中占8个字节。也就是说一个NSObjec对象所占用的内存是8个字节。 为了探寻OC对象在内存中如何体现，我们来看下面一段代码 1NSObject *objc = [[NSObject alloc] init]; 上面一段代码在内存中如何体现的呢？上述一段代码中系统为NSObject对象分配8个字节的内存空间，用来存放一个成员isa指针。那么isa指针这个变量的地址就是结构体的地址，也就是NSObjcet对象的地址。 假设isa的地址为0x100400110，那么上述代码分配存储空间给NSObject对象，然后将存储空间的地址赋值给objc指针。objc存储的就是isa的地址。objc指向内存中NSObject对象地址，即指向内存中的结构体，也就是isa的位置。 自定义类的内部实现1234567891011121314151617@interface Student : NSObject&#123; @public int _no; int _age;&#125;@end@implementation Studentint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Student *stu = [[Student alloc] init]; stu -&gt; _no = 4; stu -&gt; _age = 5; NSLog(@\"%@\",stu); &#125; return 0;&#125;@end 按照上述步骤同样生成c++文件。并查找Student，我们发现Student_IMPL 12345struct Student_IMPL &#123; struct NSObject_IMPL NSObject_IVARS; int _no; int _age;&#125;; 发现第一个是 NSObject_IMPL的实现。而通过上面的实验我们知道NSObject_IMPL内部其实就是Class isa 那么我们假设 struct NSObject_IMPL NSObject_IVARS; 12345struct Student_IMPL &#123; Class *isa; int _no; int _age;&#125;; 因此此结构体占用多少存储空间，对象就占用多少存储空间。因此结构体占用的存储空间为，isa指针8个字节空间+int类型_no4个字节空间+int类型_age4个字节空间共16个字节空间 123Student *stu = [[Student alloc] init];stu -&gt; _no = 4;stu -&gt; _age = 5; 那么上述代码实际上在内存中的体现为，创建Student对象首先会分配16个字节，存储3个东西，isa指针8个字节，4个字节的_no ,4个字节的_age sutdent对象的3个变量分别有自己的地址。而stu指向isa指针的地址。因此stu的地址为0x100400110，stu对象在内存中占用16个字节的空间。并且经过赋值，_no里面存储着4 ，_age里面存储着5 验证Student在内存中模样 1234567891011121314151617181920struct Student_IMPL &#123; Class isa; int _no; int _age;&#125;;@interface Student : NSObject &#123; @public int _no; int _age;&#125;@end@implementation Studentint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // 强制转化 struct Student_IMPL *stuImpl = (__bridge struct Student_IMPL *)stu; NSLog(@\"_no = %d, _age = %d\", stuImpl-&gt;_no, stuImpl-&gt;_age); // 打印出 _no = 4, _age = 5 &#125; return 0;&#125; 上述代码将oc对象强转成Student_IMPL的结构体。也就是说把一个指向oc对象的指针，指向这种结构体。由于我们之前猜想，对象在内存中的布局与结构体在内存中的布局相同，那么如果可以转化成功，说明我们的猜想正确。由此说明stu这个对象指向的内存确实是一个结构体。 实际上想要获取对象占用内存的大小，可以通过更便捷的运行时方法来获取。 123class_getInstanceSize([Student class])NSLog(@\"%zd,%zd\", class_getInstanceSize([NSObject class]) ,class_getInstanceSize([Student class]));// 打印信息 8和16 窥探内存结构实时查看内存数据 方式一：通过打断点。 Debug Workflow -&gt; viewMemory address中输入stu的地址 从上图中，我们可以发现读取数据从高位数据开始读，查看前16位字节，每四个字节读出的数据为16进制 0x0000004(4字节) 0x0000005(4字节) isa的地址为 00D1081000001119(8字节) 方式二：通过lldb指令xcode自带的调试器 12345678910memory read 0x10074c450// 简写 x 0x10074c450// 增加读取条件// memory read/数量格式字节数 内存地址// 简写 x/数量格式字节数 内存地址// 格式 x是16进制，f是浮点，d是10进制// 字节大小 b：byte 1字节，h：half word 2字节，w：word 4字节，g：giant word 8字节示例：x/4xw // /后面表示如何读取数据 w表示4个字节4个字节读取，x表示以16进制的方式读取数据，4则表示读取4次 同时也可以通过lldb修改内存中的值 12memory write 0x100400c68 6将_no的值改为了6 那么一个NSObject对象占用多少内存？ NSObjcet实际上是只有一个名为isa的指针的结构体，因此占用一个指针变量所占用的内存空间大小，如果64bit占用8个字节，如果32bit占用4个字节。 更复杂的继承关系在64bit环境下， 下面代码的输出内容？1234567891011121314151617181920212223/* Person */@interface Person: NSObject &#123; int _age;&#125;@end@implementation Person@end/* Student */@interface Student: Person &#123; int _no;&#125;@end@implementation Student@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSLog(@\"%zd %zd\", class_getInstanceSize([Person class]), class_getInstanceSize([Student class]) ); &#125; return 0;&#125; 我们依据上面的分析与发现，类对象实质上是以结构体的形式存储在内存中，画出真正的内存图例 我们发现只要是继承自NSObject的对象，那么底层结构体内一定有一个isa指针。 那么他们所占的内存空间是多少呢？单纯的将指针和成员变量所占的内存相加即可吗？上述代码实际打印的内容是16 16，也就是说，person对象和student对象所占用的内存空间都为16个字节。 其实实际上person对象确实只使用了12个字节。但是因为内存对齐的原因。使person对象也占用16个字节。 我们可以总结内存对齐为两个原则： 原则 1. 前面的地址必须是后面的地址正数倍,不是就补齐。 原则 2. 整个Struct的地址必须是最大字节的整数倍。 通过上述内存对齐的原则我们来看，person对象的第一个地址要存放isa指针需要8个字节，第二个地址要存放_age成员变量需要4个字节，根据原则一，8是4的整数倍，符合原则一，不需要补齐。然后检查原则2，目前person对象共占据12个字节的内存，不是最大字节数8个字节的整数倍，所以需要补齐4个字节，因此person对象就占用16个字节空间。 而对于student对象，我们知道student对象中，包含person对象的结构体实现，和一个int类型的_no成员变量，同样isa指针8个字节，_age成员变量4个字节，_no成员变量4个字节，刚好满足原则1和原则2，所以student对象占据的内存空间也是16个字节。 OC的类信息存放在哪里OC对象主要可以分为三种 instance对象（实例对象） class对象（类对象） meta-class对象（元类对象） instance对象就是通过类alloc出来的对象，每次调用alloc都会产生新的instance对象12NSObjcet *object1 = [[NSObjcet alloc] init];NSObjcet *object2 = [[NSObjcet alloc] init]; object1和object2都是NSObject的instace对象（实例对象），但他们是不同的两个对象，并且分别占据着两块不同的内存。instance对象在内存中存储的信息包括 isa指针 其他成员变量 衍生问题：在上图实例对象中根本没有看到方法，那么实例对象的方法的代码放在什么地方呢？那么类的方法的信息，协议的信息，属性的信息都存放在什么地方呢？ class对象 我们通过class方法或runtime方法得到一个class对象。class对象也就是类对象 1234567Class objectClass1 = [object1 class];Class objectClass2 = [object2 class];Class objectClass3 = [NSObject class];// runtimeClass objectClass4 = object_getClass(object1);Class objectClass5 = object_getClass(object2);NSLog(@\"%p %p %p %p %p\", objectClass1, objectClass2, objectClass3, objectClass4, objectClass5); 每一个类在内存中有且只有一个class对象 可以通过打印内存地址证明，class对象在内存中存储的信息主要包括 1.isa指针 2.superclass指针 3.类的属性信息（@property），类的成员变量信息（ivar） 4.类的对象方法信息（instance method），类的协议信息（protocol） 成员变量的值时存储在实例对象中的，因为只有当我们创建实例对象的时候才为成员变赋值。但是成员变量叫什么名字，是什么类型，只需要有一份就可以了。 类方法放在那里？ 元类对象 meta-class 1234567//runtime中传入类对象此时得到的就是元类对象Class objectMetaClass = object_getClass([NSObject class]);// 而调用类对象的class方法时得到还是类对象，无论调用多少次都是类对象Class cls = [[NSObject class] class];Class objectClass3 = [NSObject class];class_isMetaClass(objectMetaClass) // 判断该对象是否为元类对象NSLog(@\"%p %p %p\", objectMetaClass, objectClass3, cls); // 后面两个地址相同，说明多次调用class得到的还是类对象 每个类在内存中有且只有一个meta-class对象。 meta-class对象和class对象的内存结构是一样的，但是用途不一样，在内存中存储的信息主要包括 1.isa指针 2.superclass指针 3.类的类方法的信息（class method） meta-class对象和class对象的内存结构是一样的，所以meta-class中也有类的属性信息，类的对象方法信息等成员变量，但是其中的值可能是空的。 对象的isa指针指向哪里? 1.当对象调用实例方法的时候，我们上面讲到，实例方法信息是存储在class类对象中的，那么要想找到实例方法，就必须找到class类对象，那么此时isa的作用就来了。 1[stu studentMethod]; instance的isa指向class，当调用对象方法时，通过instance的isa找到class，最后找到对象方法的实现进行调用。 2.当类对象调用类方法的时候，同上，类方法是存储在meta-class元类对象中的。那么要找到类方法，就需要找到meta-class元类对象，而class类对象的isa指针就指向元类对象 1[Student studentClassMethod]; class 的 isa 指向 meta-class 当调用类方法时，通过 class 的 isa 找到 meta-class，最后找到类方法的实现进行调用 3.当对象调用其父类对象方法的时候，又是怎么找到父类对象方法的呢？，此时就需要使用到class类对象superclass指针。 12[stu personMethod];[stu init]; 当Student的instance对象要调用Person的对象方法时，会先通过isa找到Student的class，然后通过superclass找到Person的class，最后找到对象方法的实现进行调用，同样如果Person发现自己没有响应的对象方法，又会通过Person的superclass指针找到NSObject的class对象，去寻找响应的方法 当类对象调用父类的类方法时，就需要先通过isa指针找到meta-class，然后通过superclass去寻找响应的方法 12[Student personClassMethod];[Student load]; 当Student的class要调用Person的类方法时，会先通过isa找到Student的meta-class，然后通过superclass找到Person的meta-class，最后找到类方法的实现进行调用 最后又是这张静定的isa指向图，经过上面的分析我们在来看这张图，就显得清晰明了很多。 对isa、superclass总结 1.instance的isa指向class 2.class的isa指向meta-class 3.meta-class的isa指向基类的meta-class，基类的isa指向自己 4.class的superclass指向父类的class，如果没有父类，superclass指针为nil 5.meta-class的superclass指向父类的meta-class，基类的meta-class的superclass指向基类的class 6.instance调用对象方法的轨迹，isa找到class，方法不存在，就通过superclass找父类 7.class调用类方法的轨迹，isa找meta-class，方法不存在，就通过superclass找父类 如何证明isa指针的指向真的如上面所说？我们通过如下代码证明：1234NSObject *object = [[NSObject alloc] init];Class objectClass = [NSObject class];Class objectMetaClass = object_getClass([NSObject class]);NSLog(@\"%p %p %p\", object, objectClass, objectMetaClass); 打断点并通过控制台打印相应对象的isa指针 我们发现object-&gt;isa与objectClass的地址不同，这是因为从64bit开始，isa需要进行一次位运算，才能计算出真实地址。而位运算的值我们可以通过下载objc源代码找到。 我们通过位运算进行验证。 我们发现，object-isa指针地址0x001dffff96537141经过同0x00007ffffffffff8位运算，得出objectClass的地址0x00007fff96537140 接着我们来验证class对象的isa指针是否同样需要位运算计算出meta-class对象的地址。当我们以同样的方式打印objectClass-&gt;isa指针时，发现无法打印 同时也发现左边objectClass对象中并没有isa指针。我们来到Class内部看一下 12345678910111213141516typedef struct objc_class *Class;struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ 相信了解过isa指针的同学对objc_class结构体内的内容很熟悉了，今天这里不深入研究，我们只看第一个对象是一个isa指针，为了拿到isa指针的地址，我们自己创建一个同样的结构体并通过强制转化拿到isa指针。 12345struct xx_cc_objc_class&#123;Class isa;&#125;;Class objectClass = [NSObject class];struct xx_cc_objc_class *objectClass2 = (__bridge struct xx_cc_objc_class *)(objectClass); 此时我们重新验证一下 确实，objectClass2的isa指针经过位运算之后的地址是meta-class的地址。 关于OC Class 的底层实现Class的本质我们知道不管是类对象还是元类对象，类型都是Class，class和mete-class的底层都是objc_class结构体的指针，内存中就是结构体，本章来探寻Class的本质。 12Class objectClass = [NSObject class]; Class objectMetaClass = object_getClass([NSObject class]); 点击Class来到内部，我们可以发现 1typedef struct objc_class *Class; Class对象其实是一个指向objc_class结构体的指针。因此我们可以说类对象或元类对象在内存中其实就是objc_class结构体。 我们来到objc_class内部，可以看到这段在底层原理中经常出现的代码。 123456789101112131415struct objc_class &#123; Class _Nonnull isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class _Nullable super_class OBJC2_UNAVAILABLE; const char * _Nonnull name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list * _Nullable ivars OBJC2_UNAVAILABLE; struct objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE; struct objc_cache * _Nonnull cache OBJC2_UNAVAILABLE; struct objc_protocol_list * _Nullable protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ 这部分代码相信在文章中很常见，但是OBJC2_UNAVAILABLE;说明这些代码已经不在使用了。那么目前objc_class的结构是什么样的呢？我们通过objc源码中去查找objc_class结构体的内容 我们发现这个结构体继承 objc_object 并且结构体内有一些函数，因为这是c++结构体，在c上做了扩展，因此结构体中可以包含函数。我们来到objc_object内，截取部分代码 我们发现objc_object中有一个isa指针，那么objc_class继承objc_object，也就同样拥有一个isa指针 那么我们之前了解到的，类中存储的类的成员变量信息，实例方法，属性名等这些信息在哪里呢。我们来到class_rw_t中，截取部分代码，我们发现class_rw_t中存储着方法列表，属性列表，协议列表等内容。 而class_rw_t是通过bits调用data方法得来的，我们来到data方法内部实现。我们可以看到，data函数内部仅仅对bits进行&amp;FAST_DATA_MASK操作 而成员变量信息则是存储在class_ro_t内部中的，我们来到class_ro_t内查看 最后总结通过一张图进行总结 我们可以自定义一个结构体，如果我们自己写的结构和objc_class真实结构是一样的，那么当我们强制转化的时候，就会一一对应的赋值。此时我们就可以拿到结构体内部的信息。 下列代码是我们仿照objc_class结构体，提取其中需要使用到的信息，自定义的一个结构体。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#import &lt;Foundation/Foundation.h&gt;#ifndef XXClassInfo_h#define XXClassInfo_h# if __arm64__# define ISA_MASK 0x0000000ffffffff8ULL# elif __x86_64__# define ISA_MASK 0x00007ffffffffff8ULL# endif#if __LP64__ typedef uint32_t mask_t;#else typedef uint16_t mask_t;#endif typedef uintptr_t cache_key_t;struct bucket_t &#123; cache_key_t _key; IMP _imp;&#125;;struct cache_t &#123; bucket_t *_buckets; mask_t _mask; mask_t _occupied;&#125;;struct entsize_list_tt &#123; uint32_t entsizeAndFlags; uint32_t count;&#125;;struct method_t &#123; SEL name; const char *types; IMP imp;&#125;;struct method_list_t : entsize_list_tt &#123; method_t first;&#125;;struct ivar_t &#123; int32_t *offset; const char *name; const char *type; uint32_t alignment_raw; uint32_t size;&#125;;struct ivar_list_t : entsize_list_tt &#123; ivar_t first;&#125;;struct property_t &#123; const char *name; const char *attributes;&#125;;struct property_list_t : entsize_list_tt &#123; property_t first;&#125;;struct chained_property_list &#123; chained_property_list *next; uint32_t count; property_t list[0];&#125;;typedef uintptr_t protocol_ref_t; struct protocol_list_t &#123; uintptr_t count; protocol_ref_t list[0];&#125;;struct class_ro_t &#123; uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; // instance对象占用的内存空间#ifdef __LP64__ uint32_t reserved;#endif const uint8_t * ivarLayout; const char * name; // 类名 method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; // 成员变量列表 const uint8_t * weakIvarLayout; property_list_t *baseProperties;&#125;;struct class_rw_t &#123; uint32_t flags; uint32_t version; const class_ro_t *ro; method_list_t * methods; // 方法列表 property_list_t *properties; // 属性列表 const protocol_list_t * protocols; // 协议列表 Class firstSubclass; Class nextSiblingClass; char *demangledName;&#125;;#define FAST_DATA_MASK 0x00007ffffffffff8ULstruct class_data_bits_t &#123; uintptr_t bits; public: class_rw_t* data() &#123; // 提供data()方法进行 &amp; FAST_DATA_MASK 操作 return (class_rw_t *)(bits &amp; FAST_DATA_MASK); &#125;&#125;;/* OC对象 */struct xx_objc_object &#123; void *isa;&#125;;/* 类对象 */struct xx_objc_class : xx_objc_object &#123; Class superclass; cache_t cache; class_data_bits_t bits; public: class_rw_t* data() &#123; return bits.data(); &#125; xx_objc_class* metaClass() &#123; // 提供metaClass函数，获取元类对象 // 上一篇我们讲解过，isa指针需要经过一次 &amp; ISA_MASK操作之后才得到真正的地址 return (xx_objc_class *)((long long)isa &amp; ISA_MASK); &#125;&#125;;#endif /* XXClassInfo_h */ 接下来我们将自己定义的类强制转化为我们自定义的精简的class结构体类型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#import &lt;Foundation/Foundation.h&gt;#import &lt;objc/runtime.h&gt;#import \"XXClassInfo.h\"/* Person */@interface Person : NSObject &lt;NSCopying&gt; &#123; @public int _age;&#125;@property (nonatomic, assign) int height;- (void)personMethod;+ (void)personClassMethod;@end@implementation Person- (void)personMethod &#123;&#125;+ (void)personClassMethod &#123;&#125;@end/* Student */@interface Student : Person &lt;NSCoding&gt; &#123; @public int _no;&#125;@property (nonatomic, assign) int score;- (void)studentMethod;+ (void)studentClassMethod;@end@implementation Student- (void)studentMethod &#123;&#125;+ (void)studentClassMethod &#123;&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; NSObject *object = [[NSObject alloc] init]; Person *person = [[Person alloc] init]; Student *student = [[Student alloc] init]; xx_objc_class *objectClass = (__bridge xx_objc_class *)[object class]; xx_objc_class *personClass = (__bridge xx_objc_class *)[person class]; xx_objc_class *studentClass = (__bridge xx_objc_class *)[student class]; xx_objc_class *objectMetaClass = objectClass-&gt;metaClass(); xx_objc_class *personMetaClass = personClass-&gt;metaClass(); xx_objc_class *studentMetaClass = studentClass-&gt;metaClass(); class_rw_t *objectClassData = objectClass-&gt;data(); class_rw_t *personClassData = personClass-&gt;data(); class_rw_t *studentClassData = studentClass-&gt;data(); class_rw_t *objectMetaClassData = objectMetaClass-&gt;data(); class_rw_t *personMetaClassData = personMetaClass-&gt;data(); class_rw_t *studentMetaClassData = studentMetaClass-&gt;data(); // 0x00007ffffffffff8 NSLog(@\"%p %p %p %p %p %p\", objectClassData, personClassData, studentClassData, objectMetaClassData, personMetaClassData, studentMetaClassData); return 0;&#125; 通过打断点，我们可以看到class内部信息。 至此，我们再次拿出那张经典的图，挨个分析图中isa指针和superclass指针的指向 instance对象首先我们来看instance对象，我们通过上一篇文章知道，instance对象中存储着isa指针和其他成员变量，并且instance对象的isa指针是指向其类对象地址的。我们首先分析上述代码中我们创建的object，person，student三个instance对象与其相对应的类对象objectClass，personClass，studentClass。 从上图中我们可以发现instance对象中确实存储了isa指针和其成员变量，同时将instance对象的isa指针经过&amp;运算之后计算出的地址确实是其相应类对象的内存地址。由此我们证明isa，superclass指向图中的1，2，3号线。 class对象接着我们来看class对象，同样通过上一篇文章，我们明确class对象中存储着isa指针，superclass指针，以及类的属性信息，类的成员变量信息，类的对象方法，和类的协议信息，而通过上面对object源码的分析，我们知道这些信息存储在class对象的class_rw_t中，我们通过强制转化来窥探其中的内容。如下图 上图中我们通过模拟对person类对象调用.data函数，即对bits进行&amp;FAST_DATA_MASK(0x00007ffffffffff8UL)运算，并转化为class_rw_t。即上图中的personClassData。其中我们发现成员变量信息，对象方法，属性等信息只显示first第一个，如果想要拿到更多的需要通过代码将指针后移获取。 而上图中的instaceSize = 16也同person对象中isa指针8个字节+_age4个字节+_height4个字节相对应起来。这里不在展开对objectClassData及studentClassData进行分析，基本内容同personClassData相同。 那么类对象中的isa指针和superclass指针的指向是否如那张经典的图示呢？我们来验证一下。 通过上图中的内存地址的分析，由此我们证明isa，superclass指向图中，isa指针的4，5，6号线，以及superclass指针的10，11，12号线。 meta-class对象最后我们来看meta-class元类对象，上文提到meta-class中存储着isa指针，superclass指针，以及类的类方法信息。同时我们知道meta-class元类对象与class类对象，具有相同的结构，只不过存储的信息不同，并且元类对象的isa指针指向基类的元类对象，基类的元类对象的isa指针指向自己。元类对象的superclass指针指向其父类的元类对象，基类的元类对象的superclass指针指向其类对象。 与class对象相同，我们同样通过模拟对person元类对象调用.data函数，即对bits进行&amp;FAST_DATA_MASK(0x00007ffffffffff8UL)运算，并转化为class_rw_t。 首先我们可以看到结构同personClassData相同，并且成员变量及属性列表等信息为空，而methods中存储着类方法personClassMethod。 接着来验证isa及superclass指针的指向是否同上图序号标注一样。 上图中通过地址证明meta-class的isa指向基类的meta-class，基类的isa指针也指向自己。 上图中通过地址证明meta-class的superclass指向父类的meta-class，基类的meta-class的superclass指向基类的class类。 以上文章整理自：https://juejin.im/post/5ac81c75518825556534c0af、https://juejin.im/post/5ad210636fb9a028da7cf90c","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS Principle：LLVMAndClang","slug":"iOS Principle LLVMAndClang","date":"2018-05-29T13:56:27.000Z","updated":"2018-11-16T13:24:49.138Z","comments":true,"path":"2018/05/29/iOS Principle LLVMAndClang/","link":"","permalink":"https://reversescale.github.io/2018/05/29/iOS Principle LLVMAndClang/","excerpt":"LLVM 是 Low Level Virtual Machine 的简称，这个库提供了与编译器相关的支持，能够进行程序语言的编译期优化、链接优化、在线编译优化、代码生成。简而言之，可以作为多种语言编译器的后台来使用~","text":"LLVM 是 Low Level Virtual Machine 的简称，这个库提供了与编译器相关的支持，能够进行程序语言的编译期优化、链接优化、在线编译优化、代码生成。简而言之，可以作为多种语言编译器的后台来使用~ 👨🏻‍💻 Github Demo 方便记忆 编译语言：OC 和 Swift 基于 Clang 和 LLVM 来编译（Clang 前端、LLVM 后端） 特点：Clang 更快、内存占用小、兼容GCC、设计简单、模块化库（GCC 支持JAVA等和更多平台） 编译工作：Clang 语法分析，语义分析，生成中间代码；LLVM 机器无关的代码优化，生成机器语言 编译完成：生成 dSYM 文件存放函数地址映射，Fabric、友盟等崩溃解析 编译插入：预处理——宏、插入脚本——cocoapod 编译时间优化： 代码层—优化@class代替#import、打包库、头文件进行预编译； 编译器层—debug模式不生成dsym和开启Build Active Architecture并且关闭编译器优化Only 整理学习 iOS Principle 一系列的文章，每篇开头归结知识点，帮助记忆 相关概念历史原因2000年，伊利诺伊大学厄巴纳－香槟分校（University of Illinois at Urbana-Champaign 简称UIUC）这所享有世界声望的一流公立研究型大学的 Chris Lattner（他的 twitter @clattner_llvm ） 开发了一个叫作 Low Level Virtual Machine 的编译器开发工具套件，后来涉及范围越来越大，可以用于常规编译器，JIT编译器，汇编器，调试器，静态分析工具等一系列跟编程语言相关的工作，于是就把简称 LLVM 这个简称作为了正式的名字。Chris Lattner 后来又开发了 Clang，使得 LLVM 直接挑战 GCC 的地位。2012年，LLVM 获得美国计算机学会 ACM 的软件系统大奖，和 UNIX，WWW，TCP/IP，Tex，JAVA 等齐名。 Chris Lattner 生于 1978 年，2005年加入苹果，将苹果使用的 GCC 全面转为 LLVM。2010年开始主导开发 Swift 语言。 iOS 开发中 Objective-C 是 Clang / LLVM 来编译的。 Swift 是 Swift / LLVM，其中 Swift 前端会多出 SIL optimizer，它会把 .swift 生成为中间代码 .sil 属于 High-Level IR， 因为 Swift 在编译时就完成了方法绑定，直接通过地址调用属于强类型语言，方法调用不再是像OC那样的消息发送，这样编译就可以获得更多的信息用在后面的后端优化上。 LLVM是一个模块化和可重用的编译器和工具链技术的集合，Clang 是 LLVM 的子项目，是 C，C++ 和 Objective-C 编译器，目的是提供惊人的快速编译，比 GCC 快3倍，其中的 clang static analyzer 主要是进行语法分析，语义分析和生成中间代码，当然这个过程会对代码进行检查，出错的和需要警告的会标注出来。LLVM 核心库提供一个优化器，对流行的 CPU 做代码生成支持。lld 是 Clang / LLVM 的内置链接器，clang 必须调用链接器来产生可执行文件。 这里是 Clang 官方详细文档： Welcome to Clang’s documentation! — Clang 4.0 documentation 这篇是对 LLVM 架构的一个概述： The Architecture of Open Source Applications 将编译器之前对于编译的前世今生也是需要了解的，比如回答下这个问题，编译器程序是用什么编译的？看看 《linkers and loaders》这本书就知道了。 LLVM 与 Clang 介绍LLVM 是 Low Level Virtual Machine 的简称，这个库提供了与编译器相关的支持，能够进行程序语言的编译期优化、链接优化、在线编译优化、代码生成。简而言之，可以作为多种语言编译器的后台来使用。如果这样还比较抽象的话，介绍下 Clang 就知道了：Clang 是一个 C++ 编写、基于 LLVM、发布于 LLVM BSD 许可证下的 C/C++/Objective C/Objective C++ 编译器，其目标（之一）就是超越 GCC。 Clang 开发事出有因，Wiki 介绍如下： Apple 使用 LLVM 在不支持全部 OpenGL 特性的 GPU (Intel 低端显卡) 上生成代码 (JIT)，令程序仍然能够正常运行。之后 LLVM 与 GCC 的集成过程引发了一些不快，GCC 系统庞大而笨重，而 Apple 大量使用的 Objective-C 在 GCC 中优先级很低。此外 GCC 作为一个纯粹的编译系统，与 IDE 配合很差。加之许可证方面的要求，Apple 无法使用修改版的 GCC 而闭源。于是 Apple 决定从零开始写 C family 的前端，也就是基于 LLVM 的 Clang 了。 Clang 的特性： 快：通过编译 OS X 上几乎包含了所有 C 头文件的 carbon.h 的测试，包括预处理 (Preprocess)，语法 (lex)，解析 (parse)，语义分析 (Semantic Analysis)，抽象语法树生成 (Abstract Syntax Tree) 的时间，Clang 是 Apple GCC 4.0 的 2.5x 快。(2007-7-25) 内存占用小：Clang 内存占用是源码的 130%，Apple GCC 则超过 10x。 诊断信息可读性强：我不会排版，推荐去网站观看。其中错误的语法不但有源码提示，还会在错误的调用和相关上下文的下方有~和^的提示，相比之下 GCC 的提示很天书。 GCC 兼容性。 设计清晰简单，容易理解，易于扩展增强。与代码基础古老的 GCC 相比，学习曲线平缓。 基于库的模块化设计，易于 IDE 集成及其他用途的重用。由于历史原因，GCC 是一个单一的可执行程序编译器，其内部完成了从预处理到最后代码生成的全部过程，中间诸多信息都无法被其他程序重用。Clang 将编译过程分成彼此分离的几个阶段，AST 信息可序列化。通过库的支持，程序能够获取到 AST 级别的信息，将大大增强对于代码的操控能力。对于 IDE 而言，代码补全、重构是重要的功能，然而如果没有底层的支持，只使用 tags 分析或是正则表达式匹配是很难达成的。 当然，GCC 也有其优势： 支持 JAVA/ADA/FORTRAN 当前的 Clang 的 C++ 支持落后于 GCC，参见。（近日 Clang 已经可以自编译，见） GCC 支持更多平台 GCC 更流行，广泛使用，支持完备 GCC 基于 C，不需要 C++ 编译器即可编译 iOS 开发中用途 一般可以将编程语言分为两种，编译语言和直译式语言。 编译语言:像C++,Objective C都是编译语言。编译语言在执行的时候，必须先通过编译器生成机器码，机器码可以直接在CPU上执行，所以执行效率较高。 直译式语言:像JavaScript,Python都是直译式语言。直译式语言不需要经过编译的过程，而是在执行的时候通过一个中间的解释器将代码解释为CPU可以执行的代码。所以，较编译语言来说，直译式语言效率低一些，但是编写的更灵活，也就是为啥JS大法好。 iOS开发目前的常用语言是：Objective和Swift。二者都是编译语言，换句话说都是需要编译才能执行的。二者的编译都是依赖于Clang + LLVM. iOS编译不管是OC还是Swift，都是采用Clang作为编译器前端，LLVM(Low level vritual machine)作为编译器后端。所以简单的编译过程如图 编译器前端编译器前端的任务是进行：语法分析，语义分析，生成中间代码(intermediate representation )。在这个过程中，会进行类型检查，如果发现错误或者警告会标注出来在哪一行。 编译器后端编译器后端会进行机器无关的代码优化，生成机器语言，并且进行机器相关的代码优化。iOS的编译过程，后端的处理如下 LVVM优化器会进行BitCode的生成，链接期优化等等。 LLVM机器码生成器会针对不同的架构，比如arm64等生成不同的机器码。 执行一次 XCode build 的流程当你在XCode中，选择build的时候(快捷键command+B)，会执行如下过程 编译信息写入辅助文件，创建编译后的文件架构(name.app) 处理文件打包信息，例如在debug环境下 12345Entitlements:&#123; &quot;application-identifier&quot; = &quot;app的bundleid&quot;; &quot;aps-environment&quot; = development;&#125; 执行CocoaPod编译前脚本(例如对于使用CocoaPod的工程会执行CheckPods Manifest.lock) 编译各个.m文件，使用CompileC和clang命令。 1234CompileC ClassName.o ClassName.m normal x86_64 objective-c com.apple.compilers.llvm.clang.1_0.compilerexport LANG=en_US.US-ASCIIexport PATH=&quot;...&quot;clang -x objective-c -arch x86_64 -fmessage-length=0 -fobjc-arc... -Wno-missing-field-initializers ... -DDEBUG=1 ... -isysroot iPhoneSimulator10.1.sdk -fasm-blocks ... -I 上文提到的文件 -F 所需要的Framework -iquote 所需要的Framework ... -c ClassName.c -o ClassName.o 通过这个编译的命令，我们可以看到 clang是实际的编译命令 x objective-c 指定了编译的语言 arch x86_64制定了编译的架构，类似还有arm7等 fobjc-arc 一些列-f开头的，指定了采用arc等信息。这个也就是为什么你可以对单独的一个.m文件采用非ARC编程。 Wno-missing-field-initializers 一系列以-W开头的，指的是编译的警告选项，通过这些你可以定制化编译选项 DDEBUG=1 一些列-D开头的，指的是预编译宏，通过这些宏可以实现条件编译 iPhoneSimulator10.1.sdk 制定了编译采用的iOS SDK版本 I 把编译信息写入指定的辅助文件 F 链接所需要的Framework c ClassName.c 编译文件 o ClassName.o 编译产物 工作流程 链接需要的Framework，例如Foundation.framework,AFNetworking.framework,ALiPay.fframework 编译xib文件 拷贝xib，图片等资源文件到结果目录 编译ImageAssets 处理info.plist 执行CocoaPod脚本 拷贝Swift标准库 创建.app文件和对其签名 dSYM 文件我们在每次编译过后，都会生成一个dsym文件。dsym文件中，存储了16进制的函数地址映射。 在App实际执行的二进制文件中，是通过地址来调用方法的。在App crash的时候，第三方工具(Fabric,友盟等)会帮我们抓到崩溃的调用栈，调用栈里会包含crash地址的调用信息。然后，通过dSYM文件，我们就可以由地址映射到具体的函数位置。 XCode中，选择Window -&gt; Organizer可以看到我们生成的archier文件 iOS 如何调试第三方统计到的崩溃报告 (http://blog.csdn.net/hello_hwc/article/details/50036323) attribute或多或少，你都会在第三方库或者iOS的头文件中，见到过attribute。 比如 1__attribute__ ((warn_unused_result)) //如果没有使用返回值，编译的时候给出警告 attribtue 是一个高级的的编译器指令，它允许开发者指定更更多的编译检查和一些高级的编译期优化。 分为三种： 函数属性 (Function Attribute) 类型属性 (Variable Attribute ) 变量属性 (Type Attribute ) 语法结构 attribute 语法格式为：attribute ((attribute-list)) 放在声明分号“;”前面。 比如，在三方库中最常见的，声明一个属性或者方法在当前版本弃用了 1@property (strong,nonatomic)CLASSNAME * property __deprecated; 这样的好处是：给开发者一个过渡的版本，让开发者知道这个属性被弃用了，应当使用最新的API，但是被__deprecated的属性仍然可以正常使用。如果直接弃用，会导致开发者在更新Pod的时候，代码无法运行了。 attribtue的使用场景很多，本文只列举iOS开发中常用的几个： 1234567891011121314151617181920//弃用API，用作API更新#define __deprecated __attribute__((deprecated))//带描述信息的弃用#define __deprecated_msg(_msg) __attribute__((deprecated(_msg)))//遇到__unavailable的变量/方法，编译器直接抛出Error#define __unavailable __attribute__((unavailable))//告诉编译器，即使这个变量/方法 没被使用，也不要抛出警告#define __unused __attribute__((unused))//和__unused相反#define __used __attribute__((used))//如果不使用方法的返回值，进行警告#define __result_use_check __attribute__((__warn_unused_result__))//OC方法在Swift中不可用#define __swift_unavailable(_msg) __attribute__((__availability__(swift, unavailable, message=_msg))) Clang警告处理你一定还见过如下代码： 1234#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;///代码#pragma clang diagnostic pop 这段代码的作用是 对当前编译环境进行压栈 忽略-Wundeclared-selector(未声明的)Selector警告 编译代码 对编译环境进行出栈 通过clang diagnostic push/pop,你可以灵活的控制代码块的编译选项。 iOS 合理利用Clang警告来提高代码质量 (http://blog.csdn.net/Hello_Hwc/article/details/46425503) 预处理所谓预处理，就是在编译之前的处理。预处理能够让你定义编译器变量，实现条件编译。 比如，这样的代码很常见 12345#ifdef DEBUG//...#else//...#endif 同样，我们同样也可以定义其他预处理变量,在XCode-选中Target-build settings中，搜索proprecess。然后点击图中蓝色的加号，可以分别为debug和release两种模式设置预处理宏。 比如我们加上：TestServer，表示在这个宏中的代码运行在测试服务器 然后，配合多个Target(右键Target，选择Duplicate)，单独一个Target负责测试服务器。这样我们就不用每次切换测试服务器都要修改代码了。 12345#ifdef TESTMODE//测试服务器相关的代码#else//生产服务器相关代码#endif 插入脚本通常，如果你使用CocoaPod来管理三方库，那么你的Build Phase是这样子的： 其中：[CP]开头的，就是CocoaPod插入的脚本。 Check Pods Manifest.lock，用来检查cocoapod管理的三方库是否需要更新 Embed Pods Framework，运行脚本来链接三方库的静态/动态库 Copy Pods Resources，运行脚本来拷贝三方库的资源文件 而这些配置信息都存储在这个文件(.xcodeprog)里 到这里，CocoaPod的原理也就大致搞清楚了，通过修改xcodeproject，然后配置编译期脚本，来保证三方库能够正确的编译连接。 同样，我们也可以插入自己的脚本，来做一些额外的事情。比如，每次进行archive的时候，我们都必须手动调整target的build版本，如果一不小心，就会忘记。这个过程，我们可以通过插入脚本自动化。 123buildNumber=$(/usr/libexec/PlistBuddy -c &quot;Print CFBundleVersion&quot; &quot;$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;&quot;)buildNumber=$(($buildNumber + 1))/usr/libexec/PlistBuddy -c &quot;Set :CFBundleVersion $buildNumber&quot; &quot;$&#123;PROJECT_DIR&#125;/$&#123;INFOPLIST_FILE&#125;&quot; 这段脚本其实很简单，读取当前pist的build版本号,然后对其加一，重新写入。 使用起来也很简单： Xcode – 选中Target – 选中build phase 选择添加Run Script Phase 然后把这段脚本拷贝进去，并且勾选Run Script Only When installing，保证只有我们在安装到设备上的时候，才会执行这段脚本。重命名脚本的名字为Auto Increase build number 然后，拖动这个脚本的到Link Binary With Libraries下面 脚本编译打包脚本化编译打包对于CI(持续集成)来说，十分有用。iOS开发中，编译打包必备的两个命令是： 1234567//编译成.appxcodebuild -workspace $projectName.xcworkspace -scheme $projectName -configuration $buildConfig clean build SYMROOT=$buildAppToDir//打包xcrun -sdk iphoneos PackageApplication -v $appDir/$projectName.app -o $appDir/$ipaName.ipa通过info命令，可以查看到详细的文档info xcodebuild 之前写的一套基于 Python 的编译打包脚本 (https://github.com/ReverseScale/AutoBuildScript/blob/master/autobuild.py) 提高项目编译速度通常，当项目很大，源代码和三方库引入很多的时候，我们会发现编译的速度很慢。在了解了XCode的编译过程后，我们可以从以下角度来优化编译速度： 查看编译时间我们需要一个途径，能够看到编译的时间，这样才能有个对比，知道我们的优化究竟有没有效果。 对于XCode 8，关闭XCode，终端输入以下指令 1defaults write com.apple.dt.Xcode ShowBuildOperationDuration YES 然后，重启XCode，然后编译，你会在这里看到编译时间。 代码层面的优化2.1)forward declaration 所谓forward declaration，就是@class CLASSNAME，而不是#import CLASSNAME.h。这样，编译器能大大提高#import的替换速度。 2.2)对常用的工具类进行打包(Framework/.a) 打包成Framework或者静态库，这样编译的时候这部分代码就不需要重新编译了。 2.3)常用头文件放到预编译文件里 XCode的pch文件是预编译文件，这里的内容在执行XCode build之前就已经被预编译，并且引入到每一个.m文件里了。 编译器选项优化3.1)Debug模式下，不生成dsym文件 上文提到了，dysm文件里存储了调试信息，在Debug模式下，我们可以借助XCode和LLDB进行调试。所以，不需要生成额外的dsym文件来降低编译速度。 3.2)Debug开启Build Active Architecture Only 在XCode -&gt; Build Settings -&gt; Build Active Architecture Only 改为YES。这样做，可以只编译当前的版本，比如arm7/arm64等等，记得只开启Debug模式。这个选项在高版本的XCode中自动开启了。 3.3)Debug模式下，关闭编译器优化 编译器优化 更多深入学习关于 iOS 编译 Clang LLVM 相关的知识整理参见：深入剖析 iOS 编译 Clang LLVM 版权声明此系列文章内容多为网上资料整理，文章结尾会列出参照链接，如有纰漏欢迎讨论🤗 以上文章整理自：https://my.oschina.net/u/2345393/blog/820141，https://linuxtoy.org/archives/llvm-and-clang.html，https://blog.csdn.net/hello_hwc/article/details/53557308，https://github.com/ming1016/study/wiki/深入剖析-iOS-编译-Clang---LLVM","categories":[{"name":"Principle","slug":"Principle","permalink":"https://reversescale.github.io/categories/Principle/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"走在技术前沿的 iOS 架构实现","slug":"iOS Architecture","date":"2018-05-01T13:56:27.000Z","updated":"2018-11-16T12:08:39.132Z","comments":true,"path":"2018/05/01/iOS Architecture/","link":"","permalink":"https://reversescale.github.io/2018/05/01/iOS Architecture/","excerpt":"我理解的框架，就好比计算机的主板，房屋的建筑骨架，道路的基础设施配套，框架搭的好，能直接影响开发者的开发心情，更能让项目健壮性和扩展性大大增强~","text":"我理解的框架，就好比计算机的主板，房屋的建筑骨架，道路的基础设施配套，框架搭的好，能直接影响开发者的开发心情，更能让项目健壮性和扩展性大大增强~ 基于 Objective-C 实现的框架设计，YTKNetwork网络层 + AOP替代基类 + MVVM + ReactiveObjC + JLRoutes路由 👨🏻‍💻 Github Demo 🤖 要求 iOS 8.0+ Xcode 8.0+ Objective-C 🎨 测试 UI 什么样子？ 1.展示页 2.展示页 3.展示页 4.说明页 登录视图 示例展示 跳转页面 介绍页面 🎯 安装方法安装在 iOS, 你需要在 Podfile 中添加.123456789101112131415161718source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;9.0&apos;use_frameworks! # 提示组件框架 pod &apos;SVProgressHUD&apos;, &apos;~&gt; 2.2.2&apos; # 网络请求框架 pod &apos;YTKNetwork&apos;, &apos;~&gt; 2.0.3&apos; # AOP面向切面 pod &apos;Aspects&apos;, &apos;~&gt; 1.4.1&apos; # 响应函数式框架 pod &apos;ReactiveObjC&apos;, &apos;~&gt; 3.0.0&apos; # 路由组件化解耦 pod &apos;JLRoutes&apos;, &apos;~&gt; 2.0.5&apos; # 提示组件框架 pod &apos;SVProgressHUD&apos;, &apos;~&gt; 2.2.2&apos; # 自动布局 pod &apos;Masonry&apos;, &apos;~&gt; 1.0.2&apos; 🛠 框架介绍AOP 模式（Aspects-RunTime 代替基类）+ Category 方法交换采用AOP思想，使用 Aspects 来完成替换 Controller ，View，ViewModel基类，和基类说拜拜 Casa反革命工程师 iOS应用架构谈 view层的组织和调用方案 博客中提到一个疑问是否有必要让业务方统一派生ViewController Casa大神回答是NO，原因如下 使用派生比不使用派生更容易增加业务方的使用成本 不使用派生手段一样也能达到统一设置的目的对于第一点，从 集成成本 ，上手成本 ，架构维护成本等因素入手，大神博客中也已经很详细。 框架不需要通过继承即能够对ViewController进行统一配置。业务即使脱离环境，也能够跑完代码，ViewController一旦放入框架环境，不需要添加额外的或者只需添加少量代码，框架也能够起到相应的作用 对于本人来说 ，具备这点的吸引力，已经足够让我有尝试一番的心思了。 对于OC来说，方法拦截很容易就想到自带的黑魔法方法调配 Method Swizzling， 至于为ViewController做动态配置，自然非Category莫属了Method Swizzling 业界已经有非常成熟的三方库 Aspects, 所以Demo代码采用 Aspects 做方法拦截。 12345678910111213141516171819202122+ (void)load &#123; [super load]; [FKViewControllerIntercepter sharedInstance];&#125;// .... 单例初始化代码- (instancetype)init &#123; self = [super init]; if (self) &#123; /* 方法拦截 */ // 拦截 viewDidLoad 方法 [UIViewController aspect_hookSelector:@selector(viewDidLoad) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt;aspectInfo)&#123; [self _viewDidLoad:aspectInfo.instance]; &#125; error:nil]; // 拦截 viewWillAppear: [UIViewController aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, BOOL animated)&#123; [self _viewWillAppear:animated controller:aspectInfo.instance]; &#125; error:NULL]; &#125; return self;&#125; 至于 Category 已经非常熟悉了 12345678910111213141516171819202122232425262728@interface UIViewController (NonBase)/** 去Model&amp;&amp;表征化参数列表 */@property (nonatomic, strong) NSDictionary *params;/** ViewModel 属性 */@property (nonatomic, strong) id &lt;FKViewControllerProtocol&gt; viewModel;#pragma mark - 通用类/** 返回Controller的当前bounds @param hasNav 是否有导航栏 @param hasTabBar 是否有tabbar @return 坐标 */- (CGRect)fk_visibleBoundsShowNav:(BOOL)hasNav showTabBar:(BOOL)hasTabBar;/** 隐藏键盘 */- (void)fk_hideKeyBoard;@end 至此，我们已经实现了不继承基类来实现对ViewController的配置，项目中的 View ViewModel 去基类原理如出一辙。 View层采用 MVVM 设计模式，使用 ReactiveObjC 进行数据绑定-MVC- 作为老牌思想MVC，大家早已耳熟能详，MVC素有 Massive VC之称，随着业务增加，Controller将会越来越复杂，最终Controller会变成一个”神类”, 即有网络请求等代码，又充斥着大量业务逻辑，所以为Controller减负，在某些情况下变得势在必行 -MVVM- MVVM是基于胖Model的架构思路建立的，然后在胖Model中拆出两部分：Model和ViewModel (注：胖Model 是指包含了一些弱业务逻辑的Model)胖Model实际上是为了减负 Controller 而存在的，而 MVVM 是为了拆分胖Model , 最终目的都是为了减负Controller。 我们知道，苹果MVC并没有专门为网络层代码分专门的层级，按照以往习惯，大家都写在了Controller 中，这也是Controller 变Massive得元凶之一，现在我们可以将网络请求等诸如此类的代码放到ViewModel中了 （文章后半部分将会描述ViewModel中的网络请求） -数据流向- 正常的网络请求获取数据，然后更新View自然不必多说，那么如果View产生了数据要怎么把数据给到Model，由于View不直接持有ViewModel，所以我们需要有个桥梁 ReactiveCocoa, 通过 Signal 来和 ViewModel 通信，这个过程我们使用 通知 或者 Target-Action也可以实现相同的效果，只不过没有 ReactiveCocoa 如此方便罢了 123456789101112131415161718/* View -&gt; ViewModel 传递数据示例 */#pragma mark - Bind ViewModel- (void)bindViewModel:(id&lt;FKViewModelProtocol&gt;)viewModel withParams:(NSDictionary *)params &#123; if ([viewModel isKindOfClass:[FKLoginViewModel class]])&#123; FKLoginViewModel *_viewModel = (FKLoginViewModel *)viewModel; // 绑定账号 View -&gt; ViewModel 传递数据 @weakify(self); RAC(_viewModel, userAccount) = [[self.inputTextFiled.rac_textSignal takeUntil:self.rac_prepareForReuseSignal] map:^id _Nullable(NSString * _Nullable account) &#123; @strongify(self); // 限制账号长度 if (account.length &gt; 25) &#123; self.inputTextFiled.text = [account substringToIndex:25]; &#125; return self.inputTextFiled.text; &#125;]; &#125;&#125; 上面代码给出了 View -&gt; ViewModel 绑定的一个例子 具体一些详情，可以直接看DemoMVVM一些总结： View C ViewModel Model 实际上应该称之为MVCVM Controller 将不再直接和 Model 进行绑定，而通过桥梁ViewModel 最终 Controller 的作用变成一些UI的处理逻辑，和进行View和ViewModel的绑定 MVVM 和 MVC 兼容 由于多了一层 ViewModel, 会需要写一些胶水代码，所以代码量会增加 网络层使用 YTKNetwork 配合 ReactiveCocoa 封装网络请求，解决如何交付数据，交付什么样的数据（去Model化)等问题YTKNetwork 是猿题库 iOS 研发团队基于 AFNetworking 封装的 iOS 网络库，其实现了一套 High Level 的 API，提供了更高层次的网络访问抽象。 笔者对 YTKNetwork 进行了一些封装，结合 ReactiveCocoa，并提供 reFormatter 接口对服务器响应数据重新处理，灵活交付给业务层。接下来，本文会回答两个问题 以什么方式将数据交付给业务层？ 交付什么样的数据 ?对于第一个问题 以什么方式将数据交付给业务层？ 虽然 iOS应用架构谈 网络层设计方案 中 Casa大神写到 尽量不要用block，应该使用代理的确，Block难以追踪和定位错误，容易内存泄漏， YTKNetwork 也提供代理方式回调 1234567891011121314@protocol YTKRequestDelegate &lt;NSObject&gt;@optional/// Tell the delegate that the request has finished successfully.////// @param request The corresponding request.- (void)requestFinished:(__kindof YTKBaseRequest *)request;/// Tell the delegate that the request has failed.////// @param request The corresponding request.- (void)requestFailed:(__kindof YTKBaseRequest *)request;@end 前文有说过，MVVM 并不等于 ReactiveCocoa , 但是想要体验最纯正的 ReactiveCocoa 还是Block较为酸爽，Demo中笔者两者都给出了代码, 大家可以自行选择和斟酌哈我们看一下 YTKNetwork 和 ReactiveCocoa 结合的代码 123456789101112131415161718192021222324252627- (RACSignal *)rac_requestSignal &#123; [self stop]; RACSignal *signal = [[RACSignal createSignal:^RACDisposable * _Nullable(id&lt;RACSubscriber&gt; _Nonnull subscriber) &#123; // 请求起飞 [self startWithCompletionBlockWithSuccess:^(__kindof YTKBaseRequest * _Nonnull request) &#123; // 成功回调 [subscriber sendNext:[request responseJSONObject]]; [subscriber sendCompleted]; &#125; failure:^(__kindof YTKBaseRequest * _Nonnull request) &#123; // 错误回调 [subscriber sendError:[request error]]; &#125;]; return [RACDisposable disposableWithBlock:^&#123; // Signal销毁 停止请求 [self stop]; &#125;]; &#125;] takeUntil:[self rac_willDeallocSignal]]; //设置名称 便于调试 if (DEBUG) &#123; [signal setNameWithFormat:@\"%@ -rac_xzwRequest\", RACDescription(self)]; &#125; return signal;&#125; 写了一个简单的 Category FKBaseRequest+Rac.hViewModel 中使用 RACCommand 封装调用：1234567891011- (RACCommand *)loginCommand &#123; if (!_loginCommand) &#123; @weakify(self); _loginCommand = [[RACCommand alloc] initWithSignalBlock:^RACSignal * _Nonnull(id _Nullable input) &#123; @strongify(self); return [[[FKLoginRequest alloc] initWithUsr:self.userAccount pwd:self.password] rac_requestSignal]; &#125;]; &#125; return _loginCommand;&#125; Block方式交付业务1234567FKLoginRequest *loginRequest = [[FKLoginRequest alloc] initWithUsr:self.userAccount pwd:self.password];return [[[loginRequest rac_requestSignal] doNext:^(id _Nullable x) &#123; // 解析数据 [[NSUserDefaults standardUserDefaults] setObject:@(YES) forKey:@\"isLogin\"]; &#125;] materialize]; Delegate方式交付业务12345678910FKLoginRequest *loginRequest = [[FKLoginRequest alloc] initWithUsr:self.userAccount pwd:self.password];// 数据请求响应代理 通过代理回调loginRequest.delegate = self;return [loginRequest rac_requestSignal];#pragma mark - YTKRequestDelegate- (void)requestFinished:(__kindof YTKBaseRequest *)request &#123; // 解析数据 [[NSUserDefaults standardUserDefaults] setObject:@(YES) forKey:@\"isLogin\"];&#125; 交付什么样的数据 ? 现在诸如 JSONModel ，YYModel 之类的Json转Model的库也非常多，大多数Json对象，网络请求成功直接就被转成Model了然而 iOS应用架构谈 网络层设计方案 中给出了两种有意思的交付思路 使用 reformer 对数据进行清洗 去特定对象表征 （去Model） Casa文章中好处已经写得很详细了，通过不同的 reformer 来重塑和交付不同的业务数据，可以说是非常灵活了 使用 reformer 对数据进行清洗 在网络层封装 FKBaseRequest.h 中 给出了 FKBaseRequestFeformDelegate 接口来重塑数据1234567891011121314151617181920@protocol FKBaseRequestFeformDelegate &lt;NSObject&gt;/** 自定义解析器解析响应参数 @param request 当前请求 @param jsonResponse 响应数据 @return 自定reformat数据 */- (id)request:(FKBaseRequest *)request reformJSONResponse:(id)jsonResponse;@end然后在对应的 reformer 对数据进行重塑#pragma mark - FKBaseRequestFeformDelegate- (id)request:(FKBaseRequest *)request reformJSONResponse:(id)jsonResponse &#123; if([request isKindOfClass:FKLoginRequest.class])&#123; // 在这里对json数据进行重新格式化 &#125; return jsonResponse;&#125; 也可以直接在子类的 RequestManager 中覆盖父类方法达到一样的效果12345/* FKLoginRequest.m */// 可以在这里对response 数据进行重新格式化， 也可以使用delegate 设置 reformattor- (id)reformJSONResponse:(id)jsonResponse &#123;&#125; 去特定对象表征 （去Model） 这思路可以说是业界的泥石流了去Model也就是说，使用NSDictionary形式交付数据，对于网络层而言，只需要保持住原始数据即可，不需要主动转化成数据原型但是会存在一些小问题 去Model如何保持可读性？ 复杂和多样的数据结构如何解析？ Casa大神 提出了 使用EXTERN + Const 字符串形式，并建议字符串跟着reformer走，个人觉得很多时候API只需要一种解析格式，所以Demo跟着 APIManager 走，其他情况下常量字符串建议听从 Casa大神 的建议，常量定义： 123456/* FKBaseRequest.h */// 登录token keyFOUNDATION_EXTERN NSString *FKLoginAccessTokenKey;/* FKBaseRequest.m */NSString *FKLoginAccessTokenKey = @\"accessToken\"; 在 .h 和 .m 文件中要同时写太多代码，我们也可以使用局部常量的形式，只要在 .h 文件中定义即可 12345678910111213// 也可以写成 局部常量形式static const NSString *FKLoginAccessTokenKey2 = @\"accessToken\";最终那么我们的reformer可能会变成这样子- (id)request:(FKBaseRequest *)request reformJSONResponse:(id)jsonResponse &#123; if([request isKindOfClass:FKLoginRequest.class])&#123; // 在这里对json数据进行重新格式化 return @&#123; FKLoginAccessTokenKey : jsonResponse[@\"token\"], &#125;; &#125; return jsonResponse;&#125; 复杂和多样的数据结构如何解析？有时候，reformer 交付过来的数据，我们需要解析的可能是字符串类型，也可能是NSNumber类型，也有可能是数组为此，笔者提供了一系列 Encode Decode方法，来降低解析的复杂度和安全性1234567891011121314151617181920212223242526#pragma mark - Encode Decode 方法// NSDictionary -&gt; NSStringFK_EXTERN NSString* DecodeObjectFromDic(NSDictionary *dic, NSString *key);// NSArray + index -&gt; idFK_EXTERN id DecodeSafeObjectAtIndex(NSArray *arr, NSInteger index);// NSDictionary -&gt; NSStringFK_EXTERN NSString * DecodeStringFromDic(NSDictionary *dic, NSString *key);// NSDictionary -&gt; NSString ？ NSString ： defaultStrFK_EXTERN NSString* DecodeDefaultStrFromDic(NSDictionary *dic, NSString *key,NSString * defaultStr);// NSDictionary -&gt; NSNumberFK_EXTERN NSNumber * DecodeNumberFromDic(NSDictionary *dic, NSString *key);// NSDictionary -&gt; NSDictionaryFK_EXTERN NSDictionary *DecodeDicFromDic(NSDictionary *dic, NSString *key);// NSDictionary -&gt; NSArrayFK_EXTERN NSArray *DecodeArrayFromDic(NSDictionary *dic, NSString *key);FK_EXTERN NSArray *DecodeArrayFromDicUsingParseBlock(NSDictionary *dic, NSString *key, id(^parseBlock)(NSDictionary *innerDic));#pragma mark - Encode Decode 方法// (nonull Key: nonull NSString) -&gt; NSMutableDictionaryFK_EXTERN void EncodeUnEmptyStrObjctToDic(NSMutableDictionary *dic,NSString *object, NSString *key);// nonull objec -&gt; NSMutableArrayFK_EXTERN void EncodeUnEmptyObjctToArray(NSMutableArray *arr,id object);// (nonull (Key ? key : defaultStr) : nonull Value) -&gt; NSMutableDictionaryFK_EXTERN void EncodeDefaultStrObjctToDic(NSMutableDictionary *dic,NSString *object, NSString *key,NSString * defaultStr);// (nonull Key: nonull object) -&gt; NSMutableDictionaryFK_EXTERN void EncodeUnEmptyObjctToDic(NSMutableDictionary *dic,NSObject *object, NSString *key); 我们的reformer可以写成这样子1234567891011#pragma mark - FKBaseRequestFeformDelegate- (id)request:(FKBaseRequest *)request reformJSONResponse:(id)jsonResponse &#123; if([request isKindOfClass:FKLoginRequest.class])&#123; // 在这里对json数据进行重新格式化 return @&#123; FKLoginAccessTokenKey : DecodeStringFromDic(jsonResponse, @\"token\") &#125;; &#125; return jsonResponse;&#125; 解析有可能是这样子1NSString *token = DecodeStringFromDic(jsonResponse, FKLoginAccessTokenKey) 好了，至此我们解决了两个问题 以什么方式将数据交付给业务层答：delegate 最佳，block为次 交付什么样的数据答：纯字典，去Model 采用 JLRoutes 路由对应用进行组件化解耦 带着问题思考如何才能设计出最好的组件化路由： 1）3D-Touch功能或者点击推送消息，要求外部跳转到App内部一个很深层次的一个界面。 2）自家的一系列App之间如何相互跳转？ 3）如何解除App组件之间和App页面之间的耦合性？ 4）如何能统一iOS和Android两端的页面跳转逻辑？甚至如何能统一三端的请求资源的方式？ 5）如果使用了动态下发配置文件来配置App的跳转逻辑，那么如果做到iOS和Android两边只要共用一套配置文件？ 6）如果App出现bug了，如何不用JSPatch，就能做到简单的热修复功能？ 7）如何在每个组件间调用和页面跳转时都进行埋点统计？每个跳转的地方都手写代码埋点？利用Runtime AOP ？ 8）如何在每个组件间调用的过程中，加入调用的逻辑检查，令牌机制，配合灰度进行风控逻辑？ 9）如何在App任何界面都可以调用同一个界面或者同一个组件？只能在AppDelegate里面注册单例来实现？ iOS应用架构谈 组件化方案 一文中 Casa 针对 蘑菇街组件化 提出了质疑，质疑点主要在这几方面 App启动时组件需要注册URL URL调用组件方式不太好传递类似 UIImage 等非常规对象 URL需要添加额外参数可读性差，所以没必要使用URL 对于 App启动时组件需要注册URL 顾虑主要在于，注册的URL需要在应用生存周期内常驻内存，如果是注册Class还好些，如果注册的是实例，消耗的内存就非常可观了 12345#pragma mark - 路由表NSString *const FKNavPushRoute = @\"/com_madao_navPush/:viewController\";NSString *const FKNavPresentRoute = @\"/com_madao_navPresent/:viewController\";NSString *const FKNavStoryBoardPushRoute = @\"/com_madao_navStoryboardPush/:viewController\";NSString *const FKComponentsCallBackRoute = @\"/com_madao_callBack/*\"; 而且JLRoutes 还支持 * 来进行通配，路由表如何编写大家可以自由发挥对应的路由事件 handler 12345678910111213141516171819202122232425262728293031323334353637// push// 路由 /com_madao_navPush/:viewController[[JLRoutes globalRoutes] addRoute:FKNavPushRoute handler:^BOOL(NSDictionary&lt;NSString *,id&gt; * _Nonnull parameters) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [self _handlerSceneWithPresent:NO parameters:parameters]; &#125;); return YES;&#125;];// present// 路由 /com_madao_navPresent/:viewController[[JLRoutes globalRoutes] addRoute:FKNavPresentRoute handler:^BOOL(NSDictionary&lt;NSString *,id&gt; * _Nonnull parameters) &#123; dispatch_async(dispatch_get_main_queue(), ^&#123; [self _handlerSceneWithPresent:YES parameters:parameters]; &#125;); return YES;&#125;];#pragma mark - Private/// 处理跳转事件- (void)_handlerSceneWithPresent:(BOOL)isPresent parameters:(NSDictionary *)parameters &#123; // 当前控制器 NSString *controllerName = [parameters objectForKey:FKControllerNameRouteParam]; UIViewController *currentVC = [self _currentViewController]; UIViewController *toVC = [[NSClassFromString(controllerName) alloc] init]; toVC.params = parameters; if (currentVC &amp;&amp; currentVC.navigationController) &#123; if (isPresent) &#123; [currentVC.navigationController presentViewController:toVC animated:YES completion:nil]; &#125;else &#123; [currentVC.navigationController pushViewController:toVC animated:YES]; &#125; &#125;&#125; 通过URL中传入的组件名动态注册，处理相应跳转事件，并不需要每个组件一一注册使用URL路由，必然URL会散落到代码各个地方 1234NSString *key = @\"key\";NSString *value = @\"value\";NSString *url = [NSString stringWithFormat:@\"/com_madao_navPush/%@?%@=%@\", NSStringFromClass(ViewController.class), key, value];[[UIApplication sharedApplication] openURL:[NSURL URLWithString:url]]; 诸如此类丑陋的代码，散落在各个地方的话简直会让人头皮发麻, 所以笔者在 JLRoutes+GenerateURL.h 写了一些 Helper方法1234567891011121314151617181920212223242526272829303132333435/** 避免 URL 散落各处， 集中生成URL @param pattern 匹配模式 @param parameters 附带参数 @return URL字符串 */+ (NSString *)fk_generateURLWithPattern:(NSString *)pattern parameters:(NSArray *)parameters;/** 避免 URL 散落各处， 集中生成URL 额外参数将被 ?key=value&amp;key2=value2 样式给出 @param pattern 匹配模式 @param parameters 附加参数 @param extraParameters 额外参数 @return URL字符串 */+ (NSString *)fk_generateURLWithPattern:(NSString *)pattern parameters:(NSArray *)parameters extraParameters:(NSDictionary *)extraParameters;/** 解析NSURL对象中的请求参数http://madao?param1=value1¶m2=value2 解析成 @&#123;param1:value1, param2:value2&#125; @param URL NSURL对象 @return URL字符串 */+ (NSDictionary *)fk_parseParamsWithURL:(NSURL *)URL;/** 将参数对象进行url编码 将@&#123;param1:value1, param2:value2&#125; 转换成 ?param1=value1&amp;param2=value2 @param dic 参数对象 @return URL字符串 */+ (NSString *)fk_mapDictionaryToURLQueryString:(NSDictionary *)dic; 宏定义Helper12345678910#undef JLRGenRoute#define JLRGenRoute(Schema, path) \\([NSString stringWithFormat: @\"%@:/%@\", \\Schema, \\path])#undef JLRGenRouteURL#define JLRGenRouteURL(Schema, path) \\([NSURL URLWithString: \\JLRGenRoute(Schema, path)]) 最终我们的调用可以变成12NSString *router = [JLRoutes fk_generateURLWithPattern:FKNavPushRoute parameters:@[NSStringFromClass(ViewController.class)] extraParameters:nil];[[UIApplication sharedApplication] openURL:JLRGenRouteURL(FKDefaultRouteSchema, router)]; 📝 整理制作Casa Taloyum：https://casatwy.com/modulization_in_action.html 简书博客：http://www.jianshu.com/p/921dd65e79cb 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"ReactNative 开发常用命令行（持续更新）","slug":"ReactNative command","date":"2018-03-29T14:56:27.000Z","updated":"2018-11-16T12:13:47.540Z","comments":true,"path":"2018/03/29/ReactNative command/","link":"","permalink":"https://reversescale.github.io/2018/03/29/ReactNative command/","excerpt":"记录一些 ReactNative 常用的命令行，包括了例如安装、启动服务、插件管理、热更新等一些日常经常使用的命令，会随着使用的深入不断的补充 ~","text":"记录一些 ReactNative 常用的命令行，包括了例如安装、启动服务、插件管理、热更新等一些日常经常使用的命令，会随着使用的深入不断的补充 ~ Node 相关查看所有安装的node版本信息：1nvm list 查看更新了的node的版本(可能需要翻墙)：1nvm ls-remote 安装node：1nvm install v7.4.0 设置默认的node版本(这里设置成了7.4.0)，解决有些版本有些兼容性的问题：1nvm alias default v7.4.0 React 相关卸载命令：1npm uninstall -g react-native-cli 安装命令：1npm install -g react-native-cli 查看某个模块最新发布版本信息(这里查看react-native发布的版本信息)：1npm info react-native 升级或者降级react-native的版本并且更新package.json，需要用在react-native项目目录下：1npm install --save react-native@0.41.1 新建 react-native 项目并指定版本：1react-native init demo --version 0.40.0 开启服务：1react-native start 运行Android：1react-native run-android 运行iOS：1react-native run-ios 版本查看：1react-native --version 项目版本查看：1react-native -v 查看react-native的帮助信息：1react-native --help 使用 Cocoapods 管理 ReactNativePodfile 文件格式：1234567891011pod &apos;React&apos;, :path =&gt; &apos;./node_modules/react-native&apos;, :subspecs =&gt; [ &apos;Core&apos;, &apos;RCTText&apos;, &apos;RCTImage&apos;, &apos;RCTActionSheet&apos;, &apos;RCTGeolocation&apos;, &apos;RCTNetwork&apos;, &apos;RCTSettings&apos;, &apos;RCTVibration&apos;, &apos;RCTWebSocket&apos;, ] ReactNative 0.42.0 以上版本需在 Podfile 配置 yoga：12# 如果你的RN版本 &gt;= 0.42.0，请加入下面这行pod &quot;yoga&quot;, :path =&gt; &quot;./node_modules/react-native/ReactCommon/yoga&quot; 开源组件库：安装最新版本：1npm install react-native-tab-navigator --save 安装指定版本：1npm install --save react-native-tab-navigator@0.4.0 react-native 集成组件绑定(ReactNative 0.27以后，自集成RNPM)：1react-native link react-native-splash-screen 常用开源库：12345678npm install --save react-native-tab-navigator@0.4.0npm install --save react-native-scrollable-tab-view@0.7.0npm install --save react-native-check-box@1.0.4npm install --react-native-easy-toast@1.0.9npm install --save GitHubTrending@2.0.0npm install --save react-native-htmlview@0.5.0npm install --save react-native-popover@0.5.0npm install --react-native-splash-screen@2.0.0 Code-Push 常用命令Code-Push 推包命令：1code-push release-react &lt;appName&gt; &lt;platform&gt; [options] 示例： 1code-push release-react RNAPPGithub ios --t 1.0.2 --dev false --d Staging --des &quot;1.热更新相关设置&quot; --m true Code-Push 线上查看更新：1code-push deployment ls RNAPPGithub Code-Push 查看项目Key：1code-push deployment ls RNAPPGithub -k Code-Push iOS更新打包方法：1react-native bundle --platform ios --entry-file index.js --bundle-output release_ios/main.jsbundle --assets-dest release_ios/ --dev fasle IDE 技巧《使用VS Code调试React-Native程序》（https://jingyan.baidu.com/article/ad310e80fb13fc1849f49ed1.html）","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"https://reversescale.github.io/tags/ReactNative/"}]},{"title":"ReactNative 学习成果总结","slug":"ReactNative APP","date":"2018-03-29T11:56:27.000Z","updated":"2018-11-16T12:13:55.027Z","comments":true,"path":"2018/03/29/ReactNative APP/","link":"","permalink":"https://reversescale.github.io/2018/03/29/ReactNative APP/","excerpt":"ReactNative 这几年风生水起，当然除了 React 社区生态圈的加持和 Facebook 的大力推广以外，另外一个最主要的原因就是其在开发效率和应用性能方面取得了一个比较好的平衡~","text":"ReactNative 这几年风生水起，当然除了 React 社区生态圈的加持和 Facebook 的大力推广以外，另外一个最主要的原因就是其在开发效率和应用性能方面取得了一个比较好的平衡~ 学习课程：《双平台真实开发GitHub App React Native技术全面掌握》399 大洋，含着泪吃了一个月泡面.. 👨🏻‍💻 Github Demo 知识点： 1.整理 ReactNative 网络封装及常用的三方模块 2.ReactNative 的 AsyncStorage数据库技术、离线缓存 3.ReactNative 的数据 DAO 层设计技巧，数据状态实时更新 4.ReactNative 的代码提取技巧，组合模式应用技巧，数据异步刷新与动态添加 5.ReactNative 的版本升级、数据统计、社会化分享、第三方登录，热更新等 6.ReactNative 项目发布前的优化、打包与上线 目录结构： 生命周期及使用场景 项目介绍 组件化 集成与管理 布局约束 组件封装 本地持久化 网络请求封装 功能调试 双平台适配 开源组件库的使用 热更新 生命周期及使用场景常用方法： constructor: componentWillMount: render: componentDidMount: componentWillReceiveProps: shouldComponentUpdate: componentWillUpdate: componentDidUpdate componentWillUnmount: constructor:在组件创建的时候调用一次,这个方法进行this.state初始化状态机。123456constructor(props) &#123; super(props); // 初始状态 this.state = &#123; isShow:true &#125;;&#125; componentWillMount:在组件生命周期中只会被执行一次,在初始渲染(render函数)前被执行。注意: 如果这个函数通过setState函数修改状态机变量,RN框架不会额外执行渲染(界面刷新) 如果子组件也有componentWillMount函数使用,会在父组件之后调用 需要从本地存储中读取数据用于显示,常用这个函数 render:该函数组件必有的，通过返回JSX或其他组件来构成DOM，换言之，就是组件的核心渲染过程。 componentDidMount:在React Native组件的生命周期中,这个函数只会被执行一次，它在初始渲染完成后会马上被调用。在这之后开发者可以通过子组件的引用来访问，操作任何子组件。如果RN组件的子组件也有componentDidMount函数，并会在父组件的componentDidMount函数之前被调用。 常用来网络请求数据 componentWillReceiveProps:在React Native组件的初始渲染完成后，props改变时，这个函数被调用，参数是个新的props。 shouldComponentUpdate:React Native组件的初始渲染执行完成后, RN组件接收到新的state或者props时这个函数会调用。 通过这个函数阻止无必要的重新渲染，是提高React Native应用程序性能的一大技巧。 componentWillUpdate:初始渲染完成后,重新渲染前会调用这个函数。 这个函数不能通过this.setState再次改变状态机变量的值。 组件更新时调用。 componentDidUpdateRN组件初始渲染完成后，RN框架在重新渲染RN组件完成后调用。参数是渲染前的props和state。 组件更新完毕时调用。 componentWillUnmount:ReactNative 组件被卸载前会调用，通常做一些清理内容。 项目介绍双平台效果预览： React Native是React在移动端的跨平台方案。如果想更快地理解和掌握React Native开发，就必须先了解React。 React是FaceBook开源的一个前端框架，它起源于 Facebook 的内部项目，并于 2013 年 5 月开源。因为React 拥有较高的性能，代码逻辑非常简单，所以越来越多的人已开始关注和使用它，目前该框架在Github上已经有7万+star。 ReactNative 技术导图： 组件化React采用组件化的方式开发，通过将view构建成组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。有一句话说的很形象：在React中，构建应用就像搭积木一样。 组件化特征React认为一个组件应该具有如下特征： 可组合（Composeable）：一个组件易于和其它组件一起使用，或者嵌套在另一个组件内部。如果一个组件内部创建了另一个组件，那么说父组件拥有它创建的子组件，通过这个特性，一个复杂的UI可以拆分成多个简单的UI组件； 可重用（Reusable）：每个组件都是具有独立功能的，它可以被使用在多个UI场景； 可维护（Maintainable）：每个小的组件仅仅包含自身的逻辑，更容易被理解和维护； 封装好的导航栏就可以被称之为一个组件，它符合上述三个特点： 可组合：可以将导航栏组件放在页面组件中作为页面组件的子组件。而且在导航栏组件的内部，也有按钮组件等子组件。 可重用：如果封装好了该组件，就可以放在任意需要导航栏的页面（组件）使用，也可以放在其他项目中使用。 可维护：因为具有独立的功能和展示逻辑，所以便于定位和修改。 组件的属性与状态在React Native（React.js）里，组件所持有的数据分为两种： 属性（props）：组件的props是不可变的，它只能从其他的组件（例如父组件）传递过来。 状态（state）：组件的state是可变的，它负责处理与用户的交互。在通过用户点击事件等操作以后，如果使得当前组件的某个state发生了改变，那么当前组件就会触发render()方法刷新自己。 我们可以看到这个页面有两个子页面，一个是‘最热’页面（组件），另一个是‘趋势‘页面（组件）。那么这两个组件都有什么props和state呢？ 1.props：由于props是从其父组件传递过来的，那么可想而知，props的声明应该是在当前组件的父组件里来做。在React Native中，通常props的声明是和当前组件的声明放在一起的： 1234//最热子页面&lt;FavoriteTabPage &#123;...this.props&#125; tabLabel='最热' flag=&#123;FlAG_STORAGE.flag_popular&#125;/&gt;//趋势子页面&lt;FavoriteTabPage &#123;...this.props&#125; tabLabel='趋势' flag=&#123;FlAG_STORAGE.flag_trending&#125;/&gt; 在这里，收藏页面是父组件，而最热页面和趋势页面是其子组件。在收藏页面组件里声明了最热页面和趋势页面的组件。 而且我们也可以看到，最热页面和趋势页面组件都用的是同一个组件：FavoriteTabPage，而这两个页面的不同点只在于传入的两个props的不同：tabLabel和flag。 而在FavoriteTabPage组件内部，如果想调用flag这个props，可以使用this.props.flag来调用。 2.state: 下面是最热和趋势页面的组件： 12345678class FavoriteTabPage extends Component&#123;//组件的构造方法constructor(props)&#123; super(props); this.state=&#123; dataSource:new ListView.DataSource(&#123;rowHasChanged:(r1,r2)=&gt;r1!==r2&#125;),isLoading:false, &#125;&#125; 这里面定义了两个state: dataSource:列表的数据源 isLoading:是否正在刷新 这两个state都是将来可能经常变化的。比如在网络请求以后，列表的数据源会被替换掉，这个时候就要调用: 1234this.setState(&#123; //把新的值newDataArr对象传给dataSource dataSource:newDataArr&#125;) 3.DOMDOM 是前端的一个概念，暂时可以粗略理解为一个页面的树形结构。React 生命周期的三大阶段 Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM 在每个阶段都有相应的状态和与之对应的回调函数，具体可以看下图： 上图来自：贾鹏辉的技术博客：React Native之React速学教程(中) 集成与管理1.指定版本初始化在终端输入react-native demo –version 0.40.0命令以后，就会初始化一个React Native版本为0.40.0的项目。这个最初项目里面直接就包含了iOS和Android的工程文件夹，可以用对应的IDE打开后编译运行。 在新建一个React Native项目之后的根目录结构是这样的： 2.使用 Cocoapods 管理 ReactNativePodfile 文件格式：1234567891011pod &apos;React&apos;, :path =&gt; &apos;./node_modules/react-native&apos;, :subspecs =&gt; [ &apos;Core&apos;, &apos;RCTText&apos;, &apos;RCTImage&apos;, &apos;RCTActionSheet&apos;, &apos;RCTGeolocation&apos;, &apos;RCTNetwork&apos;, &apos;RCTSettings&apos;, &apos;RCTVibration&apos;, &apos;RCTWebSocket&apos;, ] ReactNative 0.42.0 以上版本需在 Podfile 配置 yoga：12# 如果你的RN版本 &gt;= 0.42.0，请加入下面这行pod &quot;yoga&quot;, :path =&gt; &quot;./node_modules/react-native/ReactCommon/yoga&quot; 输入react-native run-ios或者react-native run-android指令， 就会自动打开模拟器运行项目(前提是安装了相应的开发环境)。 但是一个比较完整的项目仅仅有这些类别的文件是不够的，还需要一些工具类，模型类，资源等文件。为了很好地区分它们，使项目结构一目了然，需要组织好项目文件夹以及类的命名，下面是我将教程里的文件夹命名和结构稍加修改后的一个方案，可供大家参考： 布局约束采用Flex布局的元素，被称为Flex container，其所有子元素被称为Flex item；容器默认存在两个轴，分别是主轴（main axis）和垂直的交叉轴（cross axis）,主轴开始的位置叫做main start，结束的位置叫main end；交叉轴的开始位置叫做cross start，结束的位置叫做cross end；单个item占据的主轴空间叫做main size，占据的交叉轴控件叫做cross size。 如下图所示： 组件化驱动下，搜索结果页中展示的 Cell 与之前的列表页 Cell 可以重用： 我们把该组件定名为：RespositoryCell，结合代码来看一下具体的实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960export default class RepositoryCell extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; isFavorite: this.props.projectModel.isFavorite, favoriteIcon: this.props.projectModel.isFavorite ? require('../../res/images/ic_star.png') : require('../../res/images/ic_unstar_transparent.png'), &#125;; &#125; componentWillReceiveProps(nextProps) &#123; this.setFavoriteState(nextProps.projectModel.isFavorite) &#125; setFavoriteState(isFavorite) &#123; this.props.projectModel.isFavorite = isFavorite; this.setState(&#123; isFavorite: isFavorite, favoriteIcon: isFavorite ? require('../../res/images/ic_star.png') : require('../../res/images/ic_unstar_transparent.png') &#125;) &#125; onPressFavorite() &#123; this.setFavoriteState(!this.state.isFavorite) this.props.onFavorite(this.props.projectModel.item, !this.state.isFavorite) &#125; render() &#123; let item = this.props.projectModel.item? this.props.projectModel.item:this.props.projectModel; let favoriteButton=this.props.projectModel.item? &lt;TouchableOpacity style=&#123;&#123;padding:6&#125;&#125; onPress=&#123;()=&gt;this.onPressFavorite()&#125; underlayColor='transparent'&gt; &lt;Image ref='favoriteIcon' style=&#123;[&#123;width: 22, height: 22,&#125;,this.props.theme.styles.tabBarSelectedIcon]&#125; source=&#123;this.state.favoriteIcon&#125;/&gt; &lt;/TouchableOpacity&gt;:null; return ( &lt;TouchableOpacity onPress=&#123;this.props.onSelect&#125; style=&#123;styles.container&#125; &gt; &lt;View style=&#123;styles.cell_container&#125;&gt; &lt;Text style=&#123;styles.title&#125;&gt;&#123;item.full_name&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.description&#125;&gt;&#123;item.description&#125;&lt;/Text&gt; &lt;View style=&#123;styles.row&#125;&gt; &lt;View style=&#123;styles.row&#125;&gt; &lt;Text&gt;Author:&lt;/Text&gt; &lt;Image style=&#123;&#123;height: 22, width: 22&#125;&#125; source=&#123;&#123;uri: item.owner.avatar_url&#125;&#125; /&gt; &lt;/View&gt; &lt;View style=&#123;&#123;justifyContent: 'space-between', flexDirection: 'row'&#125;&#125;&gt; &lt;Text&gt;Star:&lt;/Text&gt; &lt;Text&gt;&#123;item.stargazers_count&#125;&lt;/Text&gt; &lt;/View&gt; &#123;favoriteButton&#125; &lt;/View&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; ) &#125;&#125; 这里声明了RespositoryCell组件，它继承于Component，也就是组件类，即是说，声明组件的时候必须都要继承与这个类。 集中看一下该组件的render方法，它返回的是该组件的实际布局：在语法上使用JSX，类似于HTML的标签式语法，很清楚地将cell的层级展现了出来： 最外层被一个View组件包裹着，里面第一层有三个子组件：两个Text组件和一个作为底部背景的View组件。 底部背景的View组件又有三个子组件：View组件（显示作者信息），View组件（显示star信息）,收藏按钮。 结构分解图： 组件封装 我的页面 个人中心 对于“我的页面”和“个人中心”这类结构相似的页面，建议进行组件封装，封装后的 AboutPage 实现代码简洁如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768export default class AboutPage extends Component&#123; constructor(props) &#123; super(props); this.aboutCommon=new AboutCommon(props,(dic)=&gt;this.updateState(dic),FLAG_ABOUT.flag_about,config); this.state = &#123; projectModels: [], author:config.author &#125; &#125; componentDidMount() &#123; this.aboutCommon.componentDidMount(); &#125; componentWillUnmount() &#123; this.aboutCommon.componentWillUnmount(); &#125; updateState(dic)&#123; this.setState(dic); &#125; onClick(tab) &#123; let TargetComponent, params = &#123;...this.props,menuType:tab&#125;; switch (tab) &#123; case MORE_MENU.About_Author: TargetComponent = AboutMePage; break; case MORE_MENU.Website: TargetComponent = WebViewPage; params.title='GitHubPopular'; var url='https://reversescale.github.io'; params.url=url; break; case MORE_MENU.Feedback: var url='mailto://reversescale@icloud.com'; Linking.canOpenURL(url).then(supported =&gt; &#123; if (!supported) &#123; console.log('Can\\'t handle url: ' + url); &#125; else &#123; return Linking.openURL(url); &#125; &#125;).catch(err =&gt; console.error('An error occurred', err)); break; case MORE_MENU.Share: break; &#125; if (TargetComponent) &#123; this.props.navigator.push(&#123; component: TargetComponent, params: params, &#125;); &#125; &#125; render() &#123; let content=&lt;View&gt; &#123;this.aboutCommon.renderRepository(this.state.projectModels)&#125; &#123;ViewUtils.getSettingItem(()=&gt;this.onClick(MORE_MENU.Website), require('../../../res/images/ic_computer.png'), MORE_MENU.Website, this.props.theme.styles.tabBarSelectedIcon)&#125; &lt;View style=&#123;GlobalStyles.line&#125;/&gt; &#123;ViewUtils.getSettingItem(()=&gt;this.onClick(MORE_MENU.About_Author), require('../my/img/ic_insert_emoticon.png'), MORE_MENU.About_Author, this.props.theme.styles.tabBarSelectedIcon)&#125; &lt;View style=&#123;GlobalStyles.line&#125;/&gt; &#123;ViewUtils.getSettingItem(()=&gt;this.onClick(MORE_MENU.Feedback), require('../../../res/images/ic_feedback.png'), MORE_MENU.Feedback, this.props.theme.styles.tabBarSelectedIcon)&#125; &lt;/View&gt; return this.aboutCommon.render(content, &#123; 'name': 'GitHub Popular', 'description': '这是一个用来查看GitHub最受欢迎与最热项目的App,它基于React Native支持Android和iOS双平台。', \"avatar\": \"http://og1yl0w9z.bkt.clouddn.com/18-3-28/61685877.jpg\", \"backgroundImg\": \"http://og1yl0w9z.bkt.clouddn.com/18-3-28/37407402.jpg\", &#125;); &#125;&#125; 本地持久化 主题选择界面 切换主题后界面 在涉及如主题变更等操作时，需要将状态信息保存，这时就需要用到类似于iOS 中的NSUserDefault， AsyncStorage 是React Native中的 Key-Value 存储系统，可以做本地持久化。 首先看它主要的几个接口： 根据键来获取值，获取的结果会放在回调函数中：1static getItem(key: string, callback:(error, result)) 根据键来设置值：1static setItem(key: string, value: string, callback:(error)) 根据键来移除项：1static removeItem(key: string, callback:(error)) 获取所有的键：1static getAllKeys(callback:(error, keys)) 设置多项，其中 keyValuePairs 是字符串的二维数组，比如：[[‘k1’, ‘val1’], [‘k2’, ‘val2’]]：1static multiSet(keyValuePairs, callback:(errors)) 获取多项，其中 keys 是字符串数组，比如：[‘k1’, ‘k2’]：1static multiGet(keys, callback:(errors, result)) 删除多项，其中 keys 是字符串数组，比如：[‘k1’, ‘k2’]：1static multiRemove(keys, callback:(errors)) 清除所有的项目：1static clear(callback:(error)) 网络请求封装在React Native中，经常使用Fetch函数来实现网络请求，它支持GET和POST请求并返回一个Promise对象，这个对象包含一个正确的结果和一个错误的结果。 来看一下用Fetch发起的POST请求封装： 12345678910111213141516171819static post(url,data)&#123; return new Promise((resolve,reject)=&gt;&#123; fetch(url,&#123; method:'POST', header:&#123; 'Accept':'application/json', 'Content-Type':'application/json' &#125;, body:JSON.stringify(data) &#125;) .then(response=&gt;response.json()) .then(result=&gt;&#123; resolve(result); &#125;) .catch(error=&gt;&#123; reject(error); &#125;) &#125;) &#125; 从上面的代码中，我们可以大致看到：Fetch函数中，第一个参数是请求url，第二个参数是一个字典，包括方法，请求头，请求体等信息。 随后的then和catch分别捕捉了fetch函数的返回值：一个Promise对象的正确结果和错误结果。注意，这里面有两个then，其中第二个then把第一个then的结果拿了过来。而第一个then做的事情是把网络请求的结果转化为JSON对象。 那么什么是Promise对象呢？ Promise 是异步编程的一种解决方案，Promise对象可以获取某个异步操作的消息。它里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 它分为三种状态： Pending（进行中）、Resolved（已成功）和Rejected（已失败） 它的构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject： resolve函数的作用：将Promise对象的状态从“未完成”变成“成功”(即从Pending变为Resolved)，在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject函数的作用：将Promise对象的状态从“未完成”变成“成功”(即从Pending变为Rejected)，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 GET 请求封装：123456789101112static get(url)&#123; return new Promise((resolve,reject)=&gt;&#123; fetch(url) .then(response=&gt;response.json()) .then(result=&gt;&#123; resolve(result); &#125;) .catch(error=&gt;&#123; reject(error); &#125;) &#125;) &#125; 因为只是GET请求，所以不需要配置请求体，而且因为这个fetch函数返回值是一个Promise对象， 所以我们可以用.then和.catch来捕捉正确和错误的结果。 功能调试我们可以使用浏览器的开发者工具来调试React Native项目，可以通过打断点的方式来看数据信息以及方法的调用： 首先在iOS模拟器中点击command + D，然后再弹出菜单里点击Debug JS Remotely。随后就打开了浏览器进入了调试。 浏览器一般会展示下面的页面，然后点击command + option + J进入真生的调试界面。 双平台适配因为React Native讲求的是一份代码跑在两个平台上，而客观上这两个平台又有一些不一样的地方，所以就需要在别要的时候做一下两个平台的适配。 例如导航栏：在iOS设备中是存在导航栏的，而安卓设备上是没有的。所以在定制导航栏的时候，在不同平台下给导航栏设置不同的高度： 12345678910const NAV_BAR_HEIGHT_IOS = 54;const NAV_BAR_HEIGHT_ANDROID = 50;// css navBar: &#123; flexDirection: 'row', alignItems: 'center', justifyContent: 'space-between', height: Platform.OS === 'ios' ? NAV_BAR_HEIGHT_IOS : NAV_BAR_HEIGHT_ANDROID, &#125;, 上面的Platform是React Native内置的用于区分平台的库，可以在引入后直接使用。 建议在调试程序的时候，同时打开iOS和Android的模拟器进行调试，因为有些地方可能在某个平台上是没问题的，但是另一个平台上有问题，这就需要使用Platform来区分平台。 开源组件库的使用ReactNative 的组件与原生的组件有许多共同之处，如下拉刷新，同样的 Github 中开源组件已经相当完善。 开源组件库方法如下，安装最新版本：1npm install react-native-tab-navigator --save 安装指定版本：1npm install --save react-native-tab-navigator@0.4.0 react-native 集成组件绑定(ReactNative 0.27以后，自集成RNPM)：1react-native link react-native-splash-screen 常用开源库：12345678npm install --save react-native-tab-navigator@0.4.0npm install --save react-native-scrollable-tab-view@0.7.0npm install --save react-native-check-box@1.0.4npm install --react-native-easy-toast@1.0.9npm install --save GitHubTrending@2.0.0npm install --save react-native-htmlview@0.5.0npm install --save react-native-popover@0.5.0npm install --react-native-splash-screen@2.0.0 下图为使用 react-native-splash-screen 后的效果演示： 热更新CodePush 是微软提供的一套用于热更新 React Native 和 Cordova 应用的服务。 CodePush 是提供给 React Native 和 Cordova 开发者直接部署移动应用更新给用户设备的云服务。CodePush 作为一个中央仓库，开发者可以推送更新 (JS, HTML, CSS and images)，应用可以从客户端 SDK 里面查询更新。 Code-Push 推包命令：1code-push release-react &lt;appName&gt; &lt;platform&gt; [options] 示例：1code-push release-react RNAPPGithub ios --t 1.0.0 --dev false --d Staging --des &quot;1.热更新我的页面背景色&quot; --m true 1code-push release-react RNAPPGithub ios --t 1.0.1 --dev false --d Staging --des &quot;1.热更新相关设置&quot; --m true Code-Push 线上查看更新：1code-push deployment ls RNAPPGithub Code-Push 查看项目Key：1code-push deployment ls RNAPPGithub -k Code-Push iOS更新打包方法：1react-native bundle --platform ios --entry-file index.ios.js --bundle-output release_ios/main.jsbundle --assets-dest release_ios/ --dev fasle 总结之前也有零零散散的调研这门技术，但是经过系统的 15 个下午的坚持学习，深感跨平台技术的独到之处，特别是在与原生交互的编写上简直让人欲生欲死，还好在 Github 上已经有各路大神开源的各种方便开发的组件库可以供我们使用。 分享链接《React Native 开发常用命令行（持续更新）》(https://juejin.im/post/5abc54c86fb9a028da7c998c) 《ReactNative 开发常用的三方模块》(https://www.jianshu.com/p/53ff78168acc) 《使用VS Code调试React-Native程序》（https://jingyan.baidu.com/article/ad310e80fb13fc1849f49ed1.html） 参考资料 React Native中文网 贾鹏辉的技术博客 从一个实战项目来看一下React Native开发的几个关键技术点 Marno:给所有开发者的React Native详细入门指南 大漠:一个完整的Flexbox指南 阮一峰:Flex 布局教程：语法篇 八段代码彻底掌握 Promise 阮一峰：Promise对象 asce1885:React Native 高质量学习资料汇总 世锋日上:ReactNative 学习资源大汇集","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"https://reversescale.github.io/tags/ReactNative/"}]},{"title":"基于 Aspects 深入了解 AOP","slug":"Library Aspects","date":"2018-03-23T13:56:27.000Z","updated":"2018-11-16T13:22:46.436Z","comments":true,"path":"2018/03/23/Library Aspects/","link":"","permalink":"https://reversescale.github.io/2018/03/23/Library Aspects/","excerpt":"AOP(Aspect-Oriented-Programming)，翻译过来就是「面向切面编程」，使用场景很多，如统计埋点、方法替换等~","text":"AOP(Aspect-Oriented-Programming)，翻译过来就是「面向切面编程」，使用场景很多，如统计埋点、方法替换等~ 👨🏻‍💻 Github Demo 🎨 测试 UI 什么样子？ 1.展示页 2.展示页 3.展示页 展示列表 拦截系统事件 自定义拦截 🎯 安装方法安装在 iOS, 你需要在 Podfile 中添加.12345source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;9.0&apos;use_frameworks!pod &quot;Aspects&quot; 🛠 配置系统级拦截拦截系统级级事件，如 viewWillAppear 等 1234567891011121314#import &lt;Aspects.h&gt;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. [UIViewController aspect_hookSelector:@selector(viewWillAppear:) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo, BOOL animated) &#123; NSLog(@&quot;View Controller %@ will appear animated: %tu&quot;, aspectInfo.instance, animated); &#125; error:NULL];&#125;- (void)viewWillAppear:(BOOL)animated &#123; [super viewWillAppear:animated]; NSLog(@&quot;System View Controller will appear&quot;);&#125; 自定义拦截拦截自定义事件，如对类的操作 12345678910111213141516171819202122232425262728// Cat.h 类@interface Cat: NSObject+ (void)classFee;@end// Cat.m 类@implementation Cat+ (void)classFee &#123; NSLog(@&quot;Miao~&quot;);&#125;@end// 实现方法#import &quot;Cat.h&quot;#import &lt;Aspects.h&gt;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view. Class catMetal = objc_getMetaClass(NSStringFromClass(Cat.class).UTF8String); [catMetal aspect_hookSelector:@selector(classFee) withOptions:AspectPositionAfter usingBlock:^(id&lt;AspectInfo&gt; aspectInfo) &#123; NSLog(@&quot;Miao~,I am angry~&quot;); &#125; error:NULL]; [Cat classFee];&#125; 📝 深入学习索引： AOP 简介 Aspects 简介 Aspects 结构剖析 Aspects 核心代码剖析 优秀 AOP 库应该具备的特质 总结 AOP 简介在 Objective-C 的实现结构中 Runtime 的动态派发机制保证了这么语言的灵活性，而在运行时，动态地将代码切入到类的指定方法、指定位置上的编程思想就是AOP(面向切面编程)。 AOP 是一种编程范式或者编程思想，它解决了 OOP (Object-oriented programming) 的延伸问题 什么时候需要使用 AOP假设随着我们所在的公司逐步发展，之前第三方的用户页面统计已经不能满足需求了，公司要求实现一个我们自己的用户页面统计。 在传统的 OOP 思想下，可能会如下操作： 一个熟悉 OOP 思想的程序猿会理所应当的想到要把用户页面统计这一任务放到 ViewController 中； 考虑到一个个的手动添加统计代码要死人（而且还会漏，以后新增 ViewController 也要手动加），于是想到了 OOP 思想中的继承； 不巧由于项目久远，所有的 ViewController 都是直接继承自系统类 UIViewController（笑），此时选择抽一个项目 RootViewController，替换所有 ViewController 继承 RootViewController； 然后在 RootViewController 的 viewWillAppear: 和 viewWillDisappear: 方法加入时间统计代码，记录 ViewController 以及 Router 传参。 其实 OOP 也有其特殊的定位，也能够实现上述的需求。 而 AOP 则更适合在给多个 App 写通用组件并以通用的形式实现统计的情况下。 一个简单的思路：Hook 方法交换的方法，在原方法执行之后记录需要统计的信息并上报。 单通过 Method Swizzling 来 Hook 的方法在处理不当的情况下容易出现安全隐患 Aspects 简介 Aspects 是一个使用起来简单愉快的 AOP 库，使用 Objective-C 编写，适用于 iOS 与 Mac OS X。 Aspects 简单易用，作者通过在 NSObject (Aspects) 分类中暴露出的两个接口分别提供了对实例和 Class 的 Hook 实现： 12345678910@interface NSObject (Aspects)+ (id)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;- (id)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;@end Aspects 支持实例 Hook，相较其他 Objective-C AOP 库而言可操作粒度更小，适合的场景更加多样化。作为使用者无需进行更多的操作即可 Hook 指定实例或者 Class 的指定 SEL，AspectOptions 参数可以指定 Hook 的点，以及是否执行一次之后就撤销 Hook。 Aspects 结构剖析 尽管 Aspects 只有不到千行的源码，但是其内部实现考虑到了很多 Hook 相关的安全问题和其他细节，对比其他 Objective-C AOP 开源项目来说 Aspects 更为健全。 Aspects 内部结构Aspects 内部定义了两个协议： AspectToken - 用于注销 Hook AspectInfo - 嵌入 Hook 中的 Block 首位参数 此外 Aspects 内部还定义了 4 个类： AspectInfo - 切面信息，遵循 AspectInfo 协议 AspectIdentifier - 切面 ID，应该遵循 AspectToken 协议（作者漏掉了，已提 PR） AspectsContainer - 切面容器 AspectTracker - 切面跟踪器 以及一个结构体： AspectBlockRef - 即 _AspectBlock，充当内部 Block如果你扒一遍源码，还会发现两个内部静态全局变量： static NSMutableDictionary *swizzledClassesDict; static NSMutableSet *swizzledClasses; Aspects 协议AspectToken AspectToken 协议旨在让使用者可以灵活的注销之前添加过的 Hook，内部规定遵守此协议的对象须实现 remove 方法。 12345/// 不透明的 Aspect Token，用于注销 Hook@protocol AspectToken /// 注销一个 aspect./// 返回 YES 表示注销成功，否则返回 NO- (BOOL)remove;@end AspectInfo AspectInfo 协议旨在规范对一个切面，即 aspect 的 Hook 内部信息的纰漏，我们在 Hook 时添加切面的 Block 第一个参数就遵守此协议。 12345678/// AspectInfo 协议是我们块语法的第一个参数。@protocol AspectInfo /// 当前被 Hook 的实例- (id)instance;/// 被 Hook 方法的原始 invocation- (NSInvocation *)originalInvocation;/// 所有方法参数（装箱之后的）惰性执行- (NSArray *)arguments;@end 装箱是一个开销昂贵操作，所以用到再去执行 Aspects 内部类接着协议，我们下面详细介绍一下 Aspects 的内部类。 AspectInfo AspectInfo 在这里是一个 Class，其遵守上文中讲到的 AspectInfo 协议，不要混淆。 123456@interface AspectInfo : NSObject - (id)initWithInstance:(__unsafe_unretained id)instance invocation:(NSInvocation *)invocation;@property (nonatomic, unsafe_unretained, readonly) id instance;@property (nonatomic, strong, readonly) NSArray *arguments;@property (nonatomic, strong, readonly) NSInvocation *originalInvocation;@end AspectInfo 比较简单，参考 ReactiveCocoa 团队提供的 NSInvocation 参数通用方法可将参数装箱为 NSValue，简单来说 AspectInfo 扮演了一个提供 Hook 信息的角色。 AspectIdentifier AspectIdentifier 类定义： 123456789@interface AspectIdentifier : NSObject+ (instancetype)identifierWithSelector:(SEL)selector object:(id)object options:(AspectOptions)options block:(id)block error:(NSError **)error;- (BOOL)invokeWithInfo:(id)info;@property (nonatomic, assign) SEL selector;@property (nonatomic, strong) id block;@property (nonatomic, strong) NSMethodSignature *blockSignature;@property (nonatomic, weak) id object;@property (nonatomic, assign) AspectOptions options;@end AspectIdentifier 实际上是添加切面的 Block 的第一个参数，其应该遵循 AspectToken 协议，事实上也的确如此，其提供了 remove 方法的实现。 AspectIdentifier 内部需要注意的是由于使用 Block 来写 Hook 中我们加的料，这里生成了 blockSignature，在 AspectIdentifier 初始化的过程中会去判断 blockSignature 与入参 object 的 selector 得到的 methodSignature 的兼容性，兼容性判断成功才会顺利初始化。 AspectsContainer AspectsContainer 作为切面的容器类，关联指定对象的指定方法，内部有三个切面队列，分别容纳关联指定对象的指定方法中相对应 AspectOption 的 Hook： NSArray *beforeAspects; - AspectPositionBefore NSArray *insteadAspects; - AspectPositionInstead NSArray *afterAspects; - AspectPositionAfter AspectsContainer 在 NSObject 分类中通过 AssociatedObject 方法与当前要 Hook 的目标关联在一起的。 12345678@interface AspectsContainer : NSObject- (void)addAspect:(AspectIdentifier *)aspect withOptions:(AspectOptions)injectPosition;- (BOOL)removeAspect:(id)aspect;- (BOOL)hasAspects;@property (atomic, copy) NSArray *beforeAspects;@property (atomic, copy) NSArray *insteadAspects;@property (atomic, copy) NSArray *afterAspects;@end 关联目标是 Hook 之后的 Selector，即 aliasSelector（原始 SEL 名称加 aspects_ 前缀对应的 SEL） AspectTracker AspectTracker 类定义： 123456@interface AspectTracker : NSObject- (id)initWithTrackedClass:(Class)trackedClass parent:(AspectTracker *)parent;@property (nonatomic, strong) Class trackedClass;@property (nonatomic, strong) NSMutableSet *selectorNames;@property (nonatomic, weak) AspectTracker *parentEntry;@end AspectTracker 作为切面追踪器，原理大致如下： 12345678910111213// Add the selector as being modified.currentClass = klass;AspectTracker *parentTracker = nil;do &#123; AspectTracker *tracker = swizzledClassesDict[currentClass]; if (!tracker) &#123; tracker = [[AspectTracker alloc] initWithTrackedClass:currentClass parent:parentTracker]; swizzledClassesDict[(id)currentClass] = tracker; &#125; [tracker.selectorNames addObject:selectorName]; // All superclasses get marked as having a subclass that is modified. parentTracker = tracker;&#125;while ((currentClass = class_getSuperclass(currentClass))); 全局变量 swizzledClassesDict 中的 value 对应着 AspectTracker 指针。 AspectTracker 是从下而上追踪，最底层的 parentEntry 为 nil，父类的 parentEntry 为子类的 tracker。 Aspects 静态全局变量 1）static NSMutableDictionary *swizzledClassesDict; static NSMutableDictionary *swizzledClassesDict; 在 Aspects 中扮演着已混写类字典的角色，Aspects 内部提供了专门访问这个全局字典的方法： 12345678static NSMutableDictionary *aspect_getSwizzledClassesDict() &#123; static NSMutableDictionary *swizzledClassesDict; static dispatch_once_t pred; dispatch_once(&amp;pred, ^&#123; swizzledClassesDict = [NSMutableDictionary new]; &#125;); return swizzledClassesDict;&#125; 这个全局变量可以简单理解为记录整个 Hook 影响的 Class 包含其 SuperClass 的追踪记录的全局字典。 2）static NSMutableSet *swizzledClasses; static NSMutableSet *swizzledClasses; 在 Aspects 中担当记录已混写类的角色，Aspects 内部提供一个用于修改这个全局变量内容的方法： 12345678910static void _aspect_modifySwizzledClasses(void (^block)(NSMutableSet *swizzledClasses)) &#123; static NSMutableSet *swizzledClasses; static dispatch_once_t pred; dispatch_once(&amp;pred, ^&#123; swizzledClasses = [NSMutableSet new]; &#125;); @synchronized(swizzledClasses) &#123; block(swizzledClasses); &#125;&#125; Aspects 核心代码剖析Hook Class &amp;&amp; Hook InstanceAspects 不光支持 Hook Class 还支持 Hook Instance，这提供了更小粒度的控制，配合 Hook 的撤销功能可以更加灵活精准的实现功能。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static Class aspect_hookClass(NSObject *self, NSError **error) &#123; // 断言 self NSCParameterAssert(self); // classClass statedClass = self.class;// isaClass baseClass = object_getClass(self);NSString *className = NSStringFromClass(baseClass); // 已经子类化过了if ([className hasSuffix:AspectsSubclassSuffix]) &#123;return baseClass; // 我们混写了一个 class 对象，而非一个单独的 object&#125;else if (class_isMetaClass(baseClass)) &#123; // baseClass 是元类，则 self 是 Class 或 MetaClass，混写 self return aspect_swizzleClassInPlace((Class)self); // 可能是一个 KVO'ed class。混写就位。也要混写 meta classes。 &#125;else if (statedClass != baseClass) &#123; // 当 .class 和 isa 指向不同的情况，混写 baseClass return aspect_swizzleClassInPlace(baseClass); &#125; // 默认情况下，动态创建子类 // 拼接子类后缀 AspectsSubclassSuffixconst char *subclassName = [className stringByAppendingString:AspectsSubclassSuffix].UTF8String;// 尝试用拼接后缀的名称获取 isaClass subclass = objc_getClass(subclassName); // 找不到 isa，代表还没有动态创建过这个子类if (subclass == nil) &#123; // 创建一个 class pair，baseClass 作为新类的 superClass，类名为 subclassNamesubclass = objc_allocateClassPair(baseClass, subclassName, 0);if (subclass == nil) &#123; // 返回 nil，即创建失败 NSString *errrorDesc = [NSString stringWithFormat:@\"objc_allocateClassPair failed to allocate class %s.\", subclassName]; AspectError(AspectErrorFailedToAllocateClassPair, errrorDesc); return nil; &#125; // 混写 forwardInvocation:aspect_swizzleForwardInvocation(subclass);// subClass.class = statedClassaspect_hookedGetClass(subclass, statedClass);// subClass.isa.class = statedClassaspect_hookedGetClass(object_getClass(subclass), statedClass);// 注册新类objc_registerClassPair(subclass);&#125; // 覆盖 isaobject_setClass(self, subclass);return subclass;&#125; 难点就在于对 .class 和 object_getClass 的区分。 .class 当 target 是 Instance 则返回 Class，当 target 是 Class 则返回自身 object_getClass 返回 isa 指针的指向 动态创建一个 Class 的完整步骤也是我们应该注意的。 objc_allocateClassPair class_addMethod class_addIvar objc_registerClassPair Hook 的实现在上面 aspect_hookClass 方法中，不仅仅是返回一个要 Hook 的 Class，期间还做了一些细节操作，不论是 Class 还是 Instance，都会调用 aspect_swizzleForwardInvocation 方法，这个方法没什么难点，简单贴一下代码让大家有个印象： 123456789101112static void aspect_swizzleForwardInvocation(Class klass) &#123; // 断言 klass NSCParameterAssert(klass); // 如果没有 method，replace 实际上会像是 class_addMethod 一样 IMP originalImplementation = class_replaceMethod(klass, @selector(forwardInvocation:), (IMP)__ASPECTS_ARE_BEING_CALLED__, \"v@:@\"); // 拿到 originalImplementation 证明是 replace 而不是 add，情况少见 if (originalImplementation) &#123; // 添加 AspectsForwardInvocationSelectorName 的方法，IMP 为原生 forwardInvocation: class_addMethod(klass, NSSelectorFromString(AspectsForwardInvocationSelectorName), originalImplementation, \"v@:@\"); &#125; AspectLog(@\"Aspects: %@ is now aspect aware.\", NSStringFromClass(klass));&#125; 上面的方法就是把要 Hook 的目标 Class 的 forwardInvocation: 混写了，混写之后 forwardInvocation: 的具体实现在 ASPECTS_ARE_BEING_CALLED 中，里面能看到 invoke 标识位的不同是如何实现的，还有一些其他的实现细节： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// 宏定义，以便于我们有一个更明晰的 stack trace#define aspect_invoke(aspects, info) \\for (AspectIdentifier *aspect in aspects) &#123;\\ [aspect invokeWithInfo:info];\\ if (aspect.options &amp; AspectOptionAutomaticRemoval) &#123; \\ aspectsToRemove = [aspectsToRemove?:@[] arrayByAddingObject:aspect]; \\ &#125; \\&#125;static void __ASPECTS_ARE_BEING_CALLED__(__unsafe_unretained NSObject *self, SEL selector, NSInvocation *invocation) &#123; // __unsafe_unretained NSObject *self 不解释了 // 断言 self, invocation NSCParameterAssert(self); NSCParameterAssert(invocation); // 从 invocation 可以拿到很多东西，比如 originalSelector SEL originalSelector = invocation.selector; // originalSelector 加前缀得到 aliasSelectorSEL aliasSelector = aspect_aliasForSelector(invocation.selector);// 用 aliasSelector 替换 invocation.selector invocation.selector = aliasSelector; // Instance 的容器 AspectsContainer *objectContainer = objc_getAssociatedObject(self, aliasSelector); // Class 的容器 AspectsContainer *classContainer = aspect_getContainerForClass(object_getClass(self), aliasSelector); AspectInfo *info = [[AspectInfo alloc] initWithInstance:self invocation:invocation]; NSArray *aspectsToRemove = nil; // Before hooks. aspect_invoke(classContainer.beforeAspects, info); aspect_invoke(objectContainer.beforeAspects, info); // Instead hooks. BOOL respondsToAlias = YES; if (objectContainer.insteadAspects.count || classContainer.insteadAspects.count) &#123; // 如果有任何 insteadAspects 就直接替换了 aspect_invoke(classContainer.insteadAspects, info); aspect_invoke(objectContainer.insteadAspects, info); &#125;else &#123; // 否则正常执行 // 遍历 invocation.target 及其 superClass 找到实例可以响应 aliasSelector 的点 invoke Class klass = object_getClass(invocation.target); do &#123; if ((respondsToAlias = [klass instancesRespondToSelector:aliasSelector])) &#123; [invocation invoke]; break; &#125; &#125;while (!respondsToAlias &amp;&amp; (klass = class_getSuperclass(klass))); &#125; // After hooks. aspect_invoke(classContainer.afterAspects, info); aspect_invoke(objectContainer.afterAspects, info); // 如果没有 hook，则执行原始实现（通常会抛出异常） if (!respondsToAlias) &#123; invocation.selector = originalSelector; SEL originalForwardInvocationSEL = NSSelectorFromString(AspectsForwardInvocationSelectorName); // 如果可以响应 originalForwardInvocationSEL，表示之前是 replace method 而非 add method if ([self respondsToSelector:originalForwardInvocationSEL]) &#123; ((void( *)(id, SEL, NSInvocation *))objc_msgSend)(self, originalForwardInvocationSEL, invocation); &#125;else &#123; [self doesNotRecognizeSelector:invocation.selector]; &#125; &#125; // 移除 aspectsToRemove 队列中的 AspectIdentifier，执行 remove [aspectsToRemove makeObjectsPerformSelector:@selector(remove)];&#125;#undef aspect_invoke aspect_invoke 宏定义的作用域 代码实现对应了 Hook 的 AspectOptions 参数的 Before，Instead 和 After。 aspect_invoke 中 aspectsToRemove 是一个 NSArray，里面容纳着需要被销户的 Hook，即 AspectIdentifier（之后会调用 remove 移除）。 遍历 invocation.target 及其 superClass 找到实例可以响应 aliasSelector 的点 invoke 实现代码。 Block Hook Aspects 让我们在指定 Class 或 Instance 的特定 Selector 执行时，根据 AspectOptions 插入我们自己的 Block 做 Hook，而这个 Block 内部有我们想要的有关于当前 Target 和 Selector 的信息，我们来看一下 Aspects 是怎么办到的： 1234567891011121314151617181920212223242526272829303132333435363738- (BOOL)invokeWithInfo:(id)info &#123; NSInvocation *blockInvocation = [NSInvocation invocationWithMethodSignature:self.blockSignature]; NSInvocation *originalInvocation = info.originalInvocation; NSUInteger numberOfArguments = self.blockSignature.numberOfArguments; // 偏执。我们已经在 hook 注册的时候检查过了，（不过这里我们还要检查）。 if (numberOfArguments &gt; originalInvocation.methodSignature.numberOfArguments) &#123; AspectLogError(@\"Block has too many arguments. Not calling %@\", info); return NO; &#125; // block 的 `self` 将会是 AspectInfo。可选的。 if (numberOfArguments &gt; 1) &#123; [blockInvocation setArgument:&amp;info atIndex:1]; &#125; // 简历参数分配内存 argBuf 然后从 originalInvocation 取 argument 赋值给 blockInvocationvoid *argBuf = NULL; for (NSUInteger idx = 2; idx &lt; numberOfArguments; idx++) &#123; const char *type = [originalInvocation.methodSignature getArgumentTypeAtIndex:idx];NSUInteger argSize;NSGetSizeAndAlignment(type, &amp;argSize, NULL); // reallocf 优点，如果创建内存失败会自动释放之前的内存，讲究if (!(argBuf = reallocf(argBuf, argSize))) &#123; AspectLogError(@\"Failed to allocate memory for block invocation.\");return NO;&#125; [originalInvocation getArgument:argBuf atIndex:idx];[blockInvocation setArgument:argBuf atIndex:idx]; &#125; // 执行 [blockInvocation invokeWithTarget:self.block]; // 释放 argBuf if (argBuf != NULL) &#123; free(argBuf); &#125; return YES;&#125; 考虑两个问题： [blockInvocation setArgument:&amp;info atIndex:1]; 为什么要在索引 1 处插入呢？ for (NSUInteger idx = 2; idx &lt; numberOfArguments; idx++) 为什么要从索引 2 开始遍历参数呢？ 优秀 AOP 库应该具备的特质 良好的使用体验 可控粒度小 使用 Block 做 Hook 支持撤销 Hook 安全性 良好的使用体验Aspects 使用 NSObject + Categroy 的方式提供接口，非常巧妙的涵盖了 Instance 和 Class。 Aspects 提供的接口保持高度一致（本着易用，简单，方便的原则设计接口和整个框架的实现会让你的开源项目更容易被人们接纳和使用）： 12345678+ (id)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error;- (id)aspect_hookSelector:(SEL)selector withOptions:(AspectOptions)options usingBlock:(id)block error:(NSError **)error; 可控粒度小Aspects 不仅支持大部分 AOP 框架应该做到的对于 Class 的 Hook，还支持粒度更小的 Instance Hook，而其在内部实现中为了支持 Instance Hook 所做的代码也非常值得我们参考和学习（已在上文 Aspects 核心代码剖析处单独分析）。 为使用者提供更为自由的 Hook 方式以达到更加精准的控制是每个使用者乐于见到的事。 使用 Block 做 HookAspects 使用 Block 来做 Hook 应该考虑到了很多东西，支持使用者通过在 Block 中获取到相关的信息，书写自己额外的操作就可以实现 Hook 需求。 支持撤销 HookAspects 还支持撤销之前做的 Hook 以及已混写的 Method，为了实现这个功能 Aspects 设计了全局容器，把 Hook 和混写用全局容器做记录，让一切都可以复原，这不正是我们想要的吗？ 安全性在学习 Runtime 的时候，就应该看到过不少文章讲解 Method Swizzling 要注意的安全性问题，由于用到了大量 Runtime 方法，加上 AOP 是面向整个切面的，所以一单发现问题就会比较严重，设计的面会比较广，而且难以调试。 不能因为容易造成问题就可以回避 Method Swizzling，就好比大学老师讲到递归时强调容易引起循环调用，很多人就在内心回避使用递归，甚至于非常适合使用递归来写的算法题（这里指递归来写会易读写、易维护）只会用复杂的方式来思考。 总结 文章简单介绍了 AOP 的概念，希望能给各位读者对 AOP 思想的理解提供微薄的帮助。 文章系统的剖析了 Aspects 开源库的内部结构，希望能让大家在浏览 Aspects 源码时快速定位代码位置，找到核心内容。 文章重点分析了 Aspects 的核心代码，提炼了一些笔者认为值得注意的点，但愿可以在大家扒源码时提供一些指引。 文章结尾总结了 Aspects 作为一个比较优秀的 AOP 开源库所具有的特质，不过毕竟是很久之前的代码了，如果有哪位想要造一个关于 AOP 的轮子，希望这篇文章能够产生些许帮助。 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"Swift 4.0 中对 Dictionary 的改进","slug":"Swift 4 Dictionary","date":"2018-03-13T13:56:27.000Z","updated":"2018-11-16T12:47:15.150Z","comments":true,"path":"2018/03/13/Swift 4 Dictionary/","link":"","permalink":"https://reversescale.github.io/2018/03/13/Swift 4 Dictionary/","excerpt":"Swift 4 发布已经有一段时间了，不知道大家有没有切换到 4.0 版本。 这次 4.0 更新给我最大的感受就是没有了前几次升级的跳跃式变化。 不用为了更新语言版本，完全推翻已有的项目，这也是 Swift 慢慢趋向于稳定的标志~","text":"Swift 4 发布已经有一段时间了，不知道大家有没有切换到 4.0 版本。 这次 4.0 更新给我最大的感受就是没有了前几次升级的跳跃式变化。 不用为了更新语言版本，完全推翻已有的项目，这也是 Swift 慢慢趋向于稳定的标志~ 咱们这次说说 Swift 4.0 对 Dictionary 这个经常会用到的类的改进。 自动根据 key 分组Dictionary 新增了一个构造方法，可以将给定的一个数组，根据指定的条件进行分组。 来看一个例子: 123456789struct Person &#123; var name: String var gender: Gender var age: Int enum Gender &#123; case male case female &#125;&#125; 这里有一个 Person 结构, 然后我们初始化一个数组： 12345let p1 = Person(name: \"aa\", gender: .female, age: 22)let p2 = Person(name: \"bb\", gender: .male, age: 24)let p3 = Person(name: \"cc\", gender: .male, age: 21)let persons = [p1, p2, p3] 现在用新的 Dictionary 构造方法，可以立即将这组 Person 实例根据他们的 gender 属性进行分组： 123let groupedDict = Dictionary(grouping: persons) &#123; p in return p.gender&#125; 这个构造方法，第一个参数 grouping 接收的是 persons 数组， 第二个参数是一个闭包，用于返回根据进行分组的依据，我们这里返回的是 p.gender。结果一目了然： 123456789[ .male: [ Person(name: \"bb\", gender: .male, age: 24), Person(name: \"cc\", gender: .male, age: 21) ], .female: [ Person(name: \"aa\", gender: .female, age: 22) ]] 以往要实现这样的功能，就需要手动遍历整个数组，取出 key， 然后生成字典， 现在方便很多。 value 无缝转换另外一个比较有用的特性是，Dictionary 提供的 mapValues 方法。 还以我们刚才生成的 groupedDict 为例，可以进行这样的操作： 123let count = groupedDict.mapValues &#123; persons in persons.count&#125; 先看一下输出，大家可能就猜到这个方法的用途是什么了： 1234[ .male: 2, .female: 1] 上面的输出可以看到， mapValues 会遍历每一个 key 对应的 values， 然后传递给闭包进行自定义转换。 我们例子中的闭包返回的就是每个 key 对应的 Person 集合的数量，最生成了一个新的 Dictionary，里面的 key 和之前一样，只是对应的值变成了我们闭包中自定义的了。 mapValues 方法同样是一个帮助我们解决繁杂操作的工具方法。 从键值对元组中直接构建假如我们有这样一个数组: 1let personsTuples = [(\"group 1\", [p1, p2]), (\"group 2\", [p3])] 然后可以调用 uniqueKeysWithValues 构造方法直接初始化字典： 1let dict = Dictionary(uniqueKeysWithValues: personsTuples) personsTuples 数组中，每一个元素都是一个元组(Tuple)， 这个构造方法把元组中的第一项当做 key， 第二项当做 value， 生成一个新的 Dictionary，如下所示： 123456789[ \"group 1\": [ Person(name: \"aa\", gender: .female, age: 22), Person(name: \"bb\", gender: .male, age: 24) ], \"group 2\": [ Person(name: \"cc\", gender: .male, age: 21) ]] 使用 uniqueKeysWithValues 构造方法时候需要注意，就是传入的数组中，不能有重复的 key， 否则会报运行时错误，比如这个数组就会报错： 1let personsTuples = [(\"group 1\", [p1, p2]), (\"group 2\", [p3]), (\"group 2\", [p4])] 上面数组中 group 2 出现了两次。 如果用它来初始化的话，就会出错。 所以 Swift 4.0 还提供了另外一个初始化方法， 对于上面这个数组，可以调用： 123let dict = Dictionary(personsTuples) &#123; old, new in return new&#125; 第二个闭包参数，会在遇到重复的 key 时候调用。 它提供两个参数，一个是同样这个 key 的上一个值 old， 还有当前的值 new。 我们这里直接返回 new，意思就是 每次遇到重复的 key， 就用新的值代替老的值。 这样初始化后，生成的 Dictionary 结构如下： 123456789[ \"group 1\": [ p1, p2 ], \"group 2\": [ p4 ]] group 2 中的值， 是第二次 key 所对应的 p4。 提供默认值如果我们访问了一个字典中不存在的 key， 会返回 nil： 1dict[\"group 3\"] 因为上面字典中，不存在 group 3 这个 key， 所以它返回了 nil。 Swift 4 中新增了指定默认值的能力： 1dict[\"group 3\", default: []] 这样调用，如果 group 3 这个 key 不存在的话， 就会返回我们指定的默认值空数组， 而不是 nil 了。 这个特性在我们处理 JSON 数据解析这类的问题上很实用。 过滤器过滤器对于集合类来说是比较常用的功能。 Swift 4 中对 Dictionary 类型也提供了过滤器的支持： 123let filteredDict = dict.filter &#123; key, val in return val.count &gt;= 2&#125; filter 方法接收一个闭包，它会遍历 Dictionary 中所有的元素，并且作为闭包的参数传入。 我们需要通过闭包的返回值确定这个元素是否被保留。 上面的例子中，比如我们 dict 中的元素是 ： 123456789[ \"group 1\": [ p1, p2 ], \"group 2\": [ p4 ]] 调用 filter 后，我们只保留数量大于 2 的集合： 123456[ \"group 1\": [ p1, p2 ]] 总结以上就是 Swift 4.0 对于 Dictionary 的主要改进。 这些新增的工具方法对于提高我们开发效率和代码质量都有帮助，希望这里的介绍对你有帮助。 关于 Dictionary 更完整的信息，大家还可以参考苹果官方的文档，还有 Swift Blog 中的介绍。 参考文献Dictionary 官方文档：https://developer.apple.com/documentation/swift/dictionarySwift Blog: https://swift.org/blog/dictionary-and-set-improvements/","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://reversescale.github.io/tags/Swift/"}]},{"title":"Swift 4.0 新特征汇总及演示","slug":"Swift 4 New feature","date":"2018-03-09T13:16:27.000Z","updated":"2018-11-16T12:16:08.813Z","comments":true,"path":"2018/03/09/Swift 4 New feature/","link":"","permalink":"https://reversescale.github.io/2018/03/09/Swift 4 New feature/","excerpt":"Swift 在不断的版本迭代中，由于其 ABI 尚不稳定，所以给开发者带来许多的挑战，但也正因为如此，这门语言才有无限可能~","text":"Swift 在不断的版本迭代中，由于其 ABI 尚不稳定，所以给开发者带来许多的挑战，但也正因为如此，这门语言才有无限可能~ 👨🏻‍💻 Github Demo Key Paths 新语法key-path 通常是用在键值编码（KVC）与键值观察（KVO）上的，KVC、KVO 相关内容可以参考我之前写的这篇文章：Swift - 反射（Reflection）的介绍与使用样例（附KVC介绍） 1.Swift 3 之前使用的是 String 类型的 key-Path1234567891011121314151617//用户类class User: NSObject&#123; @objc var name:String = &quot;&quot; //姓名 @objc var age:Int = 0 //年龄&#125; //创建一个User实例对象let user1 = User()user1.name = &quot;hangge&quot;user1.age = 100 //使用KVC取值let name = user1.value(forKey: &quot;name&quot;)print(name) //使用KVC赋值user1.setValue(&quot;hangge.com&quot;, forKey: &quot;name&quot;) 具体显示如下： 2.到了 Swift 3 新增了 #keyPath() 写法使用 #keyPath() 写法，可以避免我们因为拼写错误而引发问题。1234567891011121314151617//用户类class User: NSObject&#123; @objc var name:String = &quot;&quot; //姓名 @objc var age:Int = 0 //年龄&#125; //创建一个User实例对象let user1 = User()user1.name = &quot;hangge&quot;user1.age = 100 //使用KVC取值let name = user1.value(forKeyPath: #keyPath(User.name))print(name) //使用KVC赋值user1.setValue(&quot;hangge.com&quot;, forKeyPath: #keyPath(User.name)) 3.Swift 4 中直接用 \\ 作为开头创建 KeyPath新的方式不仅使用更加简单，而且有如下优点： 类型可以定义为 class、struct 定义类型时无需加上 @objc 等关键字 性能更好 类型安全和类型推断，例如：user1.value(forKeyPath: #keyPath(User.name)) 返回的类型是 Any，user1[keyPath: \\User.name] 直接返回 String 类型 可以在所有值类型上使用（1）比如上面的样例在 Swift4 中可以这么写：1234567891011121314151617//用户类class User: NSObject&#123; var name:String = &quot;&quot; //姓名 var age:Int = 0 //年龄&#125; //创建一个User实例对象let user1 = User()user1.name = &quot;hangge&quot;user1.age = 100 //使用KVC取值let name = user1[keyPath: \\User.name]print(name) //使用KVC赋值user1[keyPath: \\User.name] = &quot;hangge.com&quot; （2）keyPath 定义在外面也是可以的：123456let keyPath = \\User.name let name = user1[keyPath: keyPath]print(name) user1[keyPath: keyPath] = &quot;hangge.com&quot; （3）可以使用 appending 方法向已定义的 Key Path 基础上填加新的 Key Path。12let keyPath1 = \\User.phonelet keyPath2 = keyPath1.appending(path: \\.number) 类与协议的组合类型在 Swift 4 中，可以把类（Class）和协议（Protocol）用 &amp; 组合在一起作为一个类型使用。 使用样例1：12345678910111213protocol MyProtocol &#123; &#125; class View &#123; &#125; class ViewSubclass: View, MyProtocol &#123; &#125; class MyClass &#123; var delegate: (View &amp; MyProtocol)?&#125; let myClass = MyClass()myClass.delegate = ViewSubclass() //这个编译正常myClass.delegate = View() //这个编译报错: 具体错误信息如下： 使用样例2：123456789101112131415161718192021protocol Shakeable &#123; func shake()&#125; extension UIButton: Shakeable &#123; func shake() &#123; /* ... */ &#125;&#125; extension UISlider: Shakeable &#123; func shake() &#123; /* ... */ &#125;&#125; func shakeEm(controls: [UIControl &amp; Shakeable]) &#123; for control in controls where control.isEnabled &#123; control.shake() &#125;&#125; 下标支持泛型1.下标的返回类型支持泛型有时候我们会写一些数据容器，Swift 支持通过下标来读写容器中的数据。但是如果容器类中的数据类型定义为泛型，过去下标语法就只能返回 Any，在取出值后需要用 as? 来转换类型。现在 Swift 4 定义下标也可以使用泛型了。12345678910111213141516171819202122struct GenericDictionary&lt;Key: Hashable, Value&gt; &#123; private var data: [Key: Value] init(data: [Key: Value]) &#123; self.data = data &#125; subscript&lt;T&gt;(key: Key) -&gt; T? &#123; return data[key] as? T &#125;&#125; //字典类型: [String: Any]let earthData = GenericDictionary(data: [&quot;name&quot;: &quot;Earth&quot;, &quot;population&quot;: 7500000000, &quot;moons&quot;: 1]) //自动转换类型，不需要在写 &quot;as? String&quot;let name: String? = earthData[&quot;name&quot;]print(name) //自动转换类型，不需要在写 &quot;as? Int&quot;let population: Int? = earthData[&quot;population&quot;]print(population) 2.下标类型同样支持泛型12345678910111213141516extension GenericDictionary &#123; subscript&lt;Keys: Sequence&gt;(keys: Keys) -&gt; [Value] where Keys.Iterator.Element == Key &#123; var values: [Value] = [] for key in keys &#123; if let value = data[key] &#123; values.append(value) &#125; &#125; return values &#125;&#125; // Array下标let nameAndMoons = earthData[[&quot;moons&quot;, &quot;name&quot;]] // [1, &quot;Earth&quot;]// Set下标let nameAndMoons2 = earthData[Set([&quot;moons&quot;, &quot;name&quot;])] // [1, &quot;Earth&quot;] Codable 序列化如果要将一个对象持久化，需要把这个对象序列化。过去的做法是实现 NSCoding 协议，但实现 NSCoding 协议的代码写起来很繁琐，尤其是当属性非常多的时候。Swift 4 中引入了 Codable 协议，可以大大减轻了我们的工作量。我们只需要让需要序列化的对象符合 Codable 协议即可，不用再写任何其他的代码。1234struct Language: Codable &#123; var name: String var version: Int&#125; 1.Encode 操作我们可以直接把符合了 Codable 协议的对象 encode 成 JSON 或者 PropertyList。12345678let swift = Language(name: &quot;Swift&quot;, version: 4) //encoded对象let encodedData = try JSONEncoder().encode(swift) //从encoded对象获取Stringlet jsonString = String(data: encodedData, encoding: .utf8)print(jsonString) 2.Decode 操作12let decodedData = try JSONDecoder().decode(Language.self, from: encodedData)print(decodedData.name, decodedData.version) SubtringSwift 4 中有一个很大的变化就是 String 可以当做 Collection 来用，并不是因为 String 实现了 Collection 协议，而是 String 本身增加了很多 Collection 协议中的方法，使得 String 在使用时看上去就是个 Collection。1234567let str = &quot;hangge.com&quot; print(str.prefix(5)) // &quot;hangg&quot;print(str.suffix(5)) // &quot;e.com&quot; print(str.dropFirst()) // &quot;angge.com&quot;print(str.dropLast()) // &quot;hangge.co&quot; 比如上面的样例，我们使用一些 Collection 协议的方法对字符串进行截取，只不过它们的返回结果不是 String 类型，而是 Swift 4 新增的 Substring 类型。 1.为何要引入 Substring？既然我们想要的到的就是字符串，那么直接返回 String 就好了，为什么还要多此一举返回 Substring。原因只有一个：性能。具体可以参考下图：当我们用一些 Collection 的方式得到 String 里的一部分时，创建的都是 Substring。Substring 与原 String 是共享一个 Storage。这意味我们在操作这个部分的时候，是不需要频繁的去创建内存，从而使得 Swift 4 的 String 相关操作可以获取比较高的性能。而当我们显式地将 Substring 转成 String 的时候，才会 Copy 一份 String 到新的内存空间来，这时新的 String 和之前的 String 就没有关系了。 2.使用 Substring 的注意事项由于 Substring 与原 String 是共享存储空间的，只要我们使用了 Substring，原 String 就会存在内存空间中。只有 Substring 被释放以后，整个 String 才会被释放。而且 Substring 类型无法直接赋值给需要 String 类型的地方，我们必须用 String() 包一层。当然这时系统就会通过复制创建出一个新的字符串对象，之后原字符串就会被释放。 3.使用样例这里对 String 进行扩展，新增一个 subString 方法。直接可以根据起始位置（Int 类型）和需要的长度（Int 类型），来截取出子字符串。123456789101112extension String &#123; //根据开始位置和长度截取字符串 func subString(start:Int, length:Int = -1) -&gt; String &#123; var len = length if len == -1 &#123; len = self.count - start &#125; let st = self.index(startIndex, offsetBy:start) let en = self.index(st, offsetBy:len) return String(self[st ..&lt; en]) &#125;&#125; 使用样例：1234let str1 = &quot;欢迎访问hangge.com&quot;let str2 = str1.subString(start: 4, length: 6)print(&quot;原字符串：\\(str1)&quot;)print(&quot;截取出的字符串：\\(str2)&quot;) 运行结果如下： 注意：这个方法最后我们会将 Substring 显式地转成 String 再返回。 废除 swap 方法（1）过去我们会使用 swap(_:_:) 来将两个变量的值进行交换：1234var a = 1var b = 2swap(&amp;a, &amp;b)print(a, b) （2）后面 swap() 方法将会被废弃，建议使用 tuple（元组）特性来实现值交换，也只需要一句话就能实现：1234var a = 1var b = 2(b, a) = (a, b)print(a, b) 使用 tuple 方式的好处是，多个变量值也可以一起进行交换：12345var a = 1var b = 2var c = 3(a, b, c) = (b, c, a)print(a, b, c) （3）补充一下：现在数组增加了个 swapAt 方法可以实现两个元素的位置交换。1234var fruits = [&quot;apple&quot;, &quot;pear&quot;, &quot;grape&quot;, &quot;banana&quot;]//交换元素位置（第2个和第3个元素位置进行交换）fruits.swapAt(1, 2)print(fruits) 减少隐式 @objc 自动推断1.过去的情况（Swift 3）（1）在项目中如果想把 Swift 写的 API 暴露给 Objective-C 调用，需要增加 @objc。在 Swift 3 中，编译器会在很多地方为我们隐式的加上 @objc。（2）比如当一个类继承于 NSObject，那么这个类的所有方法都会被隐式的加上 @objc。1234class MyClass: NSObject &#123; func print() &#123; &#125; // 包含隐式的 @objc func show() &#123; &#125; // 包含隐式的 @objc&#125; （3）但这样做很多并不需要暴露给 Objective-C 也被加上了 @objc。而大量 @objc 会导致二进制文件大小的增加。 2.现在的情况（Swift 4）（1）在 Swift 4 中隐式 @objc 自动推断只会发生在下面这种必须要使用 @objc 的情况： 覆盖父类的 Objective-C 方法 符合一个 Objective-C 的协议 （2）大多数地方必须手工显示地加上 @objc。1234class MyClass: NSObject &#123; @objc func print() &#123; &#125; //显示的加上 @objc @objc func show() &#123; &#125; //显示的加上 @objc&#125; （3）如果在类前加上 @objcMembers，那么它、它的子类、扩展里的方法都会隐式的加上 @objc。123456789@objcMembersclass MyClass: NSObject &#123; func print() &#123; &#125; //包含隐式的 @objc func show() &#123; &#125; //包含隐式的 @objc&#125; extension MyClass &#123; func baz() &#123; &#125; //包含隐式的 @objc&#125; （4）如果在扩展（extension）前加上 @objc，那么该扩展里的方法都会隐式的加上 @objc。123456class SwiftClass &#123; &#125; @objc extension SwiftClass &#123; func foo() &#123; &#125; //包含隐式的 @objc func bar() &#123; &#125; //包含隐式的 @objc&#125; （5）如果在扩展（extension）前加上 @nonobjc，那么该扩展里的方法都不会隐式的加上 @objc。12345678@objcMembersclass MyClass : NSObject &#123; func wibble() &#123; &#125; //包含隐式的 @objc&#125; @nonobjc extension MyClass &#123; func wobble() &#123; &#125; //不会包含隐式的 @objc&#125;","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"https://reversescale.github.io/tags/Swift/"}]},{"title":"移动端 iOS 年终工作总结 - 纯干货请自备酒水","slug":"iOS 2017","date":"2018-02-26T15:56:27.000Z","updated":"2018-11-16T12:08:25.843Z","comments":true,"path":"2018/02/26/iOS 2017/","link":"","permalink":"https://reversescale.github.io/2018/02/26/iOS 2017/","excerpt":"时间匆匆，一转眼 2017 年已经过去了，这一年依旧在不断学习，厚积而薄发~","text":"时间匆匆，一转眼 2017 年已经过去了，这一年依旧在不断学习，厚积而薄发~ 主题：发展 内容大纲观点： Swift 发展观 ReactNative 发展观 进阶： 模块化 Pods 依赖库及组件化 环境自动切换 + 自动化打包测试 + 线上质量监控 管理： 团队核心组成架构 硬件设备投入 例会和文档化 组织 CodeReview 工具： Gitlab 及 Git 相关规范 Sketch 设计工具 + Zeplin 标注工具 成果： Github 原创开源项目 90+，共计 400+ 贡献力 参与维护开源项目 fastlane 20.5k（至2018.02.08） 完成 Swifter 功能展示应用研发 观点Swift 发展观Apple 在 WWDC 2017 大会上发布 Swift 4，Swift 4 带来了更快、更容易使用的 String 实现，可以保持 Unicode 的正确性，并增加对创建、使用广告管理子串的支持，它提高了开发者创建、使用和管理集合类型的能力，它支持结构化枚举类型的归档并允许对外部格式进行类型安全的序列化，包括 JSON 和 plist。 既然提到了 WWDC（https://developer.apple.com/wwdc/），相信 Swift 的发展观就没有太多争议了，近几年所有的官方演示视频都是基于 Swift 来演示的，作为 iOS 的开发人员可能会继续使用 Objective-C，但是如果对 Swift 是持抗拒心理的，那无疑对自身发展是不负责任的。 Apple 于 2017 年宣布 Swift 5 后会锁定 ABI，也就标志着这门语言会正式作为 iOS、macOS 的主流语言。同年 12 月，Apple 宣布会着手计划 iOS 和 macOS 的应用层面合并。配合 Apple 一直以来的对 Swift 幼儿教育以及在 AI、AR 等领域的推进，不难看出这门语言未来的发展潜力。 ReactNative 发展观提到 ReactNative 就不得不说 FaceBook，其实现在主流的移动端开发规范就是这家公司设计的。当然除了 React 社区生态圈的加持和 Facebook 的大力推广以外，另外一个最主要的原因就是其在开发效率和应用性能方面取得了一个比较好的平衡： 开发效率通过 JS 工程实践，逻辑跨平台复用得到极大提升 性能则通过全 Native 的 UI 层得到满足 跨平台这一特性对于小公司的吸引力则更体现在节约用人成本上，对简单的需求能做到一端多用，随时变更线上内容。 对于已经正在运营的项目，完全切 ReactNative 总是不太现实，其实大多数厂商的方法是对运营引流有影响的关键性页面（如：首页）进行 ReactNative 改版，这里可能就会引入一个 模块化 的概念，后面会有讲到。 对于想要入门的朋友，慕课网上一个入门级 ReactNative 教学还不错。 教学视频：http://coding.imooc.com/class/89.html 源码：https://github.com/crazycodeboy/GitHubPopular/ 进阶模块化模块化、组件化我后半年一直在调研的课题，对这些的研究也给我带来了从量变到质变的提升。 什么是模块化？ 那么什么是模块化呢？《 Java 应用架构设计：模块化模式与 OSGi 》一书中对它的定义是：模块化是一种处理复杂系统分解为更好的可管理模块的方式。 我们可以把软件看做是一辆汽车，开发一款软件的过程就是生产一辆汽车的过程。一辆汽车由车架、发动机、变数箱、车轮等一系列模块组成；同样，一款大型商业软件也是由各个不同的模块组成的。 汽车的这些模块是由不同的工厂生产的，一辆 BMW 的发动机可能是由位于德国的工厂生产的，它的自动变数箱可能是 Jatco（世界三大变速箱厂商之一）位于日本的工厂生产的，车轮可能是中国的工厂生产的，最后交给华晨宝马的工厂统一组装成一辆完整的汽车。这就类似于我们在软件工程领域里说的多团队并行开发，最后将各个团队开发的模块统一打包成我们可使用的 App 。 一款发动机、一款变数箱都不可能只应用于一个车型，比如同一款 Jatco 的 6AT 自动变速箱既可能被安装在 BMW 的车型上，也可能被安装在 Mazda 的车型上。这就如同软件开发领域里的模块重用。 到了冬天，特别是在北方我们可能需要开着车走雪路，为了安全起见往往我们会将汽车的公路胎升级为雪地胎；轮胎可以很轻易的更换，这就是我们在软件开发领域谈到的低耦合。一个模块的升级替换不会影响到其它模块，也不会受其它模块的限制；同时这也类似于我们在软件开发领域提到的可插拔。 20180906 更新 再谈模块化、组件化、插件化定义 模块化：一个可实现的单元，核心是内聚和分离，如登录模块的抽离 组件化：也称构件，最理想情况下是与业务无关，强调复用，如可复用 Library 插件化：与组件化不同，组件化在编译时合并模块，插件化在运行时合并模块，如可实现远程替换功能 模块化分层设计 上面的类比很清晰的说明的模块化带来的好处： 多团队并行开发测试； 模块间解耦、重用； 可单独编译打包某一模块，提升开发效率。 在《安居客 Android 项目架构演进》这篇文章中，作者介绍了安居客 Android 端的模块化设计方案，这里作者还是拿它来举例。但首先要对本文中的组件和模块做个区别定义： 组件：指的是单一的功能组件，如地图组件（MapSDK）、支付组件（AnjukePay）、路由组件（Router）等等； 模块：指的是独立的业务模块，如新房模块（NewHouseModule）、二手房模块（SecondHouseModule）、即时通讯模块（InstantMessagingModule）等等；模块相对于组件来说粒度更大。 针对模块化作者的团队也定义了一些自己的游戏规则: 对于 Business Module Layer，各业务模块之间不允许存在相互依赖关系，它们之间的跳转通讯采用路由框架 Router 来实现（后面会介绍 Router 框架的实现）; 对于 Business Component Layer，单一业务组件只能对应某一项具体的业务，个性化需求对外部提供接口让调用方定制; 合理控制各组件和各业务模块的拆分粒度，太小的公有模块不足以构成单独组件或者模块的，作者先放到类似于 CommonBusiness 的组件中，在后期不断的重构迭代中视情况进行进一步的拆分; 上层的公有业务或者功能模块可以逐步下放到下层，合理把握好度就好； 各 Layer 间严禁反向依赖，横向依赖关系由各业务 Leader 和技术小组商讨决定。 自从 Oasis Feng 在去年的 MDCC2016 上分享了模块化的经验后，模块化在 Android 社区越来越多的被提起。作者自然也不落俗的去做了一些研究和探索。安居客现在面临很多问题：例如全量编译时间太长（我这台13款的 MacBook Pro 上打一次包得花十多分钟）；例如新房、二手房、租房等等模块间耦合严重，不利于多团队并行开发测试；另外在17年初安居客重新将租房 App 捡起推广，单独让人来开发维护一个三年前的项目并不划算，所以作者希望能直接从现在的安居客用户端中拆分出租房模块作为一个单独的 App 发布上线。这样看来模块化似乎是一个不错的选择。 所以作者做模块化的目的大致是这样的： 业务模块间解耦 单个业务模块单独编译打包，加快编译速度 多团队间并行开发、测试 解决好租App需要单独维护的问题，降低研发成本 关于模块化组件化的生动解读来自安居客 Android 组组长张磊的博客 http://baronzhang.com Pods 依赖库及组件化组件化与模块化安居客的 Android 团队内部成立了技术小组，基础组件的开发是技术小组很重要的一部分工作；模块化更多的是现有的方案受到来自业务上的挑战以及受到了 Oasis Feng 在 MDCC 上的分享和整个大环境的启发，现在正处于设计规划和 Demo 开发的阶段。 组件化组件化不是个新概念，通俗的讲组件化就是基于可重用的目的，将一个大的软件系统拆分成一个个独立组件。 组件化的带来的好处不言而喻： 避免重复造轮子，节省开发维护成本； 降低项目复杂性，提升开发效率； 多个团队公用同一个组件，在一定层度上确保了技术方案的统一性。 现在的安居客有是三个业务团队：安居客用户 App、经纪人 App、集客家 App。为了避免各个业务团队重复造轮子，团队中也需要有一定的技术沉淀，因此组件化是必须的。现在我们需要提供更多的、职能单一、性能更优的组件供业务团队使用。根据业务相关性，我们将这些组件分为：基础组件和业务组件。 阿里架构组同样是组件化的先驱者，以下是阿里架构组 Evans 对组件化的观点： 首先，我的理解分块化应该是有四种，组件化+模块化+插件化+解耦 第一，组件和组件其实是没有什么鬼明确的约束 ，因为组件一般都是单独开发、单独测试，不能直接放到主项目中开发，测试也是单独针对性的测试 （里面涉及到短链+组件的生命周期+….） 第二，模块化我的理解是，怎么做好project的模块化的拆分，我们内部一直在说越底层的模块，应该越稳定，越抽象，越具有高复用度，但是其实有一个壁垒就是怎么去提升模块的复用度，怎么去快速具备复用性高于代码复用性，这我们就要做好每个模块只做好一件事情，模块化结构要更加清晰，每个模块都只做一件事情，具有良好的延展性和拓展性，但愿不要出现下层模块依赖上层模块的现象，业务模块之间也尽量不要耦合。好处是同样的功能模块，可以在多个app中复用，业务隔离了跨团队开发代码控制和版本风险都变小了。 第三，解耦其实理解很简单就是在基于模块设计原则上, 让模块之间没有循环依赖, 让业务模块之间解除依赖，不相互调用。 概况的理解就是 组件化：单独开发、测试、维护的开发模式 模块化：对 Project 进行拆分，根据业务、功能进行分类 解耦：模块设计原则上, 让模块之间没有非必要依赖 而组件化现在主流的做法是通过 CocoaPods 对要包装的内容进行打包，提交到公司的私有库（开源项目是公有库），进行日常维护及开发。 环境自动切换 + 自动化打包测试 + 线上质量监控环境自动切换 Debug 和 Release 仅仅是编译选项的不同，那么为什么要区分 Debug 和 Release 版本呢？ Debug 和 Release，主要是针对其面向的目标不同的而进行区分的。 Debug 通常称为调试版本，通过一系列编译选项的配合，编译的结果通常包含调试信息，而且不做任何优化，为开发人员提供强大的应用程序调试能力。 而 Release 通常称为发布版本，是为用户使用的，一般客户不允许在发布版本上进行调试。所以不保存调试信息，同时，它往往进行了各种优化，以期达到代码最小和速度最优。为用户的使用提供便利。 对于一些企业版应用或者有内部测试的需求其实还可以新增 Beta 版，收集核心用户的建议或者测试新开发的功能模块，对反馈做出迅速反应，灵活控制。 由于之前引入了组件化开发模式，所有我又加入了 UnitTest（单元测试）模式，只要用于对组件的分离化测试，快速定位问题。 切换环境的同时会对应切换应用的图标，能有效避免测试环节中的环境混淆和降低辨别成本。 自动化打包测试 关于自动化打包就不得不说在创业公司的经历，那时开发任务重，提测前常常加班到晚上 12 点，就算 bug 修完，也要等半个小时看着 Xcode 不慌不忙的打包完成上传测试平台发邮件才能安心回家。 鉴于这种惨痛经历，利用闲暇时间就搞了个自动打包脚本，后期又整理一遍并适配 Xcode 8.2 之后的版本。 做的了三步配置，杜绝污染，一行命令自动上传。 也是鉴于 Xcode 版本升级后的苦逼适配经历，最终选择了开源的 fastlane 包，从此搭上了组织的小火车，配合 Testflight 终于可以放心的玩耍了… FastLane 是一种配置 iOS 和 Android 自动化 Beta 部署和发布的最简单的方法之一。它可以简化一些乏味、单调、重复的工作，像截图、代码签名以及发布 App。也能无缝衔接蒲公英、Fir等测试平台，这酸爽… 省时：每次将新版本推送到商店或Beta测试服务时，都可节省时间。 集成：集成当前开发环境中所有存在的工具和服务。 开源：100%基于MIT许可开源。 简单：简单的设置助手，几分钟配置即可使用。 运行：基于你的app和数据，运行在本地机器上。 CI：集成几乎所有CI系统。 支持：支持iOS、Mac以及Android 应用。 自定义：根据自身需要扩展和定制fastlane，不依赖任何人。 命令行：不需要记住除fastlane以外的任何命令。 配置：可以在任何电脑上配置，包括CI服务器。 对于 Testflight，就像没故事的卓同学所说的。 Testflight 有个较大的使用门槛，需要收集用户的邮箱，之后在 Testflight 里输入苹果发出的邀请码才能开始测试。很多用户嫌麻烦就退出了，运营认为这样会给测试带来很大的不便。但是冷静了心态后其实事情并没有那么糟糕。真正对这个产品有兴趣的用户不会因为要填个邮箱就放弃了。那些流失的只是普通的用户。用户使用了 Testflight 后，后续的测试包的发布也会收到更新。不会像企业版那样，只能手动的告诉用户我们有新的测试包。当 beta 测试活跃用户超过 100 个会有一个质变。这些都是积极的重度用户，一群重度用户使用你的新版本几天，至少可以保证核心业务逻辑是没有纰漏的。 这里推荐配合测试的 SDK 质量监控服务——Bugtags，Bugtags 可以通过悬浮窗或者摇一摇的方式进行截图，并将捕获的 bug 图片上传到测试平台，其自身也包括 Crash 的自动上传。 线上质量监控Crashlytics 成立于2011年，是专门为移动应用开者发提供的保存和分析应用崩溃信息的工具。 Crashlytics 不会漏掉任何应用崩溃信息。在发生崩溃后，用户再次进入 APP 并联网情况下，日志自动上传。 Crashlytics 可以象 Bug 管理工具那样，管理这些崩溃日志。例如：Crashlytics 会根据每种类型的 Crash 的出现频率以及影响的用户量来自动设置优先级。对于每种类型的 Crash，Crashlytics 除了会像一般的工具提供 Call Stack 外，还会显示更多相关的有助于诊断的信息，例如：设备是否越狱，当时的内存量，当时的 iOS 版本等。对于修复掉的 Crash 日志，可以在 Crashlytics 的后台将其关掉。 Crashlytics 可以每天和每周将崩溃信息汇总发到你的邮箱。 提供在线的报告，解释崩溃原因，甚至能给出是哪一行代码导致的崩溃。 Crashlytics 有配套的 macOS 应用 Fabric 用户体验值得国内 SDK 服务商学习。 2013 年 Twitter 对 Crashlytics 进行人才和服务的多重收购，一年后 Google 收购 Firebase，从此 Fabric 和 Firebase 这对好基友就成为了应用崩溃报告的黄金搭档。 管理团队核心组成架构关于团队的观点，我基本和没故事的卓同学看法一致，除了技术的硬指标，在早期团队还有一个工程团队文化的问题。一个几十个人的项目，里面某个特定的人的积极性对于项目其实是不太重要的。他只要完成应该完成的工作。甚至和其他人不说话也影响不大。一个大的项目也不能因为任何一个人不在了就运行不下去。 我之前思考过团队文化是什么，怎么形容团队文化。后来看到一个说法感觉挺贴切。文化是空气，无处不在。公司没有规定下班后社交平台上看到用户反馈需要你去回应，也不会规定你发现其他部门的产品有问题是不当回事还是应该去和其他部门的人沟通，又或者看到一个更好的建议是不是要和公司提出来。这些行为背后的支撑就是团队文化。在团队里的人决定了价值观。 技术团队做事就像古代的八抬大轿，公司业务就像轿子里的小娘子，团队文化就像抬轿子时喊的号子，团队里的每个人就像是抬轿子的车夫。抬轿子的大多数人走的快，每个人的步子齐，那轿子里的小娘子就坐得很舒服，如果哪个环节出现问题都会对坐轿子的人有影响。 所以，车夫水平要挑好，号子要响亮提气，每个人的步伐要协调，轿子就能平稳上路，可是如果想快点赶路，那可能就要尝试不同的抬轿姿势，换更响亮的号子，排练更协调步子，甚至换个更轻的轿子、换个轮子… 硬件设备投入接着上面的“花轿”说，硬件投入的重要性就不言而喻了，别人已经换上了带轮子的马车了，当然跑的飞快。 拿 Swift 的编译速度讲，MacBook Air 和 MacBook Pro 的处理器芯片和内存容量决定了两种电脑的编译耗时可能相差1倍左右，而一块外接显示屏能节省的频繁操作更是以少积多。 如果把一个工程师的薪资换算成时薪，配合硬件设备浪费掉的时间，将是一笔不那么明智的开销，当然如果你的工程师每天只是喝凉水看新闻，那请配给他一个保温杯和老花镜~ 例会和文档化有哪些会？ 当我打算写这个主题时，反思了下过去都参加过哪些会议，发现有时会莫名其妙的就参加了一些完全无意义的会议。下面我们先看看一般程序员都会碰到哪些会议。 需求会 这类会议一般是产品或项目经理召集，组织参与项目的程序员一起讨论需求并确定排期。这类会议容易出的问题是，程序员到了会上才第一次知道需求，并陷入到需求细节的无休止讨论中。更好的方式是提前让程序员详细了解需求，会上只需敲定排期并让互相有协作依赖的程序员之间达成一致和形成承诺。 讨论会 这类会议的场景比较广泛，比如：项目进行过程中同组程序员之间就设计或实现的讨论，或与其他组项目合作人之间的讨论等等。这类会议容易出现的问题是临时把一堆人拉到会上，然后陷入混乱的自由讨论，失去焦点。 还有一类讨论会叫头脑风暴会，也是容易把一堆人拉到会上，开动头脑风暴。如今遗憾的领悟到这是最没效率也没效果的方式。头脑风暴会需要就待解决的问题让参与人员提前准备，搜集或阅读材料，不同人从不同角度各自提出自己的观点或方案，然后到了会上将所有观点和方案列出来，再开动头脑，碰撞连接一下，看看能不能风暴出一些新的观点或方案去有效解决问题。 周例会 一般来说一个部门或小组都会每周开个例会，例会容易被当作日常的例行工作而不被重视。例会应该有固定的时间和议程，而且例会是一群经常一起工作并熟悉的人开会。虽然开例会的人都在同一个部门，但并不意味着他们都会相互合作完成同一个项目或事情。所以，例会是通过了解各自工作来完成了解整个部门或小组工作进展的机会，而不是每周固定的休闲时光。当然我们也可以在每周的例会留出一段自由讨论时间，可以畅所欲言，增加工作之外交流。 除了周例会，有些实施敏捷方法的团队也会开每日站立会，每日站立会的一般内容是： 昨天干了什么 今天计划干什么 遇到了什么障碍 每日站立会议的主要目的是让团队成员互相交流互通工作情况，而不是为了让经理们了解情况而召开的会议。每日站立会不是一个团队的人站一圈各自说下工作情况，因为曾经发现彼此并不关心对方工作内容的人站一圈开这个站立会，其意义何在？ 分享会 部门内、公司内或行业内都会有各类不同规模分享会，想清楚你为什么要去参加一个分享会？一般来说我只有两个原因，我对分享的内容感兴趣，这应该是大部分人参会的原因。另一个，即使分享内容我已经很熟悉，那么参会的原因一般就是对分享人感兴趣，想要去通过这个分享了解分享人。 还有一种情况可能是碍于面子参加一些完全没兴趣的分享会，恩，这种还是尽量规避吧。 临时会 总会碰到这种情况，突然有个人过来叫你临时去参加个会，然后你就一脸懵逼的去了。这种会似乎属于身不由己，不好规避，这类会议多是非计划性的任务驱动型会议。英特尔前 CEO 安迪·格鲁夫说过： 在现实中，有 20% 的情况还得靠任务导向会议来解决。但如果经理人将超过 25% 的时间用在应急的任务导向会议上，这个组织就一定有了毛病。这种类型的会议随时召开，而且会针对具体情况产生决策，若这种临时紧急的任务驱动会议太多了，那问题肯定出在平时的工作中。 总结会 可能是项目上线或产品发布后的总结会，也可能是线上故障后的经验教训总结会。我以前开过的很多总结会都变成了领导的总结会，关于这类会大家有什么好想法吗？ 对于以上这些千奇百怪的会议，于是有人制作了这幅漫画： 其实呢，凡事都有两面性，最难把控的永远是人，作为有效的讨论活动，会议本事没有问题，精耕细作也会在一定程度上保证质量。重要的是会议的气氛、主题以及控场力。 高效会议的三个要诀：1.提前通知议题并发给参会人相关资料，不要求可参加可不参加的人2.会议必须有主持人，引导大家时刻盯住会议主题3.要有会议纪要，会后对会议结论、行动计划、负责人、进度表和考核目标的提炼总结 我之前遇到一个项目领导就很有特色，由于采取封闭式敏捷开发模式，需要每天确定工作内容，调节各部门间工作进展，所以需要每天做午会，但是当时并不枯燥而且团队协作融洽，因为在例会过后有组织抽签买饮料、零食和惩罚倒霉鬼的活动，如今想来，他确实是一个优秀的组织者。 以上这些会议内容来自博客园的 mindwind，让我们同情他一刻钟~ 文档化文档化和例会一样是充满争议的举措，本质上是为了让一切有据可查，方便后期查阅和减少交接工作负担。但也不乏反对者，认为是在浪费时间，形势主义。 还是一样的道理，稳定的方法不会错，难把握的是个人。把每一个账号密码整理保存也是文档化。保持会议记录、工作聊天日志也能在必要时不接受飞来的横“锅”~ 组织 CodeReview还是引用没故事的卓同学的话，Code review 是一件神奇的事情。所有有素养的工程师都觉得 code review 好，据我们所知国外很多优秀的 IT 企业都很注重 code review，但是在国内却很少看到有团队执行 code review。或者中小团队里很少看到 code review。 作为一个 leader，在 review 的时候帮助成员成长，和只是看下代码是不是能完成功能最后会引向不同的结果。看过一句很有触动的话，现在很多 leader 知道自己的工作里需要管理其他人，但是却忽略了还需要 lead 。老实说推进 code review 确实遇到很多阻力。有团队里的也有团队外的。团队外的看法是 code review 拖慢了项目进度。我作为一个核心的开发成员，每天超过 20% 的时间是没有可见的工作产出的。有时别人写的有问题被我打回去改，一个已经完成的功能又多花了几个小时。团队内遇到的问题是，很多成员不理解这项工作背后的价值。 同样的感触来自上面提到的那家公司，负责我们的小组组长是一名有着 6 年移动端开发经验的优秀工程师，在一套严格的代码规范要求和 code review 的锻炼下，我的成长几乎是肉眼可见的（对比回看之前的代码），他对我们的指导也是无私且专业的，以至于我现在依然在感谢着他。 CodeReview 的方式 开 Code Review 会议 团队内部会整理 Check List 团队内部成员交换代码 找出可优化方案 多问问题，例如：“这块儿是怎么工作的？”、“如果有XXX 情况，你这个怎么处理？” 区分重点，优先抓住设计，可读性，健壮性等重点问题 整理好的编码实践，用来作为 Code Review 的参考 CodeReview 的内容 [1]架构/设计/常规1.单一职责原则这是经常被违背的原则。一个类只能干一个事情，一个方法最好也只干一件事情。比较常见的违背是一个类既干UI的事情，又干逻辑的事情，这个在低质量的客户端代码里很常见2.行为是否统一，例如：1)缓存是否统一2)错误处理是否统一3)错误提示是否统一4)弹出框是否统一5)……3.代码污染代码有没有对其他模块强耦合4.重复代码–&gt;应该抽取5.开闭原则6.面向接口编程7.健壮性1)是否考虑线程安全2)数据访问是否一致性3)边界处理是否完整4)逻辑是否健壮5)是否有内存泄漏6)有没有循环依赖7)有没有野指针8)是否检查了数组的“越界“错误9)……8.错误处理9.改动是不是对代码的提升新的改动是打补丁，让代码质量继续恶化，还是对代码质量做了修复10.效率/性能1)关键算法的时间复杂度多少？有没有可能有潜在的性能瓶颈2)客户端程序对频繁消息和较大数据等耗时操作是否处理得当 [2]代码风格1.可读性衡量可读性的可以有很好实践的标准，就是 Reviewer 能否非常容易的理解这个代码。如果不是，那意味着代码的可读性要进行改进2.命名1)命名对可读性非常重要2)是否跟系统属性命名造成冲突3)英语用词尽量准确一点，必要时可以查字典3.函数长度/类长度1)函数太长的不好阅读2)类太长了，检查是否违反的 单一职责 原则4.注释恰到好处的注释,不是注释越多越好5.参数个数不要太多，一般不要超过 3 个 工具Gitlab 及 Git 相关规范Gitlab对于代码仓库开源首选 GitHub，不开源现在也有许多服务商，如：Gitee 等，如果有钱任性 GitHub 普通的团队套餐每个月每人 9 刀，但我相信大多数中小企业会选择 Gitlab。 还有就是服务端如果要自己配置 CI 服务不太方便。如果部署在自己的服务器上，其他一些服务脚本也部署在一起，会有很大的自主权。综合之后选择了主流的 Gitlab。 第三方仓库都可能遇到父爱如山般的维护时期。 Git 相关规范Git 相比 SVN 能避免大多数非人为问题，这点相信已经不需要论证了。但是那些人为的问题怎么办，那当然需要规范了。 首先，做好分工，特别是 Storyboard 和 XIB 多种，尽量避免出现多人修改同一个文件。 每个人的所有开发工作都只在自己的分支开发。例如小明开发，你就在本地切换到自己的 xiaoming_gittutorial 分支然后进行开发。 每个人只允许在自己的分支直接push远程分支。 合并的时候必须遵循以下条件： 首先，本地切换到develop分支。pull```123* 例如你是小明，那么在 pull 到远程的 develop 最新的内容之后。```git merge xiaoming_gittutorial 如果出现 conflict 那么清除 conflict 之后，commit 然后把本地 develop push 到远程的 develop。 每完成一个功能就提交一次，不要累计代码。 保证主分支代码永远可运行，版本完整（用于脚本自动化发测试包）。 这样的流程有什么好处呢？ 几乎不会出现 conflict。 你永远也不会污染 develop 分支。 每次都是在本地 merge 完清除了 conflict 之后再 push 会远端，那么别人更新本地 develop 分支，再合并的时候，就算出现 conflict 也只会是自己最新代码产生的 conflict。 Sketch 设计工具 + Zeplin 标注工具移动端也属于前端，是做直接和用户打交道的事情，当然也包括设计狮，设计狮是一种很厉害的猫科动物，他们有着令人恐惧的像素眼和血统中的强迫症。（以上我喝多了说的，不要当真哈~） Sketch 作为一款移动时代设计师新宠，自然有其存在的道理。 自动保存和版本管理 矢量编辑和完美像素 智能参考线 自由编辑元素 布尔运算 单图层多重混合模式 四舍五入像素数值取整 共享样式和组件 优秀的输出 分配间距 移动设备模版 自带格栅 出色的文字渲染 丰富的插件（标注、内容填充） 多种软件高度配合 旋转复制 手机实时预览 Zeplin 面向的用户是设计师和前端（Web、Mobile）工程师，相当于做的是中间桥梁这一块，核心功能为标注、Style Guide、备注文档与简单的团队协作。 sketch支持多画板，便于同时预览，占用内存较ps小很多 sketch支持导出flinto，便于制作交互动效原型 zeplin解放设计师的双手，从此告别切图和标注 zeplin降低工程师的沟通成本，提高设计还原度 Abstract 就是一个借助 Git 对 Sketch 文件进行版本控制的软件。 详情参见《Git 与 Sketch 的神奇邂逅：Abstract》（https://sspai.com/post/40595） 成果年终总结 Github 原创开源项目 90+，共计 400+ 贡献力 参与维护开源项目 fastlane 20.5k（至2018.02.08） 完成 Swifter 功能展示应用研发 Swifter 是一款基于 Swift 开发的，采用 MVVM 模式、RxSwift 函数式响应编程、组件化和 ReactNative 等技术的技术示例应用。","categories":[{"name":"Summary","slug":"Summary","permalink":"https://reversescale.github.io/categories/Summary/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"让 Async 帮你解决线程问题","slug":"Library Async","date":"2018-02-23T03:56:27.000Z","updated":"2018-11-16T12:09:19.724Z","comments":true,"path":"2018/02/23/Library Async/","link":"","permalink":"https://reversescale.github.io/2018/02/23/Library Async/","excerpt":"线程这种东西一般封装比较深，很微观，也很考察计算机基础知识，虽然系统为我们封装的 GCD、NSOperation 已经很好用了，但是我发现了个更好用的~","text":"线程这种东西一般封装比较深，很微观，也很考察计算机基础知识，虽然系统为我们封装的 GCD、NSOperation 已经很好用了，但是我发现了个更好用的~ 👨🏻‍💻 Github Demo 🤖 要求 iOS 9.0+ Xcode 9.0+ Swift 4 🎨 测试 UI 什么样子？ 1.展示页 2.展示页 3.展示页 常见场景列表 耗时操作场景示例 黑科技操作场景示例 🎯 安装方法在 iOS, 你需要在 Podfile 中添加.12345source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;9.0&apos;use_frameworks!pod &apos;AsyncSwift&apos; 🛠 配置耗时操作这是应用最广泛的场景，为了避免阻塞主线程，将耗时操作放在子线程处理，然后在主线程使用处理结果。比如读取沙盒中的一些数据，然后将读取的数据展示在 UI，这个场景还有几个细分：1.1 执行一个耗时操作后回调主线程123456Async.background &#123;print(\"A: This is run on the \\(qos_class_self().description) (expected \\(QOS_CLASS_BACKGROUND.description))\") sleep(2)&#125;.main &#123; print(\"B: This is run on the \\(qos_class_self().description) (expected \\(qos_class_main().description)), after the previous block\")&#125; 1.2 串行耗时操作 每一段子任务依赖上一个任务完成，全部完成后回调主线程：1234567891011let backgroundBlock = Async.background &#123; print(\"This is run on the first\\(qos_class_self().description) (expected \\(QOS_CLASS_BACKGROUND.description))\") sleep(2) print(\"This is run on the second \\(qos_class_self().description) (expected \\(QOS_CLASS_BACKGROUND.description))\") sleep(2)&#125;// Run other code here...backgroundBlock.main &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(qos_class_main().description)), after the previous block\")&#125; 1.3 并发耗时操作 每一段子任务独立，所有子任务完成后回调主线程：12345678910111213141516Async.main &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(qos_class_main().description))\") // Prints: \"This is run on the Main (expected Main) count: 1 (expected 1)\" &#125;.userInteractive &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(QOS_CLASS_USER_INTERACTIVE.description))\") // Prints: \"This is run on the Main (expected Main) count: 2 (expected 2)\" &#125;.userInitiated &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(QOS_CLASS_USER_INITIATED.description)) \") // Prints: \"This is run on the User Initiated (expected User Initiated) count: 3 (expected 3)\" &#125;.utility &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(QOS_CLASS_UTILITY.description)) \") // Prints: \"This is run on the Utility (expected Utility) count: 4 (expected 4)\" &#125;.background &#123; print(\"This is run on the \\(qos_class_self().description) (expected \\(QOS_CLASS_BACKGROUND.description)) \") // Prints: \"This is run on the User Interactive (expected User Interactive) count: 5 (expected 5)\"&#125; 延时执行延时一段时间后执行代码，一般见于打开 App 一段时间后，弹出求好评对话框。123456let seconds = 3.0Async.main(after: seconds) &#123; print(\"Is called after 3 seconds\")&#125;.background(after: 6.0) &#123; print(\"At least 3.0 seconds after previous block, and 6.0 after Async code is called\")&#125; 其他用法请见 Demo。 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"门罗币(Monero XMR)给你最轻巧的矿工生活(包教包会)","slug":"Monero XMR","date":"2018-02-08T18:56:27.000Z","updated":"2018-11-16T12:10:01.852Z","comments":true,"path":"2018/02/09/Monero XMR/","link":"","permalink":"https://reversescale.github.io/2018/02/09/Monero XMR/","excerpt":"你向往躺着赚钱吗？你想不努力工作就实现财务自由吗？你想什么都不做就有数不完的钱吗？洗洗睡吧~","text":"你向往躺着赚钱吗？你想不努力工作就实现财务自由吗？你想什么都不做就有数不完的钱吗？洗洗睡吧~ 从2017年8月21日开始，XMR一路走高，从$55左右，一路上涨，到本文写作时，已经达到$269（≈￥1,699）。数据来源：Crypto coins mining profit calculator compared to Ethereum 门罗币（Monero，代号XMR）是一个创建于2014年4月开源加密货币，它着重于隐私、分权和可扩展性。与自比特币衍生的许多加密货币不同，Monero基于CryptoNote协议，并在区块链模糊化方面有显著的算法差异。Monero的模块化代码结构得到了比特币核心维护者之一的Wladimir J. van der Laan的赞赏。Monero致力于成为可代替的不可追踪的电子货币。相比比特币及其分叉，Monero具有更高程度的匿名性。 Monero于2014年4月18日发布。 高涨的币价使得在国内一直默默无闻的XMR瞬间成为焦点，现在已经变成挖矿收益最高的币种之一。以1060 3G为例，在不超频的情况下，挖掘XMR的速度在430H/s左右，不计电费，单卡日收益达到$1.62，超过了之前收益之王ETH。 如何挖矿？ 作为矿工，大家最关心的应该还是怎么挖矿了，下面就向大家介绍一下挖矿的最轻巧姿势。 获得一个钱包地址（推荐）使用在线钱包：https://mymonero.com/特点：使用方便，安全性差 或者在XMR的官方网站下载钱包 App：Monero: Downloads(https://getmonero.org/downloads/)特点：相对安全，方便性差 参与挖矿在网上，你可能看到过许许多多硬件驱动的挖矿方式，组合多少显卡的矿池，但是这里的主题是“最轻巧”，所以我们只做帮工好了。 Coinhive是一个提供恶意JS脚本的网站平台（https://coinhive.com），允许攻击者将脚本挂在到自己的或入侵的网站上，所有访问该网站的用户都可能成为门罗币的挖掘矿工。该工具在网络犯罪分子中间迅速扩散，俨然已经成为了互联网的“Martin Shkreli”。 Coinhive工具其实是一个Java库，用户访问加载该JS的网站后，Coinhive的JS代码库在用户的浏览器上运行，开始为网站所有者挖掘门罗币，消耗的是用户自己的CPU资源。 不得不说，这个想法相当地有创意！Coinhive于9月14日推出，作者向站长们推广Coinhive时声称，站长们加载了Coinhive JS就可以实现盈利：它仅耗费访问用户的少部分CPU，就可以为网站所有者赚取利润，用于支持他们的业务，再也不用添加各种烦人的广告了。 这一想法获得了某些人的支持，在The Pirate Bay（全球知名的BT下载网站）试运行了两天后，由于用户的负面反馈，最后放弃了。 未开情况下 CPU 占用： 理论上你可以使用闲置的那 54.08% 进行挖矿，实测对 CPU 的负荷还是很大的下图是开通100 Threads 下处理器占用情况： 矿工分成之前已经介绍过这种机制的原理了，轻量也注定着收益不会太高，但是简单的使用却可以为你省下大把时间，相信你的时间才是最宝贵的。 上面那些对于刚刚接触的你可能不是很受用，那来看看下面这些 以为这样以后每天的早餐钱就有了？😆那你最好仔细读读下面的东西…","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://reversescale.github.io/tags/Blockchain/"}]},{"title":"iOS 模块化路由之 JLRoute","slug":"Library JLRoute","date":"2018-02-01T13:56:27.000Z","updated":"2018-11-16T12:09:27.900Z","comments":true,"path":"2018/02/01/Library JLRoute/","link":"","permalink":"https://reversescale.github.io/2018/02/01/Library JLRoute/","excerpt":"基于 JLRoute 实现的模块化路由，支持自动注册映射表、Url 跳转原生页面、WebView 页面和 ReactNative 页面、跳转传参及回调等~","text":"基于 JLRoute 实现的模块化路由，支持自动注册映射表、Url 跳转原生页面、WebView 页面和 ReactNative 页面、跳转传参及回调等~ 模块化已经成为调剂庞大项目结构的一剂良药，对项目的开发、维护和后续的扩展的好处已经不言而喻。 👨🏻‍💻 Github Demo 🤖 要求 iOS 8.0+ Xcode 7.0+ 🎯 安装方法安装在 iOS, 你需要在 Podfile 中添加.1234567891011121314151617source &apos;https://github.com/CocoaPods/Specs.git&apos;platform :ios, &apos;9.0&apos;use_frameworks!pod &apos;JLRoutes&apos;, &apos;~&gt; 2.0.1&apos;# &apos;node_modules&apos;目录一般位于根目录中# 但是如果你的结构不同，那你就要根据实际路径修改下面的`:path`pod &apos;React&apos;, :path =&gt; &apos;./node_modules/react-native&apos;, :subspecs =&gt; [ &apos;Core&apos;, &apos;RCTText&apos;, &apos;RCTNetwork&apos;, &apos;RCTWebSocket&apos;, # 这个模块是用于调试功能的 # 在这里继续添加你所需要的模块]# 如果你的RN版本 &gt;= 0.42.0，请加入下面这行pod &quot;Yoga&quot;, :path =&gt; &quot;./node_modules/react-native/ReactCommon/yoga&quot; 启动 ReactNative 环境1.修改项目ModuleARNPageViewController.m IP 跳转地址 2.进入项目所在目录，运行(首次运行需要 npm install) 1npm start 🛠 JLRoutes的工作流程和原理单一的Scheme注册过程： 1.调用注册方法（用户注册routePattern，默认优先级0） 1- (void)addRoute:(NSString *)routePattern handler:(BOOL (^__nullable)(NSDictionary&lt;NSString *, id&gt; *parameters))handlerBlock; 2.路由解析（这些解析跟我们设置路由的规则有直接关系） (1)判断接口URL是否设置可选性URL并将对应的URL封装成JLRRouteDefinition对象 (2)将JLRRouteDefinition对象装载进一个可变数组，内存保留了所有的对象！！ （JLRRouteDefinition对象包括有路径，参数解析，block等信息） 单一的Scheme调用过程：1.调用URL 1+ (BOOL)routeURL:(NSURL *)URL 2.解析URL，将参数，路由信息封装成JLRRouteRequest对象 1- (instancetype)initWithURL:(NSURL *)URL alwaysTreatsHostAsPathComponent:(BOOL)alwaysTreatsHostAsPathComponent 3.给JLrouteRequest对象和路由数组里的JLRRouteDefinition对象作比对，并且返回JLRRouteResponse 对象抽出参数和URL在数组里 1JLRRouteResponse *response = [route routeResponseForRequest:request decodePlusSymbols:shouldDecodePlusSymbols]; 4.调用JLRRouteResponse 对象里面的回调方法 1[route callHandlerBlockWithParameters:finalParameters]; JLRoutes的URL注册规则： 1.普通注册 123456JLRoutes *routes = [JLRoutes globalRoutes];[routes addRoute:@&quot;/user/view/:userID&quot; handler:^BOOL(NSDictionary *parameters) &#123;NSString *userID = parameters[@&quot;userID&quot;]; // defined in the route by specifying &quot;:userID&quot;// present UI for viewing user with ID &apos;userID&apos;return YES; // return YES to say we have handled the route&#125;]; URL里，分号表示这个是参数 另外一种注册方式，下标注册法 123JLRoutes.globalRoutes[@&quot;/route/:param&quot;] = ^BOOL(NSDictionary *parameters) &#123;// ...&#125;; 如何按照以上的方式注册，在任何时刻（包括在其它的APP）你都可以调用这个URL。 12NSURL *viewUserURL = [NSURL URLWithString:@&quot;myapp://user/view/joeldev&quot;];[[UIApplication sharedApplication] openURL:viewUserURL]; 在这个例子中，在parmameters字典里面的userID会传给block，它是一个键值对。”userID”: “joeldev”。给UI层或者任何需要它的地方用的。 字典参数： 字典参数总包括至少一下3个键： 12345&#123;&quot;JLRouteURL&quot;: &quot;(the NSURL that caused this block to be fired)&quot;,&quot;JLRoutePattern&quot;: &quot;(the actual route pattern string)&quot;,&quot;JLRouteScheme&quot;: &quot;(the route scheme, defaults to JLRoutesGlobalRoutesScheme)&quot;&#125; 处理Block 你会发现，每个注册的block都会返回一个YES。这个值，如果你返回NO，JLRoutes会跳过这个匹配，然后继续去匹配其它的。 如果你的block设置成nil，它会默认返回YES。 2.复杂注册 1234567[[JLRoutes globalRoutes] addRoute:@&quot;/:object/:action/:primaryKey&quot; handler:^BOOL(NSDictionary *parameters) &#123;NSString *object = parameters[@&quot;object&quot;];NSString *action = parameters[@&quot;action&quot;];NSString *primaryKey = parameters[@&quot;primaryKey&quot;];// stuffreturn YES;&#125;]; 这个地址会被匹配很多URL，如/user/view/joeldev or /post/edit/123。这些URL上的是参数。 12NSURL *editPost = [NSURL URLWithString:@&quot;myapp://post/edit/123?debug=true&amp;foo=bar&quot;];[[UIApplication sharedApplication] openURL:editPost]; 这时，pramater字典就会是以下这样的（传参） 12345678910&#123;&quot;object&quot;: &quot;post&quot;,&quot;action&quot;: &quot;edit&quot;,&quot;primaryKey&quot;: &quot;123&quot;,&quot;debug&quot;: &quot;true&quot;,&quot;foo&quot;: &quot;bar&quot;,&quot;JLRouteURL&quot;: &quot;myapp://post/edit/123?debug=true&amp;foo=bar&quot;,&quot;JLRoutePattern&quot;: &quot;/:object/:action/:primaryKey&quot;,&quot;JLRouteScheme&quot;: &quot;JLRoutesGlobalRoutesScheme&quot;&#125; 3.Scheme（有没有多态的感觉） JLRoutes支持用指定的URL scheme来创建路由。相同的scheme才能被匹配。默认地，所有的URL会设置进global scheme。 123456789101112[[JLRoutes globalRoutes] addRoute:@&quot;/foo&quot; handler:^BOOL(NSDictionary *parameters) &#123;// This block is called if the scheme is not &apos;thing&apos; or &apos;stuff&apos; (see below)return YES;&#125;];[[JLRoutes routesForScheme:@&quot;thing&quot;] addRoute:@&quot;/foo&quot; handler:^BOOL(NSDictionary *parameters) &#123;// This block is called for thing://fooreturn YES;&#125;];[[JLRoutes routesForScheme:@&quot;stuff&quot;] addRoute:@&quot;/foo&quot; handler:^BOOL(NSDictionary *parameters) &#123;// This block is called for stuff://fooreturn YES;&#125;]; 如果你调用的使用，是这样调用的 123[[JLRoutes globalRoutes] addRoute:@&quot;/global&quot; handler:^BOOL(NSDictionary *parameters) &#123;return YES;&#125;]; 它只会调用global scheme的对应的URL。不会调用ting scheme里面对应的URL。 当然，你可以设置，如果指定的scheme没有这个URL，去查询global scheme 有没有。你需要设置一个属性。 1[JLRoutes routesForScheme:@&quot;thing&quot;].shouldFallbackToGlobalRoutes = YES; 3.通配符的设置URL的方式 通配符为：* 通配符符后面所有的URL上的参数都会以一个数组保存在parameters字典里面的JLRouteWildcardComponentsKey对应的value里。 例如，如果你注册URL如下: 123456789[[JLRoutes globalRoutes] addRoute:@&quot;/wildcard/*&quot; handler:^BOOL(NSDictionary *parameters) &#123;NSArray *pathComponents = parameters[JLRouteWildcardComponentsKey];if ([pathComponents count] &gt; 0 &amp;&amp; [pathComponents[0] isEqualToString:@&quot;joker&quot;]) &#123;// the route matched; do stuffreturn YES;&#125;// not interested unless the joker&apos;s in itreturn NO;&#125;]; 如果调用的URL开始是／wildcard，这个路由就可能被触发！！如果第一个参数是joker，就被触发，如果不是，就被拒绝触发。。。 4.选择性路由 如果路由地址设置样式有括号，如：/the(/foo/:a)(/bar/:b)，其实它代表的URL有如下： 1234/the/foo/:a/bar/:b/the/foo/:a/the/bar/:b/the 5.查询Routes 下面的方式，你可以查看Routes里所有注册的URL Routes。 1234/// All registered routes, keyed by scheme+ (NSDictionary &lt;NSString *, NSArray &lt;JLRRouteDefinition *&gt; *&gt; *)allRoutes;/// Return all registered routes in the receiving scheme namespace.- (NSArray &lt;JLRRouteDefinition *&gt; *)routes; 自定义路由解析如果你想自己定制一个路由编辑，你可以继承JLRouteDefinition并且用 addRoute：方法去添加你自定义类的对象。 📝 调研来源JLRoutes：https://github.com/joeldev/JLRoutes JLRoutes资料博客：https://www.varsiri.com/archives/305 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iPhone X + iOS 11 适配指南","slug":"iPhone X iOS 11","date":"2017-09-30T09:56:27.000Z","updated":"2018-11-16T12:08:45.619Z","comments":true,"path":"2017/09/30/iPhone X iOS 11/","link":"","permalink":"https://reversescale.github.io/2017/09/30/iPhone X iOS 11/","excerpt":"北京时间今天凌晨1点，苹果再一次让全世界沸腾。iPhone X 带给我们的最大改变：全屏 Super Retina显示屏。它提供了更多的内容显示空间，同时也营造了更加深入的沉浸感。作为 iOS 开发者，在为强大的 Face ID 和全面屏欣喜的同时，我更担忧“齐刘海”的适配！ 下面结合官方的人机交互指南，来了解下如何设计 App 才能在iPhone X 和其他所有 iOS 设备上都看起来很棒~","text":"北京时间今天凌晨1点，苹果再一次让全世界沸腾。iPhone X 带给我们的最大改变：全屏 Super Retina显示屏。它提供了更多的内容显示空间，同时也营造了更加深入的沉浸感。作为 iOS 开发者，在为强大的 Face ID 和全面屏欣喜的同时，我更担忧“齐刘海”的适配！ 下面结合官方的人机交互指南，来了解下如何设计 App 才能在iPhone X 和其他所有 iOS 设备上都看起来很棒~ 前言北京时间今天凌晨1点，苹果再一次让全世界沸腾。iPhone X 带给我们的最大改变：全屏 Super Retina显示屏。它提供了更多的内容显示空间，同时也营造了更加深入的沉浸感。作为 iOS 开发者，在为强大的 Face ID 和全面屏欣喜的同时，我更担忧“齐刘海”的适配！ 下面结合官方的人机交互指南，来了解下如何设计 App 才能在iPhone X 和其他所有 iOS 设备上都看起来很棒。 理论部分屏幕尺寸 在竖屏下，iPhone X 上的显示的宽度与 iPhone 6，iPhone 7和 iPhone 8的4.7英寸显示屏的宽度保持一致。然而，iPhone X 比4.7英寸显示屏高了145个点，这导致增加了大约20％的垂直高度内容。 大家在为设计师悲伤的同时也不要忘记添加启动图（LaunchImage or LaunchScreen.storyboard）呦~ 安全区 在 iPhone X 布局中，最关键的是：必须确保布局填满屏幕，同时又不会被设备的圆角，传感器外壳或用于访问主屏幕的指示灯所遮盖，苹果为称此区域为“安全区”。 可喜的是，大多数标准的系统提供的UI元素和控件（如 navigation bars，tables 和 collections）都已经为新外形做了很好的适配。 背景已经延伸到显示器的边缘，并且UI元件被很恰当地插入和定位在安全区域。 因此，对于具有自定义布局的 App，支持iPhone X 也应该比较容易，特别是如果使用了 AutoLayout 并遵守安全区域(safe area)和边距布局(margin layout)指南。这些在上文都已经有过较详细的阐述。 下面说几点需要特别注意的： 在 iPhone X 上预览 App: 在拿到新机之前，也可以先使用 Simulator 来预览和检查下布局问题。 但是一些依赖硬件的功能，如图像效果和交互体验，最好还是在真机上预览。 始终保持全屏体验: 确保背景延伸到显示区域的边缘，以及垂直可滚动的布局（如 tables 和 collections）一直延续到底部。 防止边缘内容被裁剪: 一般来说，内容应该是居中对称的，这样它在任何方向看起来都会很棒，不会被边角角或设备外壳夹住，或被主屏幕的指示器遮挡。 为了获得最佳效果，请使用标准的系统界面元素和 AutoLayout 构建界面。 所有 App 都应遵循 UIKit 定义的安全区域和布局边距，因为这些区域可以根据设备和上下文进行适当的填充。 安全区域还可以防止内容覆盖status bar, navigation bar, toolbar, 以及 tab bar. 注意 status bar 的高度: status bar 在iPhone X 上比在其他 iPhone上更高。 如果假定你固定 status bar 的高度用于将内容定位在 status bar 的下方，那么现在必须更新你的的 App，才能根据用户的设备动态定位内容。 特别需要注意，当后台任务（如录音和位置跟踪）处于活动状态时，iPhone X上的状态栏不会改变高度。 重新考虑隐藏 status bar: iPhone X 较之显示高度为4.7“iPhone 的显示屏提供了更多的内容垂直空间，status bar 占据的只是扩展出来的屏幕区域。况且 status bar 更直观的显示用户有用的信息，如果非要隐藏状态栏，那最好用与这些信息同等重要的内容替代。 注意长宽比差异: iPhone X 具有不同于4.7“iPhone 的长宽比。因此，全屏4.7英寸iPhone 图形在iPhone X 上全屏显示时出现裁剪或 letterboxing 。同样，全屏iPhone X 图形全屏显示在4.7“iPhone 上时也会被裁剪或 pillarboxing ，因此要确保重要的视觉内容适配这两种尺寸。 避免交互式控件出现在屏幕底部和角落: iPhone X 提供了显示屏底部的滑动手势来访问主屏幕和应用程序切换器的新交互方式，这些手势可能会取消在此区域中实现的自定义手势。 况且屏幕的两个角落过多复杂的交互也不是最佳体验的良好实践。 不要遮挡或者特别修饰显示特性来引起用户注意: 请勿尝试隐藏设备的圆角、传感器外壳，或者通过在屏幕顶部和底部放置控件来访问主屏幕的引导。也要特别注意不要试图使用像括号，边框或各种符号等视觉修饰这些特殊区域。 为了轻松访问主屏幕允许自动隐藏指示器: 当开启自动隐藏时，如果用户离开屏幕几秒钟，指示器将消失。 当用户再次触摸屏幕时，它会重新出现。 这种行为应该只能用于提升观看体验，如播放视频或照片幻灯片。 色彩iPhone X 的显示器支持 P3 色彩空间，它可以产生比 sRGB 更丰富，更饱和的颜色。 可以使用 wide color 来增强视觉体验。 它可以让照片和视频更加逼真生动。 更多内容可以参考官网Color management（https://developer.apple.com/ios/human-interface-guidelines/visual-design/color/#color-management） 手势想必大家都在发布会上看到了，iPhone X 上的显示屏可以使用屏幕边缘手势来访问主屏幕，应用程序切换器，通知中心和控制中心。适应这个新变化的同时，对于开发者要特别注意： 避免干扰系统范围的屏幕边缘手势:用户依赖这些手势在每个 App 中操作，所以在极少数情况下，比如游戏这种强调沉浸式体验的 App 可能需要自定义的屏幕边缘手势，优先级高于系统的手势。 这种行为（称为边缘保护）应该谨慎使用，因为它使得用户难以访问系统级的操作。 更多内容参考官网Gestures （https://developer.apple.com/ios/human-interface-guidelines/user-interaction/gestures/） 补充的注意事项 认证方法准确:iPhone X 支持 Face ID进行身份验证。 如果你的 App 集成了 Apple Pay 或其他系统身份验证功能，请务必注意不要在 iPhone X 上引用 Touch ID。同样地，也请确保不要在支持Touch ID 的设备上引用 Face ID。 更详细的内容请参考Authentication(https://developer.apple.com/ios/human-interface-guidelines/user-interaction/authentication/) 不要重复增加系统提供的键盘功能:在 iPhone X上，即使使用自定义键盘，Emoji / Globe 按钮和 Dictation 按钮也自动显示在键盘的下方。 你的 App 不能影响这些按钮，因此避免在键盘中重复增加这些按钮造成混乱。 由于 iPhone X的屏幕比例发生变化，对于长期靠“等比缩放”完成适配的H5活动页而言也有不小的影响，需要对页面结构进行适当微调。 更详细内容请参阅Custom-keyboards(https://developer.apple.com/ios/human-interface-guidelines/extensions/custom-keyboards/) 判断 iPhone X 机型 (Swift)如何判断当前的设备是 iPhone X 呢？有好几种办法，可以考虑取得「iPhone 10,1」这样的 Module Name 来判断，也可以用屏幕分辨率的形式来判断。我觉得要用屏幕分辨率的方式来做，因为这是目前为止最简单也最不容易出错的。因为 iPhone X 只有一种分辨率，那就是 812pt x 375pt (@3x），且没有任何其他设备用了一样的分辨率，特别是高度。 于是写了一个基于 UIDevice 的扩展（或者其他任意方法也行）： 12345678extension UIDevice &#123; public func isX() -&gt; Bool &#123; if UIScreen.main.bounds.height == 812 &#123; return true &#125; return false &#125;&#125; 在代码中，就可以用 UIDevice.current.isX() 来判断是不是跑在 iPhone X 机型上，然后做一些或不做一些特殊的 Hack 了。 当然如果你习惯用三方库，也可以尝试“DeviceKit” 1234567let device = Device()print(device) // prints, for example, \"iPhone X\"if device == .iPhoneX &#123; // Do something&#125; else &#123; // Do something else&#125; 代码适配部分当我们能够判断出设备型号就可以配合系统版本进行适配了 适配 UITableView 组件12345678if (@available(iOS 11.0, *)) &#123; self.contentInsetAdjustmentBehavior = .never self.estimatedRowHeight = 0 self.estimatedSectionHeaderHeight = 0 self.estimatedSectionFooterHeight = 0&#125; else &#123; // Fallback on earlier versions&#125; 适配 UIScrollView 组件12345if (@available(iOS 11.0, *)) &#123; scrollView?.contentInsetAdjustmentBehavior = .never&#125; else &#123; // Fallback on earlier versions&#125; UITableView中的sectionHeader或者Footer显示不正常还有的发现某些界面tableView的sectionHeader、sectionFooter高度与设置不符的问题，在iOS11中如果不实现-tableView: viewForHeaderInSection:和-tableView: viewForFooterInSection:，则-tableView: heightForHeaderInSection:和- tableView: heightForFooterInSection:不会被调用，导致它们都变成了默认高度，这是因为tableView在iOS11默认使用Self-Sizing，tableView的estimatedRowHeight、estimatedSectionHeaderHeight、estimatedSectionFooterHeight三个高度估算属性由默认的0变成了UITableViewAutomaticDimension，解决办法简单粗暴，就是实现对应方法或把这三个属性设为0。 1234567if #available(iOS 11.0, *) &#123; tableView.estimatedRowHeight = 0; tableView.estimatedSectionHeaderHeight = 0; tableView.estimatedSectionFooterHeight = 0;&#125; else &#123; automaticallyAdjustsScrollViewInsets = false;&#125;; 适配网页加载不全下面有白边1234if #available(iOS 11.0, *) &#123; webView.scrollView.contentInsetAdjustmentBehavior = .never&#125; else &#123;&#125;; 适配iPhoneX不能铺满屏的问题给Brand Assets添加一张1125*2436大小的图片 打开Assets.xcassets文件夹，找到Brand Assets 右键Show in Finder 添加一张1125*2436大小的图片 修改Contents.json文件,添加如下内容 123456789&#123;&quot;extent&quot; : &quot;full-screen&quot;,&quot;idiom&quot; : &quot;iphone&quot;,&quot;subtype&quot; : &quot;2436h&quot;,&quot;filename&quot; : &quot;1125_2436.png”,&quot;minimum-system-version&quot; : &quot;11.0&quot;,&quot;orientation&quot; : &quot;portrait&quot;,&quot;scale&quot; : &quot;3x&quot;&#125; 使用 LaunchScreen.storyboard 设置启动图 使用 LaunchScreen.storyboard 文件将简单视图约束定位，实现各种尺寸的自适应。 适配iPhoneX12345//适配iPhoneXlet LL_iPhoneX = (kScreenW == Double(375.0) &amp;&amp; kScreenH == Double(812.0) ?true:false)let kNavibarH = LL_iPhoneX ? Double(88.0) : Double(64.0)let kTabbarH = LL_iPhoneX ? Double(49.0+34.0) : Double(49.0)let kStatusbarH = LL_iPhoneX ? Double(44.0) : Double(20.0) Xcode9 打包注意事项Xcode9 打包版本只能是8.2及以下版本,或者9.0及更高版本 Xcode9 不支持8.3和8.4版本 Xcode9 新打包要在构建版本的时候加入1024*1024 AppSore icon Xcode9 沿用了之前的分包设计，可以配置打出多种设备的包文件，用户安装时根据设备不同分别安装不同的API包，减小安装包大小。 iOS 11 相册权限变更iOS11以前： NSPhotoLibraryUsageDescription：访问相册和存储照片到相册（读写），会出现用户授权。 iOS11之后： NSPhotoLibraryUsageDescription：无需添加。默认开启访问相册权限（读），无需用户授权。 NSPhotoLibraryAddUsageDescription： 添加内容到相册。（写），会出现用户授权。","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS RAC 的使用总结","slug":"Reactive Cocoa","date":"2017-07-16T14:56:27.000Z","updated":"2018-11-16T13:27:23.887Z","comments":true,"path":"2017/07/16/Reactive Cocoa/","link":"","permalink":"https://reversescale.github.io/2017/07/16/Reactive Cocoa/","excerpt":"Reactive Cocoa(简称RAC),是 GitHub 上开源的一个应用于 iOS 和 OS X 开发的一个新框架，RAC具有函数式编程和响应者编程的特性~","text":"Reactive Cocoa(简称RAC),是 GitHub 上开源的一个应用于 iOS 和 OS X 开发的一个新框架，RAC具有函数式编程和响应者编程的特性~ ReactiveCocoa解决的问题: 1.传统iOS开发过程中,状态以及状态之间依赖过多的问题 2.传统MVC架构的问题:Controller比较复杂,可测试性差 3.提供统一的消息传递机制 键值观察–监听 TF 的值发生变化123456789101112- (void)demo1&#123; @weakify(self); [self.tF.rac_textSignal subscribeNext:^(NSString *value) &#123; @strongify(self); self.value = value; &#125;]; //当self.value的值变化时调用Block，这是用KVO的机制，RAC封装了KVO [RACObserve(self, value) subscribeNext:^(NSString *value) &#123; NSLog(@&quot;%@&quot;,value); &#125;];&#125; map 的使用1234567891011121314151617- (void)demo2&#123; //创建一个信号 RACSignal *signalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; //这个信号里面有一个Next事件的玻璃球和一个complete事件的玻璃球 [subscriber sendNext:@&quot;唱歌&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //对信号进行改进,当信号里面流的是唱歌.就改进为&apos;跳舞&apos;返还给self.value RAC(self, tF.text) = [signalA map:^id(NSString *value) &#123; if ([value isEqualToString:@&quot;唱歌&quot;]) &#123; return @&quot;跳舞&quot;; &#125; return @&quot;&quot;; &#125;]; &#125; filter 使用,你向西，他就向东，他向左，你就向右1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void)demo3&#123; //创建两个通道,一个从A流出的通道A,和一个从B流出的通道B RACChannelTerminal *channelA = RACChannelTo(self, value); RACChannelTerminal *channelB = RACChannelTo(self, value2); //改造通道A,使通过通道A的值,如果等于&apos;西&apos;,就改为&apos;东&apos; [[channelA map:^id(NSString *value) &#123; if ([value isEqualToString:@&quot;西&quot;]) &#123; NSLog(@&quot;东&quot;); return @&quot;东&quot;; &#125; NSLog(@&quot;====== %@&quot;,value); return value; &#125;] subscribe:channelB];//通道A流向B //改造通道B,使通过通道B的值,如果等于&apos;左&apos;,就改为&apos;右&apos;传出去 [[channelB map:^id(id value) &#123; if ([value isEqualToString:@&quot;左&quot;]) &#123; NSLog(@&quot;右&quot;); return @&quot;右&quot;; &#125; NSLog(@&quot;====== %@&quot;,value); return value; &#125;] subscribe:channelA];//通道B流向通道A //KVO监听valueA的值的变化,过滤valueA的值,返回Yes表示通过 //只有value有值,才可通过 [[RACObserve(self, value) filter:^BOOL(id value) &#123; return value ? YES : NO; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;你向%@&quot;,x); &#125;]; //KVO监听value2的变化 [[RACObserve(self, value2) filter:^BOOL(id value) &#123; return value ? YES: NO; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;他向%@&quot;,x); &#125;]; //下面使value的值和value2的值发生改变 self.value = @&quot;西&quot;; self.value2 = @&quot;左&quot;; &#125; 代理1)代理的第一种写法 .m文件123- (void)demo4&#123; [self.delegate makeAnApp:@&quot;12345上山打老虎&quot; String:@&quot;老虎不在家,怎么办&quot;];&#125; .h文件12345- (void)makeAnApp:(NSString *)string String:(NSString *)string;@end@interface Base5Controller : UIViewController@property (nonatomic, assign)id&lt;ProgrammerDelegate&gt; delegate; 第一个控制器的.h123456789101112131415161718192021222324Base5Controller *base = [[Base5Controller alloc] init]; // base.delegate = self; [self demo4]; // 这里是个坑,必须将代理最后设置,否则信号是无法订阅到的 // 雷纯峰大大是这样子解释的:在设置代理的时候，系统会缓存这个代理对象实现了哪些代码方法 // 如果将代理放在订阅信号前设置,那么当控制器成为代理时是无法缓存这个代理对象实现了哪些代码方法的 base.delegate = self; [self.navigationController pushViewController:base animated:YES]; &#125; else &#123; [self.navigationController pushViewController:[cl new] animated:YES]; &#125;&#125;#pragma mark---demo4//使用RAC代替代理时,rac_signalForSelector: fromProtocol:这个代替代理的方法使用时,切记要将self设为代理这句话放在订阅代理信号的后面写,否则会无法执行- (void)demo4&#123; //为self添加一个信号,表示代理ProgrammerDelegate的makeAnApp; //RACTuple 相当于swift中的元祖 [[self rac_signalForSelector:@selector(makeAnApp:String:) fromProtocol:@protocol(ProgrammerDelegate)] subscribeNext:^(RACTuple *x) &#123; //这里可以立即为makeAnApp的方法要执行的代码 NSLog(@&quot;%@ &quot;,x.first); NSLog(@&quot;%@&quot;,x.second); &#125;];&#125; 2)方法2 使用RACSubject替代代理123456789101112131415161718192021/*** RACSubject:信号提供者,自己可以充当信号,又能发送信号创建方法:1.创建RACSubject2.订阅信号3.发送信号工作流程:1.订阅信号,内部保存了订阅者,和订阅者相应block2.当发送信号的,遍历订阅者,调用订阅者的nextBolck注:如果订阅信号,必须在发送信号之前订阅信号,不然收不到信号,有利用区别RACReplaySubject*/-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; RacSubjectController *racsub = [[RacSubjectController alloc] init]; racsub.subject = [RACSubject subject]; [racsub.subject subscribeNext:^(id x) &#123; NSLog(@&quot;被通知了%@&quot;,x); &#125;]; [self.navigationController pushViewController:racsub animated:YES];&#125; 在RacSubjectController.h里面声明属性1@property (nonatomic, strong) RACSubject *subject; .m里面进行数据的传递12345-(void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event&#123; if (self.subject) &#123; [self.subject sendNext:@1]; &#125;&#125; 广播12345678910111213141516//发送通知- (void)demo5&#123; NSNotificationCenter *center = [NSNotificationCenter defaultCenter]; //发送广播通知 [center postNotificationName:@&quot;妇女之友&quot; object:nil userInfo:@&#123;@&quot;技巧&quot;:@&quot;用心听&quot;&#125;];&#125;//接收通知NSNotificationCenter *center = [NSNotificationCenter defaultCenter];//RAC的通知不需要我们手动移除//注册广播通知RACSignal *siganl = [center rac_addObserverForName:@&quot;妇女之友&quot; object:nil];//设置接收通知的回调处理[siganl subscribeNext:^(NSNotification *x) &#123; NSLog(@&quot;技巧: %@&quot;,x.userInfo[@&quot;技巧&quot;]);&#125;]; 两个信号串联,两个管串联,一个管处理完自己的东西,下一个管才开始处理自己的东西12345678910111213141516171819202122- (void)demo6&#123; //创建一个信号管A RACSignal *siganlA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;吃饭&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //创建一个信号管B RACSignal *siganlB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;吃的饱饱的,才可以睡觉的&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //串联管A和管B RACSignal *concatSiganl = [siganlA concat:siganlB]; //串联后的接收端处理 ,两个事件,走两次,第一个打印siggnalA的结果,第二次打印siganlB的结果 [concatSiganl subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125; 并联,只要有一个管有东西,就可以打印123456789101112131415161718192021- (void)demo7&#123; //创建信号A RACSignal *siganlA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;纸厂污水&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //创建信号B RACSignal *siganlB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;电镀厂污水&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //并联两个信号,根上面一样,分两次打印 RACSignal *mergeSiganl = [RACSignal merge:@[siganlA,siganlB]]; [mergeSiganl subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125; 组合,只有两个信号都有值,才可以组合1234567891011121314151617181920- (void)demo8&#123; //定义2个自定义信号 RACSubject *letters = [RACSubject subject]; RACSubject *numbers = [RACSubject subject]; //组合信号 [[RACSignal combineLatest:@[letters,numbers] reduce:^(NSString *letter, NSString *number)&#123; return [letter stringByAppendingString:number]; &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;]; //自己控制发生信号值 [letters sendNext:@&quot;A&quot;]; [letters sendNext:@&quot;B&quot;]; [numbers sendNext:@&quot;1&quot;]; //打印B1 [letters sendNext:@&quot;C&quot;];//打印C1 [numbers sendNext:@&quot;2&quot;];//打印C2&#125; 合流压缩12345678910111213141516171819202122- (void)demo9&#123; //创建信号A RACSignal *siganlA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;红&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //创建信号B RACSignal *siganlB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;白&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //合流后处理的是压缩包,需要解压后才能取到里面的值 [[siganlA zipWith:siganlB] subscribeNext:^(id x) &#123; //解压缩 RACTupleUnpack(NSString *stringA, NSString *stringB) = x; NSLog(@&quot;%@ %@&quot;,stringA, stringB); &#125;];&#125; 映射,我可以点石成金12345678910111213141516171819- (void)demo10&#123; RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:nil]; [subscriber sendCompleted]; return nil; &#125;]; //对信号进行改造,改&quot;石&quot;成&quot;金&quot; siganl = [siganl map:^id(NSString *value) &#123; if ([value isEqualToString:@&quot;石&quot;]) &#123; return @&quot;金&quot;; &#125; return value; &#125;]; //打印,不论信号发送的是什么,这一步都会走的 [siganl subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125; 过滤,未满18岁,禁止入内12345678910111213141516171819- (void)demo11&#123; RACSignal *singal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@(15)]; [subscriber sendNext:@(17)]; [subscriber sendNext:@(21)]; [subscriber sendNext:@(14)]; [subscriber sendNext:@(30)]; [subscriber sendCompleted]; return nil; &#125;]; //过滤信号,打印 [[singal filter:^BOOL(NSNumber *value) &#123; //大于18岁的,才可以通过 return value.integerValue &gt;= 18;//return为yes可以通过 &#125;] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125; 秩序(flattenMap 方法也可以换成 then 方法,效果一样)123456789101112131415161718192021222324252627282930313233-(void)demo12&#123; RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;打蛋液&quot;); [subscriber sendNext:@&quot;蛋液&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //对信号进行秩序秩序的第一步 siganl = [siganl flattenMap:^RACStream *(NSString *value) &#123; //处理上一步的RACSiganl的信号value.这里的value=@&quot;蛋液&quot; NSLog(@&quot;把%@倒进锅里面煎&quot;,value); return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;煎蛋&quot;]; [subscriber sendCompleted]; return nil; &#125;]; &#125;]; //对信号进行第二步处理 siganl = [siganl flattenMap:^RACStream *(id value) &#123; NSLog(@&quot;把%@装载盘里&quot;,value); return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;上菜&quot;]; [subscriber sendCompleted]; return nil; &#125;]; &#125;]; //最后打印 最后带有===上菜 [siganl subscribeNext:^(id x) &#123; NSLog(@&quot;====%@&quot;,x); &#125;];&#125; 命令12345678910111213-(void)demo13&#123; RACCommand *command = [[RACCommand alloc] initWithSignalBlock:^RACSignal *(id input) &#123; //打印：今天我投降了 //命令执行代理 NSLog(@&quot;%@我投降了&quot;,input); //返回一个RACSignal信号 return [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; return nil; &#125;]; &#125;]; //执行命令 [command execute:@&quot;今天&quot;];&#125; 延迟12345678910111213- (void)demo14&#123; RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;等等我,我还有10s就到了&quot;); [subscriber sendNext:@&quot;北极&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //延迟10s接受next的玻璃球 [[siganl delay:10] subscribeNext:^(id x) &#123; NSLog(@&quot;我到了%@&quot;,x); &#125;];&#125; 重放123456789101112131415161718- (void)demo15&#123; RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;电影&quot;); [subscriber sendNext:@&quot;电影&quot;]; [subscriber sendCompleted]; return nil; &#125;]; //创建该普通信号的重复信号 RACSignal *replaySiganl = [siganl replay]; //重复接受信号 [replaySiganl subscribeNext:^(NSString *x) &#123; NSLog(@&quot;小米%@&quot;,x); &#125;]; [replaySiganl subscribeNext:^(NSString *x) &#123; NSLog(@&quot;小红%@&quot;,x); &#125;];&#125; 定时—每隔 8 小时服用一次药12345678- (void)demo16&#123; //创建定时器信号.定时8小时 RACSignal *siganl = [RACSignal interval:60 * 60 * 8 onScheduler:[RACScheduler mainThreadScheduler]]; //定时器执行代码 [siganl subscribeNext:^(id x) &#123; NSLog(@&quot;吃药&quot;); &#125;];&#125; 超时12345678910111213141516171819202122- (void)demo17&#123; RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; NSLog(@&quot;我快到了&quot;); RACSignal *sendSiganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:nil]; [subscriber sendCompleted]; return nil; &#125;]; //发生信号要1个小时10分钟才到 [[sendSiganl delay:60 * 70] subscribeNext:^(id x) &#123; //这里才发送next玻璃球到siganl [subscriber sendNext:@&quot;我到了&quot;]; [subscriber sendCompleted]; &#125;]; return nil; &#125;]; [[siganl timeout:60 * 60 onScheduler:[RACScheduler mainThreadScheduler]] subscribeNext:^(id x) &#123; NSLog(@&quot;等了你一个小时,你一直没来,我走了&quot;); &#125;];&#125; 重试12345678910111213141516171819202122- (void)demo18&#123; __block int failedCount = 0; //创建信号 RACSignal *siganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; if (failedCount &lt; 100) &#123; failedCount ++; NSLog(@&quot;我失败了&quot;); [subscriber sendError:nil]; &#125;else&#123; NSLog(@&quot;经历了数百次后,我成功了&quot;); [subscriber sendNext:nil]; &#125; return nil; &#125;]; //重试 RACSignal *retrySiganl = [siganl retry]; //直到发生next的玻璃球 [retrySiganl subscribeNext:^(id x) &#123; NSLog(@&quot;重要成功了&quot;); &#125;];&#125; 节流,不好意思,这里每一秒只能通过一个人,如果 1s 内发生多个,只通过最后一个1234567891011121314151617181920212223242526272829- (void)demo19&#123; RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; //即使发送一个next的玻璃球 [subscriber sendNext:@&quot;A&quot;]; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(1 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@&quot;B&quot;]; &#125;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@&quot;C&quot;]; [subscriber sendNext:@&quot;D&quot;]; [subscriber sendNext:@&quot;E&quot;]; &#125;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@&quot;F&quot;]; &#125;); return nil; &#125;]; //对信号进行节流,限制时间内一次只能通过一个玻璃球 [[signal throttle:1] subscribeNext:^(id x) &#123; NSLog(@&quot;%@通过了&quot;,x); &#125;]; /* [2015-08-16 22:08:45.677]旅客A [2015-08-16 22:08:46.737]旅客B [2015-08-16 22:08:47.822]旅客E [2015-08-16 22:08:48.920]旅客F */&#125; 条件(takeUntil 方法,当给定的 signal 完成前一直取值)1234567891011121314151617181920212223242526- (void)demo20&#123; RACSignal *takeSiganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; //创建一个定时器信号,每一秒触发一次 RACSignal *siganl = [RACSignal interval:1 onScheduler:[RACScheduler mainThreadScheduler]]; [siganl subscribeNext:^(id x) &#123; //在这里定时发送next玻璃球 [subscriber sendNext:@&quot;直到世界尽头&quot;]; &#125;]; return nil; &#125;]; //创建条件信号 RACSignal *conditionSiganl = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; //设置5s后发生complete玻璃球 dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; NSLog(@&quot;世界的今天到了,请下车&quot;); [subscriber sendCompleted]; &#125;); return nil; &#125;]; //设置条件,takeSiganl信号在conditionSignal信号接收完成前,不断取值 [[takeSiganl takeUntil:conditionSiganl] subscribeNext:^(id x) &#123; NSLog(@&quot;%@&quot;,x); &#125;];&#125; RACReplaySubject 使用12345678910111213141516171819202122232425/*** RACReplaySubject创建方法 1.创建RACSubject 2.订阅信号 3.发送信号 工作流程: 1.订阅信号,内部保存了订阅者,和订阅者相应的block 2.当发送信号的,遍历订阅者,调用订阅者的nextBlock 3.发送的信号会保存起来,当订阅者订阅信号的时候,会将之前保存的信号,一个个作用于新的订阅者,保存信号的容量由capacity决定,这也是有别于RACSubject的*/-(void)RACReplaySubject&#123; RACReplaySubject *replaySubject = [RACReplaySubject subject]; [replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot; 1 %@&quot;,x); &#125;]; [replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot;2 %@&quot;,x); &#125;]; [replaySubject sendNext:@7]; [replaySubject subscribeNext:^(id x) &#123; NSLog(@&quot;3 %@&quot;,x); &#125;];&#125; rac_liftSelector:withSignals 使用12345678910111213141516171819//这里的rac_liftSelector:withSignals 就是干这件事的，它的意思是当signalA和signalB都至少sendNext过一次，接下来只要其中任意一个signal有了新的内容，doA:withB这个方法就会自动被触发-(void)test&#123; RACSignal *sigalA = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; double delayInSeconds = 2.0; dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds *NSEC_PER_SEC)); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(popTime * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; [subscriber sendNext:@&quot;A&quot;]; &#125;); return nil; &#125;]; RACSignal *signalB = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@&quot;B&quot;]; [subscriber sendNext:@&quot;Another B&quot;]; [subscriber sendCompleted]; return nil; &#125;]; [self rac_liftSelector:@selector(doA:withB:) withSignals:sigalA,signalB, nil];&#125; 来源：简书作者未魏雨辰 《iOS RAC的使用总结》","categories":[{"name":"Summary","slug":"Summary","permalink":"https://reversescale.github.io/categories/Summary/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"Jenkins + Fastlane 自动打包脚本","slug":"AutoBuildScript","date":"2017-06-20T13:55:38.000Z","updated":"2018-11-17T07:36:42.180Z","comments":true,"path":"2017/06/20/AutoBuildScript/","link":"","permalink":"https://reversescale.github.io/2017/06/20/AutoBuildScript/","excerpt":"使用 Jenkins 运行 Fastlane 命令，实现定时自动打包、修改版本号、上传 Fir 或者 TestFlight 等功能，从此再也不用被小伙伴追着要测试包。 三步配置，杜绝污染，一步操作自动上传~","text":"使用 Jenkins 运行 Fastlane 命令，实现定时自动打包、修改版本号、上传 Fir 或者 TestFlight 等功能，从此再也不用被小伙伴追着要测试包。 三步配置，杜绝污染，一步操作自动上传~ 👨🏻‍💻 Github Demo 📺 故事背景记得大约两年前，当时在创业公司，开发任务重，提测前常常加班到晚上 12 点，就算 bug 修完，也要看着 Xcode 不慌不忙的花半个多小时打包完成，再上传测试平台，发了邮件才能安心回家。鉴于这种惨痛经历，利用闲暇时间就搞一搞自动打包脚本，后期有配上 Jenkins，从此过上了没羞没臊的生活。（已适配 Xcode 8.2 之后版本） 🚀 框架的优势 1.市面上文件最少，使用最便捷的自动化打包脚本 2.冗余方法少，结构清晰，注释齐全 3.同时支持多平台上传，如：Dir、Fir、蒲公英、App Store等 4.具备较高自定义性 5.[自编脚本的时代] -&gt; [Fastlane 的时代] █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🚂 自编脚本的时代 [🚂 自编脚本的时代] 了解一下即可，有些准备工作提供参考，如环境已经配置好，请直接阅读 [🚄 Fastlane 的时代] 第一步 安装fir-cilfir-cli 使用 Ruby 构建, 无需编译, 只要安装相应 gem 即可. 12$ ruby -v # &gt; 1.9.3$ gem install fir-cli 常见的安装问题(1)使用系统自带的 Ruby 安装, 需确保 ruby-dev 已被正确的安装: 12$ xcode-select --install # OS X 系统$ sudo apt-get install ruby-dev # Linux 系统 (2)现 Permission denied 相关错误: 解决：在命令前加上 sudo (3)出现 Gem::RemoteFetcher::FetchError 相关错误: 解决：更换 Ruby 的淘宝源(由于国内网络原因, 你懂的), 并升级下系统自带的 gem12345678$ gem sources --remove https://rubygems.org/$ gem sources -a https://ruby.taobao.org/$ gem sources -l*** CURRENT SOURCES ***https://ruby.taobao.org# 请确保只有 ruby.taobao.org, 如果有其他的源, 请 remove 掉gem update --systemgem install fir-cli (4)Mac OS X 10.11 以后的版本, 由于10.11引入了 rootless, 无法直接安装 fir-cli, 有以下三种解决办法: 方法一： 使用 Homebrew 及 RVM 安装 Ruby, 再安装 fir-cli(推荐)12345# Install Homebrew:$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;# Install RVM:$ \\curl -sSL https://get.rvm.io | bash -s stable --ruby$ gem install fir-cli 方法二： 指定 fir-cli 中 bin 文件的 PATH1$ export PATH=/usr/local/bin:$PATH;gem install -n /usr/local/bin fir-cli 方法三： 重写 Ruby Gem 的 bindir12$ echo &apos;gem: --bindir /usr/local/bin&apos; &gt;&gt; ~/.gemrc$ gem install fir-cli 第二步 登录fir.im 先到 https://fir.im 创建项目，得到 API Token 并复制。 1fir login 命令用于使用 API token 登录 fir.im, 并使用发布应用等相关命令. 1fir me 命令用于查看当前登录用户信息. 显示信息如下：12345678$ fir login XXX_YOUR_API_TOKEN_XXXI, [2016-03-08T12:48:56.499435 #13043] INFO -- : Login succeed, previous user&apos;s email: xxx@fir.imI, [2016-03-08T12:48:56.507044 #13043] INFO -- : Login succeed, current user&apos;s email: xxx@fir.imI, [2016-03-08T12:48:56.507147 #13043] INFO -- :$ fir meI, [2016-03-08T12:48:14.175488 #12986] INFO -- : Login succeed, current user&apos;s email: xxx@fir.imI, [2016-03-08T12:48:14.175687 #12986] INFO -- : Login succeed, current user&apos;s name: xxxI, [2016-03-08T12:48:14.175765 #12986] INFO -- : 第三步 下载并配置 shell 脚本1.把文件夹导入工程目录根目录下 2.配置 shell 脚本 12345678# 需要改动的地方 (根据项目具体信息改动)PROJECT_NAME = &quot;***&quot; #项目名称VERSION = &quot;1.0.0&quot; #打包版本号 会根据不同的版本创建文件夹（与项目本身的版本号无关）TAGREAT_NAME = &quot;***&quot; #项目对应target的名称如 &quot;Meifabao_User&quot; &quot;Miefabao_stylist&quot;CONFIGURATION = &quot;Release&quot; #打包的环境设置 Release 环境 Debug 环境PROFILE = &quot;AdHoc&quot; #配置文件分为四种 AdHoc Dev AppStore Ent 分别对应四种配置文件OUTPUT = &quot;./Packge/%s&quot; %(CONFIGURATION) #打包导出ipa文件路径（请确保 “%s” 之前的文件夹正确并存在） 根据具体项目填写 3.控制台到项目所在目录下，启动脚本(必要时加管理员权限) 可以将 autobuild.py 拖拽到控制台，执行脚本 注：其他的功能脚本由于实用性不高（其实我懒得搞），暂时没有适配，有兴趣的朋友可以自行配置试用，包括：邮件发送、打包 App Store 等等。 当看到 时，打包好的项目已经躺在你的 Fir 测试平台中了。 █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🚄 Fastlane 的时代2018.08.20 更新：Jenkins + Fastlane + GitLab + fir (或者蒲公英) 第一步 安装 FastlaneFastlane 是一套使用Ruby写的自动化工具集，用于iOS和Android的自动化打包、发布等工作，可以节省大量的时间 1sudo gem install fastlane --verbose 第二步 移动脚本至项目目录下根据注释完善脚本配置信息 脚本说明： 支持版本号自增长 支持传入自定的宏，用于在代码里使用此预编译的宏来区分开发环境和发布环境 支持自动上传到 fir 和 testflight 上传成功后弹窗提示 第三步 上传上传到 fir 的用法：1./build.sh -m &quot;xxxx_app_test&quot; -t test 上传到 testflight 的用法：1./build.sh -m &quot;xxxx_app_pro&quot; -t pro 第四步 配置 Jenkins Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。 1）下载 Jenkins： 点击 http://mirrors.jenkins.io/war-stable/latest/jenkins.war 下载最新的Jenkins.war 2）运行服务器： 需要先安装 java sdk （http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html） 1java -jar jenkins.war 3）运行 Jenkins 1jenkins 4）配置 Jenkins： 浏览器打开 http://localhost:8080/ 输入安全密码，安全密码命令行输出的一个文件里面。 然后自动安装推荐的插件，并新建管理员账号密码。 5）安装插件 登录http://localhost:8080/ ，选择系统管理 - 管理插件。在可选插件中选择GitLab Plugin，Gitlab Hook Plugin，和 Cocoapod plugin 进行安装。 6）构建任务 点击新建，输入名称，构建一个自由风格的软件项目。 配置 Git 仓库地址，并添加 git 账号。 配置构建脚本 附录 执行脚本过程中遇到的问题和解决方案 1）fir: command not found 这个是因为没有安装fir-cil，导致找不到相应的命令行，只需要安装一下就行了，详情见上文写的如何安装fir-cil。 2）README: No such file or directory 那是因为你的脚本目录下没有README的文件，只需要建一个README的文件就行了，打开终端，cd到当前位置，然后执行下面的命令： 1touch README 3）ERROR – : Token can not be blank 这个原因是因为你没有登录fir导致的，你执行这个脚本之前应该先登录一下fir，详情请看上文写的登录fir.im。 4）ERROR – : Code=14 (没有试用的设备 Domain=IDEDistributionErrorDomain Code=14 “No applicable devices 原因：rvm ruby 配置错误 解决：控制台 rvm system █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 2018.08.20 更新：Jenkins 相关设置5）查看端口占用 端口占用 使用 lsof 会列举所有占用的端口列表： 1lsof 使用less可以用于分页展示，如： 1lsof | less 也可以使用 -i 查看某个端口是否被占用，如： 1lsof -i:3000 杀死进程 1kill PID（进程的PID，如2044） 6）Jenkins 改时区 http://your-jenkins/systemInfo，查看user.timezone变量的值 在jenkins的【系统管理】-【脚本命令行】里运行 1System.setProperty(&apos;org.apache.commons.jelly.tags.fmt.timeZone&apos;, &apos;Asia/Shanghai&apos;) 7）Jenkins 构建超时 jenkins的”build timeout plugin”插件可以帮我们完成该任务。我使用的是jenkins-2.7.1, 默认就已经安装了该插件，如果默认没有安装可在插件管理中搜索进行安装。 8）Jenkins 定时构建和Poll SCM的区别 Build periodically：周期进行项目构建（源码是否发生变化没有关系） Poll SCM：定时检查源码变更，如果有更新就checkout最新code下来，然后执行构建动作 12345678910111213每15分钟构建一次：H/15 * * * * 或 */5 * * * *每天8点构建一次：0 8 * * *每天8点~17点，两小时构建一次：0 8-17/2 * * *周一到周五，8点~17点，两小时构建一次：0 8-17/2 * * 1-5每月1号、15号各构建一次，除12月：H H 1,15 1-11 **/5 * * * * （每5分钟检查一次源码变化）0 2 * * * （每天2:00 必须build一次源码） █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🕹 agvtool 命令行2018.08.20 更新：管理版本号 常用命令行： 设置 版本号 为 1.1.01xcrun agvtool new-marketing-version 1.1.0 设置 build 号 自动加11xcrun agvtool next-version -all 简介agvtool 是一个命令行工具，允许你自动递增到下一个最高的数量或具体的数字这些数字。 修改Xcode的默认设置默认情况下，在不使用任何版本控制系统。设置版本系统苹果通用确保 Xcode 将包括在你的项目中生成的所有agvtool版本信息。 上图：设置当前项目的版本和版本控制系统的构建设置 设置你的版本号和 bulid 版本号agvtool 查询应用程序的 Info.plist 得到你的版本和 bulid 版本号。 所以确保 CFBundleVersion (Bundle version) 和 CFBundleShortVersionString (Bundle versions string, short）的 key 在你的 Info.plist 中。 上图：info.plist 命令行操作更新版本号退出Xcode，然后导航到包含项目的目录，运行下列命令在终端应用 agvtool 属性工作。 设置 版本号 为 1.1.01xcrun agvtool new-marketing-version 1.1.0 设置 build 号 自动加11xcrun agvtool next-version -all 设置 build 号为 311xcrun agvtool new-version -all 31 查看 Version Numbers1xcrun agvtool what-marketing-version 查看 Build Numbers1xcrun agvtool what-version 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Summary","slug":"Summary","permalink":"https://reversescale.github.io/categories/Summary/"}],"tags":[{"name":"Script","slug":"Script","permalink":"https://reversescale.github.io/tags/Script/"}]},{"title":"使用 CocoaPods 对公有库开源和私有库组件","slug":"Open source library","date":"2017-01-22T13:56:27.000Z","updated":"2018-11-16T13:29:52.512Z","comments":true,"path":"2017/01/22/Open source library/","link":"","permalink":"https://reversescale.github.io/2017/01/22/Open source library/","excerpt":"最近在研究使用 CocoaPods 对 iOS 工程组件化，创建公有 Pod 库和私有 Pod 库方法，为了方便整理和学习就整理了这篇文章~","text":"最近在研究使用 CocoaPods 对 iOS 工程组件化，创建公有 Pod 库和私有 Pod 库方法，为了方便整理和学习就整理了这篇文章~ 创建公有 Pod 库或者私有 Pod 库，实际上原理是一样的，都是基于 git 服务和 repo 协议，不一样的是，两者的版本索引查询方式不一样，公有库的 podspec 由 CocoaPods/Specs 管理，而内部私有使用的 pod 库需要自己建立一个仓库来管理 podspec。 实用：开源公有库例子: 我有封装过一个工具CollectionIndexTools，CollectionIndexTools 可以给 Collection 添加一个类似 TableView 右侧的索引条，我想通过 Podfile 中添加 pod ‘CollectionIndexToolsLib’ 即可使用. 注册 CocoaPods 账户信息想要创建一个开源 pod 库，首先我们需要注册 CocoaPods, 这里使用 trunk 方式，作为一个 iOS 开发人员你一定安装了 CocoaPods，那么只需要在终端执行： 1pod trunk register 邮箱地址 &apos;用户名&apos; --verbose 这里我们一般使用 Github 邮箱和用户名，然后在你的邮箱中会收到确认邮件，在浏览器中点击链接确认即注册成功，成功之后可以终端执行： 1pod trunk me 查看自己的注册信息，以后当你有了自己的开源Pod库，也可以用此方式随时查看自己发布过的Pods： 创建共享库文件并上传到公有仓库共享库需要三个必不可少的部分: 1.共享文件夹(文件夹存放着你要共享的内容, 也就是其他人pod得到的文件, .podspec文件中的source_files需要指定此文件路径及文件类型); 2.LICENSE文件(默认一般选择MIT); 3.库描述文件.podspec(本库的各项信息描述, 需要提交给CocoaPods, pod通过这个文件查找到你共享的库, .podspec文件的格式见第3点). 这一步分两种场景: 场景一：如果你已经有了现成的想要共享的文件,你只需要满足上面三个部分,即可上传到公有仓库即可继续其他的步骤; 场景二：你想要创建一个全新的工程去做自己的共享, 可以使用终端命令: 1pod lib create CollectionIndexToolsLib 需要输入一些模板参数： Cocoapods 会自动生成一个模板项目，目录结构： 123456789101112131415CollectionIndexToolsLib├── Example #demo APP│ ├── CollectionIndexToolsLib│ ├── CollectionIndexToolsLib.xcodeproj│ ├── CollectionIndexToolsLib.xcworkspace│ ├── Podfile #demo APP 的依赖描述文件│ ├── Podfile.lock│ ├── Pods #demo APP 的依赖文件│ └── Tests├── LICENSE #开源协议 默认MIT├── Pod #组件的目录│ ├── Assets #资源文件│ └── Classes #类文件├── PodCollectionIndexToolsLib.podspec #第三步要创建的podspec文件└── README.md #markdown格式的README 编辑.podspec文件以CollectionIndexToolsLib.podspec为例:123456789101112131415161718192021Pod::Spec.new do |s| s.name = 'CollectionIndexToolsLib' s.version = '0.1.0' s.summary = 'Custom IndexTools similar to TableViews index bar' s.description = &lt;&lt;-DESC I believe you must have thought about adding an index like Table View to Collection View. I will give you one today. DESC s.homepage = 'https://github.com/ReverseScale/CollectionIndexToolsLib' s.license = 'MIT' s.author = &#123; 'ReverseScale' =&gt; 'reversescale@icloud.com' &#125; s.source = &#123; :git =&gt; 'https://github.com/ReverseScale/CollectionIndexToolsLib.git', :tag =&gt; s.version.to_s &#125; s.ios.deployment_target = '8.0' s.source_files = 'CollectionIndexToolsLib/Classes/**/*' s.requires_arc = trueend 理论上前面的设置就可以通过验证，下面是注释参照：1234567891011121314151617181920212223242526272829Pod::Spec.new do |s| s.name = \"PodTestLibrary\" #名称 s.version = \"0.1.0\" #版本号 s.summary = \"Just Testing.\" #简短介绍，下面是详细介绍 s.description = &lt;&lt;-DESC Testing Private Podspec. * Markdown format. * Don't worry about the indent, we strip it! DESC s.homepage = \"https://coding.net/u/wtlucky/p/podTestLibrary\" #主页,这里要填写可以访问到的地址，不然验证不通过 # s.screenshots = \"www.example.com/screenshots_1\", \"www.example.com/screenshots_2\" #截图 s.license = 'MIT' #开源协议 s.author = &#123; \"wtlucky\" =&gt; \"wtlucky@foxmail.com\" &#125; #作者信息 s.source = &#123; :git =&gt; \"https://coding.net/wtlucky/podTestLibrary.git\", :tag =&gt; \"0.1.0\" &#125; #项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS # s.social_media_url = 'https://twitter.com/&lt;TWITTER_USERNAME&gt;' #多媒体介绍地址 s.platform = :ios, '7.0' #支持的平台及版本 s.requires_arc = true #是否使用ARC，如果指定具体文件，则具体的问题使用ARC s.source_files = 'Pod/Classes/**/*' #代码源文件地址，**/*表示Classes目录及其子目录下所有文件，如果有多个目录下则用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置 s.resource_bundles = &#123; 'PodTestLibrary' =&gt; ['Pod/Assets/*.png'] &#125; #资源文件地址 s.public_header_files = 'Pod/Classes/**/*.h' #公开头文件地址 s.frameworks = 'UIKit' #所需的framework，多个用逗号隔开 s.dependency 'AFNetworking', '~&gt; 2.3' #依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependencyend 编写完成后, 我们需要验证.podspec文件的合法性, 这里需要终端cd到.podspec文件所在文件夹, 执行:忽视警告：–allow-warnings 1pod lib lint CollectionIndexToolsLib.podspec 如有警告或者错误请重新检查你的编写正确性，如果没有问题会出现： 123-&gt; CollectionIndexToolsLib (0.1.0)CollectionIndexToolsLib passed validation. 打tag, 发布一个release版本一切准备就绪后, 我们需要在你的git仓库里面存在一个与.podspec文件中一致的version, 这里你可以在你的git仓库中的releases一项去手动发布, 也可以在当前文件夹下使用终端命令: 12git tag -m &apos;🔖:Releasing tags.&apos; &apos;0.1.0&apos;git push --tag #推送tag到远端仓库 成功之后即可在你的 releases 里面看到这个 tag 的版本. 发布自己的库描述文件podspec给cocoapods同样在这个文件夹下, 终端执行:忽视警告：–allow-warnings 1pod trunk push CollectionIndexToolsLib.podspec 将你的库文件.podspec文件提交到公有的specs上面, 这一步做的操作是验证你的podspec文件是否合法+提交到specs中(等同于fork;commit;push)+将上传的podspec文件转成json格式文件)，成功后会出现Congrats信息。 成功上传后等待片刻就可以用查找命令找到你的库： 1pod search CollectionIndexToolsLib 日后维护更新开源库如果有错误或者需要迭代版本,修改工程文件后推送到远端仓库后, 需要修改podspec中的版本号, 并重新打tag上传, 再进行新一轮的验证和发布.如果在开发过程中发现某基础组件存在 bug 需要更新 Pod，具体操作步骤如下： 修改 podspec 文件中的 s.version; 修复 bug 并对项目打 tag，tag 名称和 s.version 一直并 push 到远程仓库。 验证 podspec 文件的有效性； 推送 podspec 文件到远程仓库； 执行 pod search RRCache 验证结果； 实用：组件化私有库组件化的实用之处请参考《移动端 iOS 年终工作总结-纯干货请自备酒水》（https://juejin.im/post/5a934dfa6fb9a0634514d8a9） 私有Pod库和公有Pod库的创建方式没有什么区别, 不一样的是管理他们的 spec repo 不一样. 所以我们需要自己创建一个跟CocoaPods/Specs类似的仓库来管理内部创建的Pod库的podspec文件, 供内部人员更新和依赖使用内部Pod组件库. 私有repo的构建形式有两种, 一种是私有git服务器上面创建，一种是本机创建. 本机创建请参考官方文档:Private Pods, 这里介绍的是在公司内部搭建的git服务器上面创建整个服务的方式. 创建一个git仓库用来做内部私有库的Spec Repo在私有服务器一个仓库,一个用来存放所有共享库的podspec, 这里创建好之后的内部SSH协议地址是:https://gitee.com/WhatsXie/LibComponent.git, 花钱买git的私有仓库或者使用其他免费的第三方git服务(如Bitbucket等)创建的私有仓库给到的http/https地址也一样.终端输入命令:1pod repo add LibComponent https://gitee.com/WhatsXie/LibComponent.git 将LibComponent添加到本地repo, 添加成功后可以在/.cocoapods/repos/目录下可以看到官方的specs:master和刚刚加入的specs:LibComponent 如果有其他合作人员共同使用这个私有Spec Repo的话在他有对应Git仓库的权限的前提下执行相同的命令添加这个Spec Repo即可. 创建私有Pod组件库继续创建一个私有仓库,用来建立需要共享的内部组件, 以RSGuidePageLib为例:https://gitee.com/WhatsXie/RSGuidePageLib.git 可以创建示例工程, 像创建公有的库一样, 填写自己的podspec文件 1234567891011121314151617181920212223242526272829Pod::Spec.new do |s|s.name = 'RSGuidePageLib's.version = '0.3.0's.summary = 'Custom guide page package's.description = &lt;&lt;-DESCSwift implementation of the guide page package, support for multiple pictures and video guide pageDESCs.homepage = 'https://gitee.com/WhatsXie/RSGuidePageLib.git's.license = &#123; :type =&gt; 'MIT', :file =&gt; 'LICENSE' &#125;s.author = &#123; 'ReverseScale@icloud.com' =&gt; 'reversescale' &#125;s.source = &#123; :git =&gt; 'https://gitee.com/WhatsXie/RSGuidePageLib.git', :tag =&gt; s.version.to_s &#125;s.ios.deployment_target = '8.0's.swift_version = '3.2's.source_files = 'RSGuidePageLib/Classes/**/*'s.requires_arc = true 值得注意的是:podspec文件中的homepage和source不支持ssh协议地址,所以我们得放入http/https地址. 与公有库的创建方式一样, pod lib lint Category.podspec验证成功之后push到仓库, 然后打tag发布release版本. 然后将podspec加入私有Sepc repo中公有库使用trunk方式将.podspec文件发布到CocoaPods/Specs, 内部的pod组件库则是添加到我们第一步创建的私有Spec repo中去, 在终端执行:–allow-warnings 忽略警告–private 私有库 1pod repo push LibComponent RSGuidePageLib.podspec 添加成功之后LibComponent中会包含RSGuidePageLib库的podspec信息, 可以前往~/.cocoapods/repos下的LibComponent文件夹中查看, 同时git服务器中的远端也更新了. 移除私有Repo 1pod repo remove [name] 查找和使用内部组件库执行pod search Category就能查到刚刚创建好的Category库了, 然后在想要使用此组件的工程的Podfile中加入pod ‘Category’, ‘~&gt;1.0.1’即可使用内部组件啦！ 值得注意的是:必须在Podfile前面需要添加你的私有Spec repo的git地址source, pod install时, 才能在私有repo中查找到私有库, 像这样: 1234567891011# Uncomment the next line to define a global platform for your projectsource &apos;https://github.com/CocoaPods/Specs.git&apos;source &apos;https://gitee.com/WhatsXie/LibComponent.git&apos;# platform :ios, &apos;9.0&apos;target &apos;Demo&apos; dopod &apos;RSGuidePageLib&apos;, &apos;~&gt;0.3.0’end 经过测试, 这种方式可以把你的所有可以拆分出来的组件, 甚至是业务都来使用Pod管理, 这样达到了解耦和单项更新优化。某些组件不影响老版本的依赖使用, 出现问题修改Podfile中的依赖版本即可随时回滚, 给开发了带来极大的便利。 参考链接 CocoaPods创建公有和私有Pod库方法总结（https://www.aliyun.com/jiaocheng/376300.html） CocoaPods Guides(https://guides.cocoapods.org) Private Pods(https://guides.cocoapods.org/making/private-cocoapods.html) 手把手教你发布代码到CocoaPods(Trunk方式)(http://www.cnblogs.com/wengzilin/p/4742530.html) 使用Cocoapods创建私有podspec(http://blog.wtlucky.com/blog/2015/02/26/create-private-podspec/) COCOAPODS创建私有PODS(http://www.cnblogs.com/tufeibo/p/5654268.html) CocoaPods 组件化实践 - 私有Pod(https://www.jianshu.com/p/475d6b6d5600)","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"最简便的方式让你的应用接入 Emoji","slug":"Emoji Keyboard","date":"2016-11-20T03:56:27.000Z","updated":"2018-11-16T13:30:46.211Z","comments":true,"path":"2016/11/20/Emoji Keyboard/","link":"","permalink":"https://reversescale.github.io/2016/11/20/Emoji Keyboard/","excerpt":"不知道从什么时候开始，Emoji 表情无处不在。它们每天被数百万人使用，或喜或悲或猥琐，是一个无与伦比的表达工具~","text":"不知道从什么时候开始，Emoji 表情无处不在。它们每天被数百万人使用，或喜或悲或猥琐，是一个无与伦比的表达工具~ 我们相信，用户不应该被限制在 Unicode 库中，我们构建了这个键盘，以增加所有与我们合作的应用程序的参与度，保留率和收入。 👨🏻‍💻 Github Demo 🤖 要求 iOS 9.0+ &amp; Android Xcode 9.0+ Swift / Objective-C 🚀 准备开始Makemoji 应用内键盘是我们 SDK 的核心。 这是一个动态控制的表情符号键盘与紧密集成的文本输入，由我们的CMS和仪表板支持。 您可以创建自己的类别，上传 emoji / gifs 并沿着 unicode 表情符号跟踪其使用情况。 我们的文本输入的输出是一个简单的 HTML 消息，以及一个纯文本版本和我们所谓的“替代”版本，它使用一个简单的模板系统。 这个输出可以保存在您的设备上，后端或您选择的任何地方。 🎨 测试 UI 什么样子？ 展示页 展示页 展示页 输入前样式 文字键盘样式 表情键盘样式 🎯 安装方法安装在 iOS, 你需要在 Podfile 中添加.1pod &quot;Makemoji-SDK&quot; 如果你使用 Android, 添加在工程 build.gradle 目录下123456789dependencies &#123; compile &apos;com.makemoji:makemoji-sdk-android:0.9.777&apos;&#125; repositories &#123; jcenter() maven &#123; url &quot;https://dl.bintray.com/mm/maven/&quot; &#125;&#125; 设置你的 SDK Key要获得您的SDK密钥，请发送电子邮件至sdk@makemoji.com 要开始使用MakemojiSDK，您将首先设置您的SDK密钥。 iOS 在 AppDelegate 中:1#import &quot;MakemojiSDK.h&quot; 12345- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; // setup your SDK key [MakemojiSDK setSDKKey:@&quot;YOUR-SDK-KEY&quot;]; return YES;&#125; Android 在 AndroidManifest.xml:123&lt;application android:name=&quot;com.makemoji.sbaar.mojilist.App&quot; ... 和 App.java12345public void onCreate()&#123; super.onCreate(); Moji.initialize(this,&quot;YOUR_KEY_HERE&quot;); //Moji.setUserId(&quot;Google ad id here if needed&quot;); // optional custom user id for analytics&#125; 🛠 配置设置假设您有一个应用程序的聊天区域，并且您希望使用我们的键盘来让用户在对话中共享独特的表情符号。 让我们开始设置我们的文本输入对象属性。 1234#import &quot;METextInputView.h&quot;@interface ViewController : UIViewController &lt;METextInputViewDelegate&gt;@property (nonatomic, retain) METextInputView * meTextInputView; METextInputView 是一个容器对象，它包含导航/趋势图栏以及文本输入。 这是为了解决苹果的InputAccessoryView的某些技术限制，尽管这种行为非常相似。 在 viewDidLoad 或 init 视图控制器中，初始化 METextInputView。12self.meTextInputView = [[METextInputView alloc] initWithFrame:CGRectZero];self.meTextInputView.delegate = self; 您需要将自己分配给委托，以侦听事件的回调，如点击发送或照相机按钮和键盘事件。 接下来，我们需要确定我们要在页面上使用什么类型的输入。 浮动输入如果你的应用程序需要一个浮动的 iMessage 类型的文本输入，你可以简单地将 METextInputView 添加到你的视图中。 1[self.view addSubview:self.meTextInputView]; 这个默认模式在键盘之后，随着一个摄像头/发送按钮，并且当用户输入一个长消息时，扩展到全屏。 METextInputView 遵循 ‘firstResponder` 模式来隐藏/显示键盘。 有很多方法可以定制这个输入和导航栏的外观和感觉。 我们将在 Customizations 中介绍 分离的输入如果您需要从键盘分离的文本输入，您将需要调用 detachTextInputView 方法，然后将 textInputContainerView 添加到您的视图。 12[self.meTextInputView detachTextInputView:YES];[self.view addSubview:self.meTextInputView.textInputContainerView]; 由于“发送按钮”和“摄像头”按钮在此模式下处于隐藏状态，因此您需要在 METextInputView 的 sendMessage 方法上附加一个按钮来触发捕获文本。 输入大小变化当使用我们的浮动输入时，您将希望在显示键盘时使用 didChangeFrame 委托回调来调整周围的视图。 123-(void)meTextInputView:(METextInputView *)inputView didChangeFrame:(CGRect)frame &#123; self.tableView.frame = CGRectMake(self.tableView.frame.origin.x, self.tableView.frame.origin.y, self.tableView.frame.size.width, self.meTextInputView.frame.origin.y);&#125; 发送消息Makemoji 消息由三部分组成：一个完全形成的HTML消息，一个ASCII兼容的明文消息和一个 substitute 消息。 你使用哪一个取决于你的消息存储是如何配置的。 替代文本允许您将带有Makemoji表情符号占位符的明文存储为文本的一部分。 这是一个示例消息。 12345&#123; html = &quot;&lt;p dir=\\&quot;auto\\&quot; style=\\&quot;margin-bottom:16px;font-family:&apos;.SF UI Text&apos;;font-size:16px;font-weight:bold;\\&quot;&gt;&lt;span style=\\&quot;color:#000000;\\&quot;&gt;Hey lets play &lt;/span&gt;&lt;img style=\\&quot;vertical-align:middle;width:20px;height:20px;\\&quot; src=\\&quot;https://d1tvcfe0bfyi6u.cloudfront.net/emoji/14-large@2x.png\\&quot; id=\\&quot;14\\&quot; link=\\&quot;\\&quot; name=\\&quot;Pacman\\&quot; /&gt;&lt;span style=\\&quot;color:#000000;\\&quot;&gt; at the &lt;/span&gt;&lt;img style=\\&quot;vertical-align:middle;width:20px;height:20px;\\&quot; src=\\&quot;https://d1tvcfe0bfyi6u.cloudfront.net/emoji/692-large@2x.png\\&quot; id=\\&quot;692\\&quot; name=\\&quot;Arcade\\&quot; link=\\&quot;\\&quot; /&gt;&lt;/p&gt;\\n&quot;; plaintext = &quot;Hey lets play at the \\n&quot;; substitute = &quot;Hey lets play [Pacman.E] at the [Arcade.BA]&quot;;&#125; 当用户点击 ‘sendButton时，didTapSend` 委托回调被触发，并返回一个包含html，plaintext和substitute消息的字符串的NSDictionary。 12345-(void)meTextInputView:(METextInputView *)inputView didTapSend:(NSDictionary *)message &#123; // send message to your backend here [self.messages addObject:message]; [self.tableView reloadData];&#125; 然后，您可以将选择的部分发送到后端以存储消息。 显示消息现在你已经有Makemoji消息了，我们需要设置一个显示它们的方法。 通常这将在 UITableViewCell 中，但您也可以使用任何自定义视图来显示消息。 我们已经包括一个优化的UITableViewCells用于显示HTML消息和一种方法来自动缓存你的表单元格高度。 这可以防止任何不必要的表情符号和文本布局，并提高性能。 这里是我们提供的信息显示的概述。 MESimpleTableViewCell这个单元格提供了一个基本的布局，默认情况下尝试使用整个单元格区域。 您将使用此单元格作为子类快速实现自定义表格单元格。 MEChatTableViewCell聊天单元提供一个iMessage，如聊天泡泡，间距，可设定的方向和颜色设置。 MECollectionViewCell简单表格单元格的集合视图版本。 MEMessageView单元的底层视图，消息的核心显示视图。 替代文字使用 substitute 类型的消息时，可以通过在 METextInputView 上使用下面的静态方法将其转换回HTML 1+(NSString *)convertSubstituedToHTML:(NSString *)substitute withFontName:(NSString *)fontName pointSize:(CGFloat)pointSize textColor:(UIColor *)color 高度缓存使用 cellHeightForHTML 方法获取消息的行高。 此方法缓存单元高度以提高性能。 123456789101112// determine row height with HTML- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; if (self.meTextInputView == nil) &#123; return 0; &#125; NSDictionary * message = [self.messages objectAtIndex:indexPath.row]; return [self.meTextInputView cellHeightForHTML:[message objectForKey:@&quot;html&quot;] atIndexPath:indexPath maxCellWidth:self.tableView.frame.size.width cellStyle:MECellStyleChat];&#125; 您可以通过重置 METextInputView 上的 cachedHeights 属性来手动重置 UITableViewCell 高度缓存。 表格单元格使用MEChatTableViewCell，您可以使用setCellDisplay在左侧或右侧显示聊天气泡。 这应该发生在为每个消息设置您的HTML之前。 12345678910111213141516171819202122- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; static NSString *CellIdentifier = @&quot;Cell&quot;; MEChatTableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier]; if (cell == nil) &#123; cell = [[MEChatTableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier]; &#125; // display chat cell on right side [cell setCellDisplay:MECellDisplayRight]; // display chat cell on left side if (indexPath.row % 2) &#123; [cell setCellDisplay:MECellDisplayLeft]; &#125; NSDictionary * message = [self.messages objectAtIndex:indexPath.row]; [cell setHTMLString:[message objectForKey:@&quot;html&quot;]]; return cell; &#125; Hypermoji - 带有URL的表情符号我们已经创建了一种新的方式来共享内容，浏览网页，观看视频或听音乐，而不用离开Hypermoji的应用程序。 要在Hypermoji（具有URL链接的表情符号）上点击时显示网页，请使用 didTapHypermoji 委托回调 1234// handle tapping of links (Hypermoji)-(void)meTextInputView:(METextInputView *)inputView didTapHypermoji:(NSString*)urlString &#123; // open webview here&#125; 相机按钮这是一个标准的UIButton，可以用图像或文本进行自定义。 要处理相机按钮的操作，请使用didTapCameraButton委托回调。 123-(void)meTextInputView:(METextInputView *)inputView didTapCameraButton:(UIButton*)cameraButton &#123; // Present image controller&#125; 自定义您可以通过在 METextInputView 上设置 displayCameraButton 属性来显示或隐藏内置摄像头 1self.meTextInputView.displayCameraButton = NO; 您可以通过在 METextInputView 上设置 displaySendButton 属性来显示或隐藏内置的发送按钮 1self.meTextInputView.displaySendButton = NO; 使用setFont你可以设置你的文本输入的默认字体。 1[self.meTextInputView setFont:[UIFont systemFontOfSize:20]]; 更改占位符文本的颜色 1self.meTextInputView.placeholderLabel.textColor = [UIColor darkGrayColor]; 控制锁定的类别您将需要侦听NSNotification MECategorySelectedLockedCategory 来确定什么时候锁定了一个类别。 要解锁一个类别，您需要调用 [MakemojiSDK unlockCategory：@“category”] 您可以收听 ‘MECategoryUnlockedSuccessNotification和MECategoryUnlockedFailedNotification` 以确定解锁呼叫是否成功。 📝 应用程序提交Makemoji SDK 使用IDFA跟踪ID来为您的应用程序中的视图，共享和点击进行归因。 将应用程序提交到 App Store 时，您需要检查“将此应用程序安装到以前投放的广告”选项。 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Project","slug":"Project","permalink":"https://reversescale.github.io/categories/Project/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"https://reversescale.github.io/tags/iOS/"}]},{"title":"iOS 开发中常用的设计模式","slug":"Design patterns iOS","date":"2016-09-21T06:56:27.000Z","updated":"2018-11-16T13:25:33.846Z","comments":true,"path":"2016/09/21/Design patterns iOS/","link":"","permalink":"https://reversescale.github.io/2016/09/21/Design patterns iOS/","excerpt":"之前有朋友问到设计模式，便特意找了一篇文章，专门介绍在 iOS 开发中，对设计模式的具体应用，同时推荐一本书《Head First设计模式》~","text":"之前有朋友问到设计模式，便特意找了一篇文章，专门介绍在 iOS 开发中，对设计模式的具体应用，同时推荐一本书《Head First设计模式》~ （一）代理模式应用场景：当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。优势：解耦合敏捷原则：开放-封闭原则实例：tableview的 数据源delegate，通过和protocol的配合，完成委托诉求。列表row个数delegate自定义的delegate （二）观察者模式应用场景：一般为model层对，controller和view进行的通知方式，不关心谁去接收，只负责发布信息。优势：解耦合敏捷原则：接口隔离原则，开放-封闭原则实例：Notification通知中心，注册通知中心，任何位置可以发送消息，注册观察者的对象可以接收。kvo，键值对改变通知的观察者，平时基本没用过。 （三）MVC模式应用场景：是一中非常古老的设计模式，通过数据模型，控制器逻辑，视图展示将应用程序进行逻辑划分。优势：使系统，层次清晰，职责分明，易于维护敏捷原则：对扩展开放-对修改封闭实例：model-即数据模型，view-视图展示，controller进行UI展现和数据交互的逻辑控制。 （四）单例模式应用场景：确保程序运行期某个类，只有一份实例，用于进行资源共享控制。优势：使用简单，延时求值，易于跨模块敏捷原则：单一职责原则实例：[UIApplication sharedApplication]。注意事项：确保使用者只能通过 getInstance方法才能获得，单例类的唯一实例。java，C++中使其没有公有构造函数，私有化并覆盖其构造函数。object c中，重写allocWithZone方法，保证即使用户用 alloc方法直接创建单例类的实例，返回的也只是此单例类的唯一静态变量。 （五）策略模式应用场景：定义算法族，封装起来，使他们之间可以相互替换。优势：使算法的变化独立于使用算法的用户敏捷原则：接口隔离原则；多用组合，少用继承；针对接口编程，而非实现。实例：排序算法，NSArray的sortedArrayUsingSelector；经典的鸭子会叫，会飞案例。注意事项：1，剥离类中易于变化的行为，通过组合的方式嵌入抽象基类2，变化的行为抽象基类为，所有可变变化的父类3，用户类的最终实例，通过注入行为实例的方式，设定易变行为防止了继承行为方式，导致无关行为污染子类。完成了策略封装和可替换性。 （六）工厂模式应用场景：工厂方式创建类的实例，多与proxy模式配合，创建可替换代理类。优势：易于替换，面向抽象编程，application只与抽象工厂和易变类的共性抽象类发生调用关系。敏捷原则：DIP依赖倒置原则实例：项目部署环境中依赖多个不同类型的数据库时，需要使用工厂配合proxy完成易用性替换注意事项：项目初期，软件结构和需求都没有稳定下来时，不建议使用此模式，因为其劣势也很明显，增加了代码的复杂度，增加了调用层次，增加了内存负担。所以要注意防止模式的滥用。 设计模式六大原则1、开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle）为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle）原则是尽量使用合成/聚合的方式，而不是使用继承。 《Head First设计模式》http://pan.baidu.com/s/1nvTqSdj 验证码：DG58","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"https://reversescale.github.io/categories/Design-Patterns/"}],"tags":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/tags/Book/"}]},{"title":"GoF 设计模式 + 情景再现","slug":"Design patterns Gof","date":"2016-03-01T12:29:16.000Z","updated":"2018-11-16T13:25:39.532Z","comments":true,"path":"2016/03/01/Design patterns Gof/","link":"","permalink":"https://reversescale.github.io/2016/03/01/Design patterns Gof/","excerpt":"《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995），这几位作者常被称为”四人组（Gang of Four）”~","text":"《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995），这几位作者常被称为”四人组（Gang of Four）”~ 设计模式和情景再现创建型模式1、ABSTRACT FACTORY—追MM少不了请吃饭了，麦当劳的套餐和肯德基的套餐都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说“两个B套餐”就行了。麦当劳和肯德基就是B套餐的Abstract Factory, B套餐里含有汉堡, 鸡翅和饮料. 麦当劳或肯德基会根据B套餐的规格, 让汉堡Factory, 鸡翅Factory, 饮料Factory分别生产对应B套餐的材料。抽象工厂模式：客户类和工厂类分开。消费者任何时候需要某套产品集合时，只需向抽象工厂请求即可。抽象工厂会再向具体的工厂生产出符合产品集规格的产品。 2、BUILDER—MM最爱听的就是“我爱你”这句话了，见到不同地方的MM,要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出“我爱你”这句话了，国外的MM也可以轻松搞掂，这就是我的“我爱你”builder。（这一定比美军在伊拉克用的翻译机好卖）建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。 3、FACTORY METHOD—请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说“要一个汉堡”，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。 4、PROTOTYPE—跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype了。（100块钱一份，你要不要）原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。 5、SINGLETON—俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Singleton，她们只要说道“老公”，都是指的同一个人，那就是我。(刚才做了个梦啦，哪有这么好的事)单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。 结构型模式6、ADAPTER—在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的Adapter，让我和Sarah可以相互交谈了(也不知道他会不会耍我)适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。 7、BRIDGE—早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我“早上碰到MM新做了个发型怎么说”这种问题，自己用BRIDGE组合一下不就行了。桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。 8、COMPOSITE—Mary今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM都会用Composite模式了，你会了没有？合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。 9、DECORATOR—Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上“最好的的礼物，就是爱你的Fita”，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来……，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。 10、FACADE—我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。 11、FLYWEIGHT—每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。享元模式：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。 12、PROXY—跟MM在网上聊天，一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。 行为模式13、CHAIN OF RESPONSIBILITY—晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi,可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了，听说是个老处女呀，快跑!责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。 14、COMMAND—俺有一个MM家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送COMMAND，就数你最小气，才请我吃面。” :-(命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。 15、INTERPRETER—俺有一个《泡MM真经》，上面有各种泡MM的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟MM约会时，只要做一个Interpreter，照着上面的脚本执行就可以了。解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。 16、ITERATOR—我爱上了Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件”我：“什么条件我都答应，你说吧”Mary：“我看上了那个一克拉的钻石”我：“我买，我买，还有吗？”Mary：“我看上了湖边的那栋别墅”我：“我买，我买，还有吗？”……迭代子模式：迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。 17、MEDIATOR—四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。 18、MEMENTO—同时跟几个MM聊天时，一定要记清楚刚才跟MM说了些什么话，不然MM发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个MM说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。 19、OBSERVER—想知道咱们公司最新MM情报吗？加入公司的MM情报邮件组就行了，tom负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦观察者模式：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。 20、STATE—跟MM交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的MM就会说“有事情啦”，对你不讨厌但还没喜欢上的MM就会说“好啊，不过可以带上我同事么？”，已经喜欢上你的MM就会说“几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把MM的状态从不讨厌不喜欢变成喜欢哦。状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。 21、STRATEGY—跟不同类型的MM约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到MM的芳心，我的追MM锦囊中有好多Strategy哦。策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模式把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。 22、TEMPLATE METHOD——看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤(Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦(具体实现)；模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。 23、VISITOR—情人节到了，要给每个MM送一束鲜花和一张卡片，可是每个MM送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下Visitor，让花店老板根据MM的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。 设计模式之间的关系图： 设计模式的六大原则1、开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle）为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle）原则是尽量使用合成/聚合的方式，而不是使用继承。","categories":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"https://reversescale.github.io/categories/Design-Patterns/"}],"tags":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/tags/Book/"}]}]}