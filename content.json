{"meta":{"title":"Technology","subtitle":"","description":"","author":"Steven's Blog","url":"https://reversescale.github.io"},"pages":[{"title":"Not found","date":"2018-11-15T12:15:47.151Z","updated":"2018-11-15T02:35:05.000Z","comments":true,"path":"404.html","permalink":"https://reversescale.github.io/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#fff;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#000;margin-top:260px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=5; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2018-01-25T14:41:06.000Z","comments":true,"path":"archives/index.html","permalink":"https://reversescale.github.io/archives/index.html","excerpt":"","text":""},{"title":"About","date":"2015-08-16T06:58:08.000Z","updated":"2018-11-15T09:08:24.000Z","comments":false,"path":"about/index.html","permalink":"https://reversescale.github.io/about/index.html","excerpt":"","text":"👨🏻‍💻 职业：程序员劝退师Excellence is a continuous process and not an accident. Thanks for reading! ~ 📟 WeChat：WhatsXie🤪 不只生产 bug 更是 bug 的搬运工📮 邮件：ReverseScale@iCloud.com🤖 Github：https://github.com/ReverseScale 博客新装修，历史文章正在路上…"},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2018-01-25T14:41:06.000Z","comments":false,"path":"categories/index.html","permalink":"https://reversescale.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2018-01-25T14:41:06.000Z","comments":true,"path":"tags/index.html","permalink":"https://reversescale.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"使用 ngrok 快速实现内网穿透","slug":"Ngrok through","date":"2018-08-13T03:56:27.000Z","updated":"2018-11-15T09:22:35.000Z","comments":true,"path":"2018/08/13/Ngrok through/","link":"","permalink":"https://reversescale.github.io/2018/08/13/Ngrok through/","excerpt":"重点是使用简便、简便、简便","text":"重点是使用简便、简便、简便 Ngrok是什么官方的解释是能够让你本地网页快速通过代理被外界访问的一个极为方便的工具，不用搭建服务器等等麻烦的工序，适合前段开发过程中，快速评估检测项目。 而我用来在家里快速访问 Jenkins，偷个懒🤪 搭建方法由于要完成一个网页优化的作业找了很久ngrok的使用方法，都不够简便易行最后终于发现了一个好方法。 下载 MAC 版的 ngrok：https://ngrok.com/download 解压到指定目录：Safari 浏览器下载 Mac OS X 环境一般直接解压（反正我是自动解压的），将 ngrok 放进项目目录。 进入到 ngrok 所在路径：1cd /tmp 开启服务1./ngrok http localhost:8080 会出现如下 ngrok 控制台 等待 Session Status 状态为 online（变绿），就可以在外网通过 Forwarding 的地址进行连接了。 注意：Forwarding地址中的 c33faf1b 不是固定的，在每次开始 ngrok 服务的时候都会变更，想固定？ ngrok:😛要钱。 测试一下例如： ngrok 穿透前在局域网中访问地址：http://localhost:8080 ngrok 穿透后局域网 + 公网访问地址：https://c33faf1b.ngrok.io","categories":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/categories/Tips/"}],"tags":[{"name":"Tips","slug":"Tips","permalink":"https://reversescale.github.io/tags/Tips/"}]},{"title":"如何用 Swift 打造你的第一个区块链 App","slug":"How to build DApp","date":"2018-07-06T14:51:21.000Z","updated":"2018-11-14T15:17:05.000Z","comments":true,"path":"2018/07/06/How to build DApp/","link":"","permalink":"https://reversescale.github.io/2018/07/06/How to build DApp/","excerpt":"区块链(Blockchain) 是一种突破性技术(Disruptive Technologies)，近年渐获关注。为什么呢？","text":"区块链(Blockchain) 是一种突破性技术(Disruptive Technologies)，近年渐获关注。为什么呢？ 因为区块链是许多加密货币(Cryptocurrencies) 如比特币(Bitcoin)、以太坊(Ethereum)、莱特币(Litecoin) 的创始技术。那区块链是如何运作的呢？在本次的教学里，我将会谈到所有关于区块链技术的知识，以及如何用Swift 来制作自己的「区块链」。那么，让我们开始吧！ 区块链的运作顾名思义，区块链就是一个由不同的区块串连在一起的「链」，每个区块包含三则资讯：资料(Data)、杂凑值(Hash)、和前一个区块的杂凑值。 资料 ──依据使用情境，储存在区块的资料会因区块链的类型而不同。例如，在比特币区块链中，储存资料就是与交易有关的资讯，即是转帐的金额、以及参与交易二人的资讯。 杂凑值 ──你可以把杂凑想成是一种数位指纹，它是用来识别一个区块及其资料。杂凑最重要的地方，就是它是一个独一无二的字母数字(Alphanumeric)程式码，通常会由64个字元组成。当一个区块被创造时，杂凑值也同时产生。当一个区块被更动时，杂凑值也会同时被更动。透过这种方式，当你想要查看区块上的任何变动时，杂凑值就非常重要。 前一个区块的杂凑值 ──每个区块就是藉由储存前个区块的杂凑来链结在一起，组成一个区块链！这就是让区块链如此安全的原因。看看这张图片： 如你所见，每个区块由资料（未显示）、杂凑值、和前一个区块杂凑值所组成。举个例子，黄色区块包含了自己的杂凑值H7S6、和红色区块的杂凑值8SD9。以这种方式，它们组成了一个链结，并以此连结在一起。现在，假设有个骇客入侵并尝试更动红色区块。请记住，每次一个区块以任何方式被更动时，区块的杂值凑也会被更动！因此，当下一个区块执行确认、并看到前一个区块的杂凑值并不吻合时，它会有效地将自己从「链」中分离出来，而不会被骇客读取。 这就是区块练会如此安全的原因，你几乎不可能尝试回溯并更改任何资料。杂凑值提供了不错的保密及隐私，但还有两个安全机制来让区块链更加安全：验证(Proof-of-work)及智慧合约(Smart Contract)。虽然我不会详述，但你可以在这里了解更多。区块链最后一个保全方式就是基于它的位置。与大多储存在伺服器或是资料库内的资料不同，区块链使用点对点网路(Peer-To-Peer, P2P)，它是一种网路型态，允许任何人加入并将该网路上的资料分发给每位接收者。每当有人加入这个网路时，他们就会得到区块链的完整拷贝；每当有人建立一个新区块时，就会传送到网路内的所有人。然后，透过一些复杂的程式，让节点(Node)在加入这个区块到区块链之前，先确认该区块有否被窜改。就这样，任何地方的任何人都可以取得这些资讯。如果你是HBO矽谷群瞎传(Silicon Valley)的忠实粉丝，这听起来可能有点熟悉，因为在这出美剧里，主角就是用了类似的技术来建立一个全新网路。 因为每个人或节点都有一份区块链的拷贝，他们可以有共识并确认哪些区块是合法的。因此，如果你想要骇入一个区块，你必须骇入网路上超过50% 的区块来通过你的资讯。这就是为什么区块链或许是过去十年以来最安全的技术之一。 关于范例应用现在你了解区块链是如何运作了，那么开始来制作我们的范例App吧！请先下载初始项目。（https://raw.githubusercontent.com/appcoda/BlockchainDemo/master/BlockchainStarter.zip） 如你所见，我们有两个比特币钱包。第一个帐号Account 1065 拥有500 BTC，而第二个帐号0217 则什么都没有。我们利用传送按钮来传送比特币到其他帐号。为了赚取BTC，我们按下Mine 按钮就可以获得50 BTC 为奖励。基本来说，我们做的是当App 执行时，利用控制台来观察两个比特币帐号间的交易情况。 你会注意到，侧边栏里有两个重要的类别：Block及Blockchain。打开这些档案，你会看到档案是空的，那是因为我将会引导你写出这些类别的逻辑。那我们开始吧！ 在Swift 定义Block前往Block.swift并添加程式码以定义一个区块。首先，让我们了解一下区块是什么。我们先前定义了一个区块由三个部分组成：杂凑值、记录的实际资料、以及前一个区块的杂凑值。当我们想建立自己的区块链时，必须要知道区块的排序，这一点可以很容易地在Swift中定义。添加以下程式码到类别里： 1234var hash: String!var data: String!var previousHash: String!var index: Int! 现在，我们需要添加最后一个重要的程式码。我之前提到每次一个区块被更动，杂凑就会改变；这就是区块链如此安全的特色之一。所以我们必须建立一个函式来产生一个随机字母数字的杂凑。这个函式只需要几行程式码： 123func generateHash() -&gt; String &#123; return NSUUID().uuidString.replacingOccurrences(of: \"-\", with: \"\")&#125; NSUUID是一个物件，代表桥接UUID的通用唯一值。它内置于Swift中，而且非常适合用来产生32字元的字串。这个函式产生一个UUID，消除所有连字符(-)，然后回传String，即区块的杂凑。Block.swift现在应该看起来像这样： 我们已经定义了Block类别，接着让我们定义Blockchain类别吧。切换到Blockchain.swift。 在Swift 定义Blockchain如前文所说，让我们尝试从基本面来了解区块链。在基本的术语里，区块链只是区块串在一起组成的链；换句话说，它是一个包含所有项目的列表。听起来是不是有点熟悉呢？因为这就是阵列的定义，而这个阵列就是由区块所组成！让我们把下列的程式码加进去吧： 1var chain = [Block]() 小提示：这几乎可以应用在电脑科学世界的所有事上。如果你曾遇过大问题，试着将它拆解成小组件，然后以自己的方法来解决问题；就像我们弄清楚如何在Swift中加入区块及区块链一样！ 你会注意到在阵列里面包含了先前定义的Block类别，那是我们在区块链中需要的所有变数。加入两个函式到类别里，我们就完成了。试着用我前文所教的来回答这个问题： 在一个区块链中，两个主要的函式是什么？ 希望你能够回答这个问题！这两个区块链拥有的主要函式，是用来建立初始区块，以及在后面新增新的区块。当然，现在我不会下放这个链并加入智慧合约，但是这些是基本函式！加入以下程式码到Blockchain.swift： 1234567891011121314151617func createGenesisBlock(data:String) &#123; let genesisBlock = Block() genesisBlock.hash = genesisBlock.generateHash() genesisBlock.data = data genesisBlock.previousHash = \"0000\" genesisBlock.index = 0 chain.append(genesisBlock)&#125; func createBlock(data:String) &#123; let newBlock = Block() newBlock.hash = newBlock.generateHash() newBlock.data = data newBlock.previousHash = chain[chain.count-1].hash newBlock.index = chain.count chain.append(newBlock)&#125; 我们加入的第一个函式是用来建立初始区块。为此，我们建立了一个函式来把区块的资料作为Input。然后，我们定义一个名为genesisBlock的变数，并将它设为Block型别。因为它是Block型别，所以它有我们之前在Block.swift定义的所有变数及函式。我们设定generateHash()为杂凑、 Input data为资料。因为这是第一个区块，所以我们将前一个区块的杂凑设定为000，好让我们知道这是初始区块。我们将它的索引值设为0 ，然后放到区块链chain。 我们建立的下一个函式则适用于所有genesisBlock后的区块，而它会建立剩下的所有区块。你会注意到它跟之前的函式非常相似，唯一的不同的是我们将previousHash设定为前一个区块的杂凑，并将index设为它在区块练的位置。完成了！我们已经成功定义自己的Blockchain！你的程式码应该如下图所示！ 接着，我们将所有的部分连接到ViewController.swift档案，并看看执行成果吧！ 钱包后台(Wallet Backend)切换到ViewController.swift，我们可以看到所有的UI元件都已经连结完毕。我们所需要做的就是处理交易，并将交易列印到控制台上。然而在开始之前，我们应该稍微探讨一下比特币区块链。比特币来自一个总帐号，假设这个帐号的编号是000。当你挖掘一颗比特币时，就表示你解答了数学问题，并获得一定数量的比特币作为奖励。这是发行货币一个很聪明的方法，同时也创造了让更多人去挖掘的动机。在我们的App 里，我们将100 BTC 作为奖励。首先，让我们在ViewController 添加需要的变数： 123456let firstAccount = 1065let secondAccount = 0217let bitcoinChain = Blockchain()let reward = 100var accounts: [String: Int] = [\"0000\": 10000000]let invalidAlert = UIAlertController(title: \"Invalid Transaction\", message: \"Please check the details of your transaction as we were unable to process this.\", preferredStyle: .alert) 我们定义两个帐号：一个编号为1065，另一个编号为0217。我们同时新增一个bitcoinChain变数来作为我们的区块链，并将reward设定为100。我们需要一个作为比特币来源的主帐号：这是我们的初始帐号，编号为0000，它拥有一千万个比特币。你可以把这个帐号当成银行，在每一次的奖励中，就会从中取出100个比特币，并转至合法的帐号里。我们也定义一个警告，在每次交易无法完成时显示。 现在，让我们来写些将会执行的泛用函式。你可以猜到这些函式是什么吗？ 第一个函式是用来处理交易的。我们要确认传送者及接收者的帐号中，接收或扣除的金额是正确的，而且这个资讯会被记录在我们的区块链上。 下一个函式是要在控制台里印出完整的纪录，它会显示每个区块及每个区块内的资料。 最后一个函式是用来验证区块链是否合法，方法为确认前个区块的杂凑是否符合下一个区块的资讯。因为我们不会示范任何骇客方法，所以范例中的链永远都是合法的。 Transaction 函式以下是我们的泛用交易函式。在定义变数之下输入以下程式码： 1234567891011121314151617181920212223242526func transaction(from: String, to: String, amount: Int, type: String) &#123; // 1 if accounts[from] == nil &#123; self.present(invalidAlert, animated: true, completion: nil) return &#125; else if accounts[from]!-amount &lt; 0 &#123; self.present(invalidAlert, animated: true, completion: nil) return &#125; else &#123; accounts.updateValue(accounts[from]!-amount, forKey: from) &#125; // 2 if accounts[to] == nil &#123; accounts.updateValue(amount, forKey: to) &#125; else &#123; accounts.updateValue(accounts[to]!+amount, forKey: to) &#125; // 3 if type == \"genesis\" &#123; bitcoinChain.createGenesisBlock(data: \"From: \\(from); To: \\(to); Amount: \\(amount)BTC\") &#125; else if type == \"normal\" &#123; bitcoinChain.createBlock(data: \"From: \\(from); To: \\(to); Amount: \\(amount)BTC\") &#125;&#125; 看起来程式码很多，但是它的核心只是为每次的交易定义一些规则。在开头的地方，我们有四个参数：to、from、amount以及type。To、From、及Amount的含义一目了然，而Type基本上就是定义交易的类型。这里有两种Type：Normal和Genesis。一个Normal的交易类型会是在帐号1065与0217之间进行，而Genesis交易类型则会涉及到帐号0000。 第一个if-else条件式是关于来源帐号。如果来源帐号不存在或金额不足，我们会显示交易无效的警告，然后结束函式。而如果通过的话，我们会更新数值。 第二个if-else条件式是关于接收帐号。如果接收帐号不存在，那么我们随它而去，然后结束函式。要不然，我们就会传送正确的比特币数量到帐号。 第三个if-else条件式处理交易的类型。如果一个交易涉及初始区块，我们就建立一个新的初始区块；反之我们建立一个新区块来储存资料。 Printing 函式在每次交易的最后，我们想要看到一个清单列出所有交易，来确保我们知道所有发生的事情。以下是我们在transaction函式下输入的程式码： 123456789func chainState() &#123; for i in 0...bitcoinChain.chain.count-1 &#123; print(\"\\tBlock: \\(bitcoinChain.chain[i].index!)\\n\\tHash: \\(bitcoinChain.chain[i].hash!)\\n\\tPreviousHash: \\(bitcoinChain.chain[i].previousHash!)\\n\\tData: \\(bitcoinChain.chain[i].data!)\") &#125; redLabel.text = \"Balance: \\(accounts[String(describing: firstAccount)]!) BTC\" blueLabel.text = \"Balance: \\(accounts[String(describing: secondAccount)]!) BTC\" print(accounts) print(chainValidity())&#125; 这是一个简单的for回圈，包含bitcoinChain的每个区块。我们印出区块的编号、杂凑值、前个区块的杂凑、以及储存的资料，再更新UILabel来显示每个帐号内正确的BTC数目。最后，印出一个列出每个帐号的清单（应该会有三个），并验证链的合法性。现在，你应该会在函式最后一行中发生错误。这是因为我们还没定义chainValidity()函式，那么就来开始吧！ Validity 函式记住，如果前一个区块的杂凑值符合目前区块所描述的内容，那么这一个链就是合法的。我们可以轻易地用另一个for 回圈来重复验证每个区块。 123456789func chainValidity() -&gt; String &#123; var isChainValid = true for i in 1...bitcoinChain.chain.count-1 &#123; if bitcoinChain.chain[i].previousHash != bitcoinChain.chain[i-1].hash &#123; isChainValid = false &#125; &#125; return \"Chain is valid: \\(isChainValid)\\n\"&#125; 跟之前有点相似，我们在bitcoinChain中重复验证每个区块，来确认前一个区块的杂凑值是否与目前区块所描述的内容符合。这样就完成了！我们已经定义了函式，并将会每次都用到它们！你的ViewController.swift现在应该看起来像这样： 现在我们只需要将按钮连接到函式就完成了，来开始最后的篇章吧！ 将所有东西连结在一起当我们的App首次启动时，我们想让初始帐号0000传送50 BTC到我们的第一个帐号。然后，我们将让第一个帐号传送10 BTC到第二个帐号。这个步骤仅需三行程式码就可以完成。如此更改你的viewDidLoad函式： 1234567override func viewDidLoad() &#123; super.viewDidLoad() transaction(from: \"0000\", to: \"\\(firstAccount)\", amount: 50, type: \"genesis\") transaction(from: \"\\(firstAccount)\", to: \"\\(secondAccount)\", amount: 10, type: \"normal\") chainState() self.invalidAlert.addAction(UIAlertAction(title: \"OK\", style: .default, handler: nil))&#125; 我们使用先前定义好的函式，并在最后呼叫chainState()。同时，我们新增一个OK按钮到交易无效的警告中。现在让我们来看看剩下的四个函式里要加入什么：redMine()、blueMine()、redSend()及blueSend()。 挖矿函式挖矿函式非常地简单，只要三行程式码就行了。这就是我们要添加的程式码： 1234567891011@IBAction func redMine(_ sender: Any) &#123; transaction(from: \"0000\", to: \"\\(firstAccount)\", amount: 100, type: \"normal\") print(\"New block mined by: \\(firstAccount)\") chainState()&#125; @IBAction func blueMine(_ sender: Any) &#123; transaction(from: \"0000\", to: \"\\(secondAccount)\", amount: 100, type: \"normal\") print(\"New block mined by: \\(secondAccount)\") chainState()&#125; 在第一个挖矿函式中，我们使用transaction函式从初始帐号传送100 BTC到第一个帐号，先印出一个区块被挖出，再印出chainState。同样地，我们在blueMine函式里将100 BTC传送到第二个帐号。 传送函式传送函式与先前的函式也稍微相似。 123456789101112131415161718192021@IBAction func redSend(_ sender: Any) &#123; if redAmount.text == \"\" &#123; present(invalidAlert, animated: true, completion: nil) &#125; else &#123; transaction(from: \"\\(firstAccount)\", to: \"\\(secondAccount)\", amount: Int(redAmount.text!)!, type: \"normal\") print(\"\\(redAmount.text!) BTC sent from \\(firstAccount) to \\(secondAccount)\") chainState() redAmount.text = \"\" &#125;&#125; @IBAction func blueSend(_ sender: Any) &#123; if blueAmount.text == \"\" &#123; present(invalidAlert, animated: true, completion: nil) &#125; else &#123; transaction(from: \"\\(secondAccount)\", to: \"\\(firstAccount)\", amount: Int(blueAmount.text!)!, type: \"normal\") print(\"\\(blueAmount.text!) BTC sent from \\(secondAccount) to \\(firstAccount)\") chainState() blueAmount.text = \"\" &#125;&#125; 首先，我们确认redAmount或blueAmount中的文字栏位是否为空值。如果是，我们会显示一个交易无效的警告。如果不是，我们就可以继续。我们使用transaction函式输入金额，并把交易设为normal型态，以将第一个帐号的金额传送到第二个帐号（或相反）。我们印出被传送的金额，然后呼叫chainState()函式。最后，把文字栏位清空。这样我们就完成啰！确认一下你的程式码是否符合下图所示。 执行App 试试看！从前端来说，它看起来就如一个普通的交易App，但你会知道它后台的运作。试试使用App 将BTC 从一个帐号交易给另一个帐号、并试着欺骗App 吧！ 结论在这次的教学中，你学到了如何使用Swift 来建立一个区块链，并建立自己的比特币交易。请注意在真实的加密货币后台里，实作部分是跟上文是完全不一样的东西，因为它需要藉由智慧合约来分散，但是上面的示范内容用来学习的。在这个范例中，我们运用了比特币来当加密货币，但你能想到区块链还的其他用途吗？欢迎在下面留言分享你的看法！希望你在此学到新的东西！你可以在Github下载完整项目作参考。 完整项目：https://github.com/appcoda/BlockchainDemo原文链接：https://www.appcoda.com/blockchain-introduction/","categories":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://reversescale.github.io/categories/Blockchain/"}],"tags":[{"name":"Blockchain","slug":"Blockchain","permalink":"https://reversescale.github.io/tags/Blockchain/"}]},{"title":"Jenkins + Fastlane 自动打包脚本","slug":"AutoBuildScript","date":"2017-06-20T13:55:38.000Z","updated":"2018-11-15T10:44:32.000Z","comments":true,"path":"2017/06/20/AutoBuildScript/","link":"","permalink":"https://reversescale.github.io/2017/06/20/AutoBuildScript/","excerpt":"三步配置，杜绝污染，一行命令自动上传","text":"三步配置，杜绝污染，一行命令自动上传 📺 故事背景记得大约两年前，当时在创业公司，开发任务重，提测前常常加班到晚上 12 点，就算 bug 修完，也要看着 Xcode 不慌不忙的花半个多小时打包完成，再上传测试平台，发了邮件才能安心回家。鉴于这种惨痛经历，利用闲暇时间就搞一搞自动打包脚本，后期有配上 Jenkins，从此过上了没羞没臊的生活。（已适配 Xcode 8.2 之后版本） 🚀 框架的优势 1.市面上文件最少，使用最便捷的自动化打包脚本 2.冗余方法少，结构清晰，注释齐全 3.同时支持多平台上传，如：Dir、Fir、蒲公英、App Store等 4.具备较高自定义性 5.[自编脚本的时代] -&gt; [Fastlane 的时代] █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🚂 自编脚本的时代 [🚂 自编脚本的时代] 了解一下即可，有些准备工作提供参考，如环境已经配置好，请直接阅读 [🚄 Fastlane 的时代] 第一步 安装fir-cilfir-cli 使用 Ruby 构建, 无需编译, 只要安装相应 gem 即可. 12$ ruby -v # &gt; 1.9.3$ gem install fir-cli 常见的安装问题(1)使用系统自带的 Ruby 安装, 需确保 ruby-dev 已被正确的安装: 12$ xcode-select --install # OS X 系统$ sudo apt-get install ruby-dev # Linux 系统 (2)现 Permission denied 相关错误: 解决：在命令前加上 sudo (3)出现 Gem::RemoteFetcher::FetchError 相关错误: 解决：更换 Ruby 的淘宝源(由于国内网络原因, 你懂的), 并升级下系统自带的 gem12345678$ gem sources --remove https://rubygems.org/$ gem sources -a https://ruby.taobao.org/$ gem sources -l*** CURRENT SOURCES ***https://ruby.taobao.org# 请确保只有 ruby.taobao.org, 如果有其他的源, 请 remove 掉gem update --systemgem install fir-cli (4)Mac OS X 10.11 以后的版本, 由于10.11引入了 rootless, 无法直接安装 fir-cli, 有以下三种解决办法: 方法一： 使用 Homebrew 及 RVM 安装 Ruby, 再安装 fir-cli(推荐)12345# Install Homebrew:$ ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;# Install RVM:$ \\curl -sSL https://get.rvm.io | bash -s stable --ruby$ gem install fir-cli 方法二： 指定 fir-cli 中 bin 文件的 PATH1$ export PATH=/usr/local/bin:$PATH;gem install -n /usr/local/bin fir-cli 方法三： 重写 Ruby Gem 的 bindir12$ echo &apos;gem: --bindir /usr/local/bin&apos; &gt;&gt; ~/.gemrc$ gem install fir-cli 第二步 登录fir.im先到 https://fir.im 创建项目，得到 API Token 并复制。 1fir login 命令用于使用 API token 登录 fir.im, 并使用发布应用等相关命令. 1fir me 命令用于查看当前登录用户信息. 显示信息如下：12345678$ fir login XXX_YOUR_API_TOKEN_XXXI, [2016-03-08T12:48:56.499435 #13043] INFO -- : Login succeed, previous user&apos;s email: xxx@fir.imI, [2016-03-08T12:48:56.507044 #13043] INFO -- : Login succeed, current user&apos;s email: xxx@fir.imI, [2016-03-08T12:48:56.507147 #13043] INFO -- :$ fir meI, [2016-03-08T12:48:14.175488 #12986] INFO -- : Login succeed, current user&apos;s email: xxx@fir.imI, [2016-03-08T12:48:14.175687 #12986] INFO -- : Login succeed, current user&apos;s name: xxxI, [2016-03-08T12:48:14.175765 #12986] INFO -- : 第三步 下载并配置 shell 脚本1.把文件夹导入工程目录根目录下 2.配置 shell 脚本 12345678# 需要改动的地方 (根据项目具体信息改动)PROJECT_NAME = &quot;***&quot; #项目名称VERSION = &quot;1.0.0&quot; #打包版本号 会根据不同的版本创建文件夹（与项目本身的版本号无关）TAGREAT_NAME = &quot;***&quot; #项目对应target的名称如 &quot;Meifabao_User&quot; &quot;Miefabao_stylist&quot;CONFIGURATION = &quot;Release&quot; #打包的环境设置 Release 环境 Debug 环境PROFILE = &quot;AdHoc&quot; #配置文件分为四种 AdHoc Dev AppStore Ent 分别对应四种配置文件OUTPUT = &quot;./Packge/%s&quot; %(CONFIGURATION) #打包导出ipa文件路径（请确保 “%s” 之前的文件夹正确并存在） 根据具体项目填写 3.控制台到项目所在目录下，启动脚本(必要时加管理员权限) 可以将 autobuild.py 拖拽到控制台，执行脚本 注：其他的功能脚本由于实用性不高（其实我懒得搞），暂时没有适配，有兴趣的朋友可以自行配置试用，包括：邮件发送、打包 App Store 等等。 当看到 时，打包好的项目已经躺在你的 Fir 测试平台中了。 █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🚄 Fastlane 的时代2018.08.20 更新：Jenkins + Fastlane + GitLab + fir (或者蒲公英)第一步 安装 FastlaneFastlane 是一套使用Ruby写的自动化工具集，用于iOS和Android的自动化打包、发布等工作，可以节省大量的时间 1sudo gem install fastlane --verbose 第二步 移动脚本至项目目录下根据注释完善脚本配置信息 脚本说明： 支持版本号自增长 支持传入自定的宏，用于在代码里使用此预编译的宏来区分开发环境和发布环境 支持自动上传到 fir 和 testflight 上传成功后弹窗提示 第三步 上传上传到 fir 的用法：1./build.sh -m &quot;xxxx_app_test&quot; -t test 上传到 testflight 的用法：1./build.sh -m &quot;xxxx_app_pro&quot; -t pro 第四步 配置 JenkinsJenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。 下载 Jenkins：点击 http://mirrors.jenkins.io/war-stable/latest/jenkins.war 下载最新的Jenkins.war 运行服务器：需要先安装 java sdk （http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html） 1java -jar jenkins.war 运行 Jenkins1jenkins 配置 Jenkins：浏览器打开 http://localhost:8080/ 输入安全密码，安全密码命令行输出的一个文件里面。 然后自动安装推荐的插件，并新建管理员账号密码。 安装插件登录http://localhost:8080/ ，选择系统管理 - 管理插件。在可选插件中选择GitLab Plugin，Gitlab Hook Plugin，和 Cocoapod plugin 进行安装。 构建任务 点击新建，输入名称，构建一个自由风格的软件项目。 配置 Git 仓库地址，并添加 git 账号。 配置构建脚本 附录 执行脚本过程中遇到的问题和解决方案fir: command not found这个是因为没有安装fir-cil，导致找不到相应的命令行，只需要安装一下就行了，详情见上文写的如何安装fir-cil。 README: No such file or directory那是因为你的脚本目录下没有README的文件，只需要建一个README的文件就行了，打开终端，cd到当前位置，然后执行下面的命令： 1touch README ERROR – : Token can not be blank这个原因是因为你没有登录fir导致的，你执行这个脚本之前应该先登录一下fir，详情请看上文写的登录fir.im。 ERROR – : Code=14 (没有试用的设备 Domain=IDEDistributionErrorDomain Code=14 “No applicable devices原因：rvm ruby 配置错误 解决：控制台 rvm system █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 2018.08.20 更新：Jenkins 相关设置方法查看端口占用端口占用 使用 lsof 会列举所有占用的端口列表： 1lsof 使用less可以用于分页展示，如： 1lsof | less 也可以使用 -i 查看某个端口是否被占用，如： 1lsof -i:3000 杀死进程 1kill PID（进程的PID，如2044） Jenkins 改时区http://your-jenkins/systemInfo，查看user.timezone变量的值 在jenkins的【系统管理】-【脚本命令行】里运行 1System.setProperty(&apos;org.apache.commons.jelly.tags.fmt.timeZone&apos;, &apos;Asia/Shanghai&apos;) Jenkins 构建超时jenkins的”build timeout plugin”插件可以帮我们完成该任务。我使用的是jenkins-2.7.1, 默认就已经安装了该插件，如果默认没有安装可在插件管理中搜索进行安装。 Jenkins 定时构建和Poll SCM的区别 Build periodically：周期进行项目构建（源码是否发生变化没有关系） Poll SCM：定时检查源码变更，如果有更新就checkout最新code下来，然后执行构建动作 12345678910111213每15分钟构建一次：H/15 * * * * 或 */5 * * * *每天8点构建一次：0 8 * * *每天8点~17点，两小时构建一次：0 8-17/2 * * *周一到周五，8点~17点，两小时构建一次：0 8-17/2 * * 1-5每月1号、15号各构建一次，除12月：H H 1,15 1-11 **/5 * * * * （每5分钟检查一次源码变化）0 2 * * * （每天2:00 必须build一次源码） █◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢◤◢█ 🕹 agvtool 命令行2018.08.20 更新：agvtool 命令行 管理版本号常用命令行：设置 版本号 为 1.1.01xcrun agvtool new-marketing-version 1.1.0 设置 build 号 自动加11xcrun agvtool next-version -all 简介agvtool 是一个命令行工具，允许你自动递增到下一个最高的数量或具体的数字这些数字。 修改Xcode的默认设置默认情况下，在不使用任何版本控制系统。设置版本系统苹果通用确保 Xcode 将包括在你的项目中生成的所有agvtool版本信息。 上图：设置当前项目的版本和版本控制系统的构建设置 设置你的版本号和 bulid 版本号agvtool 查询应用程序的 Info.plist 得到你的版本和 bulid 版本号。 所以确保 CFBundleVersion (Bundle version) 和 CFBundleShortVersionString (Bundle versions string, short）的 key 在你的 Info.plist 中。 上图：info.plist 命令行操作更新版本号退出Xcode，然后导航到包含项目的目录，运行下列命令在终端应用 agvtool 属性工作。 设置 版本号 为 1.1.01xcrun agvtool new-marketing-version 1.1.0 设置 build 号 自动加11xcrun agvtool next-version -all 设置 build 号为 311xcrun agvtool new-version -all 31 查看 Version Numbers1xcrun agvtool what-marketing-version 查看 Build Numbers1xcrun agvtool what-version 😬 联系 微信 : WhatsXie 邮件 : ReverseScale@iCloud.com 博客 : https://reversescale.github.io","categories":[{"name":"Script","slug":"Script","permalink":"https://reversescale.github.io/categories/Script/"}],"tags":[{"name":"Script","slug":"Script","permalink":"https://reversescale.github.io/tags/Script/"}]},{"title":"GoF 设计模式 + 情景再现","slug":"Design patterns Gof","date":"2017-03-01T12:29:16.000Z","updated":"2018-11-14T14:22:56.000Z","comments":true,"path":"2017/03/01/Design patterns Gof/","link":"","permalink":"https://reversescale.github.io/2017/03/01/Design patterns Gof/","excerpt":"《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995），这几位作者常被称为”四人组（Gang of Four）”","text":"《Design Patterns: Elements of Reusable Object-Oriented Software》（即后述《设计模式》一书），由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 合著（Addison-Wesley，1995），这几位作者常被称为”四人组（Gang of Four）” 设计模式和情景再现创建型模式1、ABSTRACT FACTORY—追MM少不了请吃饭了，麦当劳的套餐和肯德基的套餐都是MM爱吃的东西，虽然口味有所不同，但不管你带MM去麦当劳或肯德基，只管向服务员说“两个B套餐”就行了。麦当劳和肯德基就是B套餐的Abstract Factory, B套餐里含有汉堡, 鸡翅和饮料. 麦当劳或肯德基会根据B套餐的规格, 让汉堡Factory, 鸡翅Factory, 饮料Factory分别生产对应B套餐的材料。抽象工厂模式：客户类和工厂类分开。消费者任何时候需要某套产品集合时，只需向抽象工厂请求即可。抽象工厂会再向具体的工厂生产出符合产品集规格的产品。 2、BUILDER—MM最爱听的就是“我爱你”这句话了，见到不同地方的MM,要能够用她们的方言跟她说这句话哦，我有一个多种语言翻译机，上面每种语言都有一个按键，见到MM我只要按对应的键，它就能够用相应的语言说出“我爱你”这句话了，国外的MM也可以轻松搞掂，这就是我的“我爱你”builder。（这一定比美军在伊拉克用的翻译机好卖）建造模式：将产品的内部表象和产品的生成过程分割开来，从而使一个建造过程生成具有不同的内部表象的产品对象。建造模式使得产品内部表象可以独立的变化，客户不必知道产品内部组成的细节。建造模式可以强制实行一种分步骤进行的建造过程。 3、FACTORY METHOD—请MM去麦当劳吃汉堡，不同的MM有不同的口味，要每个都记住是一件烦人的事情，我一般采用Factory Method模式，带着MM到服务员那儿，说“要一个汉堡”，具体要什么样的汉堡呢，让MM直接跟服务员说就行了。工厂方法模式：核心工厂类不再负责所有产品的创建，而是将具体创建的工作交给子类去做，成为一个抽象工厂角色，仅负责给出具体工厂类必须实现的接口，而不接触哪一个产品类应当被实例化这种细节。 4、PROTOTYPE—跟MM用QQ聊天，一定要说些深情的话语了，我搜集了好多肉麻的情话，需要时只要copy出来放到QQ里面就行了，这就是我的情话prototype了。（100块钱一份，你要不要）原始模型模式：通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的方法创建出更多同类型的对象。原始模型模式允许动态的增加或减少产品类，产品类不需要非得有任何事先确定的等级结构，原始模型模式适用于任何的等级结构。缺点是每一个类都必须配备一个克隆方法。 5、SINGLETON—俺有6个漂亮的老婆，她们的老公都是我，我就是我们家里的老公Singleton，她们只要说道“老公”，都是指的同一个人，那就是我。(刚才做了个梦啦，哪有这么好的事)单例模式：单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例单例模式。单例模式只应在有真正的“单一实例”的需求时才可使用。 结构型模式6、ADAPTER—在朋友聚会上碰到了一个美女Sarah，从香港来的，可我不会说粤语，她不会说普通话，只好求助于我的朋友kent了，他作为我和Sarah之间的Adapter，让我和Sarah可以相互交谈了(也不知道他会不会耍我)适配器（变压器）模式：把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口原因不匹配而无法一起工作的两个类能够一起工作。适配类可以根据参数返还一个合适的实例给客户端。 7、BRIDGE—早上碰到MM，要说早上好，晚上碰到MM，要说晚上好；碰到MM穿了件新衣服，要说你的衣服好漂亮哦，碰到MM新做的发型，要说你的头发好漂亮哦。不要问我“早上碰到MM新做了个发型怎么说”这种问题，自己用BRIDGE组合一下不就行了。桥梁模式：将抽象化与实现化脱耦，使得二者可以独立的变化，也就是说将他们之间的强关联变成弱关联，也就是指在一个软件系统的抽象化和实现化之间使用组合/聚合关系而不是继承关系，从而使两者可以独立的变化。 8、COMPOSITE—Mary今天过生日。“我过生日，你要送我一件礼物。”“嗯，好吧，去商店，你自己挑。”“这件T恤挺漂亮，买，这条裙子好看，买，这个包也不错，买。”“喂，买了三件了呀，我只答应送一件礼物的哦。”“什么呀，T恤加裙子加包包，正好配成一套呀，小姐，麻烦你包起来。”“……”，MM都会用Composite模式了，你会了没有？合成模式：合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式就是一个处理对象的树结构的模式。合成模式把部分与整体的关系用树结构表示出来。合成模式使得客户端把一个个单独的成分对象和由他们复合而成的合成对象同等看待。 9、DECORATOR—Mary过完轮到Sarly过生日，还是不要叫她自己挑了，不然这个月伙食费肯定玩完，拿出我去年在华山顶上照的照片，在背面写上“最好的的礼物，就是爱你的Fita”，再到街上礼品店买了个像框（卖礼品的MM也很漂亮哦），再找隔壁搞美术设计的Mike设计了一个漂亮的盒子装起来……，我们都是Decorator，最终都在修饰我这个人呀，怎么样，看懂了吗？装饰模式：装饰模式以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案，提供比继承更多的灵活性。动态给一个对象增加功能，这些功能可以再动态的撤消。增加由一些基本功能的排列组合而产生的非常大量的功能。 10、FACADE—我有一个专业的Nikon相机，我就喜欢自己手动调光圈、快门，这样照出来的照片才专业，但MM可不懂这些，教了半天也不会。幸好相机有Facade设计模式，把相机调整到自动档，只要对准目标按快门就行了，一切由相机自动调整，这样MM也可以用这个相机给我拍张照片了。门面模式：外部与一个子系统的通信必须通过一个统一的门面对象进行。门面模式提供一个高层次的接口，使得子系统更易于使用。每一个子系统只有一个门面类，而且此门面类只有一个实例，也就是说它是一个单例模式。但整个系统可以有多个门面类。 11、FLYWEIGHT—每天跟MM发短信，手指都累死了，最近买了个新手机，可以把一些常用的句子存在手机里，要用的时候，直接拿出来，在前面加上MM的名字就可以发送了，再不用一个字一个字敲了。共享的句子就是Flyweight，MM的名字就是提取出来的外部特征，根据上下文情况使用。享元模式：FLYWEIGHT在拳击比赛中指最轻量级。享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。外蕴状态不能影响内蕴状态，它们是相互独立的。将可以共享的状态和不可以共享的状态从常规类中区分开来，将不可以共享的状态从类里剔除出去。客户端不可以直接创建被共享的对象，而应当使用一个工厂对象负责创建被共享的对象。享元模式大幅度的降低内存中对象的数量。 12、PROXY—跟MM在网上聊天，一开头总是“hi,你好”,“你从哪儿来呀？”“你多大了？”“身高多少呀？”这些话，真烦人，写个程序做为我的Proxy吧，凡是接收到这些话都设置好了自动的回答，接收到其他的话时再通知我回答，怎么样，酷吧。代理模式：代理模式给某一个对象提供一个代理对象，并由代理对象控制对源对象的引用。代理就是一个人或一个机构代表另一个人或者一个机构采取行动。某些情况下，客户不想或者不能够直接引用一个对象，代理对象可以在客户和目标对象直接起到中介的作用。客户端分辨不出代理主题对象与真实主题对象。代理模式可以并不知道真正的被代理对象，而仅仅持有一个被代理对象的接口，这时候代理对象不能够创建被代理对象，被代理对象必须有系统的其他角色代为创建并传入。 行为模式13、CHAIN OF RESPONSIBILITY—晚上去上英语课，为了好开溜坐到了最后一排，哇，前面坐了好几个漂亮的MM哎，找张纸条，写上“Hi,可以做我的女朋友吗？如果不愿意请向前传”，纸条就一个接一个的传上去了，糟糕，传到第一排的MM把纸条传给老师了，听说是个老处女呀，快跑!责任链模式：在责任链模式中，很多对象由每一个对象对其下家的引用而接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。客户并不知道链上的哪一个对象最终处理这个请求，系统可以在不影响客户端的情况下动态的重新组织链和分配责任。处理者有两个选择：承担责任或者把责任推给下家。一个请求可以最终不被任何接收端对象所接受。 14、COMMAND—俺有一个MM家里管得特别严，没法见面，只好借助于她弟弟在我们俩之间传送信息，她对我有什么指示，就写一张纸条让她弟弟带给我。这不，她弟弟又传送过来一个COMMAND，为了感谢他，我请他吃了碗杂酱面，哪知道他说：“我同时给我姐姐三个男朋友送COMMAND，就数你最小气，才请我吃面。” :-(命令模式：命令模式把一个请求或者操作封装到一个对象中。命令模式把发出命令的责任和执行命令的责任分割开，委派给不同的对象。命令模式允许请求的一方和发送的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否执行，何时被执行以及是怎么被执行的。系统支持命令的撤消。 15、INTERPRETER—俺有一个《泡MM真经》，上面有各种泡MM的攻略，比如说去吃西餐的步骤、去看电影的方法等等，跟MM约会时，只要做一个Interpreter，照着上面的脚本执行就可以了。解释器模式：给定一个语言后，解释器模式可以定义出其文法的一种表示，并同时提供一个解释器。客户端可以使用这个解释器来解释这个语言中的句子。解释器模式将描述怎样在有了一个简单的文法后，使用模式设计解释这些语句。在解释器模式里面提到的语言是指任何解释器对象能够解释的任何组合。在解释器模式中需要定义一个代表文法的命令类的等级结构，也就是一系列的组合规则。每一个命令对象都有一个解释方法，代表对命令对象的解释。命令对象的等级结构中的对象的任何排列组合都是一个语言。 16、ITERATOR—我爱上了Mary，不顾一切的向她求婚。Mary：“想要我跟你结婚，得答应我的条件”我：“什么条件我都答应，你说吧”Mary：“我看上了那个一克拉的钻石”我：“我买，我买，还有吗？”Mary：“我看上了湖边的那栋别墅”我：“我买，我买，还有吗？”……迭代子模式：迭代子模式可以顺序访问一个聚集中的元素而不必暴露聚集的内部表象。多个对象聚在一起形成的总体称之为聚集，聚集对象是能够包容一组对象的容器对象。迭代子模式将迭代逻辑封装到一个独立的子对象中，从而与聚集本身隔开。迭代子模式简化了聚集的界面。每一个聚集对象都可以有一个或一个以上的迭代子对象，每一个迭代子的迭代状态可以是彼此独立的。迭代算法可以独立于聚集角色变化。 17、MEDIATOR—四个MM打麻将，相互之间谁应该给谁多少钱算不清楚了，幸亏当时我在旁边，按照各自的筹码数算钱，赚了钱的从我这里拿，赔了钱的也付给我，一切就OK啦，俺得到了四个MM的电话。调停者模式：调停者模式包装了一系列对象相互作用的方式，使得这些对象不必相互明显作用。从而使他们可以松散偶合。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用。保证这些作用可以彼此独立的变化。调停者模式将多对多的相互作用转化为一对多的相互作用。调停者模式将对象的行为和协作抽象化，把对象在小尺度的行为上与其他对象的相互作用分开处理。 18、MEMENTO—同时跟几个MM聊天时，一定要记清楚刚才跟MM说了些什么话，不然MM发现了会不高兴的哦，幸亏我有个备忘录，刚才与哪个MM说了什么话我都拷贝一份放到备忘录里面保存，这样可以随时察看以前的记录啦。备忘录模式：备忘录对象是一个用来存储另外一个对象内部状态的快照的对象。备忘录模式的用意是在不破坏封装的条件下，将一个对象的状态捉住，并外部化，存储起来，从而可以在将来合适的时候把这个对象还原到存储起来的状态。 19、OBSERVER—想知道咱们公司最新MM情报吗？加入公司的MM情报邮件组就行了，tom负责搜集情报，他发现的新情报不用一个一个通知我们，直接发布给邮件组，我们作为订阅者（观察者）就可以及时收到情报啦观察者模式：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。 20、STATE—跟MM交往时，一定要注意她的状态哦，在不同的状态时她的行为会有不同，比如你约她今天晚上去看电影，对你没兴趣的MM就会说“有事情啦”，对你不讨厌但还没喜欢上的MM就会说“好啊，不过可以带上我同事么？”，已经喜欢上你的MM就会说“几点钟？看完电影再去泡吧怎么样？”，当然你看电影过程中表现良好的话，也可以把MM的状态从不讨厌不喜欢变成喜欢哦。状态模式：状态模式允许一个对象在其内部状态改变的时候改变行为。这个对象看上去象是改变了它的类一样。状态模式把所研究的对象的行为包装在不同的状态对象里，每一个状态对象都属于一个抽象状态类的一个子类。状态模式的意图是让一个对象在其内部状态改变的时候，其行为也随之改变。状态模式需要对每一个系统可能取得的状态创立一个状态类的子类。当系统的状态变化时，系统便改变所选的子类。 21、STRATEGY—跟不同类型的MM约会，要用不同的策略，有的请电影比较好，有的则去吃小吃效果不错，有的去海边浪漫最合适，单目的都是为了得到MM的芳心，我的追MM锦囊中有好多Strategy哦。策略模式：策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。策略模式使得算法可以在不影响到客户端的情况下发生变化。策略模式把行为和环境分开。环境类负责维持和查询行为类，各种算法在具体的策略类中提供。由于算法和环境独立开来，算法的增减，修改都不会影响到环境和客户端。 22、TEMPLATE METHOD——看过《如何说服女生上床》这部经典文章吗？女生从认识到上床的不变的步骤分为巧遇、打破僵局、展开追求、接吻、前戏、动手、爱抚、进去八大步骤(Template method)，但每个步骤针对不同的情况，都有不一样的做法，这就要看你随机应变啦(具体实现)；模板方法模式：模板方法模式准备一个抽象类，将部分逻辑以具体方法以及具体构造子的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。先制定一个顶级逻辑框架，而将逻辑的细节留给具体的子类去实现。 23、VISITOR—情人节到了，要给每个MM送一束鲜花和一张卡片，可是每个MM送的花都要针对她个人的特点，每张卡片也要根据个人的特点来挑，我一个人哪搞得清楚，还是找花店老板和礼品店老板做一下Visitor，让花店老板根据MM的特点选一束花，让礼品店老板也根据每个人特点选一张卡，这样就轻松多了；访问者模式：访问者模式的目的是封装一些施加于某种数据结构元素之上的操作。一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。访问者模式适用于数据结构相对未定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。访问者模式使得增加新的操作变的很容易，就是增加一个新的访问者类。访问者模式将有关的行为集中到一个访问者对象中，而不是分散到一个个的节点类中。当使用访问者模式时，要将尽可能多的对象浏览逻辑放在访问者类中，而不是放到它的子类中。访问者模式可以跨过几个类的等级结构访问属于不同的等级结构的成员类。 设计模式之间的关系图： 设计模式的六大原则1、开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle）为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle）原则是尽量使用合成/聚合的方式，而不是使用继承。","categories":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/categories/Book/"}],"tags":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/tags/Book/"}]},{"title":"iOS 开发中常用的设计模式","slug":"Design patterns iOS","date":"2017-02-21T06:56:27.000Z","updated":"2018-11-14T14:51:29.000Z","comments":true,"path":"2017/02/21/Design patterns iOS/","link":"","permalink":"https://reversescale.github.io/2017/02/21/Design patterns iOS/","excerpt":"之前有朋友问到设计模式，便特意找了一篇关于 iOS 的设计模式的简介，同时推荐一本书《Head First设计模式》","text":"之前有朋友问到设计模式，便特意找了一篇关于 iOS 的设计模式的简介，同时推荐一本书《Head First设计模式》 （一）代理模式应用场景：当一个类的某些功能需要由别的类来实现，但是又不确定具体会是哪个类实现。优势：解耦合敏捷原则：开放-封闭原则实例：tableview的 数据源delegate，通过和protocol的配合，完成委托诉求。列表row个数delegate自定义的delegate （二）观察者模式应用场景：一般为model层对，controller和view进行的通知方式，不关心谁去接收，只负责发布信息。优势：解耦合敏捷原则：接口隔离原则，开放-封闭原则实例：Notification通知中心，注册通知中心，任何位置可以发送消息，注册观察者的对象可以接收。kvo，键值对改变通知的观察者，平时基本没用过。 （三）MVC模式应用场景：是一中非常古老的设计模式，通过数据模型，控制器逻辑，视图展示将应用程序进行逻辑划分。优势：使系统，层次清晰，职责分明，易于维护敏捷原则：对扩展开放-对修改封闭实例：model-即数据模型，view-视图展示，controller进行UI展现和数据交互的逻辑控制。 （四）单例模式应用场景：确保程序运行期某个类，只有一份实例，用于进行资源共享控制。优势：使用简单，延时求值，易于跨模块敏捷原则：单一职责原则实例：[UIApplication sharedApplication]。注意事项：确保使用者只能通过 getInstance方法才能获得，单例类的唯一实例。java，C++中使其没有公有构造函数，私有化并覆盖其构造函数。object c中，重写allocWithZone方法，保证即使用户用 alloc方法直接创建单例类的实例，返回的也只是此单例类的唯一静态变量。 （五）策略模式应用场景：定义算法族，封装起来，使他们之间可以相互替换。优势：使算法的变化独立于使用算法的用户敏捷原则：接口隔离原则；多用组合，少用继承；针对接口编程，而非实现。实例：排序算法，NSArray的sortedArrayUsingSelector；经典的鸭子会叫，会飞案例。注意事项：1，剥离类中易于变化的行为，通过组合的方式嵌入抽象基类2，变化的行为抽象基类为，所有可变变化的父类3，用户类的最终实例，通过注入行为实例的方式，设定易变行为防止了继承行为方式，导致无关行为污染子类。完成了策略封装和可替换性。 （六）工厂模式应用场景：工厂方式创建类的实例，多与proxy模式配合，创建可替换代理类。优势：易于替换，面向抽象编程，application只与抽象工厂和易变类的共性抽象类发生调用关系。敏捷原则：DIP依赖倒置原则实例：项目部署环境中依赖多个不同类型的数据库时，需要使用工厂配合proxy完成易用性替换注意事项：项目初期，软件结构和需求都没有稳定下来时，不建议使用此模式，因为其劣势也很明显，增加了代码的复杂度，增加了调用层次，增加了内存负担。所以要注意防止模式的滥用。 设计模式六大原则1、开闭原则（Open Close Principle）开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle）里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科 3、依赖倒转原则（Dependence Inversion Principle）这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle）这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。 5、迪米特法则（最少知道原则）（Demeter Principle）为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle）原则是尽量使用合成/聚合的方式，而不是使用继承。 《Head First设计模式》http://pan.baidu.com/s/1nvTqSdj 验证码：DG58","categories":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/categories/Book/"}],"tags":[{"name":"Book","slug":"Book","permalink":"https://reversescale.github.io/tags/Book/"}]}]}