<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<!--<![endif]-->

<head>
  <title>Objective-C Principle - ReactNative | Steven&#39;s Technology Blog</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Steven's Technology Blog">
    <meta name="author" content="Steven">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="Steven&#39;s Technology Blog" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
	
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    
    

    <!-- Custom stylesheet, (add custom styles here, always load last) -->
    <!-- Load our stylesheet for IE8 -->
    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- Google Webfonts (Monserrat 400/700, Open Sans 400/600) -->
    <link href='//fonts.useso.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>
    <link href='//fonts.useso.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'>

    <!-- Load our fonts individually if IE8+, to avoid faux bold & italic rendering -->
    <!--[if IE]>
    <link href='http://fonts.useso.com/css?family=Montserrat:400' rel='stylesheet' type='text/css'>
    <link href='http://fonts.useso.com/css?family=Montserrat:700' rel='stylesheet' type='text/css'>
    <link href='http://fonts.useso.com/css?family=Open+Sans:400' rel='stylesheet' type='text/css'>
    <link href='http://fonts.useso.com/css?family=Open+Sans:600' rel='stylesheet' type='text/css'>
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->










  
  
  

  
  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close">
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="/tags/博客，文章" target="_BLANK" class="animsition-link">文章</a></li>
                    
                        <li><a href="/tags/博客，资料" target="_BLANK" class="animsition-link">资料</a></li>
                    
                </ul>
            </li>
            
            
        	<li>
        		<a class="sb-toggle-submenu">Categories<span class="sb-caret"></span></a>
            	<ul class="sb-submenu">
				  	
				    <li><a href="/categories/API/" class="animsition-link">API<small>(1)</small></a></li>
				    
				    <li><a href="/categories/Android/" class="animsition-link">Android<small>(1)</small></a></li>
				    
				    <li><a href="/categories/Git/" class="animsition-link">Git<small>(1)</small></a></li>
				    
				    <li><a href="/categories/HTML5/" class="animsition-link">HTML5<small>(5)</small></a></li>
				    
				    <li><a href="/categories/Markdown/" class="animsition-link">Markdown<small>(1)</small></a></li>
				    
				    <li><a href="/categories/PHP/" class="animsition-link">PHP<small>(1)</small></a></li>
				    
				    <li><a href="/categories/Tools/" class="animsition-link">Tools<small>(2)</small></a></li>
				    
				    <li><a href="/categories/Unity-3D/" class="animsition-link">Unity 3D<small>(1)</small></a></li>
				    
				    <li><a href="/categories/iOS/" class="animsition-link">iOS<small>(130)</small></a></li>
				    
				    <li><a href="/categories/前沿技术/" class="animsition-link">前沿技术<small>(5)</small></a></li>
				    
				    <li><a href="/categories/文章/" class="animsition-link">文章<small>(5)</small></a></li>
				    
				    <li><a href="/categories/设计/" class="animsition-link">设计<small>(4)</small></a></li>
				    
				</ul>
        	</li>
			
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a href="https://www.qtumist.com" class="animsition-link">量子计算</a></li>
                    
                    <li><a href="https://blog.ibeats.top" class="animsition-link">CI_Knight</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">Steven's Technology Blog</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/ReverseScale" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a></li>
                            
                            
                            <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a></li>
                            
                            
                            <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a></li>
                            
                            
                            <li><a href="http://www.weibo.com/5844576818/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a></li>
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->

</div>
      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2018-05-13T11:20:31.000Z" itemprop="datePublished">
          2018-05-13
      </time>
    
    
    | 
    <a href="/tags/博客，文章/">博客，文章</a>
    
    
</span>
                <h1>Objective-C Principle - ReactNative</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<p>#OC 底层原理总结之 ReactNative 通信</p>
<a id="more"></a><!--more-->
<hr>
<p><img width="22" height="24" src="http://og1yl0w9z.bkt.clouddn.com/18-5-9/42814631.jpg">：<a href="https://github.com/ReverseScale/iOSPrinciple_ReactNative" target="_blank" rel="noopener">https://github.com/ReverseScale/iOSPrinciple_ReactNative</a></p>
<h3 id="方便记忆："><a href="#方便记忆：" class="headerlink" title="方便记忆："></a>方便记忆：</h3><ul>
<li>React原理：一套可以用简洁的语法高效绘制 DOM 的框架</li>
<li>React特点：<ul>
<li>简洁：不单单指它的 HTML 和 CSS 语法，更因为可以单用 JavaScript 构造页面</li>
<li>高效：因为 React 独创了 Virtual DOM 机制，两大特征<ul>
<li>它存在于内存中的 JavaScript 对象，并且与 DOM 是对应关系</li>
<li>使用高效的 DOM Diff 算法不需要对 DOM 进行重新绘制</li>
</ul>
</li>
</ul>
</li>
<li>React Native原理：通过 JS 对 OC 的 JavaScript Core 框架的交互来实现对原生的调用<ul>
<li>rn 在 OC 和 JS 两端都保存了一份配置表，里面标记了所有 OC 暴露给 JS 的模块和方法 ，js对oc的调用通过block方式实现回调</li>
<li>AppDelegate初始化过程中创建bridge，内部通过setUp创建BatchedBridge来批量读取 JS 对 OC 的方法调用并通过JavaScriptExecutor执行 JS 代码</li>
</ul>
</li>
<li>创建 BatchedBridge 步骤<ul>
<li>读取 JS 源码：把 JSX 代码转成 JS 加载进内存中</li>
<li>初始化模块信息：找到所有需要暴露给 JS 的类</li>
<li>初始化 JS 代码的执行器：即 RCTJSCExecutor 对象</li>
<li>生成模块列表并写入 JS 端：接受 ModuleName 并且生成模块信息</li>
<li>执行 JavaScript 源码：通过RCTJSCExecutor执行代码，写入信息</li>
</ul>
</li>
<li>相互调用方法：<ul>
<li>OC调用JS：OC会通过executeBlockOnJavaScriptQueue方法在单独的线程上运行 JS 代码<ul>
<li>处理参数：_executeJSCall:(NSString *)method方法</li>
<li>实际调用：sendAppEventWithName和body方法</li>
</ul>
</li>
<li>JS调用OC：JS 会解析出方法的类、方法和方法参数并放入到 MessageQueue 中，等待 OC 调用或超时发送<ul>
<li>使用RCT_EXPORT_METHOD 宏，用来注册模块表</li>
<li>JS中使用NativeModules.CryptoExport.注册方法调用</li>
</ul>
</li>
</ul>
</li>
<li>rn 的更新机制：React 状态机，不停地检查确认更新<ul>
<li>文本元素：ReactDOMTextComponent 比较替换文本元素</li>
<li>基本元素：updateComponent方法分属性、节点替换基本元素</li>
<li>自定义元素：_performComponentUpdate判断-先卸载再安装子节点</li>
</ul>
</li>
</ul>
<hr>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>首先，我们来看一下在iOS中Native如何调用JS。从iOS7开始，系统进一步开放了WebCore SDK，提供JavaScript引擎库，使得我们能够直接与引擎交互拥有更多的控制权。其中，有两个最基础的概念：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JSContext <span class="comment">// JS代码的环境，一个JSContext是一个全局环境的实例</span></span><br><span class="line">JSValue <span class="comment">// 包装了每一个可能的JS值：字符串、数字、数组、对象、方法等</span></span><br></pre></td></tr></table></figure>
<p>通过这两个类，我们能够非常方便的实现Javascript与Native代码之间的交互，首先我们通过一个简单示例来观察Native如何调用Javascript代码：</p>
<p>🌰：Native -&gt; JavaScript</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;JavaScriptCore/JSContext.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;JavaScriptCore/JSValue.h&gt;</span></span></span><br><span class="line">- (<span class="keyword">void</span>)createJSContext &#123;</span><br><span class="line">    JSContext *context = [[JSContext alloc] init];</span><br><span class="line">    [context evaluateScript:<span class="string">@"var num = 5 + 5"</span>];</span><br><span class="line">    [context evaluateScript:<span class="string">@"var names = ['Grace', 'Ada', 'Margaret']"</span>];</span><br><span class="line">    [context evaluateScript:<span class="string">@"var triple = function(value) &#123; return value * 3 &#125;"</span>];</span><br><span class="line">    JSValue *tripleNum = [context evaluateScript:<span class="string">@"triple(num)"</span>];</span><br><span class="line">    JSValue *tripleFunction = context[<span class="string">@"triple"</span>];</span><br><span class="line">    JSValue *result = [tripleFunction callWithArguments:@[@<span class="number">5</span>]];</span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"JSContext function \ntripleNum:%@ \nresult:%@"</span>, tripleNum, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，JSContext如何访问我们本地客户端OC代码呢？答案是通过Blocks和JSExports协议两种方式。<br>我们来看一个通过Blocks来实现JS访问本地代码的示例：</p>
<p>🌰：JavaScript -&gt; Native</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">context[<span class="string">@"testSay"</span>] = ^(<span class="built_in">NSString</span> *input) &#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *mutableString = [input mutableCopy];</span><br><span class="line">    <span class="built_in">CFStringTransform</span>((__bridge <span class="built_in">CFMutableStringRef</span>)mutableString, <span class="literal">NULL</span>, kCFStringTransformToLatin, <span class="literal">NO</span>);</span><br><span class="line">    <span class="built_in">CFStringTransform</span>((__bridge <span class="built_in">CFMutableStringRef</span>)mutableString, <span class="literal">NULL</span>, kCFStringTransformStripCombiningMarks, <span class="literal">NO</span>);</span><br><span class="line">    <span class="keyword">return</span> mutableString;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [context evaluateScript:<span class="string">@"testSay('hello world')"</span>]);</span><br></pre></td></tr></table></figure>
<p>关于JSCore库的更多学习介绍，请看JavaScriptCore。</p>
<blockquote>
<p>Java​Script​Core 相关介绍 <a href="http://nshipster.cn/javascriptcore/" target="_blank" rel="noopener">http://nshipster.cn/javascriptcore/</a></p>
</blockquote>
<h3 id="React-Native-初始化过程解析"><a href="#React-Native-初始化过程解析" class="headerlink" title="React Native 初始化过程解析"></a>React Native 初始化过程解析</h3><p>在了解React-Native中JS-&gt;Native的具体调用之前，我们先做一些准备工作，看看框架中Native app的启动过程。打开FB提供的AwesomeProject定位到appDelegate的didFinishLaunchingWithOptions方法中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定JS页面文件位置</span></span><br><span class="line">jsCodeLocation = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://localhost:8081/index.ios.bundle?platform=ios&amp;dev=false"</span>];</span><br><span class="line"><span class="comment">// 创建React Native视图对象</span></span><br><span class="line">RCTRootView *rootView = [[RCTRootView alloc] initWithBundleURL:jsCodeLocation</span><br><span class="line">moduleName:<span class="string">@"ReactExperiment"</span></span><br><span class="line">initialProperties:<span class="literal">nil</span></span><br><span class="line">launchOptions:launchOptions];</span><br><span class="line"><span class="keyword">self</span>.window = [[<span class="built_in">UIWindow</span> alloc] initWithFrame:[<span class="built_in">UIScreen</span> mainScreen].bounds];</span><br><span class="line"><span class="comment">// 创建VC，并且把React Native Root View赋值给VC</span></span><br><span class="line"><span class="built_in">UIViewController</span> *rootViewController = [<span class="built_in">UIViewController</span> new];</span><br><span class="line">rootViewController.view = rootView;</span><br><span class="line"><span class="keyword">self</span>.window.rootViewController = rootViewController;</span><br><span class="line">[<span class="keyword">self</span>.window makeKeyAndVisible];</span><br></pre></td></tr></table></figure>
<p>可以看到使用集成非常简单，那么RCTRootView到底做了哪些事情最后渲染将视图呈现在用户面前呢？<br>我们继续跟着代码往下分析就会看到我们今天的主角RCTBridge。</p>
<p>🥟：RCTBridge</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithBundleURL:(<span class="built_in">NSURL</span> *)bundleURL</span><br><span class="line">moduleName:(<span class="built_in">NSString</span> *)moduleName</span><br><span class="line">initialProperties:(<span class="built_in">NSDictionary</span> *)initialProperties</span><br><span class="line">launchOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    RCTBridge *bridge = [[RCTBridge alloc] initWithBundleURL:bundleURL</span><br><span class="line">    moduleProvider:<span class="literal">nil</span></span><br><span class="line">    launchOptions:launchOptions];</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithBridge:bridge moduleName:moduleName initialProperties:initialProperties];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RCTBridge是Naitive端的bridge，起着桥接两端的作用 。事实上具体的实现放置在RCTBatchedBridge中，在它的start方法中执行了一系列重要的初始化工作。这部分也是ReactNative SDK的精髓所在，基于GCD实现一套异步初始化组件框架。大致的工作流程如下图所示：</p>
<p><img src="http://og1yl0w9z.bkt.clouddn.com/18-5-11/60547481.jpg" alt=""></p>
<h4 id="1-Load-JS-Source-Code（并行）"><a href="#1-Load-JS-Source-Code（并行）" class="headerlink" title="1.Load JS Source Code（并行）"></a>1.Load JS Source Code（并行）</h4><p>加载页面源码阶段。该阶段主要负责从指定的位置（网络或者本地）加载React Native页面代码。与initModules各模块初始化过程并行执行，通过GCD分组队列保证两个阶段完成后才会加载解析页面源码。</p>
<h4 id="2-Init-Module（同步）"><a href="#2-Init-Module（同步）" class="headerlink" title="2.Init Module（同步）"></a>2.Init Module（同步）</h4><p>初始化加载React Native模块。该阶段会将所有注册的Native模块类整理保存到一个以Module Id为下标的数组对象中（同时还会保存一个以Module Name为Key的Dictionary，用于做索引方便后续的模块查找）。</p>
<p>整个模块的基础初始化和注册过程在系统Load Class阶段就会完成。React Native对模块注册的实现还是比较巧妙、方便，只需要对目标类添加相应的宏即可。</p>
<ul>
<li>1.注册模块。实现RCTBridgeModule协议，并且在响应的Implemention文件中添加RCT_EXPORT_MODULE宏，该宏会为所在类自动添加一个+load方法，调用RCTBridge的RCTRegisterModule实现在Load Class阶段就完成模块注册工作。</li>
<li>2.注册函数。待注册函数所在的类必须是已注册模块，在需要注册的函数前添加RCT_EXPORT_MODULE宏即可。</li>
</ul>
<p>当然这里需要注意的问题是模块初始化是一个同步任务，它必须被同步加载，所以当模块较多时势必会带来高延迟的问题，也是在新的版本中SDK将Module Method改为Lazy Load的原因之一。</p>
<h4 id="3-Setup-JS-Executor（并行）"><a href="#3-Setup-JS-Executor（并行）" class="headerlink" title="3.Setup JS Executor（并行）"></a>3.Setup JS Executor（并行）</h4><p>初始化JS引擎。React Native在0.18中已经很好的抽象了原来了JSExecutor，目前实现了RCTWebSocketExecutor和RCTJSCExecutor两个脚本引擎的封装，前者用于通过WebSocket链接到Chrome调试，后者则是内置默认引擎直接通过IOS SDK JSContext来实现相关的逻辑。</p>
<p>另外，在本阶段还会通过block hook的方式注册部分核心API</p>
<ul>
<li>1.nativeRequireModuleConfig：用于在JS端获取对应的Native Module，在0.14后的版本React Native已经对初始化模块做了部分优化，把关于Native Module Method部分的加载工作放置在requireModuleConfig时才做</li>
<li>2.nativeLoggingHook：调用Native写入日志</li>
<li>3.nativeFlushQueueImmediate：手动触发执行当前Native Call队列中所有的Native处理请求</li>
<li>4.nativePerformanceNow：用于性能统计，获取当前Native的绝对时间（毫秒）</li>
</ul>
<p>对于模块类中想要声明的方法，需要添加RCT_EXPORT_METHOD宏。它会给方法名添加” rct_export “前缀。</p>
<p>🌰：React 调用 Native 的 SVProgressHUD 提示窗</p>
<p>在 Native 中声明方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RCT_EXPORT_METHOD(calliOSActionWithOneParams:(<span class="built_in">NSString</span> *)name) &#123;</span><br><span class="line">    [SVProgressHUD setDefaultMaskType:SVProgressHUDMaskTypeBlack];</span><br><span class="line">    [SVProgressHUD showSuccessWithStatus:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"参数：%@"</span>,name]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 React 中调用 calliOSActionWithOneParams 方法<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;TouchableOpacity style=&#123;styles.calltonative&#125;</span><br><span class="line">    onPress=&#123;()=&gt;&#123;</span><br><span class="line">        RNCalliOSAction.calliOSActionWithOneParams(<span class="string">'hello'</span>);</span><br><span class="line">    &#125;&#125;&gt;</span><br><span class="line">    &lt;Text&gt;点击调用 Native 方法, 并传递一个参数&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>TouchableOpacity&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-Module-Config（并行）"><a href="#4-Module-Config（并行）" class="headerlink" title="4.Module Config（并行）"></a>4.Module Config（并行）</h4><p>这步将第2步中的Native模块类转换成Json，保存为remoteModuleConfig。注意在这里获取到的列表并非含有完整模块信息，而仅仅是一个Module List而已。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">"remoteModuleConfig"</span>:[</span><br><span class="line">[</span><br><span class="line"><span class="string">"HTSimpleAPI"</span>, <span class="comment">// module</span></span><br><span class="line">],</span><br><span class="line">[</span><br><span class="line"><span class="string">"RCTViewManager"</span>,</span><br><span class="line">],</span><br><span class="line">[</span><br><span class="line"><span class="string">"HTTestView"</span>,</span><br><span class="line">],</span><br><span class="line">[</span><br><span class="line"><span class="string">"RCTAccessibilityManager"</span>,</span><br><span class="line">],</span><br><span class="line">...</span><br><span class="line">],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="JS-Source-Code代码分析"><a href="#JS-Source-Code代码分析" class="headerlink" title="JS Source Code代码分析"></a>JS Source Code代码分析</h4><p>JS的主入口index.ios.js在我们看来只有短短数十行，然而这不是最终执行的代码。React-Native页面源码需要通过Transform Server转换处理，并把转化后的模块一起合并为一个bundle.js，这个过程称为buildBundle。转换后的index.ios.bundle才是最终可被Javascript引擎直接解释运行的代码。下面我们按照主程序的逻辑来分析源码几个核心模块实现原理。</p>
<p>在React Server中需要查看Bundle的模块映射关系可以直接访问：<a href="http://localhost:8081/index.ios.bundle.map，查看相关依赖和Bundle的缓存则可以访问：" target="_blank" rel="noopener">http://localhost:8081/index.ios.bundle.map，查看相关依赖和Bundle的缓存则可以访问：</a> <a href="http://localhost:8081/debug" target="_blank" rel="noopener">http://localhost:8081/debug</a></p>
<p>1.BatchedBridge</p>
<p>在上一部分我们知道，Native完成模块初始化后会通过Inject Json Config将配置信息同步至JS里中的全局变量__fbBatchedBridgeConfig，打开BatchedBridge.js我们可以看到如下代码。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__d(<span class="string">'BatchedBridge'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">global, require, module, exports</span>) </span>&#123; <span class="string">'use strict'</span>;</span><br><span class="line"><span class="keyword">var</span> MessageQueue=<span class="built_in">require</span>(<span class="string">'MessageQueue'</span>);</span><br><span class="line"><span class="keyword">var</span> BatchedBridge=<span class="keyword">new</span> MessageQueue(</span><br><span class="line">__fbBatchedBridgeConfig.remoteModuleConfig,</span><br><span class="line">__fbBatchedBridgeConfig.localModulesConfig);</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(global,<span class="string">'__fbBatchedBridge'</span>,&#123;<span class="attr">value</span>:BatchedBridge&#125;);</span><br><span class="line"><span class="built_in">module</span>.exports = BatchedBridge;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>对于这段代码，我们可以得出以下几个结论：</p>
<ul>
<li>1.在JS端也存在一个bridge模块BatchedBridge，也是与Native建立双向通信的关键所在</li>
<li>2.BatchedBridge是一个MessageQueue实例，它在创建时传入了__fbBatchedBridgeConfig值保存Native端支持的模块列表配置</li>
</ul>
<p>BatchedBridge在创建时将自己写入全局变量<strong>fbBatchedBridge上，这样Native可以通过JSContext[@”</strong>fbBatchedBridge”]访问到JS bridge对象。</p>
<p>2.MessageQueue</p>
<p>接着我们继续看MessageQueue，它在整个通讯链路的机制上面有着重要作用，首先我们来观察一下它的构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(remoteModules, localModules) &#123;</span><br><span class="line"><span class="keyword">this</span>.RemoteModules = &#123;&#125;;</span><br><span class="line"><span class="keyword">this</span>._callableModules = &#123;&#125;;</span><br><span class="line"><span class="keyword">this</span>._queue = [[], [], [], <span class="number">0</span>];</span><br><span class="line"><span class="keyword">this</span>._moduleTable = &#123;&#125;;</span><br><span class="line"><span class="keyword">this</span>._methodTable = &#123;&#125;;</span><br><span class="line"><span class="keyword">this</span>._callbacks = [];</span><br><span class="line"><span class="keyword">this</span>._callbackID = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>._callID = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="keyword">let</span> modulesConfig = <span class="keyword">this</span>._genModulesConfig(remoteModules);</span><br><span class="line"><span class="keyword">this</span>._genModules(modulesConfig);</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从构造函数，我们大致能了解MessageQueue的几个信息：</p>
<ul>
<li>1.RemoteModules属性，用于保存Native端模块配置</li>
<li>2.Callbacks属性缓存js的回调方法</li>
<li>3.Queue事件队列用于处理各类事件等</li>
</ul>
<p>在构造函数中，解析Native传入的remoteModules JSON，转换成JS对象</p>
<p>3.Config Modules</p>
<p>根据上一步MessageQueue的逻辑，继续往下跟踪_genModules函数，可以看到在MessageQueue已经对Native注入的Module Config做了一次预处理，如果debug模式可以看到大致的数据结构会转换成如下表中所示结构（其中HTSimepleAPI是一个自定义模块）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">config = [<span class="string">"HTSimpleAPI"</span>, <span class="built_in">Array</span>[<span class="number">1</span>]], moduleID = <span class="number">0</span></span><br><span class="line">config = <span class="literal">null</span>, moduleID = <span class="number">1</span></span><br><span class="line">config = <span class="literal">null</span>, moduleID = <span class="number">2</span></span><br><span class="line">config = [<span class="string">"RCTAccessibilityManager"</span>, <span class="built_in">Array</span>[<span class="number">3</span>]], moduleID = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>至于这样的预处理有什么作用，我们继续往下分析，后面再来总结。</p>
<p>4.Lazily Config Methods</p>
<p>对于NativeModule，它们在上一步之后只有一个包含Module Name等简单信息的Module List的对象，只有在实际调用了该模块之后才会加载该模块的具体信息（比如暴露的API等）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NativeModules = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(RemoteModules).forEach(<span class="function">(<span class="params">moduleName</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(NativeModules, moduleName, &#123;</span><br><span class="line">enumerable: <span class="literal">true</span>,</span><br><span class="line">get: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = RemoteModules[moduleName];</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.moduleID === <span class="string">'number'</span> &amp;&amp; global.nativeRequireModuleConfig) &#123;</span><br><span class="line"><span class="keyword">const</span> json = global.nativeRequireModuleConfig(moduleName);</span><br><span class="line"><span class="keyword">const</span> config = json &amp;&amp; <span class="built_in">JSON</span>.parse(json);</span><br><span class="line"><span class="built_in">module</span> = config &amp;&amp; BatchedBridge.processModuleConfig(config, <span class="built_in">module</span>.moduleID);</span><br><span class="line">RemoteModules[moduleName] = <span class="built_in">module</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">module</span>;</span><br><span class="line">&#125;,</span><br><span class="line">&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码定义了一个全局模块NativeModules，遍历之前取到的remoteModules，将每一个module在NativeModules对象上扩展了一个getter方法，该方法中通过nativeRequireModuleConfig进一步加载模块的详细信息，通过processModuleConfig对模块信息进行预处理。进一步分析代码就可以发现这个方法其实是Native中定义的全局JS Block（nativeRequireModuleConfig）。</p>
<p>接下来我们继续看processModuleConfig中具体的代码逻辑，如下表所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">processModuleConfig(config, moduleID) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">module</span> = <span class="keyword">this</span>._genModule(config, moduleID);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>;</span><br><span class="line">&#125;</span><br><span class="line">_genMethod(<span class="built_in">module</span>, method, type) &#123;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line">    fn = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> self.__nativeCall(<span class="built_in">module</span>, method, args, onFail, onSucc);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//......</span></span><br><span class="line"><span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>processModuleConfig方法的主要工作是生成methods配置，并对每一个method封装了一个闭包fn，当调用method时，会转换成成调用self.__nativeCall(moduleID, methodID, args, onFail, onSucc)方法</p>
<p>预处理完成后，在JavaScript环境中的Moudle Config信息才算完整，包含Module Name、Native Method等信息，具体信息如下所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">config = [<span class="string">"HTSimpleAPI"</span>, <span class="built_in">Array</span>[<span class="number">1</span>]], moduleID = <span class="number">0</span></span><br><span class="line">methodName = <span class="string">"test"</span>, methodID = <span class="number">0</span></span><br><span class="line">config = <span class="literal">null</span>, moduleID = <span class="number">1</span></span><br><span class="line">config = <span class="literal">null</span>, moduleID = <span class="number">2</span></span><br><span class="line">config = [<span class="string">"RCTAccessibilityManager"</span>, <span class="built_in">Array</span>[<span class="number">3</span>]], moduleID = <span class="number">3</span></span><br><span class="line">methodName = <span class="string">"setAccessibilityContentSizeMultipliers"</span>, methodID = <span class="number">0</span></span><br><span class="line">methodName = <span class="string">"getMultiplier"</span>, methodID = <span class="number">1</span></span><br><span class="line">methodName = <span class="string">"getCurrentVoiceOverState"</span>, methodID = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>还记得第二部分第5步中Native端生成的模块配置表吗？结合它的结构，我们可以得知：对于Module&amp;Method，在Native和JS端都以数组的形式存放，数组下标即为它们的ModuleID和MethodID。</p>
<p>5.__nativeCall</p>
<p>分析完Bridge部分的映射关系以及模块加载，那么我们再来看看最终调用Native代码是如何实现的。当JS调用module.method时，其实调用了self.<strong>nativeCall(module, method, args, onFail, onSucc)，对于</strong>nativeCall方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__nativeCall(<span class="built_in">module</span>, method, params, onFail, onSucc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (onFail || onSucc) &#123;</span><br><span class="line">    ......</span><br><span class="line">    onFail &amp;&amp; params.push(<span class="keyword">this</span>._callbackID);</span><br><span class="line">    <span class="keyword">this</span>._callbacks[<span class="keyword">this</span>._callbackID++] = onFail;</span><br><span class="line">    onSucc &amp;&amp; params.push(<span class="keyword">this</span>._callbackID);</span><br><span class="line">    <span class="keyword">this</span>._callbacks[<span class="keyword">this</span>._callbackID++] = onSucc;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">this</span>._queue[MODULE_IDS].push(<span class="built_in">module</span>);</span><br><span class="line"><span class="keyword">this</span>._queue[METHOD_IDS].push(method);</span><br><span class="line"><span class="keyword">this</span>._queue[PARAMS].push(params);</span><br><span class="line">global.nativeFlushQueueImmediate(<span class="keyword">this</span>._queue);</span><br><span class="line">......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码为每个method创建了一个闭包fn，在__nativeCall方法中，并且在这里做了两件重要的工作：</p>
<ul>
<li>1.把onFail和onSucc缓存到_callbacks中，同时把callbackID添加到params</li>
<li>2.把moduleID, methodID, params放入队列中，回调Native代码.</li>
</ul>
<p>__nativeCall如何做到回调Native代码呢？看第二部分第3步，在初始化JS引擎JSExecutor Setup时，Native端注册一个全局block回调nativeFlushedQueueImmediate，nativeCall在处理完毕后，通过该回调把队列作为返回值传给Native。nativeFlushedQueueImmediate的实现如下所示。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[self addSynchronousHookWithName:@<span class="string">"nativeFlushQueueImmediate"</span> usingBlock:^(NSArray *calls)&#123;</span><br><span class="line">RCTJSCExecutor *strongSelf = weakSelf;</span><br><span class="line">    <span class="keyword">if</span> (!strongSelf.valid || !calls) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">[strongSelf-&gt;_bridge handleBuffer:calls batchEnded:NO];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这里的handleBuffer就是Native端解析JS的模块调用最后通过NSInvocation机制调用Native代码对应的逻辑。有兴趣的朋友继续跟踪handleBuffer代码会发现，他的实现和React在JS端定义的MessageQueue有惊人的相似之处。</p>
<p>6.Call JS function &amp; Callbacks</p>
<p>最后，我们回过头来看看Native端是如何调用JS端的相关逻辑的，这部分我们需要回到MessageQueue.js代码中来，可以看到MessageQueue暴露了3个核心方法：’invokeCallbackAndReturnFlushedQueue’、’callFunctionReturnFlushedQueue’、’flushedQueue’。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将API暴露到全局作用域中</span></span><br><span class="line">[</span><br><span class="line"><span class="string">'invokeCallbackAndReturnFlushedQueue'</span>,</span><br><span class="line"><span class="string">'callFunctionReturnFlushedQueue'</span>,</span><br><span class="line"><span class="string">'flushedQueue'</span>,</span><br><span class="line">].forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> <span class="keyword">this</span>[fn] = <span class="keyword">this</span>[fn].bind(<span class="keyword">this</span>));</span><br><span class="line">…</span><br><span class="line"><span class="comment">// 声明带有返回值的函数</span></span><br><span class="line">callFunctionReturnFlushedQueue(<span class="built_in">module</span>, method, args) &#123;</span><br><span class="line">guard(<span class="function"><span class="params">()</span> =&gt;</span> &#123;C</span><br><span class="line"><span class="keyword">this</span>.__callFunction(<span class="built_in">module</span>, method, args);</span><br><span class="line"><span class="keyword">this</span>.__callImmediates();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.flushedQueue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 声明带有Callback的函数</span></span><br><span class="line">invokeCallbackAndReturnFlushedQueue(cbID, args) &#123;</span><br><span class="line">guard(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">this</span>.__invokeCallback(cbID, args);</span><br><span class="line"><span class="keyword">this</span>.__callImmediates();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.flushedQueue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>callFunctionReturnFlushedQueue用于实现Native调用带有返回值的JS端函数（这里的返回值也是通过Queue来模拟）；<br>invokeCallbackAndReturnFlushedQueue用于实现Native调用带有Call的JS端函数（可以将Native的Callback作为JS端函数的入参，JS端执行完后调用Native的Callback）。</p>
<p>对于callFunctionReturnFlushedQueue方法，它最终调用的是__callFunction：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__callFunction(<span class="built_in">module</span>, method, args) &#123;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">var</span> moduleMethods = <span class="keyword">this</span>._callableModules[<span class="built_in">module</span>];</span><br><span class="line">......</span><br><span class="line">moduleMethods[method].apply(moduleMethods, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，此处会根据Native传入的module, method，调用JS端相应的模块并传入参数列表args.<br>同时我们又可以获得对于MessageQueue的另一条推测，_callableModules用来存放JS端暴露给Native的模块，进一步分析我们可以发现SDK中正是通过registerCallableModules方法注册JS端暴露API模块。</p>
<p>对于JS bridge提供的调用回调方法invokeCallbackAndReturnFlushedQueue，原理上和callFunction差不多，不再细说。</p>
<h4 id="JS-Native-通信原理"><a href="#JS-Native-通信原理" class="headerlink" title="JS  Native 通信原理"></a>JS <-> Native 通信原理</-></h4><p>1.Native-&gt;JS</p>
<p>综上所述，在JS端提供callFunctionReturnFlushedQueue，Native bridge调用JS端方法时，应该使用这个方法。查看Native代码实现可知，RCTBridge封装了enqueueJSCall方法调用JS，梳理Native-&gt;JS的整体交互流程如下图所示。</p>
<p><img src="http://og1yl0w9z.bkt.clouddn.com/18-5-11/44610127.jpg" alt=""></p>
<p>之前已经论述过，如果在NATIVE端需要自定义模块提供给JS端使用那么该类需要实现RCTBridgeModule协议 。</p>
<p>此外，React-Native提供了另一种基于通知的方式，通过RCTEventDispatcher发送消息通知 。eventDispatcher作为Native Bridge的属性，封装了sendEventWithName:body:方法。使用时，Native中类同样需要实现RCTBridgeModule协议，通过self.bridge发送通知，JS端对应事件的EventEmitter添加监听处理调用。</p>
<blockquote>
<p>查看sendEvent方法的代码可以发现，这种方式本质上还是调用enqueueJSCall方法。官方推荐我们使用通知的方式来实现 Native-&gt;JS，这样可以减少模块初始化加载解析的时间。</p>
</blockquote>
<p>2.JS-&gt;Native</p>
<p>最后，我们来看一下JS如何调用Native。答案是JS不会主动传递数据给Native，也不能直接调用Native（一种情况除外，在入口直接通过NativeModules调用API），只有在Native调用JS时才会通过返回值触发调用。因为Native是基于事件响应机制的，比如触摸事件、启动事件、定时器事件、回调事件等。</p>
<p>当事件发生时，Native会调用JS相应模块处理，完毕后再通过返回值把队列传递给Native执行对应的代码。</p>
<p><img src="http://og1yl0w9z.bkt.clouddn.com/18-5-11/39019479.jpg" alt=""></p>
<p>如上图所示，整个调用过程可以归纳为：</p>
<ul>
<li>1.JS把需要Module, Method, args(CallbackID)保存在队列中， 作为返回值通过blocks回调Native</li>
<li>2.Native调用相应模块方法，完成</li>
<li>3.Native通过CallbackID调用JS回调</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>React Native的通讯基础建立在传统的JS Bridge之上，不过对于Bridge处理的MessageQueue机制、模块定义、加载机制上的巧妙处理指的借鉴。对于上述的整个原理解析可以概括为以下四个部分：</p>
<ul>
<li>1.在启动阶段，初始化JS引擎，生成Native端模块配置表存于两端，其中模块配置是同步取得，而各模块的方法配置在该方法被真正调用时懒加载。</li>
<li>2.Native和JS端分别有一个bridge，发生调用时，调用端bridge查找模块配置表将调用转换成{moduleID, methodID, args(callbackID)}，处理端通过同一份模块配置表转换为实际的方法实现。</li>
<li>3.Native-&gt;JS，原理上使用JSCore从Native执行JS代码，React-Native在此基础上给我们提供了通知发送的执行方式。</li>
<li>4.JS-&gt;Native，原理上JS并不主动调用Native，而是把方法和参数(回调)缓存到队列中，在Native事件触发并访问JS后，通过blocks回调Native。</li>
</ul>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="pagination" role="pagination">
    
    <a class="pull-left" href="/2018/06/16/Singleton/" style="float: left;">
        ← Objective-C Principle - Singleton
    </a>
    
    
    <a class="pull-right" href="/2018/05/09/thread-p/">
        Objective-C Principle - Thread →
    </a>
    
</nav>

        <div class="duoshuo"></div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By Steven. All Rights Reserved.
                </p>
                <p>Theme By <a href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/ReverseScale" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="http://www.weibo.com/5844576818/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a>&nbsp;</li>
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
        
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };
    
    resizeHero();
    
    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/jquery.flexslider-min.js"></script><!-- Flexslider plugin -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->

<!-- Initiate flexslider plugin -->
<script type="text/javascript">
    $(document).ready(function($) {
      $('.flexslider').flexslider({
        animation: "fade",
        prevText: "",
        nextText: "",
        directionNav: true
      });
    });
</script>

</body>
</html>
