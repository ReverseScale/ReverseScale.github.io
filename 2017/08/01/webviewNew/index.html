<!DOCTYPE html>
<!--[if lte IE 8 ]>
<html class="ie" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<![endif]-->
<!--[if (gte IE 9)|!(IE)]><!-->
<!--
***************  *      *     *
      8          *    *       *
      8          *  *         *
      8          **           *
      8          *  *         *
      8          *    *       *
      8          *      *     *
      8          *        *   ***********    -----Theme By Kieran(http://go.kieran.top)
-->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en-US" lang="en-US">
<!--<![endif]-->

<head>
  <title>WKWebView 坑集合 | Steven&#39;s Technology Blog</title>
  <!-- Meta data -->
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="generator" content="Steven's Technology Blog">
    <meta name="author" content="Steven">
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <!-- Favicon, (keep icon in root folder) -->
    <link rel="Shortcut Icon" href="/img/favicon.ico" type="image/ico">

    <link rel="alternate" href="/atom.xml" title="Steven&#39;s Technology Blog" type="application/atom+xml">
    <link rel="stylesheet" href="/css/all.css" media="screen" type="text/css">
	
    <link rel="stylesheet" href="/highlightjs/vs.css" type="text/css">
    
    

    <!-- Custom stylesheet, (add custom styles here, always load last) -->
    <!-- Load our stylesheet for IE8 -->
    <!--[if IE 8]>
    <link rel="stylesheet" type="text/css" href="/css/ie8.css" />
    <![endif]-->

    <!-- Google Webfonts (Monserrat 400/700, Open Sans 400/600) -->
    <link href='//fonts.useso.com/css?family=Montserrat:400,700' rel='stylesheet' type='text/css'>
    <link href='//fonts.useso.com/css?family=Open+Sans:400,600' rel='stylesheet' type='text/css'>

    <!-- Load our fonts individually if IE8+, to avoid faux bold & italic rendering -->
    <!--[if IE]>
    <link href='http://fonts.useso.com/css?family=Montserrat:400' rel='stylesheet' type='text/css'>
    <link href='http://fonts.useso.com/css?family=Montserrat:700' rel='stylesheet' type='text/css'>
    <link href='http://fonts.useso.com/css?family=Open+Sans:400' rel='stylesheet' type='text/css'>
    <link href='http://fonts.useso.com/css?family=Open+Sans:600' rel='stylesheet' type='text/css'>
    <![endif]-->

    <!-- jQuery | Load our jQuery, with an alternative source fallback to a local version if request is unavailable -->
    <script src="/js/jquery-1.11.1.min.js"></script>
    <script>window.jQuery || document.write('<script src="js/jquery-1.11.1.min.js"><\/script>')</script>

    <!-- Load these in the <head> for quicker IE8+ load times -->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
    <script src="/js/html5shiv.min.js"></script>
    <script src="/js/respond.min.js"></script>
    <![endif]-->










  
  
  

  
  <style>.col-md-8.col-md-offset-2.opening-statement img{display:none;}</style>
</head>

<!--
<body class="post-template">
-->
<body id="index" class="lightnav animsition">

      <!-- ============================ Off-canvas navigation =========================== -->

    <div class="sb-slidebar sb-right sb-style-overlay sb-momentum-scrolling">
        <div class="sb-close" aria-label="Close Menu" aria-hidden="true">
            <img src="/img/close.png" alt="Close"/>
        </div>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu">
            <li><a href="/" class="animsition-link" title="Home">Home</a></li>
            <li><a href="/archives" class="animsition-link" title="archive">archives</a></li>
            <!-- Dropdown Menu -->
			 
            <li>
                <a class="sb-toggle-submenu">Works<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                        <li><a href="/tags/博客，文章" target="_BLANK" class="animsition-link">文章</a></li>
                    
                        <li><a href="/tags/博客，资料" target="_BLANK" class="animsition-link">资料</a></li>
                    
                </ul>
            </li>
            
            
        	<li>
        		<a class="sb-toggle-submenu">Categories<span class="sb-caret"></span></a>
            	<ul class="sb-submenu">
				  	
				    <li><a href="/categories/API/" class="animsition-link">API<small>(1)</small></a></li>
				    
				    <li><a href="/categories/Android/" class="animsition-link">Android<small>(1)</small></a></li>
				    
				    <li><a href="/categories/Git/" class="animsition-link">Git<small>(1)</small></a></li>
				    
				    <li><a href="/categories/HTML5/" class="animsition-link">HTML5<small>(5)</small></a></li>
				    
				    <li><a href="/categories/Markdown/" class="animsition-link">Markdown<small>(1)</small></a></li>
				    
				    <li><a href="/categories/PHP/" class="animsition-link">PHP<small>(1)</small></a></li>
				    
				    <li><a href="/categories/Tools/" class="animsition-link">Tools<small>(2)</small></a></li>
				    
				    <li><a href="/categories/Unity-3D/" class="animsition-link">Unity 3D<small>(1)</small></a></li>
				    
				    <li><a href="/categories/iOS/" class="animsition-link">iOS<small>(111)</small></a></li>
				    
				    <li><a href="/categories/前沿技术/" class="animsition-link">前沿技术<small>(5)</small></a></li>
				    
				    <li><a href="/categories/文章/" class="animsition-link">文章<small>(5)</small></a></li>
				    
				    <li><a href="/categories/设计/" class="animsition-link">设计<small>(4)</small></a></li>
				    
				</ul>
        	</li>
			
            
            <li>
                <a class="sb-toggle-submenu">Links<span class="sb-caret"></span></a>
                <ul class="sb-submenu">
                    
                    <li><a href="https://reversescale.github.io" class="animsition-link">Steven</a></li>
                    
                    <li><a href="https://blog.ibeats.top" class="animsition-link">CI_Knight</a></li>
                    
                </ul>
            </li>
            
        </ul>
        <!-- Lists in Slidebars -->
        <ul class="sb-menu secondary">
            <li><a href="/about.html" class="animsition-link" title="about">About</a></li>
            <li><a href="/atom.xml" class="animsition-link" title="rss">RSS</a></li>
        </ul>
    </div>
    
    <!-- ============================ END Off-canvas navigation =========================== -->

    <!-- ============================ #sb-site Main Page Wrapper =========================== -->

    <div id="sb-site">
        <!-- #sb-site - All page content should be contained within this id, except the off-canvas navigation itself -->

        <!-- ============================ Header & Logo bar =========================== -->

        <div id="navigation" class="navbar navbar-fixed-top">
            <div class="navbar-inner">
                <div class="container">
                    <!-- Nav logo -->
                    <div class="logo">
                        <a href="/" title="Logo" class="animsition-link">
                         <img src="/img/logo.png" alt="Logo" width="35px;"/> 
                        </a>
                    </div>
                    <!-- // Nav logo -->
                    <!-- Info-bar -->
                    <nav>
                        <ul class="nav">
                            <li><a href="/" class="animsition-link">Steven's Technology Blog</a></li>
                            <li class="nolink"><span>Always </span>Creative.</li>
                            
                            <li><a href="https://github.com/ReverseScale" title="Github" target="_blank"><i class="icon-github"></i></a></li>
                            
                            
                            <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a></li>
                            
                            
                            <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a></li>
                            
                            
                            <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a></li>
                            
                            
                            <li><a href="http://www.weibo.com/5844576818/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a></li>
                            
                            <li class="nolink"><span>Welcome!</span></li>
                        </ul>
                    </nav>
                    <!--// Info-bar -->
                </div>
                <!-- // .container -->
                <div class="learnmore sb-toggle-right">More</div>
                <button type="button" class="navbar-toggle menu-icon sb-toggle-right" title="More">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar before"></span>
                <span class="icon-bar main"></span>
                <span class="icon-bar after"></span>
                </button>
            </div>
            <!-- // .navbar-inner -->
        </div>

        <!-- ============================ Header & Logo bar =========================== -->


      
<section id="intro">
    <div class="container">
        <div class="row col-md-offset-2">
            <div class="col-md-8">
    			<span class="post-meta">
      <time datetime="2017-08-01T12:54:26.000Z" itemprop="datePublished">
          2017-08-01
      </time>
    
    
    | 
    <a href='/tags/博客，文章/'>博客，文章</a>
    
    
</span>
                <h1>WKWebView 坑集合</h1>
            </div>
        </div>
        <div class="col-md-8 col-md-offset-2">
      		<p>#WKWebView 是苹果在 WWDC 2014 上推出的新一代 webView 组件，用以替代 UIKit 中笨重难用、内存泄漏的 UIWebView。WKWebView 拥有60fps滚动刷新率、和 safari 相同的 JavaScript 引擎等优势。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a><!--more--></h2><p><img src="http://og1yl0w9z.bkt.clouddn.com/17-8-1/83082295.jpg" alt=""></p>
<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>简单的适配方法本文不再赘述，主要来说说适配 WKWebView 过程中填过的坑以及善待解决的技术难题。</p>
<h3 id="1、WKWebView-白屏问题"><a href="#1、WKWebView-白屏问题" class="headerlink" title="1、WKWebView 白屏问题"></a>1、WKWebView 白屏问题</h3><p>WKWebView 自诩拥有更快的加载速度，更低的内存占用，但实际上 WKWebView 是一个多进程组件，Network Loading 以及 UI Rendering 在其它进程中执行。初次适配 WKWebView 的时候，我们也惊讶于打开 WKWebView 后，App 进程内存消耗反而大幅下降，但是仔细观察会发现，Other Process 的内存占用会增加。在一些用 webGL 渲染的复杂页面，使用 WKWebView 总体的内存占用（App Process Memory + Other Process Memory）不见得比 UIWebView 少很多。</p>
<p>在 UIWebView 上当内存占用太大的时候，App Process 会 crash；而在 WKWebView 上当总体的内存占用比较大的时候，WebContent Process 会 crash，从而出现白屏现象。在 WKWebView 中加载下面的测试链接可以稳定重现白屏现象:</p>
<blockquote>
<p><a href="http://people.mozilla.org/~rnewman/fennec/mem.html" target="_blank" rel="external">http://people.mozilla.org/~rnewman/fennec/mem.html</a></p>
</blockquote>
<p>这个时候 WKWebView.URL 会变为 nil, 简单的 reload 刷新操作已经失效，对于一些长驻的H5页面影响比较大。</p>
<p>我们最后的解决方案是：</p>
<h4 id="A、借助-WKNavigtionDelegate"><a href="#A、借助-WKNavigtionDelegate" class="headerlink" title="A、借助 WKNavigtionDelegate"></a>A、借助 WKNavigtionDelegate</h4><p>iOS 9以后 WKNavigtionDelegate 新增了一个回调函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">* (void)webViewWebContentProcessDidTerminate:(WKWebView*)webView API_AVAILABLE(macosx(10.11), ios(9.0));</div></pre></td></tr></table></figure></p>
<p>当 WKWebView 总体内存占用过大，页面即将白屏的时候，系统会调用上面的回调函数，我们在该函数里执行[webView reload](这个时候 webView.URL 取值尚不为 nil）解决白屏问题。在一些高内存消耗的页面可能会频繁刷新当前页面，H5侧也要做相应的适配操作。</p>
<h4 id="B、检测-webView-title-是否为空"><a href="#B、检测-webView-title-是否为空" class="headerlink" title="B、检测 webView.title 是否为空"></a>B、检测 webView.title 是否为空</h4><p>并不是所有H5页面白屏的时候都会调用上面的回调函数，比如，最近遇到在一个高内存消耗的H5页面上 present 系统相机，拍照完毕后返回原来页面的时候出现白屏现象（拍照过程消耗了大量内存，导致内存紧张，WebContent Process 被系统挂起），但上面的回调函数并没有被调用。在WKWebView白屏的时候，另一种现象是 webView.titile 会被置空, 因此，可以在 viewWillAppear 的时候检测 webView.title 是否为空来 reload 页面。</p>
<p>综合以上两种方法可以解决绝大多数的白屏问题。</p>
<h3 id="2、WKWebView-Cookie-问题"><a href="#2、WKWebView-Cookie-问题" class="headerlink" title="2、WKWebView Cookie 问题"></a>2、WKWebView Cookie 问题</h3><p>Cookie 问题是目前 WKWebView 的一大短板</p>
<h4 id="2-1、WKWebView-Cookie存储"><a href="#2-1、WKWebView-Cookie存储" class="headerlink" title="2.1、WKWebView Cookie存储"></a>2.1、WKWebView Cookie存储</h4><p>业界普遍认为 WKWebView 拥有自己的私有存储，不会将 Cookie 存入到标准的 Cookie 容器 NSHTTPCookieStorage 中。</p>
<p>实践发现 WKWebView 实例其实也会将 Cookie 存储于 NSHTTPCookieStorage 中，但存储时机有延迟，在iOS 8上，当页面跳转的时候，当前页面的 Cookie 会写入 NSHTTPCookieStorage 中，而在 iOS 10 上，JS 执行 document.cookie 或服务器 set-cookie 注入的 Cookie 会很快同步到 NSHTTPCookieStorage 中，FireFox 工程师曾建议通过 reset WKProcessPool 来触发 Cookie 同步到 NSHTTPCookieStorage 中，实践发现不起作用，并可能会引发当前页面 session cookie 丢失等问题。</p>
<p>WKWebView Cookie 问题在于 WKWebView 发起的请求不会自动带上存储于 NSHTTPCookieStorage 容器中的 Cookie。</p>
<p>比如，NSHTTPCookieStorage 中存储了一个 Cookie:</p>
<p>name=Nicholas;value=test;domain=y.qq.com;expires=Sat, 02 May 2019 23:38:25 GMT；<br>通过 UIWebView 发起请求<a href="http://y.qq.com，" target="_blank" rel="external">http://y.qq.com，</a> 则请求头会自动带上 cookie: Nicholas=test；<br>而通过 WKWebView发起请求<a href="http://y.qq.com，" target="_blank" rel="external">http://y.qq.com，</a> 请求头不会自动带上 cookie: Nicholas=test。</p>
<h4 id="2-2、WKProcessPool"><a href="#2-2、WKProcessPool" class="headerlink" title="2.2、WKProcessPool"></a>2.2、WKProcessPool</h4><p>苹果开发者文档对 WKProcessPool 的定义是：A WKProcessPool object represents a pool of Web Content process. 通过让所有 WKWebView 共享同一个 WKProcessPool 实例，可以实现多个 WKWebView 之间共享 Cookie（session Cookie and persistent Cookie）数据。不过 WKWebView WKProcessPool 实例在 app 杀进程重启后会被重置，导致 WKProcessPool 中的 Cookie、session Cookie 数据丢失，目前也无法实现 WKProcessPool 实例本地化保存。</p>
<h4 id="2-3、Workaround"><a href="#2-3、Workaround" class="headerlink" title="2.3、Workaround"></a>2.3、Workaround</h4><p>由于许多 H5 业务都依赖于 Cookie 作登录态校验，而 WKWebView 上请求不会自动携带 Cookie, 目前的主要解决方案是：</p>
<h5 id="a、WKWebView-loadRequest-前，在-request-header-中设置-Cookie-解决首个请求-Cookie-带不上的问题；"><a href="#a、WKWebView-loadRequest-前，在-request-header-中设置-Cookie-解决首个请求-Cookie-带不上的问题；" class="headerlink" title="a、WKWebView loadRequest 前，在 request header 中设置 Cookie, 解决首个请求 Cookie 带不上的问题；"></a>a、WKWebView loadRequest 前，在 request header 中设置 Cookie, 解决首个请求 Cookie 带不上的问题；</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">WKWebView * webView = [WKWebView new];</div><div class="line">NSMutableURLRequest * request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://h5.qzone.qq.com/mqzone/index&quot;]];</div><div class="line">[request addValue:@&quot;skey=skeyValue&quot; forHTTPHeaderField:@&quot;Cookie&quot;];</div><div class="line">[webView loadRequest:request];</div></pre></td></tr></table></figure>
<h5 id="b、通过-document-cookie-设置-Cookie-解决后续页面-同域-Ajax、iframe-请求的-Cookie-问题；"><a href="#b、通过-document-cookie-设置-Cookie-解决后续页面-同域-Ajax、iframe-请求的-Cookie-问题；" class="headerlink" title="b、通过 document.cookie 设置 Cookie 解决后续页面(同域)Ajax、iframe 请求的 Cookie 问题；"></a>b、通过 document.cookie 设置 Cookie 解决后续页面(同域)Ajax、iframe 请求的 Cookie 问题；</h5><p>注意：document.cookie()无法跨域设置 cookie<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">WKUserContentController* userContentController = [WKUserContentController new];</div><div class="line">WKUserScript * cookieScript = [[WKUserScript alloc] initWithSource: @&quot;document.cookie = &apos;skey=skeyValue&apos;;&quot; injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];</div><div class="line">[userContentController addUserScript:cookieScript];</div></pre></td></tr></table></figure></p>
<p>这种方案无法解决302请求的 Cookie 问题，比如，第一个请求是 www.a.com，我们通过在 request header 里带上 Cookie 解决该请求的 Cookie 问题，接着页面302跳转到 www.b.com，这个时候 www.b.com 这个请求就可能因为没有携带 cookie 而无法访问。当然，由于每一次页面跳转前都会调用回调函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- (void)webView:(WKWebView*)webView decidePolicyForNavigationAction:(WKNavigationAction*)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler;</div></pre></td></tr></table></figure></p>
<p>可以在该回调函数里拦截302请求，copy request，在 request header 中带上 cookie 并重新 loadRequest。不过这种方法依然解决不了页面 iframe 跨域请求的 Cookie 问题，毕竟-[WKWebView loadRequest:]只适合加载 mainFrame 请求。</p>
<h3 id="3、WKWebView-NSURLProtocol问题"><a href="#3、WKWebView-NSURLProtocol问题" class="headerlink" title="3、WKWebView NSURLProtocol问题"></a>3、WKWebView NSURLProtocol问题</h3><p>WKWebView 在独立于 app 进程之外的进程中执行网络请求，请求数据不经过主进程，因此，在 WKWebView 上直接使用 NSURLProtocol 无法拦截请求。苹果开源的 webKit2 源码暴露了私有API：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+ [WKBrowsingContextController registerSchemeForCustomProtocol:]</div></pre></td></tr></table></figure></p>
<p>通过注册 http(s) scheme 后 WKWebView 将可以使用 NSURLProtocol 拦截 http(s) 请求：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Class cls = NSClassFromString(@&quot;WKBrowsingContextController”);</div><div class="line">SEL sel = NSSelectorFromString(@&quot;registerSchemeForCustomProtocol:&quot;);</div><div class="line">if ([(id)cls respondsToSelector:sel]) &#123;</div><div class="line">           // 注册http(s) scheme, 把 http和https请求交给 NSURLProtocol处理</div><div class="line">           [(id)cls performSelector:sel withObject:@&quot;http&quot;];</div><div class="line">           [(id)cls performSelector:sel withObject:@&quot;https&quot;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是这种方案目前存在两个严重缺陷：</p>
<h5 id="a、post-请求-body-数据被清空"><a href="#a、post-请求-body-数据被清空" class="headerlink" title="a、post 请求 body 数据被清空"></a>a、post 请求 body 数据被清空</h5><p>由于 WKWebView 在独立进程里执行网络请求。一旦注册 http(s) scheme 后，网络请求将从 Network Process 发送到 App Process，这样 NSURLProtocol 才能拦截网络请求。在 webkit2 的设计里使用 MessageQueue 进行进程之间的通信，Network Process 会将请求 encode 成一个 Message,然后通过 IPC 发送给 App Process。出于性能的原因，encode 的时候 HTTPBody 和 HTTPBodyStream 这两个字段被丢弃掉了。</p>
<p>参考苹果源码：<br><a href="https://github.com/WebKit/webkit/blob/fe39539b83d28751e86077b173abd5b7872ce3f9/Source/WebKit2/Shared/mac/WebCoreArgumentCodersMac.mm#L61-L88" target="_blank" rel="external">https://github.com/WebKit/webkit/blob/fe39539b83d28751e86077b173abd5b7872ce3f9/Source/WebKit2/Shared/mac/WebCoreArgumentCodersMac.mm#L61-L88</a></p>
<p>及bug report:<br><a href="https://bugs.webkit.org/show_bug.cgi?id=138169" target="_blank" rel="external">https://bugs.webkit.org/show_bug.cgi?id=138169</a></p>
<p>因此，如果通过 registerSchemeForCustomProtocol 注册了 http(s) scheme, 那么由 WKWebView 发起的所有 http(s)请求都会通过 IPC 传给主进程 NSURLProtocol 处理，导致 post 请求 body 被清空；</p>
<h5 id="b、对ATS支持不足"><a href="#b、对ATS支持不足" class="headerlink" title="b、对ATS支持不足"></a>b、对ATS支持不足</h5><p>测试发现一旦打开ATS开关：Allow Arbitrary Loads 选项设置为NO，同时通过 registerSchemeForCustomProtocol 注册了 http(s) scheme，WKWebView 发起的所有 http 网络请求将被阻塞（即便将Allow Arbitrary Loads in Web Content 选项设置为YES）；</p>
<p>WKWebView 可以注册 customScheme, 比如 dynamic://, 因此希望使用离线功能又不使用 post 方式的请求可以通过 customScheme 发起请求，比如 dynamic://www.dynamicalbumlocalimage.com/，然后在 app 进程 NSURLProtocol 拦截这个请求并加载离线数据。不足：使用 post 方式的请求该方案依然不适用，同时需要 H5 侧修改请求 scheme 以及 CSP 规则；</p>
<h4 id="4、WKWebView-loadRequest-问题"><a href="#4、WKWebView-loadRequest-问题" class="headerlink" title="4、WKWebView loadRequest 问题"></a>4、WKWebView loadRequest 问题</h4><p>在 WKWebView 上通过 loadRequest 发起的 post 请求 body 数据会丢失：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//同样是由于进程间通信性能问题，HTTPBody字段被丢弃</div><div class="line">[request setHTTPMethod:@&quot;POST&quot;];</div><div class="line">[request setHTTPBody:[@&quot;bodyData&quot; dataUsingEncoding:NSUTF8StringEncoding]];</div><div class="line">[wkwebview loadRequest: request];</div><div class="line">workaround:</div></pre></td></tr></table></figure></p>
<p>假如想通过-[WKWebView loadRequest:]加载 post 请求 request1: <a href="http://h5.qzone.qq.com/mqzone/index,可以通过以下步骤实现：" target="_blank" rel="external">http://h5.qzone.qq.com/mqzone/index,可以通过以下步骤实现：</a></p>
<p>替换请求 scheme，生成新的 post 请求 request2: post://h5.qzone.qq.com/mqzone/index, 同时将 request1 的 body 字段复制到 request2 的 header 中（WebKit 不会丢弃 header 字段）;<br>通过-[WKWebView loadRequest:]加载新的 post 请求 request2;<br>通过 +[WKBrowsingContextController registerSchemeForCustomProtocol:]注册 scheme: post://;<br>注册 NSURLProtocol 拦截请求post://h5.qzone.qq.com/mqzone/index ,替换请求 scheme, 生成新的请求 request3: <a href="http://h5.qzone.qq.com/mqzone/index，将" target="_blank" rel="external">http://h5.qzone.qq.com/mqzone/index，将</a> request2 header的body 字段复制到 request3 的 body 中，并使用 NSURLConnection 加载 request3，最后通过 NSURLProtocolClient 将加载结果返回 WKWebView;</p>
<h4 id="5、WKWebView-页面样式问题"><a href="#5、WKWebView-页面样式问题" class="headerlink" title="5、WKWebView 页面样式问题"></a>5、WKWebView 页面样式问题</h4><p>在 WKWebView 适配过程中，我们发现部分H5页面元素位置向下偏移或被拉伸变形，追踪后发现主要是H5页面高度值异常导致：</p>
<h4 id="a-空间H5页面有透明导航、透明导航下拉刷新、全屏等需求，因此之前-webView-整个是从（0-0）开始布局，通过调整webView-scrollView-contentInset-来适配特殊导航栏需求。而在-WKWebView-上对-contentInset-的调整会反馈到webView-scrollView-contentSize-height的变化上，比如设置-webView-scrollView-contentInset-top-a，那么contentSize-height的值会增加a-导致H5页面长度增加，页面元素位置向下偏移；"><a href="#a-空间H5页面有透明导航、透明导航下拉刷新、全屏等需求，因此之前-webView-整个是从（0-0）开始布局，通过调整webView-scrollView-contentInset-来适配特殊导航栏需求。而在-WKWebView-上对-contentInset-的调整会反馈到webView-scrollView-contentSize-height的变化上，比如设置-webView-scrollView-contentInset-top-a，那么contentSize-height的值会增加a-导致H5页面长度增加，页面元素位置向下偏移；" class="headerlink" title="a. 空间H5页面有透明导航、透明导航下拉刷新、全屏等需求，因此之前 webView 整个是从（0, 0）开始布局，通过调整webView.scrollView.contentInset 来适配特殊导航栏需求。而在 WKWebView 上对 contentInset 的调整会反馈到webView.scrollView.contentSize.height的变化上，比如设置 webView.scrollView.contentInset.top = a，那么contentSize.height的值会增加a,导致H5页面长度增加，页面元素位置向下偏移；"></a>a. 空间H5页面有透明导航、透明导航下拉刷新、全屏等需求，因此之前 webView 整个是从（0, 0）开始布局，通过调整webView.scrollView.contentInset 来适配特殊导航栏需求。而在 WKWebView 上对 contentInset 的调整会反馈到webView.scrollView.contentSize.height的变化上，比如设置 webView.scrollView.contentInset.top = a，那么contentSize.height的值会增加a,导致H5页面长度增加，页面元素位置向下偏移；</h4><p>解决方案是：调整WKWebView布局方式，避免调整webView.scrollView.contentInset。实际上，即便在 UIWebView 上也不建议直接调整webView.scrollView.contentInset的值，这确实会带来一些奇怪的问题。如果某些特殊情况下非得调整 contentInset 不可的话，可以通过下面方式让H5页面恢复正常显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/**设置contentInset值后通过调整webView.frame让页面恢复正常显示</div><div class="line"> *参考：http://km.oa.com/articles/show/277372</div><div class="line"> */</div><div class="line">webView.scrollView.contentInset = UIEdgeInsetsMake(a, 0, 0, 0);</div><div class="line">webView.frame = CGRectMake(webView.frame.origin.x, webView.frame.origin.y, webView.frame.size.width, webView.frame.size.height - a);</div></pre></td></tr></table></figure></p>
<h5 id="b-在接入-now-直播的时候，我们发现在-iOS-9-上-WKWebView-会出现页面被拉伸变形的情况，最后发现是window-innerHeight值不准确导致（在WKWebView上返回了一个非常大的值），而H5同学通过获取window-innerHeight来设置页面高度，导致页面整体被拉伸。通过查阅相关资料发现，这个bug只在-iOS-9-的几个系统版本上出现，苹果后来fix了这个bug。我们最后的解决方案是：延迟调用window-innerHeight"><a href="#b-在接入-now-直播的时候，我们发现在-iOS-9-上-WKWebView-会出现页面被拉伸变形的情况，最后发现是window-innerHeight值不准确导致（在WKWebView上返回了一个非常大的值），而H5同学通过获取window-innerHeight来设置页面高度，导致页面整体被拉伸。通过查阅相关资料发现，这个bug只在-iOS-9-的几个系统版本上出现，苹果后来fix了这个bug。我们最后的解决方案是：延迟调用window-innerHeight" class="headerlink" title="b. 在接入 now 直播的时候，我们发现在 iOS 9 上 WKWebView 会出现页面被拉伸变形的情况，最后发现是window.innerHeight值不准确导致（在WKWebView上返回了一个非常大的值），而H5同学通过获取window.innerHeight来设置页面高度，导致页面整体被拉伸。通过查阅相关资料发现，这个bug只在 iOS 9 的几个系统版本上出现，苹果后来fix了这个bug。我们最后的解决方案是：延迟调用window.innerHeight"></a>b. 在接入 now 直播的时候，我们发现在 iOS 9 上 WKWebView 会出现页面被拉伸变形的情况，最后发现是window.innerHeight值不准确导致（在WKWebView上返回了一个非常大的值），而H5同学通过获取window.innerHeight来设置页面高度，导致页面整体被拉伸。通过查阅相关资料发现，这个bug只在 iOS 9 的几个系统版本上出现，苹果后来fix了这个bug。我们最后的解决方案是：延迟调用window.innerHeight</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setTimeout(function()&#123;height = window.innerHeight&#125;,0);</div><div class="line">or</div><div class="line">Use shrink-to-fit meta-tag</div><div class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1, shrink-to-fit=no&quot;&gt;</div></pre></td></tr></table></figure>
<h4 id="6、WKWebView-截屏问题"><a href="#6、WKWebView-截屏问题" class="headerlink" title="6、WKWebView 截屏问题"></a>6、WKWebView 截屏问题</h4><p>空间玩吧H5小游戏有截屏分享的功能，WKWebView 下通过 -[CALayer renderInContext:]实现截屏的方式失效，需要通过以下方式实现截屏功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@implementation UIView (ImageSnapshot)</div><div class="line">- (UIImage*)imageSnapshot &#123;</div><div class="line">UIGraphicsBeginImageContextWithOptions(self.bounds.size,YES,self.contentScaleFactor);</div><div class="line">    [self drawViewHierarchyInRect:self.bounds afterScreenUpdates:YES];</div><div class="line">    UIImage* newImage = UIGraphicsGetImageFromCurrentImageContext();</div><div class="line">    UIGraphicsEndImageContext();</div><div class="line">    return newImage;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>然而这种方式依然解决不了 webGL 页面的截屏问题，笔者已经翻遍苹果文档，研究过 webKit2 源码里的截屏私有API，依然没有找到合适的解决方案，同时发现 Safari 以及 Chrome 这两个全量切换到 WKWebView 的浏览器也存在同样的问题：对webGL 页面的截屏结果不是空白就是纯黑图片。无奈之下，我们只能约定一个JS接口，让游戏开发商实现该接口，具体是通过 canvas getImageData()方法取得图片数据后返回 base64 格式的数据，客户端在需要截图的时候，调用这个JS接口获取 base64 String 并转换成 UIImage。</p>
<h4 id="7、WKWebView-crash问题"><a href="#7、WKWebView-crash问题" class="headerlink" title="7、WKWebView crash问题"></a>7、WKWebView crash问题</h4><p>WKWebView 放量后，外网新增了一些 crash, 其中一类 crash 的主要堆栈如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line">28 UIKit 0x0000000190513360 UIApplicationMain + 208</div><div class="line">29 Qzone 0x0000000101380570 main (main.m:181)</div><div class="line">30 libdyld.dylib 0x00000001895205b8 _dyld_process_info_notify_release + 36</div><div class="line">Completion handler passed to -[QZWebController webView:runJavaScriptAlertPanelWithMessage:initiatedByFrame:completionHandler:] was not called</div></pre></td></tr></table></figure></p>
<p>主要是JS调用window.alert()函数引起的，从 crash 堆栈可以看出是 WKWebView 回调函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+ (void) presentAlertOnController:(nonnull UIViewController*)parentController title:(nullable NSString*)title message:(nullable NSString*)message handler:(nonnull void (^)())completionHandler;</div><div class="line">completionHandler 没有被调用导致的。在适配 WKWebView 的时候，我们需要自己实现该回调函数，window.alert()才能调起 alert 框，我们最初的实现是这样的：</div><div class="line">- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler &#123;</div><div class="line">    UIAlertController *alertController = [UIAlertController alertControllerWithTitle:@&quot;&quot; message:message preferredStyle:UIAlertControllerStyleAlert];</div><div class="line">    [alertController addAction:[UIAlertAction actionWithTitle:@&quot;确认&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction *action) &#123; completionHandler(); &#125;]];</div><div class="line">    [self presentViewController:alertController animated:YES completion:^&#123;&#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果 WKWebView 退出的时候，JS刚好执行了window.alert(), alert 框可能弹不出来，completionHandler 最后没有被执行，导致 crash；另一种情况是在 WKWebView 一打开，JS就执行window.alert()，这个时候由于 WKWebView 所在的 UIViewController 出现（push或present）的动画尚未结束，alert 框可能弹不出来，completionHandler 最后没有被执行，导致 crash。我们最终的实现大致是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (void)webView:(WKWebView*)webView runJavaScriptAlertPanelWithMessage:(NSString*)message initiatedByFrame:(WKFrameInfo*)frame completionHandler:(void (^)(void))completionHandler &#123;</div><div class="line">    if (/*UIViewController of WKWebView has finish push or present animation*/) &#123;</div><div class="line">        completionHandler();</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    UIAlertController*alertController = [UIAlertController alertControllerWithTitle:@&quot;&quot; message:message preferredStyle:UIAlertControllerStyleAlert];</div><div class="line">    [alertController addAction:[UIAlertAction actionWithTitle:@&quot;确认&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction*action) &#123; completionHandler(); &#125;]];</div><div class="line">    if (/*UIViewController of WKWebView is visible*/)</div><div class="line">        [self presentViewController:alertController animated:YES completion:^&#123;&#125;];</div><div class="line">    else</div><div class="line">        completionHandler();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>确保上面两种情况下 completionHandler 都能被执行，消除了 WKWebView 下弹 alert 框的 crash，WKWebView 下弹 confirm 框的 crash 的原因与解决方式与 alert 类似。</p>
<p>另一个 crash 发生在 WKWebView 退出前调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[WKWebView evaluateJavaScript: completionHandler:]</div></pre></td></tr></table></figure></p>
<p>执行JS代码的情况下。WKWebView 退出并被释放后导致completionHandler变成野指针，而此时 javaScript Core 还在执行JS代码，待 javaScript Core 执行完毕后会调用completionHandler()，导致 crash。这个 crash 只发生在 iOS 8 系统上，参考Apple Open Source，在iOS9及以后系统苹果已经修复了这个bug，主要是对completionHandler block做了copy（refer: <a href="https://trac.webkit.org/changeset/179160）；对于iOS" target="_blank" rel="external">https://trac.webkit.org/changeset/179160）；对于iOS</a> 8系统，可以通过在 completionHandler 里 retain WKWebView 防止 completionHandler 被过早释放。我们最后用 methodSwizzle hook 了这个系统方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">+ (void) load &#123;</div><div class="line">[self jr_swizzleMethod:NSSelectorFromString(@&quot;evaluateJavaScript:completionHandler:&quot;) withMethod:@selector(altEvaluateJavaScript:completionHandler:) error:nil];</div><div class="line">&#125;</div><div class="line">/*</div><div class="line"> * fix: WKWebView crashes on deallocation if it has pending JavaScript evaluation</div><div class="line"> */</div><div class="line">- (void)altEvaluateJavaScript:(NSString*)javaScriptString completionHandler:(void (^)(id, NSError*))completionHandler &#123;</div><div class="line">    id strongSelf = self;</div><div class="line">    [self altEvaluateJavaScript:javaScriptString completionHandler:^(id r, NSError*e) &#123;</div><div class="line">        [strongSelf title];</div><div class="line">        if (completionHandler) &#123;</div><div class="line">            completionHandler(r, e);</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="8、其它问题"><a href="#8、其它问题" class="headerlink" title="8、其它问题"></a>8、其它问题</h4><h5 id="8-1、视频自动播放"><a href="#8-1、视频自动播放" class="headerlink" title="8.1、视频自动播放"></a>8.1、视频自动播放</h5><p>WKWebView 需要通过WKWebViewConfiguration.mediaPlaybackRequiresUserAction设置是否允许自动播放，但一定要在 WKWebView 初始化之前设置，在 WKWebView 初始化之后设置无效。</p>
<h5 id="8-2、goBack-API问题"><a href="#8-2、goBack-API问题" class="headerlink" title="8.2、goBack API问题"></a>8.2、goBack API问题</h5><p>WKWebView 上调用 -[WKWebView goBack], 回退到上一个页面后不会触发window.onload()函数、不会执行JS。</p>
<h5 id="8-3、页面滚动速率"><a href="#8-3、页面滚动速率" class="headerlink" title="8.3、页面滚动速率"></a>8.3、页面滚动速率</h5><p>WKWebView 需要通过scrollView delegate调整滚动速率：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- (void)scrollViewWillBeginDragging:(UIScrollView*)scrollView &#123;</div><div class="line">     scrollView.decelerationRate = UIScrollViewDecelerationRateNormal;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>本文总结了在 WKWebView 上踩过的一些坑。虽然 WKWebView 坑比较多，但是相对 UIWebView 在内存消耗、稳定性方面还是有很大的优势。尽管苹果对 WKWebView 的开发进度过于缓慢，但相信 WKWebView 才是未来。</p>

            <div class="clearfix"></div>
            <hr class="nogutter">
        </div>
        <nav class="pagination" role="pagination">
    
    <a class="pull-left" href="/2017/08/17/moneyApple/" style="float: left;">
        ← 金融类APP常见被拒绝原因分析及解决
    </a>
    
    
    <a class="pull-right" href="/2017/08/01/58Hybrid/">
        58 同城 iOS 客户端 Hybrid 框架探索 →
    </a>
    
</nav>

        <div class="duoshuo"></div>
    </div>
</section>


      
<!-- ============================ Footer =========================== -->

<footer>
    <div class="container">
            <div class="copy">
                <p>
                    &copy; 2014<script>new Date().getFullYear()>2010&&document.write("-"+new Date().getFullYear());</script>, Content By Steven. All Rights Reserved.
                </p>
                <p>Theme By <a href="//go.kieran.top" style="color: #767D84">Kieran</a></p>
            </div>
            <div class="social">
                <ul>
                    
                    <li><a href="https://github.com/ReverseScale" title="Github" target="_blank"><i class="icon-github"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://twitter.com/" title="Twitter" target="_blank"><i class="icon-twitter"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://www.facebook.com/" title="Facebook" target="_blank"><i class="icon-facebook"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="https://google.com/" title="Google-Plus" target="_blank"><i class="icon-google-plus"></i></a>&nbsp;</li>
                    
                    
                    <li><a href="http://www.weibo.com/5844576818/profile?rightmod=1&wvr=6&mod=personinfo&is_all=1" title="Sina-Weibo" target="_blank"><i class="icon-sina-weibo"></i></a>&nbsp;</li>
                    
                </ul>
            </div>
            <div class="clearfix"> </div>
        </div>
</footer>

<!-- ============================ END Footer =========================== -->
      <!-- Load our scripts -->
        
<!-- Resizable 'on-demand' full-height hero -->
<script type="text/javascript">
    
    var resizeHero = function () {
        var hero = $(".cover,.heightblock"),
            window1 = $(window);
        hero.css({
            "height": window1.height()
        });
    };
    
    resizeHero();
    
    $(window).resize(function () {
        resizeHero();
    });
</script>
<script src="/js/plugins.min.js"></script><!-- Bootstrap core and concatenated plugins always load here -->
<script src="/js/jquery.flexslider-min.js"></script><!-- Flexslider plugin -->
<script src="/js/scripts.js"></script><!-- Theme scripts -->

<!-- Initiate flexslider plugin -->
<script type="text/javascript">
    $(document).ready(function($) {
      $('.flexslider').flexslider({
        animation: "fade",
        prevText: "",
        nextText: "",
        directionNav: true
      });
    });
</script>

</body>
</html>
